if(!window.hexToRgb) {
  window.hexToRgb = function(hex) {
    var r = Math.floor(hex / 0x010000);
    var g = Math.floor(hex%0x010000/0x000100);
    var b = hex % 0x000100;

    return {r:r,g:g,b:b};
  };
}

// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '73' };

//

if ( typeof define === 'function' && define.amd ) {

		define( 'three', THREE );

} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

		module.exports = THREE;

}


// polyfills

if ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {

	// Missing in Android stock browser.

	( function () {

		var lastTime = 0;
		var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

		for ( var x = 0; x < vendors.length && ! self.requestAnimationFrame; ++ x ) {

			self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
			self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

		}

		if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {

			self.requestAnimationFrame = function ( callback ) {

				var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
				var id = self.setTimeout( function () {

					callback( currTime + timeToCall );

				}, timeToCall );
				lastTime = currTime + timeToCall;
				return id;

			};

		}

		if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {

			self.cancelAnimationFrame = function ( id ) {

				self.clearTimeout( id );

			};

		}

	} )();

}

//

if ( self.performance === undefined ) {

	self.performance = {};

}

if ( self.performance.now === undefined ) {

	( function () {

		var start = Date.now();

		self.performance.now = function () {

			return Date.now() - start;

		}

	} )();

}

//

if ( Number.EPSILON === undefined ) {

	Number.EPSILON = Math.pow( 2, -52 );

}

//

if ( Math.sign === undefined ) {

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

	};

}

if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

	// Missing in IE9-11.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

	Object.defineProperty( Function.prototype, 'name', {

		get: function () {

			return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

		}

	} );

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
// mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;

// depth modes

THREE.NeverDepth = 0;
THREE.AlwaysDepth = 1;
THREE.LessDepth = 2;
THREE.LessEqualDepth = 3;
THREE.EqualDepth = 4;
THREE.GreaterEqualDepth = 5;
THREE.GreaterDepth = 6;
THREE.NotEqualDepth = 7;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = 300;

THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;

THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;

THREE.SphericalReflectionMapping = 305;

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1025;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
THREE.RGBEFormat = THREE.RGBAFormat; //1024;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;

// Loop styles for AnimationAction

THREE.LoopOnce = 2200;
THREE.LoopRepeat = 2201;
THREE.LoopPingPong = 2202;

// DEPRECATED

THREE.Projector = function () {

	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

	this.projectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
		vector.project( camera );

	};

	this.unprojectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
		vector.unproject( camera );

	};

	this.pickingRay = function ( vector, camera ) {

		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

	};

};

THREE.CanvasRenderer = function () {

	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

	this.domElement = document.createElement( 'canvas' );
	this.clear = function () {};
	this.render = function () {};
	this.setClearColor = function () {};
	this.setSize = function () {};

};

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

	if ( arguments.length === 3 ) {

		return this.fromArray( arguments );

	}

	return this.set( color );

};

THREE.Color.prototype = {

	constructor: THREE.Color,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value instanceof THREE.Color ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function () {

		function hue2rgb( p, q, t ) {

			if ( t < 0 ) t += 1;
			if ( t > 1 ) t -= 1;
			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
			if ( t < 1 / 2 ) return q;
			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
			return p;

		}

		return function ( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = THREE.Math.euclideanModulo( h, 1 );
			s = THREE.Math.clamp( s, 0, 1 );
			l = THREE.Math.clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		};

	}(),

	setStyle: function ( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		var m;

		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			var color;
			var name = m[ 1 ];
			var components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 5 ] );

						return this;

					}

					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 5 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						var h = parseFloat( color[ 1 ] ) / 360;
						var s = parseInt( color[ 2 ], 10 ) / 100;
						var l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 5 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

			// hex color

			var hex = m[ 1 ];
			var size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			// color keywords
			var hex = THREE.ColorKeywords[ style ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex );

			} else {

				// unknown color
				console.warn( 'THREE.Color: Unknown color ' + style );

			}

		}

		return this;

	},

	clone: function () {

		return new this.constructor( this.r, this.g, this.b );

	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	},

	copyLinearToGamma: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Quaternion = function ( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

	constructor: THREE.Quaternion,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this.onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( euler instanceof THREE.Euler === false ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		var order = euler.order;

		if ( order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this.onChangeCallback();

		return this;

	},

	setFromUnitVectors: function () {

		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

		// assumes direction vectors vFrom and vTo are normalized

		var v1, r;

		var EPS = 0.000001;

		return function ( vFrom, vTo ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					v1.set( - vFrom.y, vFrom.x, 0 );

				} else {

					v1.set( 0, - vFrom.z, vFrom.y );

				}

			} else {

				v1.crossVectors( vFrom, vTo );

			}

			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;

			this.normalize();

			return this;

		}

	}(),

	inverse: function () {

		this.conjugate().normalize();

		return this;

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this.onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this.onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this.onChangeCallback();

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var halfTheta = Math.acos( cosHalfTheta );
		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this.onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

	return qm.copy( qa ).slerp( qb, t );

};

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.Vector2.prototype = {

	constructor: THREE.Vector2,

	get width() { return this.x },
	set width( value ) { this.x = value },

	get height() { return this.y },
	set height( value ) { this.y = value },

	//

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {
			this.x *= scalar;
			this.y *= scalar;
		} else {
			this.x = 0;
			this.y = 0;
		}

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector2();
				max = new THREE.Vector2();

			}

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

		return this;

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	lengthManhattan: function() {

		return Math.abs( this.x ) + Math.abs( this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];

		return this;

	},

	rotateAround: function ( center, angle ) {

		var c = Math.cos( angle ), s = Math.sin( angle );

		var x = this.x - center.x;
		var y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
		} else {
			this.x = 0;
			this.y = 0;
			this.z = 0;
		}

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function applyEuler( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromEuler( euler ) );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function applyAxisAngle( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			return this;

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function () {

		var matrix;

		return function project( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyProjection( matrix );

		};

	}(),

	unproject: function () {

		var matrix;

		return function unproject( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyProjection( matrix );

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector3();
				max = new THREE.Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

		return this;

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function () {

		var v1, dot;

		return function projectOnVector( vector ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( vector ).normalize();

			dot = this.dot( v1 );

			return this.copy( v1 ).multiplyScalar( dot );

		};

	}(),

	projectOnPlane: function () {

		var v1;

		return function projectOnPlane( planeNormal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		}

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function reflect( normal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( this.length() * v.length() );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setEulerFromRotationMatrix: function ( m, order ) {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	},

	setEulerFromQuaternion: function ( q, order ) {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	},

	getPositionFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

		return this.setFromMatrixPosition( m );

	},

	getScaleFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

		return this.setFromMatrixScale( m );

	},

	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

		return this.setFromMatrixColumn( index, matrix );

	},

	setFromMatrixPosition: function ( m ) {

		this.x = m.elements[ 12 ];
		this.y = m.elements[ 13 ];
		this.z = m.elements[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
		var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
		var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( index, matrix ) {

		var offset = index * 4;

		var me = matrix.elements;

		this.x = me[ offset ];
		this.y = me[ offset + 1 ];
		this.z = me[ offset + 2 ];

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];
		this.z = attribute.array[ index + 2 ];

		return this;

	}

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

	constructor: THREE.Vector4,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z, this.w );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
		} else {
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;
		}

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon )
		   && ( Math.abs( m13 - m31 ) < epsilon )
		   && ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 )
			   && ( Math.abs( m13 + m31 ) < epsilon2 )
			   && ( Math.abs( m23 + m32 ) < epsilon2 )
			   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
						  + ( m13 - m31 ) * ( m13 - m31 )
						  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector4();
				max = new THREE.Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];
		this.z = attribute.array[ index + 2 ];
		this.w = attribute.array[ index + 3 ];

		return this;

	}

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Euler = function ( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

	constructor: THREE.Euler,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._order);

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = THREE.Math.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

		}

		this._order = order;

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromQuaternion: function () {

		var matrix;

		return function ( q, order, update ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();
			matrix.makeRotationFromQuaternion( q );
			this.setFromRotationMatrix( matrix, order, update );

			return this;

		};

	}(),

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new THREE.Quaternion();

		return function ( newOrder ) {

			q.setFromEuler( this );
			this.setFromQuaternion( q, newOrder );

		};

	}(),

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new THREE.Vector3( this._x, this._y, this._z );

		}

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Line3 = function ( start, end ) {

	this.start = ( start !== undefined ) ? start : new THREE.Vector3();
	this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

	constructor: THREE.Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function () {

		var startP = new THREE.Vector3();
		var startEnd = new THREE.Vector3();

		return function ( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = THREE.Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Box2 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

	constructor: THREE.Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] )

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector2();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),
	
	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector2();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

	constructor: THREE.Box3,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector3();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function () {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		var v1 = new THREE.Vector3();

		return function ( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			this.makeEmpty();

			object.traverse( function ( node ) {

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry instanceof THREE.Geometry ) {

						var vertices = geometry.vertices;

						for ( var i = 0, il = vertices.length; i < il; i ++ ) {

							v1.copy( vertices[ i ] );

							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

						var positions = geometry.attributes[ 'position' ].array;

						for ( var i = 0, il = positions.length; i < il; i += 3 ) {

							v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					}

				}

			} );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ||
		     point.z < this.min.z || point.z > this.max.z ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ||
		     box.max.z < this.min.z || box.min.z > this.max.z ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function () {

		var v1 = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Sphere();

			result.center = this.center();
			result.radius = this.size( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function () {

		var points = [
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3()
		];

		return function ( matrix ) {

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

			this.makeEmpty();
			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Matrix3 = function () {

	this.elements = new Float32Array( [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix3.prototype = {

	constructor: THREE.Matrix3,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
		te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
		te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new this.constructor().fromArray( this.elements );

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ],
			me[ 1 ], me[ 4 ], me[ 7 ],
			me[ 2 ], me[ 5 ], me[ 8 ]

		);

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},

	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},

	applyToVector3Array: function () {

		var v1;

		return function ( array, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

				v1.fromArray( array, j );
				v1.applyMatrix3( this );
				v1.toArray( array, j );

			}

			return array;

		};

	}(),

	applyToBuffer: function () {

		var v1;

		return function applyToBuffer( buffer, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = buffer.length / buffer.itemSize;

			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

				v1.x = buffer.getX( j );
				v1.y = buffer.getY( j );
				v1.z = buffer.getZ( j );

				v1.applyMatrix3( this );

				buffer.setXYZ( v1.x, v1.y, v1.z );

			}

			return buffer;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnInvertible ) {

		// input: THREE.Matrix4
		// ( based on http://code.google.com/p/webgl-mjs/ )

		var me = matrix.elements;
		var te = this.elements;

		te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
		te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
		te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
		te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
		te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
		te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
		te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
		te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
		te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

		// no inverse

		if ( det === 0 ) {

			var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1.0 / det );

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ]  = te[ 8 ];

		return array;

	},

	getNormalMatrix: function ( m ) {

		// input: THREE.Matrix4

		this.getInverse( m ).transpose();

		return this;

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ],
			te[ 3 ], te[ 4 ], te[ 5 ],
			te[ 6 ], te[ 7 ], te[ 8 ]
		];

	}

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

	this.elements = new Float32Array( [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix4.prototype = {

	constructor: THREE.Matrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new THREE.Matrix4().fromArray( this.elements );

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	extractPosition: function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		var te = this.elements;

		xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
		yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
		zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

		return this;

	},

	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0,       0,       0,       1
		);

		return this;

	},

	extractRotation: function () {

		var v1;

		return function ( m ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
			var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
			var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( euler instanceof THREE.Euler === false ) {

			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	setRotationFromQuaternion: function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

		return this.makeRotationFromQuaternion( q );

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[ 0 ] = 1 - ( yy + zz );
		te[ 4 ] = xy - wz;
		te[ 8 ] = xz + wy;

		te[ 1 ] = xy + wz;
		te[ 5 ] = 1 - ( xx + zz );
		te[ 9 ] = yz - wx;

		te[ 2 ] = xz - wy;
		te[ 6 ] = yz + wx;
		te[ 10 ] = 1 - ( xx + yy );

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	lookAt: function () {

		var x, y, z;

		return function ( eye, target, up ) {

			if ( x === undefined ) x = new THREE.Vector3();
			if ( y === undefined ) y = new THREE.Vector3();
			if ( z === undefined ) z = new THREE.Vector3();

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.lengthSq() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.lengthSq() === 0 ) {

				z.x += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
		return vector.applyProjection( this );

	},

	multiplyVector4: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},

	applyToVector3Array: function () {

		var v1;

		return function ( array, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

				v1.fromArray( array, j );
				v1.applyMatrix4( this );
				v1.toArray( array, j );

			}

			return array;

		};

	}(),

	applyToBuffer: function () {

		var v1;

		return function applyToBuffer( buffer, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = buffer.length / buffer.itemSize;

			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

				v1.x = buffer.getX( j );
				v1.y = buffer.getY( j );
				v1.z = buffer.getZ( j );

				v1.applyMatrix4( this );

				buffer.setXYZ( v1.x, v1.y, v1.z );

			}

			return buffer;

		};

	}(),

	rotateAxis: function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

		v.transformDirection( this );

	},

	crossVector: function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ]  = te[ 8 ];
		array[ offset + 9 ]  = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	},

	getPosition: function () {

		var v1;

		return function () {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

			var te = this.elements;
			return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

		};

	}(),

	setPosition: function ( v ) {

		var te = this.elements;

		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnInvertible ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements;
		var me = m.elements;

		var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
		var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
		var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
		var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

		te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
		te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
		te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
		te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
		te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
		te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
		te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
		te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
		te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
		te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
		te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
		te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
		te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
		te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
		te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
		te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

		if ( det === 0 ) {

			var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1 / det );

		return this;

	},

	translate: function ( v ) {

		console.error( 'THREE.Matrix4: .translate() has been removed.' );

	},

	rotateX: function ( angle ) {

		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

	},

	rotateY: function ( angle ) {

		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

	},

	rotateZ: function ( angle ) {

		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

	},

	rotateByAxis: function ( axis, angle ) {

		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, - s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector, matrix;

		return function ( position, quaternion, scale ) {

			if ( vector === undefined ) vector = new THREE.Vector3();
			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			var te = this.elements;

			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) {

				sx = - sx;

			}

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[ 0 ] *= invSX;
			matrix.elements[ 1 ] *= invSX;
			matrix.elements[ 2 ] *= invSX;

			matrix.elements[ 4 ] *= invSY;
			matrix.elements[ 5 ] *= invSY;
			matrix.elements[ 6 ] *= invSY;

			matrix.elements[ 8 ] *= invSZ;
			matrix.elements[ 9 ] *= invSZ;
			matrix.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = right - left;
		var h = top - bottom;
		var p = far - near;

		var x = ( right + left ) / w;
		var y = ( top + bottom ) / h;
		var z = ( far + near ) / p;

		te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
		];

	}

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Ray = function ( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

	constructor: THREE.Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	recast: function () {

		var v1 = new THREE.Vector3();

		return function ( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function ( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	},

	distanceSqToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceToSquared( point );

		};

	}(),

	distanceSqToSegment: function () {

		var segCenter = new THREE.Vector3();
		var segDir = new THREE.Vector3();
		var diff = new THREE.Vector3();

		return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			segDir.copy( v1 ).sub( v0 ).normalize();
			diff.copy( this.origin ).sub( segCenter );

			var segExtent = v0.distanceTo( v1 ) * 0.5;
			var a01 = - this.direction.dot( segDir );
			var b0 = diff.dot( this.direction );
			var b1 = - diff.dot( segDir );
			var c = diff.lengthSq();
			var det = Math.abs( 1 - a01 * a01 );
			var s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

			}

			return sqrDist;

		};

	}(),


	isIntersectionSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	intersectSphere: function () {

		// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

		var v1 = new THREE.Vector3();

		return function ( sphere, optionalTarget ) {

			v1.subVectors( sphere.center, this.origin );

			var tca = v1.dot( this.direction );

			var d2 = v1.dot( v1 ) - tca * tca;

			var radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			var thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			var t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			var t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, optionalTarget );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, optionalTarget );

		}

	}(),

	isIntersectionPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );
		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, optionalTarget );

	},

	isIntersectionBox: function () {

		var v = new THREE.Vector3();

		return function ( box ) {

			return this.intersectBox( box, v ) !== null;

		};

	}(),

	intersectBox: function ( box, optionalTarget ) {

		// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

		var tmin, tmax, tymin, tymax, tzmin, tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectTriangle: function () {

		// Compute the offset origin, edges, and normal.
		var diff = new THREE.Vector3();
		var edge1 = new THREE.Vector3();
		var edge2 = new THREE.Vector3();
		var normal = new THREE.Vector3();

		return function ( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );

		};

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;

	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

	this.center = ( center !== undefined ) ? center : new THREE.Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

	constructor: THREE.Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	},

	setFromPoints: function () {

		var box = new THREE.Box3();

		return function ( points, optionalCenter ) {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).center( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new THREE.Vector3();
		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new THREE.Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new THREE.Plane(),
		( p1 !== undefined ) ? p1 : new THREE.Plane(),
		( p2 !== undefined ) ? p2 : new THREE.Plane(),
		( p3 !== undefined ) ? p3 : new THREE.Plane(),
		( p4 !== undefined ) ? p4 : new THREE.Plane(),
		( p5 !== undefined ) ? p5 : new THREE.Plane()

	];

};

THREE.Frustum.prototype = {

	constructor: THREE.Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new THREE.Sphere();

		return function ( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function () {

		var p1 = new THREE.Vector3(),
			p2 = new THREE.Vector3();

		return function ( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6 ; i ++ ) {

				var plane = planes[ i ];

				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );

				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {

					return false;

				}

			}

			return true;

		};

	}(),


	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Plane = function ( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

	constructor: THREE.Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	isIntersectionLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectLine: function () {

		var v1 = new THREE.Vector3();

		return function ( line, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),


	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var m1 = new THREE.Matrix3();

		return function ( matrix, optionalNormalMatrix ) {

			// compute new normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

			var newCoplanarPoint = this.coplanarPoint( v2 );
			newCoplanarPoint.applyMatrix4( matrix );

			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
		var uuid = new Array( 36 );
		var rnd = 0, r;

		return function () {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

					uuid[ i ] = '-';

				} else if ( i === 14 ) {

					uuid[ i ] = '4';

				} else {

					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

				}

			}

			return uuid.join( '' );

		};

	}(),

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random float from <0, 1> with 16 bits of randomness
	// (standard Math.random() creates repetitive patterns when applied over larger space)

	random16: function () {

		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function () {

		var degreeToRadiansFactor = Math.PI / 180;

		return function ( degrees ) {

			return degrees * degreeToRadiansFactor;

		};

	}(),

	radToDeg: function () {

		var radianToDegreesFactor = 180 / Math.PI;

		return function ( radians ) {

			return radians * radianToDegreesFactor;

		};

	}(),

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	nearestPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

	},

	nextPowerOfTwo: function ( value ) {

		value --;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		value ++;

		return value;

	}

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function ( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i ++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new THREE.Vector3(),
			tmpVec = new THREE.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( ! nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint !== oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new THREE.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i ++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j ++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new THREE.Vector3();
	this.b = ( b !== undefined ) ? b : new THREE.Vector3();
	this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

	var v0 = new THREE.Vector3();

	return function ( a, b, c, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if ( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

	var v0 = new THREE.Vector3();
	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new THREE.Vector3();

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( - 2, - 1, - 1 );

		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

THREE.Triangle.containsPoint = function () {

	var v1 = new THREE.Vector3();

	return function ( point, a, b, c ) {

		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

THREE.Triangle.prototype = {

	constructor: THREE.Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();

		return function () {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

};

// File:src/core/Channels.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Channels = function () {

	this.mask = 1;

};

THREE.Channels.prototype = {

	constructor: THREE.Channels,

	set: function ( channel ) {

		this.mask = 1 << channel;

	},

	enable: function ( channel ) {

		this.mask |= 1 << channel;

	},

	toggle: function ( channel ) {

		this.mask ^= 1 << channel;

	},

	disable: function ( channel ) {

		this.mask &= ~ ( 1 << channel );

	}

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

THREE.Clock.prototype = {

	constructor: THREE.Clock,

	start: function () {

		this.startTime = self.performance.now();

		this.oldTime = this.startTime;
		this.running = true;

	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = self.performance.now();

			diff = 0.001 * ( newTime - this.oldTime );
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {};

THREE.EventDispatcher.prototype = {

	constructor: THREE.EventDispatcher,

	apply: function ( object ) {

		object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
		object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
		object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

	},

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

			return true;

		}

		return false;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = [];
			var length = listenerArray.length;

			for ( var i = 0; i < length; i ++ ) {

				array[ i ] = listenerArray[ i ];

			}

			for ( var i = 0; i < length; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

	THREE.Raycaster = function ( origin, direction, near, far ) {

		this.ray = new THREE.Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {
					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;
				}
			}
		} );

	};

	function descSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.visible === false ) return;

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	//

	THREE.Raycaster.prototype = {

		constructor: THREE.Raycaster,

		linePrecision: 1,

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			if ( camera instanceof THREE.PerspectiveCamera ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

			} else if ( camera instanceof THREE.OrthographicCamera ) {

				this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type.' );

			}

		},

		intersectObject: function ( object, recursive ) {

			var intersects = [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( descSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive ) {

			var intersects = [];

			if ( Array.isArray( objects ) === false ) {

				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( descSort );

			return intersects;

		}

	};

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

THREE.Object3D = function () {

	Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.channels = new THREE.Channels();
	this.children = [];

	this.up = THREE.Object3D.DefaultUp.clone();

	var position = new THREE.Vector3();
	var rotation = new THREE.Euler();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation.onChange( onRotationChange );
	quaternion.onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			enumerable: true,
			value: position
		},
		rotation: {
			enumerable: true,
			value: rotation
		},
		quaternion: {
			enumerable: true,
			value: quaternion
		},
		scale: {
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new THREE.Matrix4()
		},
		normalMatrix: {
			value: new THREE.Matrix3()
		}
	} );

	this.rotationAutoUpdate = true;

	this.matrix = new THREE.Matrix4();
	this.matrixWorld = new THREE.Matrix4();

	this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
THREE.Object3D.DefaultMatrixAutoUpdate = true;

THREE.Object3D.prototype = {

	constructor: THREE.Object3D,

	get eulerOrder () {

		console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );

		return this.rotation.order;

	},

	set eulerOrder ( value ) {

		console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );

		this.rotation.order = value;

	},

	get useQuaternion () {

		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	set useQuaternion ( value ) {

		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	set renderDepth ( value ) {

		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

	},

	//

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function () {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new THREE.Quaternion();

		return function ( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		};

	}(),

	rotateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new THREE.Vector3();

		return function ( axis, distance ) {

			v1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		};

	}(),

	translate: function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	},

	translateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
			return this;

		}

		if ( object instanceof THREE.Object3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

		} else {

			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

		}

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;

			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

		}

	},

	getChildByName: function ( name ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name );

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.updateMatrixWorld( true );

		return result.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function () {

		var position = new THREE.Vector3();
		var scale = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Quaternion();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, result, scale );

			return result;

		};

	}(),

	getWorldRotation: function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Euler();

			this.getWorldQuaternion( quaternion );

			return result.setFromQuaternion( quaternion, this.rotation.order, false );

		};

	}(),

	getWorldScale: function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, quaternion, result );

			return result;

		};

	}(),

	getWorldDirection: function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

		};

	}(),

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		var parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	},

	toJSON: function ( meta ) {

		var isRootObject = ( meta === undefined );

		var output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {}
			};

			output.metadata = {
				version: 4.4,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		var object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;

		object.matrix = this.matrix.toArray();

		//

		if ( this.geometry !== undefined ) {

			if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

				meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

			}

			object.geometry = this.geometry.uuid;

		}

		if ( this.material !== undefined ) {

			if ( meta.materials[ this.material.uuid ] === undefined ) {

				meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

			}

			object.material = this.material.uuid;

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( var i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		if ( isRootObject ) {

			var geometries = extractFromCache( meta.geometries );
			var materials = extractFromCache( meta.materials );
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache ( cache ) {

			var values = [];
			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}
			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive ) {

		if ( recursive === undefined ) recursive = true;

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.rotationAutoUpdate = source.rotationAutoUpdate;

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < source.children.length; i ++ ) {

				var child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = Array.isArray( normal ) ? normal : [];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = Array.isArray( color ) ? color : [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

	constructor: THREE.Face3,

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.a = source.a;
		this.b = source.b;
		this.c = source.c;

		this.normal.copy( source.normal );
		this.color.copy( source.color );

		this.materialIndex = source.materialIndex;

		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

		}

		return this;

	}

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
	return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize ) {

	this.uuid = THREE.Math.generateUUID();

	this.array = array;
	this.itemSize = itemSize;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

};

THREE.BufferAttribute.prototype = {

	constructor: THREE.BufferAttribute,

	get length() {

		console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
		return this.array.length;

	},

	get count() {

		return this.array.length / this.itemSize;

	},

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;

		this.dynamic = source.dynamic;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = colors.length; i < l; i ++ ) {

			var color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new THREE.Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyIndicesArray: function ( indices ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = indices.length; i < l; i ++ ) {

			var index = indices[ i ];

			array[ offset ++ ] = index.a;
			array[ offset ++ ] = index.b;
			array[ offset ++ ] = index.c;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new THREE.Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new THREE.Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new THREE.Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

//

THREE.Int8Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

};

THREE.Uint8Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

};

THREE.Uint8ClampedAttribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

};

THREE.Int16Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

};

THREE.Uint16Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

};

THREE.Int32Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

};

THREE.Uint32Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

};

THREE.Float32Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

};

THREE.Float64Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

};


// Deprecated

THREE.DynamicBufferAttribute = function ( array, itemSize ) {

	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
	return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );

};

// File:src/core/InstancedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {

	THREE.BufferAttribute.call( this, array, itemSize );

	this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

THREE.InstancedBufferAttribute.prototype.copy = function ( source ) {

	THREE.BufferAttribute.prototype.copy.call( this, source );

	this.meshPerAttribute = source.meshPerAttribute;

	return this;

};

// File:src/core/InterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBuffer = function ( array, stride ) {

	this.uuid = THREE.Math.generateUUID();

	this.array = array;
	this.stride = stride;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

};

THREE.InterleavedBuffer.prototype = {

	constructor: THREE.InterleavedBuffer,

	get length () {

		return this.array.length;

	},

	get count () {

		return this.array.length / this.stride;

	},

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.stride = source.stride;
		this.dynamic = source.dynamic;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( var i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

// File:src/core/InstancedInterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {

	THREE.InterleavedBuffer.call( this, array, stride );

	this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

THREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {

	THREE.InterleavedBuffer.prototype.copy.call( this, source );

	this.meshPerAttribute = source.meshPerAttribute;

	return this;

};

// File:src/core/InterleavedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {

	this.uuid = THREE.Math.generateUUID();

	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;

};


THREE.InterleavedBufferAttribute.prototype = {

	constructor: THREE.InterleavedBufferAttribute,

	get length() {

		console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
		return this.array.length;

	},

	get count() {

		return this.data.array.length / this.data.stride;

	},

	setX: function ( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	},

	setW: function ( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	},

	getX: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	},

	getY: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	},

	getZ: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	},

	getW: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	},

	setXY: function ( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

};

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

THREE.Geometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];
	this.faces = [];
	this.faceVertexUvs = [ [] ];

	this.morphTargets = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.elementsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;
	this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

	constructor: THREE.Geometry,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		this.verticesNeedUpdate = true;
		this.normalsNeedUpdate = true;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1;

		return function rotateX( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1;

		return function rotateY( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1;

		return function rotateZ( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1;

		return function translate( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1;

		return function scale( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj;

		return function lookAt( vector ) {

			if ( obj === undefined ) obj = new THREE.Object3D();

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var indices = geometry.index !== null ? geometry.index.array : undefined;
		var attributes = geometry.attributes;

		var vertices = attributes.position.array;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

		var tempNormals = [];
		var tempUVs = [];
		var tempUVs2 = [];

		for ( var i = 0, j = 0, k = 0; i < vertices.length; i += 3, j += 2, k += 4 ) {

			scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

			if ( normals !== undefined ) {

				tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

			}

			if ( colors !== undefined ) {

				scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

			}

			if ( uvs !== undefined ) {

				tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

			}

			if ( uvs2 !== undefined ) {

				tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

			}

		}

		function addFace( a, b, c ) {

			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

			var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );

			scope.faces.push( face );

			if ( uvs !== undefined ) {

				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

			}

			if ( uvs2 !== undefined ) {

				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

			}

		};

		if ( indices !== undefined ) {

			var groups = geometry.groups;

			if ( groups.length > 0 ) {

				for ( var i = 0; i < groups.length; i ++ ) {

					var group = groups[ i ];

					var start = group.start;
					var count = group.count;

					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );

					}

				}

			} else {

				for ( var i = 0; i < indices.length; i += 3 ) {

					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

				}

			}

		} else {

			for ( var i = 0; i < vertices.length / 3; i += 3 ) {

				addFace( i, i + 1, i + 2 );

			}

		}

		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.center().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	normalize: function () {

		this.computeBoundingSphere();

		var center = this.boundingSphere.center;
		var radius = this.boundingSphere.radius;

		var s = radius === 0 ? 1 : 1.0 / radius;

		var matrix = new THREE.Matrix4();
		matrix.set(
			s, 0, 0, - s * center.x,
			0, s, 0, - s * center.y,
			0, 0, s, - s * center.z,
			0, 0, 0, 1
		);

		this.applyMatrix( matrix );

		return this;

	},

	computeFaceNormals: function () {

		var cb = new THREE.Vector3(), ab = new THREE.Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new THREE.Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC;
			var cb = new THREE.Vector3(), ab = new THREE.Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( vertices[ face.a ] );
				vertexNormals[ 1 ].copy( vertices[ face.b ] );
				vertexNormals[ 2 ].copy( vertices[ face.c ] );

			} else {

				vertexNormals[ 0 ] = vertices[ face.a ].clone();
				vertexNormals[ 1 ] = vertices[ face.b ].clone();
				vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new THREE.Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new THREE.Vector3();
					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeTangents: function () {

		console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

	},

	computeLineDistances: function () {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new THREE.Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( geometry instanceof THREE.Geometry === false ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		var normalMatrix,
		vertexOffset = this.vertices.length,
		vertices1 = this.vertices,
		vertices2 = geometry.vertices,
		faces1 = this.faces,
		faces2 = geometry.faces,
		uvs1 = this.faceVertexUvs[ 0 ],
		uvs2 = geometry.faceVertexUvs[ 0 ];

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( matrix !== undefined ) {

			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			if ( uv === undefined ) {

				continue;

			}

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( uv[ j ].clone() );

			}

			uvs1.push( uvCopy );

		}

	},

	mergeMesh: function ( mesh ) {

		if ( mesh instanceof THREE.Mesh === false ) {

			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
			return;

		}

		mesh.matrixAutoUpdate && mesh.updateMatrix();

		this.merge( mesh.geometry, mesh.matrix );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i, il, face;
		var indices, j, jl;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		}


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			var dupIndex = - 1;

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {

				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

					dupIndex = n;
					faceIndicesToRemove.push( i );
					break;

				}

			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	sortFacesByMaterialIndex: function () {

		var faces = this.faces;
		var length = faces.length;

		// tag faces

		for ( var i = 0; i < length; i ++ ) {

			faces[ i ]._id = i;

		}

		// sort faces

		function materialIndexSort( a, b ) {

			return a.materialIndex - b.materialIndex;

		}

		faces.sort( materialIndexSort );

		// sort uvs

		var uvs1 = this.faceVertexUvs[ 0 ];
		var uvs2 = this.faceVertexUvs[ 1 ];

		var newUvs1, newUvs2;

		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

		for ( var i = 0; i < length; i ++ ) {

			var id = faces[ i ]._id;

			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

		}

		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.4,
				type: 'Geometry',
				generator: 'Geometry.toJSON'
			}
		};

		// standard Geometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = false; // face.materialIndex !== undefined;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 );
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		data.data = {};

		data.data.vertices = vertices;
		data.data.normals = normals;
		if ( colors.length > 0 ) data.data.colors = colors;
		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
		data.data.faces = faces;

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.vertices = [];
		this.faces = [];
		this.faceVertexUvs = [ [] ];

		var vertices = source.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			this.vertices.push( vertices[ i ].clone() );

		}

		var faces = source.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			this.faces.push( faces[ i ].clone() );

		}

		for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

			var faceVertexUvs = source.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) {

				this.faceVertexUvs[ i ] = [];

			}

			for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

				var uvs = faceVertexUvs[ j ], uvsCopy = [];

				for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

					var uv = uvs[ k ];

					uvsCopy.push( uv.clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/core/DirectGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DirectGeometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'DirectGeometry';

	this.indices = [];
	this.vertices = [];
	this.normals = [];
	this.colors = [];
	this.uvs = [];
	this.uvs2 = [];

	this.groups = [];

	this.morphTargets = {};

	this.skinWeights = [];
	this.skinIndices = [];

	// this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.groupsNeedUpdate = false;

};

THREE.DirectGeometry.prototype = {

	constructor: THREE.DirectGeometry,

	computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
	computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

	computeFaceNormals: function () {

		console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

	},

	computeVertexNormals: function () {

		console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

	},

	computeGroups: function ( geometry ) {

		var group;
		var groups = [];
		var materialIndex;

		var faces = geometry.faces;

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			// materials

			if ( face.materialIndex !== materialIndex ) {

				materialIndex = face.materialIndex;

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				group = {
					start: i * 3,
					materialIndex: materialIndex
				};

			}

		}

		if ( group !== undefined ) {

			group.count = ( i * 3 ) - group.start;
			groups.push( group );

		}

		this.groups = groups;

	},

	fromGeometry: function ( geometry ) {

		var faces = geometry.faces;
		var vertices = geometry.vertices;
		var faceVertexUvs = geometry.faceVertexUvs;

		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

		// morphs

		var morphTargets = geometry.morphTargets;
		var morphTargetsLength = morphTargets.length;

		if ( morphTargetsLength > 0 ) {

			var morphTargetsPosition = [];

			for ( var i = 0; i < morphTargetsLength; i ++ ) {

				morphTargetsPosition[ i ] = [];

			}

			this.morphTargets.position = morphTargetsPosition;

		}

		var morphNormals = geometry.morphNormals;
		var morphNormalsLength = morphNormals.length;

		if ( morphNormalsLength > 0 ) {

			var morphTargetsNormal = [];

			for ( var i = 0; i < morphNormalsLength; i ++ ) {

				morphTargetsNormal[ i ] = [];

			}

			this.morphTargets.normal = morphTargetsNormal;

		}

		// skins

		var skinIndices = geometry.skinIndices;
		var skinWeights = geometry.skinWeights;

		var hasSkinIndices = skinIndices.length === vertices.length;
		var hasSkinWeights = skinWeights.length === vertices.length;

		//

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

			} else {

				var normal = face.normal;

				this.normals.push( normal, normal, normal );

			}

			var vertexColors = face.vertexColors;

			if ( vertexColors.length === 3 ) {

				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

			} else {

				var color = face.color;

				this.colors.push( color, color, color );

			}

			if ( hasFaceVertexUv === true ) {

				var vertexUvs = faceVertexUvs[ 0 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

					this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

				}

			}

			if ( hasFaceVertexUv2 === true ) {

				var vertexUvs = faceVertexUvs[ 1 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

					this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

				}

			}

			// morphs

			for ( var j = 0; j < morphTargetsLength; j ++ ) {

				var morphTarget = morphTargets[ j ].vertices;

				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

			}

			for ( var j = 0; j < morphNormalsLength; j ++ ) {

				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

			}

			// skins

			if ( hasSkinIndices ) {

				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

			}

			if ( hasSkinWeights ) {

				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

			}

		}

		this.computeGroups( geometry );

		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

};

THREE.BufferGeometry.prototype = {

	constructor: THREE.BufferGeometry,

	addIndex: function ( index ) {

		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
		this.setIndex( index );

	},

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		this.index = index;

	},

	addAttribute: function ( name, attribute ) {

		if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

			return;

		}

		if ( name === 'index' ) {

			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );

			return;

		}

		this.attributes[ name ] = attribute;

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	removeAttribute: function ( name ) {

		delete this.attributes[ name ];

	},

	get drawcalls() {

		console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
		return this.groups;

	},

	get offsets() {

		console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
		return this.groups;

	},

	addDrawCall: function ( start, count, indexOffset ) {

		if ( indexOffset !== undefined ) {

			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

		}

		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
		this.addGroup( start, count );

	},

	clearDrawCalls: function () {

		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
		this.clearGroups();

	},

	addGroup: function ( start, count, materialIndex ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex !== undefined ? materialIndex : 0

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.applyToVector3Array( position.array );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			normalMatrix.applyToVector3Array( normal.array );
			normal.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1;

		return function rotateX( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1;

		return function rotateY( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1;

		return function rotateZ( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1;

		return function translate( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1;

		return function scale( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj;

		return function lookAt( vector ) {

			if ( obj === undefined ) obj = new THREE.Object3D();

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.center().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	setFromObject: function ( object ) {

		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

		var geometry = object.geometry;

		if ( object instanceof THREE.Points || object instanceof THREE.Line ) {

			var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
			var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

				var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );

				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

		} else if ( object instanceof THREE.Mesh ) {

			if ( geometry instanceof THREE.Geometry ) {

				this.fromGeometry( geometry );

			}

		}

		return this;

	},

	updateFromObject: function ( object ) {

		var geometry = object.geometry;

		if ( object instanceof THREE.Mesh ) {

			var direct = geometry.__directGeometry;

			if ( direct === undefined ) {

				return this.fromGeometry( geometry );

			}

			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

			geometry.verticesNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.groupsNeedUpdate = false;

			geometry = direct;

		}

		if ( geometry.verticesNeedUpdate === true ) {

			var attribute = this.attributes.position;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.vertices );
				attribute.needsUpdate = true;

			}

			geometry.verticesNeedUpdate = false;

		}

		if ( geometry.normalsNeedUpdate === true ) {

			var attribute = this.attributes.normal;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.normals );
				attribute.needsUpdate = true;

			}

			geometry.normalsNeedUpdate = false;

		}

		if ( geometry.colorsNeedUpdate === true ) {

			var attribute = this.attributes.color;

			if ( attribute !== undefined ) {

				attribute.copyColorsArray( geometry.colors );
				attribute.needsUpdate = true;

			}

			geometry.colorsNeedUpdate = false;

		}

		if ( geometry.uvsNeedUpdate ) {

				var attribute = this.attributes.uv;

				if ( attribute !== undefined ) {

						attribute.copyVector2sArray( geometry.uvs );
						attribute.needsUpdate = true;

				}

				geometry.uvsNeedUpdate = false;

		}

		if ( geometry.lineDistancesNeedUpdate ) {

			var attribute = this.attributes.lineDistance;

			if ( attribute !== undefined ) {

				attribute.copyArray( geometry.lineDistances );
				attribute.needsUpdate = true;

			}

			geometry.lineDistancesNeedUpdate = false;

		}

		if ( geometry.groupsNeedUpdate ) {

			geometry.computeGroups( object.geometry );
			this.groups = geometry.groups;

			geometry.groupsNeedUpdate = false;

		}

		return this;

	},

	fromGeometry: function ( geometry ) {

		geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );

		return this.fromDirectGeometry( geometry.__directGeometry );

	},

	fromDirectGeometry: function ( geometry ) {

		var positions = new Float32Array( geometry.vertices.length * 3 );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

		if ( geometry.normals.length > 0 ) {

			var normals = new Float32Array( geometry.normals.length * 3 );
			this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

		}

		if ( geometry.colors.length > 0 ) {

			var colors = new Float32Array( geometry.colors.length * 3 );
			this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

		}

		if ( geometry.uvs.length > 0 ) {

			var uvs = new Float32Array( geometry.uvs.length * 2 );
			this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

		}

		if ( geometry.uvs2.length > 0 ) {

			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
			this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

		}

		if ( geometry.indices.length > 0 ) {

			var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
			var indices = new TypeArray( geometry.indices.length * 3 );
			this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

		}

		// groups

		this.groups = geometry.groups;

		// morphs

		for ( var name in geometry.morphTargets ) {

			var array = [];
			var morphTargets = geometry.morphTargets[ name ];

			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

				var morphTarget = morphTargets[ i ];

				var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

				array.push( attribute.copyVector3sArray( morphTarget ) );

			}

			this.morphAttributes[ name ] = array;

		}

		// skinning

		if ( geometry.skinIndices.length > 0 ) {

			var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

		}

		if ( geometry.skinWeights.length > 0 ) {

			var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

		}

		//

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	},

	computeBoundingBox: function () {

		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new THREE.Box3();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				var bb = this.boundingBox;
				bb.makeEmpty();

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.fromArray( positions, i );
					bb.expandByPoint( vector );

				}

			}

			if ( positions === undefined || positions.length === 0 ) {

				this.boundingBox.min.set( 0, 0, 0 );
				this.boundingBox.max.set( 0, 0, 0 );

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		};

	}(),

	computeBoundingSphere: function () {

		var box = new THREE.Box3();
		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				box.makeEmpty();

				var center = this.boundingSphere.center;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.fromArray( positions, i );
					box.expandByPoint( vector );

				}

				box.center( center );

				// hoping to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.fromArray( positions, i );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		};

	}(),

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var index = this.index;
		var attributes = this.attributes;
		var groups = this.groups;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var normals = attributes.normal.array;

				for ( var i = 0, il = normals.length; i < il; i ++ ) {

					normals[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC,

			pA = new THREE.Vector3(),
			pB = new THREE.Vector3(),
			pC = new THREE.Vector3(),

			cb = new THREE.Vector3(),
			ab = new THREE.Vector3();

			// indexed elements

			if ( index ) {

				var indices = index.array;

				if ( groups.length === 0 ) {

					this.addGroup( 0, indices.length );

				}

				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

					var group = groups[ j ];

					var start = group.start;
					var count = group.count;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	computeTangents: function () {

		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

	},

	computeOffsets: function ( size ) {

		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.')

	},

	merge: function ( geometry, offset ) {

		if ( geometry instanceof THREE.BufferGeometry === false ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) offset = 0;

		var attributes = this.attributes;

		for ( var key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			var attribute1 = attributes[ key ];
			var attributeArray1 = attribute1.array;

			var attribute2 = geometry.attributes[ key ];
			var attributeArray2 = attribute2.array;

			var attributeSize = attribute2.itemSize;

			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		var normals = this.attributes.normal.array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i ] *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.4,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		data.data = { attributes: {} };

		var index = this.index;

		if ( index !== null ) {

			var array = Array.prototype.slice.call( index.array );

			data.data.index = {
				type: index.array.constructor.name,
				array: array
			};

		}

		var attributes = this.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var array = Array.prototype.slice.call( attribute.array );

			data.data.attributes[ key ] = {
				itemSize: attribute.itemSize,
				type: attribute.array.constructor.name,
				array: array
			};

		}

		var groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		var boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		var attributes = source.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );

		}

		var groups = source.groups;

		for ( var i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count );

		}

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

THREE.BufferGeometry.MaxIndex = 65535;

// File:src/core/InstancedBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferGeometry = function () {

	THREE.BufferGeometry.call( this );

	this.type = 'InstancedBufferGeometry';
	this.maxInstancedCount = undefined;

};

THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

THREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

	this.groups.push( {

		start: start,
		count: count,
		instances: instances

	} );

};

THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {

	var index = source.index;

	if ( index !== null ) {

		this.setIndex( index.clone() );

	}

	var attributes = source.attributes;

	for ( var name in attributes ) {

		var attribute = attributes[ name ];
		this.addAttribute( name, attribute.clone() );

	}

	var groups = source.groups;

	for ( var i = 0, l = groups.length; i < l; i ++ ) {

		var group = groups[ i ];
		this.addGroup( group.start, group.count, group.instances );

	}

	return this;

};

THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

// File:src/animation/AnimationAction.js

/**
 *
 * A clip that has been explicitly scheduled.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationAction = function ( clip, startTime, timeScale, weight, loop ) {

	if ( clip === undefined ) throw new Error( 'clip is null' );
	this.clip = clip;
	this.localRoot = null;
	this.startTime = startTime || 0;
	this.timeScale = timeScale || 1;
	this.weight = weight || 1;
	this.loop = loop || THREE.LoopRepeat;
	this.loopCount = 0;
	this.enabled = true;	// allow for easy disabling of the action.

	this.actionTime = - this.startTime;
	this.clipTime = 0;

	this.propertyBindings = [];
};

/*
THREE.LoopOnce = 2200;
THREE.LoopRepeat = 2201;
THREE.LoopPingPing = 2202;
*/

THREE.AnimationAction.prototype = {

	constructor: THREE.AnimationAction,

	setLocalRoot: function( localRoot ) {

		this.localRoot = localRoot;

		return this;

	},

	updateTime: function( clipDeltaTime ) {

		var previousClipTime = this.clipTime;
   		var previousLoopCount = this.loopCount;
   		var previousActionTime = this.actionTime;

		var duration = this.clip.duration;

		this.actionTime = this.actionTime + clipDeltaTime;

		if ( this.loop === THREE.LoopOnce ) {

			this.loopCount = 0;
			this.clipTime = Math.min( Math.max( this.actionTime, 0 ), duration );

			// if time is changed since last time, see if we have hit a start/end limit
			if ( this.clipTime !== previousClipTime ) {

				if ( this.clipTime === duration ) {

					this.mixer.dispatchEvent( { type: 'finished', action: this, direction: 1 } );

				} else if ( this.clipTime === 0 ) {

					this.mixer.dispatchEvent( { type: 'finished', action: this, direction: -1 } );

				}

			}


			return this.clipTime;

		}

		this.loopCount = Math.floor( this.actionTime / duration );

		var newClipTime = this.actionTime - this.loopCount * duration;
		newClipTime = newClipTime % duration;

		// if we are ping pong looping, ensure that we go backwards when appropriate
		if ( this.loop == THREE.LoopPingPong ) {

			if ( Math.abs( this.loopCount % 2 ) === 1 ) {

				newClipTime = duration - newClipTime;

			}

		}

		this.clipTime = newClipTime;

		if ( this.loopCount !== previousLoopCount ) {

   			this.mixer.dispatchEvent( { type: 'loop', action: this, loopDelta: ( this.loopCount - this.loopCount ) } );

   		}

	   	return this.clipTime;

	},

	syncWith: function( action ) {

		this.actionTime = action.actionTime;
		this.timeScale = action.timeScale;

		return this;
	},

	warpToDuration: function( duration ) {

		this.timeScale = this.clip.duration / duration;

		return this;
	},

	init: function( time ) {

		this.clipTime = time - this.startTime;

		return this;

	},

	update: function( clipDeltaTime ) {

		this.updateTime( clipDeltaTime );

		var clipResults = this.clip.getAt( this.clipTime );

		return clipResults;

	},

	getTimeScaleAt: function( time ) {

		if ( this.timeScale.getAt ) {
			// pass in time, not clip time, allows for fadein/fadeout across multiple loops of the clip
			return this.timeScale.getAt( time );

		}

		return this.timeScale;

	},

	getWeightAt: function( time ) {

		if ( this.weight.getAt ) {
			// pass in time, not clip time, allows for fadein/fadeout across multiple loops of the clip
			return this.weight.getAt( time );

		}

		return this.weight;

	}

};

// File:src/animation/AnimationClip.js

/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationClip = function ( name, duration, tracks ) {

	this.name = name;
	this.tracks = tracks;
	this.duration = ( duration !== undefined ) ? duration : -1;

	// this means it should figure out its duration by scanning the tracks
	if ( this.duration < 0 ) {
		for ( var i = 0; i < this.tracks.length; i ++ ) {
			var track = this.tracks[i];
			this.duration = Math.max( track.keys[ track.keys.length - 1 ].time );
		}
	}

	// maybe only do these on demand, as doing them here could potentially slow down loading
	// but leaving these here during development as this ensures a lot of testing of these functions
	this.trim();
	this.optimize();

	this.results = [];

};

THREE.AnimationClip.prototype = {

	constructor: THREE.AnimationClip,

	getAt: function( clipTime ) {

		clipTime = Math.max( 0, Math.min( clipTime, this.duration ) );

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			var track = this.tracks[ i ];

			this.results[ i ] = track.getAt( clipTime );

		}

		return this.results;
	},

	trim: function() {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	},

	optimize: function() {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

};


THREE.AnimationClip.CreateFromMorphTargetSequence = function( name, morphTargetSequence, fps ) {


	var numMorphTargets = morphTargetSequence.length;
	var tracks = [];

	for ( var i = 0; i < numMorphTargets; i ++ ) {

		var keys = [];

		keys.push( { time: ( i + numMorphTargets - 1 ) % numMorphTargets, value: 0 } );
		keys.push( { time: i, value: 1 } );
		keys.push( { time: ( i + 1 ) % numMorphTargets, value: 0 } );

		keys.sort( THREE.KeyframeTrack.keyComparer );

		// if there is a key at the first frame, duplicate it as the last frame as well for perfect loop.
		if ( keys[0].time === 0 ) {
			keys.push( {
				time: numMorphTargets,
				value: keys[0].value
			});
		}

		tracks.push( new THREE.NumberKeyframeTrack( '.morphTargetInfluences[' + morphTargetSequence[i].name + ']', keys ).scale( 1.0 / fps ) );
	}

	return new THREE.AnimationClip( name, -1, tracks );

};

THREE.AnimationClip.findByName = function( clipArray, name ) {

	for ( var i = 0; i < clipArray.length; i ++ ) {

		if ( clipArray[i].name === name ) {

			return clipArray[i];

		}
	}

	return null;

};

THREE.AnimationClip.CreateClipsFromMorphTargetSequences = function( morphTargets, fps ) {

	var animationToMorphTargets = {};

	// tested with https://regex101.com/ on trick sequences such flamingo_flyA_003, flamingo_run1_003, crdeath0059
	var pattern = /^([\w-]*?)([\d]+)$/;

	// sort morph target names into animation groups based patterns like Walk_001, Walk_002, Run_001, Run_002
	for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

		var morphTarget = morphTargets[ i ];
		var parts = morphTarget.name.match( pattern );

		if ( parts && parts.length > 1 ) {

			var name = parts[ 1 ];

			var animationMorphTargets = animationToMorphTargets[ name ];
			if ( ! animationMorphTargets ) {
				animationToMorphTargets[ name ] = animationMorphTargets = [];
			}

			animationMorphTargets.push( morphTarget );

		}

	}

	var clips = [];

	for ( var name in animationToMorphTargets ) {

		clips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps ) );
	}

	return clips;

};

// parse the standard JSON format for clips
THREE.AnimationClip.parse = function( json ) {

	var tracks = [];

	for ( var i = 0; i < json.tracks.length; i ++ ) {

		tracks.push( THREE.KeyframeTrack.parse( json.tracks[i] ).scale( 1.0 / json.fps ) );

	}

	return new THREE.AnimationClip( json.name, json.duration, tracks );

};


// parse the animation.hierarchy format
THREE.AnimationClip.parseAnimation = function( animation, bones, nodeName ) {

	if ( ! animation ) {
		console.error( "  no animation in JSONLoader data" );
		return null;
	}

	var convertTrack = function( trackName, animationKeys, propertyName, trackType, animationKeyToValueFunc ) {

		var keys = [];

		for ( var k = 0; k < animationKeys.length; k ++ ) {

			var animationKey = animationKeys[k];

			if ( animationKey[propertyName] !== undefined ) {

				keys.push( { time: animationKey.time, value: animationKeyToValueFunc( animationKey ) } );
			}

		}

		// only return track if there are actually keys.
		if ( keys.length > 0 ) {

			return new trackType( trackName, keys );

		}

		return null;

	};

	var tracks = [];

	var clipName = animation.name || 'default';
	var duration = animation.length || -1; // automatic length determination in AnimationClip.
	var fps = animation.fps || 30;

	var hierarchyTracks = animation.hierarchy || [];

	for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

		var animationKeys = hierarchyTracks[ h ].keys;

		// skip empty tracks
		if ( ! animationKeys || animationKeys.length == 0 ) {
			continue;
		}

		// process morph targets in a way exactly compatible with AnimationHandler.init( animation )
		if ( animationKeys[0].morphTargets ) {

			// figure out all morph targets used in this track
			var morphTargetNames = {};
			for ( var k = 0; k < animationKeys.length; k ++ ) {

				if ( animationKeys[k].morphTargets ) {
					for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

						morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
					}
				}

			}

			// create a track for each morph target with all zero morphTargetInfluences except for the keys in which the morphTarget is named.
			for ( var morphTargetName in morphTargetNames ) {

				var keys = [];

				for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

					var animationKey = animationKeys[k];

					keys.push( {
							time: animationKey.time,
							value: (( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )
						});

				}

				tracks.push( new THREE.NumberKeyframeTrack( nodeName + '.morphTargetInfluence[' + morphTargetName + ']', keys ) );

			}

			duration = morphTargetNames.length * ( fps || 1.0 );

		} else {

			var boneName = nodeName + '.bones[' + bones[ h ].name + ']';

			// track contains positions...
			var positionTrack = convertTrack( boneName + '.position', animationKeys, 'pos', THREE.VectorKeyframeTrack, function( animationKey ) {
					return new THREE.Vector3().fromArray( animationKey.pos )
				} );

			if ( positionTrack ) tracks.push( positionTrack );

			// track contains quaternions...
			var quaternionTrack = convertTrack( boneName + '.quaternion', animationKeys, 'rot', THREE.QuaternionKeyframeTrack, function( animationKey ) {
					if ( animationKey.rot.slerp ) {
						return animationKey.rot.clone();
					} else {
						return new THREE.Quaternion().fromArray( animationKey.rot );
					}
				} );

			if ( quaternionTrack ) tracks.push( quaternionTrack );

			// track contains quaternions...
			var scaleTrack = convertTrack( boneName + '.scale', animationKeys, 'scl', THREE.VectorKeyframeTrack, function( animationKey ) {
					return new THREE.Vector3().fromArray( animationKey.scl )
				} );

			if ( scaleTrack ) tracks.push( scaleTrack );

		}
	}

	if ( tracks.length === 0 ) {

		return null;

	}

	var clip = new THREE.AnimationClip( clipName, duration, tracks );

	return clip;

};

// File:src/animation/AnimationMixer.js

/**
 *
 * Mixes together the AnimationClips scheduled by AnimationActions and applies them to the root and subtree
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationMixer = function( root ) {

	this.root = root;
	this.time = 0;
	this.timeScale = 1.0;
	this.actions = [];
	this.propertyBindingMap = {};

};

THREE.AnimationMixer.prototype = {

	constructor: THREE.AnimationMixer,

	addAction: function( action ) {

		// TODO: check for duplicate action names?  Or provide each action with a UUID?

		this.actions.push( action );
		action.init( this.time );
		action.mixer = this;

		var tracks = action.clip.tracks;

		var root = action.localRoot || this.root;

		for ( var i = 0; i < tracks.length; i ++ ) {

			var track = tracks[ i ];

			var propertyBindingKey = root.uuid + '-' + track.name;
			var propertyBinding = this.propertyBindingMap[ propertyBindingKey ];

			if ( propertyBinding === undefined ) {

				propertyBinding = new THREE.PropertyBinding( root, track.name );
				this.propertyBindingMap[ propertyBindingKey ] = propertyBinding;

			}

			// push in the same order as the tracks.
			action.propertyBindings.push( propertyBinding );

			// track usages of shared property bindings, because if we leave too many around, the mixer can get slow
			propertyBinding.referenceCount += 1;

		}

	},

	removeAllActions: function() {

		for ( var i = 0; i < this.actions.length; i ++ ) {

			this.actions[i].mixer = null;

		}

		// unbind all property bindings
		for ( var properyBindingKey in this.propertyBindingMap ) {

			this.propertyBindingMap[ properyBindingKey ].unbind();

		}

		this.actions = [];
		this.propertyBindingMap = {};

		return this;

	},

	removeAction: function( action ) {

		var index = this.actions.indexOf( action );

		if ( index !== - 1 ) {

			this.actions.splice( index, 1 );
			action.mixer = null;

		}


		// remove unused property bindings because if we leave them around the mixer can get slow
		var root = action.localRoot || this.root;
		var tracks = action.clip.tracks;

		for ( var i = 0; i < tracks.length; i ++ ) {

			var track = tracks[ i ];

			var propertyBindingKey = root.uuid + '-' + track.name;
			var propertyBinding = this.propertyBindingMap[ propertyBindingKey ];

			propertyBinding.referenceCount -= 1;

			if ( propertyBinding.referenceCount <= 0 ) {

				propertyBinding.unbind();

				delete this.propertyBindingMap[ propertyBindingKey ];

			}
		}

		return this;

	},

	// can be optimized if needed
	findActionByName: function( name ) {

		for ( var i = 0; i < this.actions.length; i ++ ) {

			if ( this.actions[i].name === name ) return this.actions[i];

		}

		return null;

	},

	play: function( action, optionalFadeInDuration ) {

		action.startTime = this.time;
		this.addAction( action );

		return this;

	},

	fadeOut: function( action, duration ) {

		var keys = [];

		keys.push( { time: this.time, value: 1 } );
		keys.push( { time: this.time + duration, value: 0 } );

		action.weight = new THREE.NumberKeyframeTrack( "weight", keys );

		return this;

	},

	fadeIn: function( action, duration ) {

		var keys = [];

		keys.push( { time: this.time, value: 0 } );
		keys.push( { time: this.time + duration, value: 1 } );

		action.weight = new THREE.NumberKeyframeTrack( "weight", keys );

		return this;

	},

	warp: function( action, startTimeScale, endTimeScale, duration ) {

		var keys = [];

		keys.push( { time: this.time, value: startTimeScale } );
		keys.push( { time: this.time + duration, value: endTimeScale } );

		action.timeScale = new THREE.NumberKeyframeTrack( "timeScale", keys );

		return this;

	},

	crossFade: function( fadeOutAction, fadeInAction, duration, warp ) {

		this.fadeOut( fadeOutAction, duration );
		this.fadeIn( fadeInAction, duration );

		if ( warp ) {

			var startEndRatio = fadeOutAction.clip.duration / fadeInAction.clip.duration;
			var endStartRatio = 1.0 / startEndRatio;

			this.warp( fadeOutAction, 1.0, startEndRatio, duration );
			this.warp( fadeInAction, endStartRatio, 1.0, duration );

		}

		return this;

	},

	update: function( deltaTime ) {

		var mixerDeltaTime = deltaTime * this.timeScale;
		this.time += mixerDeltaTime;

		for ( var i = 0; i < this.actions.length; i ++ ) {

			var action = this.actions[i];

			var weight = action.getWeightAt( this.time );

			var actionTimeScale = action.getTimeScaleAt( this.time );
			var actionDeltaTime = mixerDeltaTime * actionTimeScale;

			var actionResults = action.update( actionDeltaTime );

			if ( action.weight <= 0 || ! action.enabled ) continue;

			for ( var j = 0; j < actionResults.length; j ++ ) {

				var name = action.clip.tracks[j].name;

				action.propertyBindings[ j ].accumulate( actionResults[j], weight );

			}

		}

		// apply to nodes
		for ( var propertyBindingKey in this.propertyBindingMap ) {

			this.propertyBindingMap[ propertyBindingKey ].apply();

		}

		return this;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );

// File:src/animation/AnimationUtils.js

/**
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationUtils = {

	getEqualsFunc: function( exemplarValue ) {

		if ( exemplarValue.equals ) {
			return function equals_object( a, b ) {
				return a.equals( b );
			}
		}

		return function equals_primitive( a, b ) {
			return ( a === b );
		};

	},

	clone: function( exemplarValue ) {

		var typeName = typeof exemplarValue;
		if ( typeName === "object" ) {
			if ( exemplarValue.clone ) {
				return exemplarValue.clone();
			}
			console.error( "can not figure out how to copy exemplarValue", exemplarValue );
		}

		return exemplarValue;

	},

	lerp: function( a, b, alpha, interTrack ) {

		var lerpFunc = THREE.AnimationUtils.getLerpFunc( a, interTrack );

		return lerpFunc( a, b, alpha );

	},

	lerp_object: function( a, b, alpha ) {
		return a.lerp( b, alpha );
	},

	slerp_object: function( a, b, alpha ) {
		return a.slerp( b, alpha );
	},

	lerp_number: function( a, b, alpha ) {
		return a * ( 1 - alpha ) + b * alpha;
	},

	lerp_boolean: function( a, b, alpha ) {
		return ( alpha < 0.5 ) ? a : b;
	},

	lerp_boolean_immediate: function( a, b, alpha ) {
		return a;
	},

	lerp_string: function( a, b, alpha ) {
		return ( alpha < 0.5 ) ? a : b;
	},

	lerp_string_immediate: function( a, b, alpha ) {
 		return a;
 	},

	// NOTE: this is an accumulator function that modifies the first argument (e.g. a).	This is to minimize memory alocations.
	getLerpFunc: function( exemplarValue, interTrack ) {

		if ( exemplarValue === undefined || exemplarValue === null ) throw new Error( "examplarValue is null" );

		var typeName = typeof exemplarValue;

		switch( typeName ) {

			case "object":
				if ( exemplarValue.lerp ) {
					return THREE.AnimationUtils.lerp_object;
				}

				if ( exemplarValue.slerp ) {
					return THREE.AnimationUtils.slerp_object;
				}
				break;

			case "number":
				return THREE.AnimationUtils.lerp_number;

			case "boolean":
				if ( interTrack ) {
					return THREE.AnimationUtils.lerp_boolean;
				} else {
					return THREE.AnimationUtils.lerp_boolean_immediate;
				}

			case "string":
				if ( interTrack ) {
					return THREE.AnimationUtils.lerp_string;
				} else {
					return THREE.AnimationUtils.lerp_string_immediate;
				}

		}

	}

};

// File:src/animation/KeyframeTrack.js

/**
 *
 * A Track that returns a keyframe interpolated value, currently linearly interpolated
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.KeyframeTrack = function ( name, keys ) {

	if ( name === undefined ) throw new Error( "track name is undefined" );
	if ( keys === undefined || keys.length === 0 ) throw new Error( "no keys in track named " + name );

	this.name = name;
	this.keys = keys;	// time in seconds, value as value

	// the index of the last result, used as a starting point for local search.
	this.lastIndex = 0;

	this.validate();
	this.optimize();

};

THREE.KeyframeTrack.prototype = {

	constructor: THREE.KeyframeTrack,

	getAt: function( time ) {


		// this can not go higher than this.keys.length.
		while( ( this.lastIndex < this.keys.length ) && ( time >= this.keys[this.lastIndex].time ) ) {
			this.lastIndex ++;
		};

		// this can not go lower than 0.
		while( ( this.lastIndex > 0 ) && ( time < this.keys[this.lastIndex - 1].time ) ) {
			this.lastIndex --;
		}

		if ( this.lastIndex >= this.keys.length ) {

			this.setResult( this.keys[ this.keys.length - 1 ].value );

			return this.result;

		}

		if ( this.lastIndex === 0 ) {

			this.setResult( this.keys[ 0 ].value );

			return this.result;

		}

		var prevKey = this.keys[ this.lastIndex - 1 ];
		this.setResult( prevKey.value );

		// if true, means that prev/current keys are identical, thus no interpolation required.
		if ( prevKey.constantToNext ) {

			return this.result;

		}

		// linear interpolation to start with
		var currentKey = this.keys[ this.lastIndex ];
		var alpha = ( time - prevKey.time ) / ( currentKey.time - prevKey.time );
		this.result = this.lerpValues( this.result, currentKey.value, alpha );

		return this.result;

	},

	// move all keyframes either forwards or backwards in time
	shift: function( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			for ( var i = 0; i < this.keys.length; i ++ ) {
				this.keys[i].time += timeOffset;
			}

		}

		return this;

	},

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale: function( timeScale ) {

		if ( timeScale !== 1.0 ) {

			for ( var i = 0; i < this.keys.length; i ++ ) {
				this.keys[i].time *= timeScale;
			}

		}

		return this;

	},

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
 	trim: function( startTime, endTime ) {

		var firstKeysToRemove = 0;
		for ( var i = 1; i < this.keys.length; i ++ ) {
			if ( this.keys[i] <= startTime ) {
				firstKeysToRemove ++;
			}
		}

		var lastKeysToRemove = 0;
		for ( var i = this.keys.length - 2; i > 0; i ++ ) {
			if ( this.keys[i] >= endTime ) {
				lastKeysToRemove ++;
			} else {
				break;
			}
		}

		// remove last keys first because it doesn't affect the position of the first keys (the otherway around doesn't work as easily)
		if ( ( firstKeysToRemove + lastKeysToRemove ) > 0 ) {
			this.keys = this.keys.splice( firstKeysToRemove, this.keys.length - lastKeysToRemove - firstKeysToRemove );;
		}

		return this;

	},

	/* NOTE: This is commented out because we really shouldn't have to handle unsorted key lists
	         Tracks with out of order keys should be considered to be invalid.  - bhouston
	sort: function() {

		this.keys.sort( THREE.KeyframeTrack.keyComparer );

		return this;

	},*/

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	// One could eventually ensure that all key.values in a track are all of the same type (otherwise interpolation makes no sense.)
	validate: function() {

		var prevKey = null;

		if ( this.keys.length === 0 ) {
			console.error( "  track is empty, no keys", this );
			return;
		}

		for ( var i = 0; i < this.keys.length; i ++ ) {

			var currKey = this.keys[i];

			if ( ! currKey ) {
				console.error( "  key is null in track", this, i );
				return;
			}

			if ( ( typeof currKey.time ) !== 'number' || isNaN( currKey.time ) ) {
				console.error( "  key.time is not a valid number", this, i, currKey );
				return;
			}

			if ( currKey.value === undefined || currKey.value === null) {
				console.error( "  key.value is null in track", this, i, currKey );
				return;
			}

			if ( prevKey && prevKey.time > currKey.time ) {
				console.error( "  key.time is less than previous key time, out of order keys", this, i, currKey, prevKey );
				return;
			}

			prevKey = currKey;

		}

		return this;

	},

	// currently only removes equivalent sequential keys (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0), which are common in morph target animations
	optimize: function() {

		var newKeys = [];
		var prevKey = this.keys[0];
		newKeys.push( prevKey );

		var equalsFunc = THREE.AnimationUtils.getEqualsFunc( prevKey.value );

		for ( var i = 1; i < this.keys.length - 1; i ++ ) {
			var currKey = this.keys[i];
			var nextKey = this.keys[i+1];

			// if prevKey & currKey are the same time, remove currKey.  If you want immediate adjacent keys, use an epsilon offset
			// it is not possible to have two keys at the same time as we sort them.  The sort is not stable on keys with the same time.
			if ( ( prevKey.time === currKey.time ) ) {

				continue;

			}

			// remove completely unnecessary keyframes that are the same as their prev and next keys
			if ( this.compareValues( prevKey.value, currKey.value ) && this.compareValues( currKey.value, nextKey.value ) ) {

				continue;

			}

			// determine if interpolation is required
			prevKey.constantToNext = this.compareValues( prevKey.value, currKey.value );

			newKeys.push( currKey );
			prevKey = currKey;
		}
		newKeys.push( this.keys[ this.keys.length - 1 ] );

		this.keys = newKeys;

		return this;

	}

};

THREE.KeyframeTrack.keyComparer = function keyComparator(key0, key1) {
	return key0.time - key1.time;
};

THREE.KeyframeTrack.parse = function( json ) {

	if ( json.type === undefined ) throw new Error( "track type undefined, can not parse" );

	var trackType = THREE.KeyframeTrack.GetTrackTypeForTypeName( json.type );

	return trackType.parse( json );

};

THREE.KeyframeTrack.GetTrackTypeForTypeName = function( typeName ) {
	switch( typeName.toLowerCase() ) {
	 	case "vector":
	 	case "vector2":
	 	case "vector3":
	 	case "vector4":
			return THREE.VectorKeyframeTrack;

	 	case "quaternion":
			return THREE.QuaternionKeyframeTrack;

	 	case "integer":
	 	case "scalar":
	 	case "double":
	 	case "float":
	 	case "number":
			return THREE.NumberKeyframeTrack;

	 	case "bool":
	 	case "boolean":
			return THREE.BooleanKeyframeTrack;

	 	case "string":
	 		return THREE.StringKeyframeTrack;
	};

	throw new Error( "Unsupported typeName: " + typeName );
};

// File:src/animation/PropertyBinding.js

/**
 *
 * A track bound to a real value in the scene graph.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.PropertyBinding = function ( rootNode, trackName ) {

	this.rootNode = rootNode;
	this.trackName = trackName;
	this.referenceCount = 0;
	this.originalValue = null; // the value of the property before it was controlled by this binding

	var parseResults = THREE.PropertyBinding.parseTrackName( trackName );

	this.directoryName = parseResults.directoryName;
	this.nodeName = parseResults.nodeName;
	this.objectName = parseResults.objectName;
	this.objectIndex = parseResults.objectIndex;
	this.propertyName = parseResults.propertyName;
	this.propertyIndex = parseResults.propertyIndex;

	this.node = THREE.PropertyBinding.findNode( rootNode, this.nodeName ) || rootNode;

	this.cumulativeValue = null;
	this.cumulativeWeight = 0;
};

THREE.PropertyBinding.prototype = {

	constructor: THREE.PropertyBinding,

	reset: function() {

		this.cumulativeValue = null;
		this.cumulativeWeight = 0;

	},

	accumulate: function( value, weight ) {

		if ( ! this.isBound ) this.bind();

		if ( this.cumulativeWeight === 0 ) {

			if ( weight > 0 ) {

				if ( this.cumulativeValue === null ) {
					this.cumulativeValue = THREE.AnimationUtils.clone( value );
				}
				this.cumulativeWeight = weight;

			}

		} else {

			var lerpAlpha = weight / ( this.cumulativeWeight + weight );
			this.cumulativeValue = this.lerpValue( this.cumulativeValue, value, lerpAlpha );
			this.cumulativeWeight += weight;

		}

	},

	unbind: function() {

		if ( ! this.isBound ) return;

		this.setValue( this.originalValue );

		this.setValue = null;
		this.getValue = null;
		this.lerpValue = null;
		this.equalsValue = null;
		this.triggerDirty = null;
		this.isBound = false;

	},

	// bind to the real property in the scene graph, remember original value, memorize various accessors for speed/inefficiency
	bind: function() {

		if ( this.isBound ) return;

		var targetObject = this.node;

 		// ensure there is a value node
		if ( ! targetObject ) {
			console.error( "  trying to update node for track: " + this.trackName + " but it wasn't found." );
			return;
		}

		if ( this.objectName ) {
			// special case were we need to reach deeper into the hierarchy to get the face materials....
			if ( this.objectName === "materials" ) {
				if ( ! targetObject.material ) {
					console.error( '  can not bind to material as node does not have a material', this );
					return;
				}
				if ( ! targetObject.material.materials ) {
					console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
					return;
				}
				targetObject = targetObject.material.materials;
			} else if ( this.objectName === "bones" ) {
				if ( ! targetObject.skeleton ) {
					console.error( '  can not bind to bones as node does not have a skeleton', this );
					return;
				}
				// potential future optimization: skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				targetObject = targetObject.skeleton.bones;

				// support resolving morphTarget names into indices.
				for ( var i = 0; i < targetObject.length; i ++ ) {
					if ( targetObject[i].name === this.objectIndex ) {
						this.objectIndex = i;
						break;
					}
				}
			} else {

				if ( targetObject[ this.objectName ] === undefined ) {
					console.error( '  can not bind to objectName of node, undefined', this );
					return;
				}
				targetObject = targetObject[ this.objectName ];
			}

			if ( this.objectIndex !== undefined ) {
				if ( targetObject[ this.objectIndex ] === undefined ) {
					console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
					return;
				}

				targetObject = targetObject[ this.objectIndex ];
			}

		}

 		// special case mappings
 		var nodeProperty = targetObject[ this.propertyName ];
		if ( ! nodeProperty ) {
			console.error( "  trying to update property for track: " + this.nodeName + '.' + this.propertyName + " but it wasn't found.", targetObject );
			return;
		}

		// access a sub element of the property array (only primitives are supported right now)
		if ( this.propertyIndex !== undefined ) {

			if ( this.propertyName === "morphTargetInfluences" ) {
				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {
					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
				}
				if ( ! targetObject.geometry.morphTargets ) {
					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
				}

				for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
					if ( targetObject.geometry.morphTargets[i].name === this.propertyIndex ) {
						this.propertyIndex = i;
						break;
					}
				}
			}

			this.setValue = function setValue_propertyIndexed( value ) {
				if ( ! this.equalsValue( nodeProperty[ this.propertyIndex ], value ) ) {
					nodeProperty[ this.propertyIndex ] = value;
					return true;
				}
				return false;
			};

			this.getValue = function getValue_propertyIndexed() {
				return nodeProperty[ this.propertyIndex ];
			};

		}
		// must use copy for Object3D.Euler/Quaternion
		else if ( nodeProperty.copy ) {

			this.setValue = function setValue_propertyObject( value ) {
				if ( ! this.equalsValue( nodeProperty, value ) ) {
					nodeProperty.copy( value );
					return true;
				}
				return false;
			}

			this.getValue = function getValue_propertyObject() {
				return nodeProperty;
			};

		}
		// otherwise just set the property directly on the node (do not use nodeProperty as it may not be a reference object)
		else {

			this.setValue = function setValue_property( value ) {
				if ( ! this.equalsValue( targetObject[ this.propertyName ], value ) ) {
					targetObject[ this.propertyName ] = value;
					return true;
				}
				return false;
			}

			this.getValue = function getValue_property() {
				return targetObject[ this.propertyName ];
			};

		}

		// trigger node dirty
		if ( targetObject.needsUpdate !== undefined ) { // material

			this.triggerDirty = function triggerDirty_needsUpdate() {
				this.node.needsUpdate = true;
			}

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			this.triggerDirty = function triggerDirty_matrixWorldNeedsUpdate() {
				targetObject.matrixWorldNeedsUpdate = true;
			}

		}

		this.originalValue = this.getValue();

		this.equalsValue = THREE.AnimationUtils.getEqualsFunc( this.originalValue );
		this.lerpValue = THREE.AnimationUtils.getLerpFunc( this.originalValue, true );

		this.isBound = true;

	},

	apply: function() {

		// for speed capture the setter pattern as a closure (sort of a memoization pattern: https://en.wikipedia.org/wiki/Memoization)
		if ( ! this.isBound ) this.bind();

		// early exit if there is nothing to apply.
		if ( this.cumulativeWeight > 0 ) {

			// blend with original value
			if ( this.cumulativeWeight < 1 ) {

				var remainingWeight = 1 - this.cumulativeWeight;
				var lerpAlpha = remainingWeight / ( this.cumulativeWeight + remainingWeight );
				this.cumulativeValue = this.lerpValue( this.cumulativeValue, this.originalValue, lerpAlpha );

			}

			var valueChanged = this.setValue( this.cumulativeValue );

			if ( valueChanged && this.triggerDirty ) {
				this.triggerDirty();
			}

			// reset accumulator
			this.cumulativeValue = null;
			this.cumulativeWeight = 0;

		}
	}

};


THREE.PropertyBinding.parseTrackName = function( trackName ) {

	// matches strings in the form of:
	//    nodeName.property
	//    nodeName.property[accessor]
	//    nodeName.material.property[accessor]
	//    uuid.property[accessor]
	//    uuid.objectName[objectIndex].propertyName[propertyIndex]
	//    parentName/nodeName.property
	//    parentName/parentName/nodeName.property[index]
	//	  .bone[Armature.DEF_cog].position
	// created and tested via https://regex101.com/#javascript

	var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
	var matches = re.exec(trackName);

	if ( ! matches ) {
		throw new Error( "cannot parse trackName at all: " + trackName );
	}

    if (matches.index === re.lastIndex) {
        re.lastIndex++;
    }

	var results = {
		directoryName: matches[1],
		nodeName: matches[3], 	// allowed to be null, specified root node.
		objectName: matches[5],
		objectIndex: matches[7],
		propertyName: matches[9],
		propertyIndex: matches[11]	// allowed to be null, specifies that the whole property is set.
	};

	if ( results.propertyName === null || results.propertyName.length === 0 ) {
		throw new Error( "can not parse propertyName from trackName: " + trackName );
	}

	return results;

};

THREE.PropertyBinding.findNode = function( root, nodeName ) {

	function searchSkeleton( skeleton ) {

		for ( var i = 0; i < skeleton.bones.length; i ++ ) {

			var bone = skeleton.bones[i];

			if ( bone.name === nodeName ) {

				return bone;

			}
		}

		return null;

	}

	function searchNodeSubtree( children ) {

		for ( var i = 0; i < children.length; i ++ ) {

			var childNode = children[i];

			if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

				return childNode;

			}

			var result = searchNodeSubtree( childNode.children );

			if ( result ) return result;

		}

		return null;

	}

	//

	if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

		return root;

	}

	// search into skeleton bones.
	if ( root.skeleton ) {

		var bone = searchSkeleton( root.skeleton );

		if ( bone ) {

			return bone;

		}
	}

	// search into node subtree.
	if ( root.children ) {

		var subTreeNode = searchNodeSubtree( root.children );

		if ( subTreeNode ) {

			return subTreeNode;

		}

	}

	return null;
}

// File:src/animation/tracks/VectorKeyframeTrack.js

/**
 *
 * A Track that interpolates Vectors
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.VectorKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value.clone();

};

THREE.VectorKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.VectorKeyframeTrack.prototype.constructor = THREE.VectorKeyframeTrack;

THREE.VectorKeyframeTrack.prototype.setResult = function( value ) {

	this.result.copy( value );

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.VectorKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return value0.lerp( value1, alpha );

};

THREE.VectorKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return value0.equals( value1 );

};

THREE.VectorKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value.clone()
		} );
	}

	return new THREE.VectorKeyframeTrack( this.name, clonedKeys );

};

THREE.VectorKeyframeTrack.parse = function( json ) {

	var elementCount = json.keys[0].value.length;
	var valueType = THREE[ 'Vector' + elementCount ];

	var keys = [];

	for ( var i = 0; i < json.keys.length; i ++ ) {
		var jsonKey = json.keys[i];
		keys.push( {
			value: new valueType().fromArray( jsonKey.value ),
			time: jsonKey.time
		} );
	}

	return new THREE.VectorKeyframeTrack( json.name, keys );

};

// File:src/animation/tracks/QuaternionKeyframeTrack.js

/**
 *
 * A Track that interpolates Quaternion
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.QuaternionKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value.clone();

};

THREE.QuaternionKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.QuaternionKeyframeTrack.prototype.constructor = THREE.QuaternionKeyframeTrack;

THREE.QuaternionKeyframeTrack.prototype.setResult = function( value ) {

	this.result.copy( value );

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.QuaternionKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return value0.slerp( value1, alpha );

};

THREE.QuaternionKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return value0.equals( value1 );

};

THREE.QuaternionKeyframeTrack.prototype.multiply = function( quat ) {

	for ( var i = 0; i < this.keys.length; i ++ ) {

		this.keys[i].value.multiply( quat );

	}

	return this;

};

THREE.QuaternionKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value.clone()
		} );
	}

	return new THREE.QuaternionKeyframeTrack( this.name, clonedKeys );

};

THREE.QuaternionKeyframeTrack.parse = function( json ) {

	var keys = [];

	for ( var i = 0; i < json.keys.length; i ++ ) {
		var jsonKey = json.keys[i];
		keys.push( {
			value: new THREE.Quaternion().fromArray( jsonKey.value ),
			time: jsonKey.time
		} );
	}

	return new THREE.QuaternionKeyframeTrack( json.name, keys );

};

// File:src/animation/tracks/StringKeyframeTrack.js

/**
 *
 * A Track that interpolates Strings
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.StringKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value;

};

THREE.StringKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.StringKeyframeTrack.prototype.constructor = THREE.StringKeyframeTrack;

THREE.StringKeyframeTrack.prototype.setResult = function( value ) {

	this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.StringKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return ( alpha < 1.0 ) ? value0 : value1;

};

THREE.StringKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return ( value0 === value1 );

};

THREE.StringKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value
		} );
	}

	return new THREE.StringKeyframeTrack( this.name, clonedKeys );

};

THREE.StringKeyframeTrack.parse = function( json ) {

	return new THREE.StringKeyframeTrack( json.name, json.keys );

};

// File:src/animation/tracks/BooleanKeyframeTrack.js

/**
 *
 * A Track that interpolates Boolean
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.BooleanKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value;

};

THREE.BooleanKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.BooleanKeyframeTrack.prototype.constructor = THREE.BooleanKeyframeTrack;

THREE.BooleanKeyframeTrack.prototype.setResult = function( value ) {

	this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.BooleanKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return ( alpha < 1.0 ) ? value0 : value1;

};

THREE.BooleanKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return ( value0 === value1 );

};

THREE.BooleanKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value
		} );
	}

	return new THREE.BooleanKeyframeTrack( this.name, clonedKeys );

};

THREE.BooleanKeyframeTrack.parse = function( json ) {

	return new THREE.BooleanKeyframeTrack( json.name, json.keys );

};

// File:src/animation/tracks/NumberKeyframeTrack.js

/**
 *
 * A Track that interpolates Numbers
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.NumberKeyframeTrack = function ( name, keys ) {

	THREE.KeyframeTrack.call( this, name, keys );

	// local cache of value type to avoid allocations during runtime.
	this.result = this.keys[0].value;

};

THREE.NumberKeyframeTrack.prototype = Object.create( THREE.KeyframeTrack.prototype );

THREE.NumberKeyframeTrack.prototype.constructor = THREE.NumberKeyframeTrack;

THREE.NumberKeyframeTrack.prototype.setResult = function( value ) {

	this.result = value;

};

// memoization of the lerp function for speed.
// NOTE: Do not optimize as a prototype initialization closure, as value0 will be different on a per class basis.
THREE.NumberKeyframeTrack.prototype.lerpValues = function( value0, value1, alpha ) {

	return value0 * ( 1 - alpha ) + value1 * alpha;

};

THREE.NumberKeyframeTrack.prototype.compareValues = function( value0, value1 ) {

	return ( value0 === value1 );

};

THREE.NumberKeyframeTrack.prototype.clone = function() {

	var clonedKeys = [];

	for ( var i = 0; i < this.keys.length; i ++ ) {

		var key = this.keys[i];
		clonedKeys.push( {
			time: key.time,
			value: key.value
		} );
	}

	return new THREE.NumberKeyframeTrack( this.name, clonedKeys );

};

THREE.NumberKeyframeTrack.parse = function( json ) {

	return new THREE.NumberKeyframeTrack( json.name, json.keys );

};

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

	THREE.Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new THREE.Matrix4();
	this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function () {

	var quaternion = new THREE.Quaternion();

	return function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.getWorldQuaternion( quaternion );

		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

	};

}();

THREE.Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new THREE.Matrix4();

	return function ( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

THREE.Camera.prototype.clone = function () {

	return new this.constructor().copy( this );

};

THREE.Camera.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source );

	this.matrixWorldInverse.copy( source.matrixWorldInverse );
	this.projectionMatrix.copy( source.projectionMatrix );

	return this;

};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

	THREE.Object3D.call( this );

	this.type = 'CubeCamera';

	var fov = 90, aspect = 1;

	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

	this.updateCubeMap = function ( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

		renderer.setRenderTarget( null );

	};

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	THREE.Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

	var dx = ( this.right - this.left ) / ( 2 * this.zoom );
	var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
	var cx = ( this.right + this.left ) / 2;
	var cy = ( this.top + this.bottom ) / 2;

	this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.copy = function ( source ) {
	
	THREE.Camera.prototype.copy.call( this, source );
	
	this.left = source.left;
	this.right = source.right;
	this.top = source.top;
	this.bottom = source.bottom;
	this.near = source.near;
	this.far = source.far;
	
	this.zoom = source.zoom;
	
	return this;
		
};

THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {

	var data = THREE.Object3D.prototype.toJSON.call( this, meta );

	data.object.zoom = this.zoom;
	data.object.left = this.left;
	data.object.right = this.right;
	data.object.top = this.top;
	data.object.bottom = this.bottom;
	data.object.near = this.near;
	data.object.far = this.far;

	return data;

};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

	THREE.Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.zoom = 1;

	this.fov = fov !== undefined ? fov : 50;
	this.aspect = aspect !== undefined ? aspect : 1;
	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (full-frame) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
	this.updateProjectionMatrix();

};


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

	this.fullWidth = fullWidth;
	this.fullHeight = fullHeight;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;

	this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

	var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

	if ( this.fullWidth ) {

		var aspect = this.fullWidth / this.fullHeight;
		var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
		var bottom = - top;
		var left = aspect * bottom;
		var right = aspect * top;
		var width = Math.abs( right - left );
		var height = Math.abs( top - bottom );

		this.projectionMatrix.makeFrustum(
			left + this.x * width / this.fullWidth,
			left + ( this.x + this.width ) * width / this.fullWidth,
			top - ( this.y + this.height ) * height / this.fullHeight,
			top - this.y * height / this.fullHeight,
			this.near,
			this.far
		);

	} else {

		this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

	}

};

THREE.PerspectiveCamera.prototype.copy = function ( source ) {
	
	THREE.Camera.prototype.copy.call( this, source );
	
	this.fov = source.fov;
	this.aspect = source.aspect;
	this.near = source.near;
	this.far = source.far;
	
	this.zoom = source.zoom;
	
	return this;
		
};

THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {

	var data = THREE.Object3D.prototype.toJSON.call( this, meta );

	data.object.zoom = this.zoom;
	data.object.fov = this.fov;
	data.object.aspect = this.aspect;
	data.object.near = this.near;
	data.object.far = this.far;

	return data;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color ) {

	THREE.Object3D.call( this );

	this.type = 'Light';

	this.color = new THREE.Color( color );

	this.receiveShadow = undefined;

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
THREE.Light.prototype.constructor = THREE.Light;

Object.defineProperties( THREE.Light.prototype, {
	onlyShadow: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .onlyShadow has been removed.' );
		}
	},
	shadowCameraFov: {
		set: function ( value ) {
			this.shadow.camera.fov = value;
		}
	},
	shadowCameraLeft: {
		set: function ( value ) {
			this.shadow.camera.left = value;
		}
	},
	shadowCameraRight: {
		set: function ( value ) {
			this.shadow.camera.right = value;
		}
	},
	shadowCameraTop: {
		set: function ( value ) {
			this.shadow.camera.top = value;
		}
	},
	shadowCameraBottom: {
		set: function ( value ) {
			this.shadow.camera.bottom = value;
		}
	},
	shadowCameraNear: {
		set: function ( value ) {
			this.shadow.camera.near = value;
		}
	},
	shadowCameraFar: {
		set: function ( value ) {
			this.shadow.camera.far = value;
		}
	},
	shadowCameraVisible: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow ) instead.' );
		}
	},
	shadowBias: {
		set: function ( value ) {
			this.shadow.bias = value;
		}
	},
	shadowDarkness: {
		set: function ( value ) {
			this.shadow.darkness = value;
		}
	},
	shadowMapWidth: {
		set: function ( value ) {
			this.shadow.mapSize.width = value;
		}
	},
	shadowMapHeight: {
		set: function ( value ) {
			this.shadow.mapSize.height = value;
		}
	}
} );

THREE.Light.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source );

	this.color.copy( source.color );

	return this;

};

THREE.Light.prototype.toJSON = function ( meta ) {

	var data = THREE.Object3D.prototype.toJSON.call( this, meta );

	data.object.color = this.color.getHex();
	if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

	if ( this.intensity !== undefined ) data.object.intensity = this.intensity;
	if ( this.distance !== undefined ) data.object.distance = this.distance;
	if ( this.angle !== undefined ) data.object.angle = this.angle;
	if ( this.decay !== undefined ) data.object.decay = this.decay;
	if ( this.exponent !== undefined ) data.object.exponent = this.exponent;

	return data;

};

// File:src/lights/LightShadow.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LightShadow = function ( camera ) {

	this.camera = camera;

	this.bias = 0;
	this.darkness = 1;

	this.mapSize = new THREE.Vector2( 512, 512 );

	this.map = null;
	this.matrix = null;

};

THREE.LightShadow.prototype = {

	constructor: THREE.LightShadow,

	copy: function ( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.darkness = source.darkness;

		this.mapSize.copy( source.mapSize );

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

	THREE.Light.call( this, color );

	this.type = 'AmbientLight';

	this.castShadow = undefined;

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

	THREE.Light.call( this, color );

	this.type = 'DirectionalLight';

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.shadow = new THREE.LightShadow( new THREE.OrthographicCamera( - 500, 500, 500, - 500, 50, 5000 ) );

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

THREE.DirectionalLight.prototype.copy = function ( source ) {

	THREE.Light.prototype.copy.call( this, source );

	this.intensity = source.intensity;
	this.target = source.target.clone();

	this.shadow = source.shadow.clone();

	return this;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

	THREE.Light.call( this, skyColor );

	this.type = 'HemisphereLight';

	this.castShadow = undefined;

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.groundColor = new THREE.Color( groundColor );
	this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

THREE.HemisphereLight.prototype.copy = function ( source ) {

	THREE.Light.prototype.copy.call( this, source );

	this.groundColor.copy( source.groundColor );
	this.intensity = source.intensity;

	return this;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */


THREE.PointLight = function ( color, intensity, distance, decay ) {

	THREE.Light.call( this, color );

	this.type = 'PointLight';

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 1, 500 ) );

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
THREE.PointLight.prototype.constructor = THREE.PointLight;

THREE.PointLight.prototype.copy = function ( source ) {

	THREE.Light.prototype.copy.call( this, source );

	this.intensity = source.intensity;
	this.distance = source.distance;
	this.decay = source.decay;

	this.shadow = source.shadow.clone();

	return this;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {

	THREE.Light.call( this, color );

	this.type = 'SpotLight';

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.exponent = ( exponent !== undefined ) ? exponent : 10;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 50, 5000 ) );

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
THREE.SpotLight.prototype.constructor = THREE.SpotLight;

THREE.SpotLight.prototype.copy = function ( source ) {

	THREE.Light.prototype.copy.call( this, source );

	this.intensity = source.intensity;
	this.distance = source.distance;
	this.angle = source.angle;
	this.exponent = source.exponent;
	this.decay = source.decay;

	this.target = source.target.clone();

	this.shadow = source.shadow.clone();

	return this;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function () {

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

	constructor: THREE.Loader,

	crossOrigin: undefined,

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );

		if ( parts.length === 1 ) return './';

		parts.pop();

		return parts.join( '/' ) + '/';

	},

	initMaterials: function ( materials, texturePath, crossOrigin ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

		}

		return array;

	},

	createMaterial: ( function () {

		var color, textureLoader, materialLoader;

		return function ( m, texturePath, crossOrigin ) {

			if ( color === undefined ) color = new THREE.Color();
			if ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();
			if ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();

			// convert from old material format

			var textures = {};

			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

				var fullPath = texturePath + path;
				var loader = THREE.Loader.Handlers.get( fullPath );

				var texture;

				if ( loader !== null ) {

					texture = loader.load( fullPath );

				} else {

					textureLoader.setCrossOrigin( crossOrigin );
					texture = textureLoader.load( fullPath );

				}

				if ( repeat !== undefined ) {

					texture.repeat.fromArray( repeat );

					if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

				}

				if ( offset !== undefined ) {

					texture.offset.fromArray( offset );

				}

				if ( wrap !== undefined ) {

					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;
					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;

					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;
					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;

				}

				if ( anisotropy !== undefined ) {

					texture.anisotropy = anisotropy;

				}

				var uuid = THREE.Math.generateUUID();

				textures[ uuid ] = texture;

				return uuid;

			}

			//

			var json = {
				uuid: THREE.Math.generateUUID(),
				type: 'MeshLambertMaterial'
			};

			for ( var name in m ) {

				var value = m[ name ];

				switch ( name ) {
					case 'DbgColor':
						json.color = value;
						break;
					case 'DbgIndex':
					case 'opticalDensity':
					case 'illumination':
						// These were never supported
						break;
					case 'DbgName':
						json.name = value;
						break;
					case 'blending':
						json.blending = THREE[ value ];
						break;
					case 'colorDiffuse':
						json.color = color.fromArray( value ).getHex();
						break;
					case 'colorSpecular':
						json.specular = color.fromArray( value ).getHex();
						break;
					case 'colorEmissive':
						json.emissive = color.fromArray( value ).getHex();
						break;
					case 'specularCoef':
						json.shininess = value;
						break;
					case 'shading':
						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
						break;
					case 'mapDiffuse':
						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
						break;
					case 'mapDiffuseRepeat':
					case 'mapDiffuseOffset':
					case 'mapDiffuseWrap':
					case 'mapDiffuseAnisotropy':
						break;
					case 'mapLight':
						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
						break;
					case 'mapLightRepeat':
					case 'mapLightOffset':
					case 'mapLightWrap':
					case 'mapLightAnisotropy':
						break;
					case 'mapAO':
						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
						break;
					case 'mapAORepeat':
					case 'mapAOOffset':
					case 'mapAOWrap':
					case 'mapAOAnisotropy':
						break;
					case 'mapBump':
						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
						break;
					case 'mapBumpScale':
						json.bumpScale = value;
						break;
					case 'mapBumpRepeat':
					case 'mapBumpOffset':
					case 'mapBumpWrap':
					case 'mapBumpAnisotropy':
						break;
					case 'mapNormal':
						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
						break;
					case 'mapNormalFactor':
						json.normalScale = [ value, value ];
						break;
					case 'mapNormalRepeat':
					case 'mapNormalOffset':
					case 'mapNormalWrap':
					case 'mapNormalAnisotropy':
						break;
					case 'mapSpecular':
						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
						break;
					case 'mapSpecularRepeat':
					case 'mapSpecularOffset':
					case 'mapSpecularWrap':
					case 'mapSpecularAnisotropy':
						break;
					case 'mapAlpha':
						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
						break;
					case 'mapAlphaRepeat':
					case 'mapAlphaOffset':
					case 'mapAlphaWrap':
					case 'mapAlphaAnisotropy':
						break;
					case 'flipSided':
						json.side = THREE.BackSide;
						break;
					case 'doubleSided':
						json.side = THREE.DoubleSide;
						break;
					case 'transparency':
						console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
						json.opacity = value;
						break;
					case 'opacity':
					case 'transparent':
					case 'depthTest':
					case 'depthWrite':
					case 'transparent':
					case 'visible':
					case 'wireframe':
						json[ name ] = value;
						break;
					case 'vertexColors':
						if ( value === true ) json.vertexColors = THREE.VertexColors;
						if ( value === 'face' ) json.vertexColors = THREE.FaceColors;
						break;
					default:
						console.error( 'Loader.createMaterial: Unsupported', name, value );
						break;
				}

			}

			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
			if ( json.opacity < 1 ) json.transparent = true;

			materialLoader.setTextures( textures );

			return materialLoader.parse( json );

		};

	} )()

};

THREE.Loader.Handlers = {

	handlers: [],

	add: function ( regex, loader ) {

		this.handlers.push( regex, loader );

	},

	get: function ( file ) {

		var handlers = this.handlers;

		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

			var regex = handlers[ i ];
			var loader  = handlers[ i + 1 ];

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	}

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

	constructor: THREE.XHRLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var cached = THREE.Cache.get( url );

		if ( cached !== undefined ) {

			if ( onLoad ) {

				setTimeout( function () {

					onLoad( cached );

				}, 0 );

			}

			return cached;

		}

		var request = new XMLHttpRequest();
		request.open( 'GET', url, true );

		request.addEventListener( 'load', function ( event ) {

			var response = event.target.response;

			THREE.Cache.add( url, response );

			if ( onLoad ) onLoad( response );

			scope.manager.itemEnd( url );

		}, false );

		if ( onProgress !== undefined ) {

			request.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		request.addEventListener( 'error', function ( event ) {

			if ( onError ) onError( event );

			scope.manager.itemError( url );

		}, false );

		if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
		if ( this.responseType !== undefined ) request.responseType = this.responseType;
		if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

		request.send( null );

		scope.manager.itemStart( url );

		return request;

	},

	setResponseType: function ( value ) {

		this.responseType = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;

	}

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

	constructor: THREE.ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var cached = THREE.Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			if ( onLoad ) {

				setTimeout( function () {

					onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

			} else {

				scope.manager.itemEnd( url );

			}

			return cached;

		}

		var image = document.createElement( 'img' );

		image.addEventListener( 'load', function ( event ) {

			THREE.Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}, false );

		if ( onProgress !== undefined ) {

			image.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		image.addEventListener( 'error', function ( event ) {

			if ( onError ) onError( event );

			scope.manager.itemError( url );

		}, false );

		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( manager ) {

	if ( typeof manager === 'boolean' ) {

		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
		manager = undefined;

	}

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	this.withCredentials = false;

};

THREE.JSONLoader.prototype = {

	constructor: THREE.JSONLoader,

	// Deprecated

	get statusDomElement () {

		if ( this._statusDomElement === undefined ) {

			this._statusDomElement = document.createElement( 'div' );

		}

		console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
		return this._statusDomElement;

	},

	load: function( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );

		var loader = new THREE.XHRLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			var json = JSON.parse( text );
			var metadata = json.metadata;

			if ( metadata !== undefined ) {

				if ( metadata.type === 'object' ) {

					console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
					return;

				}

				if ( metadata.type === 'scene' ) {

					console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
					return;

				}

			}

			var object = scope.parse( json, texturePath );
			onLoad( object.geometry, object.materials );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	parse: function ( json, texturePath ) {

		var geometry = new THREE.Geometry(),
		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

		parseModel( scale );

		parseSkin();
		parseMorphing( scale );
		parseAnimations();

		geometry.computeFaceNormals();
		geometry.computeBoundingSphere();

		function parseModel( scale ) {

			function isBitSet( value, position ) {

				return value & ( 1 << position );

			}

			var i, j, fi,

			offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

			type,
			isQuad,
			hasMaterial,
			hasFaceVertexUv,
			hasFaceNormal, hasFaceVertexNormal,
			hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, hex, normal,

			uvLayer, uv, u, v,

			faces = json.faces,
			vertices = json.vertices,
			normals = json.normals,
			colors = json.colors,

			nUvLayers = 0;

			if ( json.uvs !== undefined ) {

				// disregard empty arrays

				for ( i = 0; i < json.uvs.length; i ++ ) {

					if ( json.uvs[ i ].length ) nUvLayers ++;

				}

				for ( i = 0; i < nUvLayers; i ++ ) {

					geometry.faceVertexUvs[ i ] = [];

				}

			}

			offset = 0;
			zLength = vertices.length;

			while ( offset < zLength ) {

				vertex = new THREE.Vector3();

				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;

				geometry.vertices.push( vertex );

			}

			offset = 0;
			zLength = faces.length;

			while ( offset < zLength ) {

				type = faces[ offset ++ ];


				isQuad              = isBitSet( type, 0 );
				hasMaterial         = isBitSet( type, 1 );
				hasFaceVertexUv     = isBitSet( type, 3 );
				hasFaceNormal       = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor	     = isBitSet( type, 6 );
				hasFaceVertexColor  = isBitSet( type, 7 );

				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

				if ( isQuad ) {

					faceA = new THREE.Face3();
					faceA.a = faces[ offset ];
					faceA.b = faces[ offset + 1 ];
					faceA.c = faces[ offset + 3 ];

					faceB = new THREE.Face3();
					faceB.a = faces[ offset + 1 ];
					faceB.b = faces[ offset + 2 ];
					faceB.c = faces[ offset + 3 ];

					offset += 4;

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];
							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

							for ( j = 0; j < 4; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new THREE.Vector2( u, v );

								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						faceA.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						faceB.normal.copy( faceA.normal );

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 4; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);


							if ( i !== 2 ) faceA.vertexNormals.push( normal );
							if ( i !== 0 ) faceB.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						faceA.color.setHex( hex );
						faceB.color.setHex( hex );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 4; i ++ ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
							if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

						}

					}

					geometry.faces.push( faceA );
					geometry.faces.push( faceB );

				} else {

					face = new THREE.Face3();
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						face.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];

							for ( j = 0; j < 3; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new THREE.Vector2( u, v );

								geometry.faceVertexUvs[ i ][ fi ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						face.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 3; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							face.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						face.color.setHex( colors[ colorIndex ] );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 3; i ++ ) {

							colorIndex = faces[ offset ++ ];
							face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

						}

					}

					geometry.faces.push( face );

				}

			}

		};

		function parseSkin() {

			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

			if ( json.skinWeights ) {

				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

					var x =                               json.skinWeights[ i ];
					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

					geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

				}

			}

			if ( json.skinIndices ) {

				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

					var a =                               json.skinIndices[ i ];
					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

					geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

				}

			}

			geometry.bones = json.bones;

			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

			}

		};

		function parseMorphing( scale ) {

			if ( json.morphTargets !== undefined ) {

				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];

					var dstVertices = geometry.morphTargets[ i ].vertices;
					var srcVertices = json.morphTargets[ i ].vertices;

					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

						var vertex = new THREE.Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;

						dstVertices.push( vertex );

					}

				}

			}

			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

				var faces = geometry.faces;
				var morphColors = json.morphColors[ 0 ].colors;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					faces[ i ].color.fromArray( morphColors, i * 3 );

				}

			}

		}

		function parseAnimations() {

			var outputAnimations = [];

			// parse old style Bone/Hierarchy animations
			var animations = [];
			if ( json.animation !== undefined ) {
				animations.push( json.animation );
			}
			if ( json.animations !== undefined ) {
				if ( json.animations.length ) {
					animations = animations.concat( json.animations );
				} else {
					animations.push( json.animations );
				}
			}

			for ( var i = 0; i < animations.length; i ++ ) {

				var clip = THREE.AnimationClip.parseAnimation( animations[i], geometry.bones );
				if ( clip ) outputAnimations.push( clip );

			}

			// parse implicit morph animations
			if ( geometry.morphTargets ) {

				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
				var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
				outputAnimations = outputAnimations.concat( morphAnimationClips );

			}

			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

		};

		if ( json.materials === undefined || json.materials.length === 0 ) {

			return { geometry: geometry };

		} else {

			var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

			return { geometry: geometry, materials: materials };

		}

	}

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

	var scope = this;

	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		itemsTotal ++;

		if ( isLoading === false ) {

			if ( scope.onStart !== undefined ) {

				scope.onStart( url, itemsLoaded, itemsTotal );

			}

		}

		isLoading = true;

	};

	this.itemEnd = function ( url ) {

		itemsLoaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, itemsLoaded, itemsTotal );

		}

		if ( itemsLoaded === itemsTotal ) {

			isLoading = false;

			if ( scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		}

	};

	this.itemError = function ( url ) {

		if ( scope.onError !== undefined ) {

			scope.onError( url );

		}

	};

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

	constructor: THREE.BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometry = new THREE.BufferGeometry();

		var index = json.data.index;

		if ( index !== undefined ) {

			var typedArray = new self[ index.type ]( index.array );
			geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );

		}

		var attributes = json.data.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			var typedArray = new self[ attribute.type ]( attribute.array );

			geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

		}

		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

				var group = groups[ i ];

				geometry.addGroup( group.start, group.count );

			}

		}

		var boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			var center = new THREE.Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

		}

		return geometry;

	}

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	this.textures = {};

};

THREE.MaterialLoader.prototype = {

	constructor: THREE.MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setTextures: function ( value ) {

		this.textures = value;

	},

	getTexture: function ( name ) {

		var textures = this.textures;

		if ( textures[ name ] === undefined ) {

			console.warn( 'THREE.MaterialLoader: Undefined texture', name );

		}

		return textures[ name ];

	},

	parse: function ( json ) {

		var material = new THREE[ json.type ];
		material.uuid = json.uuid;

		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.shading !== undefined ) material.shading = json.shading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

		// for PointsMaterial
		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = this.getTexture( json.map );

		if ( json.alphaMap !== undefined ) {

			material.alphaMap = this.getTexture( json.alphaMap );
			material.transparent = true;

		}

		if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
		if ( json.normalScale )	material.normalScale = new THREE.Vector2( json.normalScale, json.normalScale );

		if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );

		if ( json.envMap !== undefined ) {

			material.envMap = this.getTexture( json.envMap );
			material.combine = THREE.MultiplyOperation;

		}

		if ( json.reflectivity ) material.reflectivity = json.reflectivity;

		if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		// MeshFaceMaterial

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	this.texturePath = '';

};

THREE.ObjectLoader.prototype = {

	constructor: THREE.ObjectLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( this.texturePath === '' ) {

			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

		}

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			scope.parse( JSON.parse( text ), onLoad );

		}, onProgress, onError );

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json, onLoad ) {

		var geometries = this.parseGeometries( json.geometries );

		var images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		var textures  = this.parseTextures( json.textures, images );
		var materials = this.parseMaterials( json.materials, textures );

		var object = this.parseObject( json.object, geometries, materials );

		if ( json.animations ) {

			object.animations = this.parseAnimations( json.animations );

		}

		if ( json.images === undefined || json.images.length === 0 ) {

			if ( onLoad !== undefined ) onLoad( object );

		}

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new THREE.JSONLoader();
			var bufferGeometryLoader = new THREE.BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new THREE[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new THREE.BoxGeometry(
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleBufferGeometry':

						geometry = new THREE.CircleBufferGeometry(
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CircleGeometry':

						geometry = new THREE.CircleGeometry(
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CylinderGeometry':

						geometry = new THREE.CylinderGeometry(
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereGeometry':

						geometry = new THREE.SphereGeometry(
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereBufferGeometry':

						geometry = new THREE.SphereBufferGeometry(
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'DodecahedronGeometry':

						geometry = new THREE.DodecahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'IcosahedronGeometry':

						geometry = new THREE.IcosahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'OctahedronGeometry':

						geometry = new THREE.OctahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'TetrahedronGeometry':

						geometry = new THREE.TetrahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'RingGeometry':

						geometry = new THREE.RingGeometry(
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'TorusGeometry':

						geometry = new THREE.TorusGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':

						geometry = new THREE.TorusKnotGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.p,
							data.q,
							data.heightScale
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

						break;

					default:

						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

						continue;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json, textures ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new THREE.MaterialLoader();
			loader.setTextures( textures );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var material = loader.parse( json[ i ] );
				materials[ material.uuid ] = material;

			}

		}

		return materials;

	},

	parseAnimations: function ( json ) {

		var animations = [];

		for ( var i = 0; i < json.length; i ++ ) {

			var clip = THREE.AnimationClip.parse( json[i] );

			animations.push( clip );

		}

		return animations;

	},

	parseImages: function ( json, onLoad ) {

		var scope = this;
		var images = {};

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			} );

		}

		if ( json !== undefined && json.length > 0 ) {

			var manager = new THREE.LoadingManager( onLoad );

			var loader = new THREE.ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var image = json[ i ];
				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

				images[ image.uuid ] = loadImage( path );

			}

		}

		return images;

	},

	parseTextures: function ( json, images ) {

		function parseConstant( value ) {

			if ( typeof( value ) === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return THREE[ value ];

		}

		var textures = {};

		if ( json !== undefined ) {

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				var texture = new THREE.Texture( images[ data.image ] );
				texture.needsUpdate = true;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;
				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
				if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
				if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
				if ( Array.isArray( data.wrap ) ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ] );
					texture.wrapT = parseConstant( data.wrap[ 1 ] );

				}

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	},

	parseObject: function () {

		var matrix = new THREE.Matrix4();

		return function ( data, geometries, materials ) {

			var object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( materials[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			switch ( data.type ) {

				case 'Scene':

					object = new THREE.Scene();

					break;

				case 'PerspectiveCamera':

					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					break;

				case 'OrthographicCamera':

					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new THREE.AmbientLight( data.color );

					break;

				case 'DirectionalLight':

					object = new THREE.DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'SpotLight':

					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

					break;

				case 'HemisphereLight':

					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'Mesh':

					object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'LOD':

					object = new THREE.LOD();

					break;

				case 'Line':

					object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

					break;

				case 'PointCloud':
				case 'Points':

					object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new THREE.Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new THREE.Group();

					break;

				default:

					object = new THREE.Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			if ( data.type === 'LOD' ) {

				var levels = data.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance );

					}

				}

			}

			return object;

		}

	}()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

	constructor: THREE.TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var texture = new THREE.Texture();

		var loader = new THREE.ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/CubeTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.CubeTextureLoader.prototype = {

	constructor: THREE.CubeTextureLoader,

	load: function ( urls, onLoad, onProgress, onError ) {

		var texture = new THREE.CubeTexture( [] );

		var loader = new THREE.ImageLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( var i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

};

THREE.BinaryTextureLoader.prototype = {

	constructor: THREE.BinaryTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texture = new THREE.DataTexture();

		var loader = new THREE.XHRLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setResponseType( 'arraybuffer' );

		loader.load( url, function ( buffer ) {

			var texData = scope._parser( buffer );

			if ( ! texData ) return;

			if ( undefined !== texData.image ) {

				texture.image = texData.image;

			} else if ( undefined !== texData.data ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

			if ( undefined !== texData.format ) {

				texture.format = texData.format;

			}
			if ( undefined !== texData.type ) {

				texture.type = texData.type;

			}

			if ( undefined !== texData.mipmaps ) {

				texture.mipmaps = texData.mipmaps;

			}

			if ( 1 === texData.mipmapCount ) {

				texture.minFilter = THREE.LinearFilter;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

	constructor: THREE.CompressedTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var images = [];

		var texture = new THREE.CompressedTexture();
		texture.image = images;

		var loader = new THREE.XHRLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setResponseType( 'arraybuffer' );

		if ( Array.isArray( url ) ) {

			var loaded = 0;

			var loadTexture = function ( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

						if ( texDatas.mipmapCount === 1 )
 							texture.minFilter = THREE.LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, onProgress, onError );

			};

			for ( var i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				if ( texDatas.isCubemap ) {

					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = THREE.LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

	Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.side = THREE.FrontSide;

	this.opacity = 1;
	this.transparent = false;

	this.blending = THREE.NormalBlending;

	this.blendSrc = THREE.SrcAlphaFactor;
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = THREE.LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this._needsUpdate = true;

};

THREE.Material.prototype = {

	constructor: THREE.Material,

	get needsUpdate () {

		return this._needsUpdate;

	},

	set needsUpdate ( value ) {

		if ( value === true ) this.update();

		this._needsUpdate = value;

	},

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			var currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
				continue;

			}

			if ( currentValue instanceof THREE.Color ) {

				currentValue.set( newValue );

			} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

				currentValue.copy( newValue );

			} else if ( key === 'overdraw' ) {

				// ensure overdraw is backwards-compatible with legacy boolean type
				this[ key ] = Number( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		var data = {
			metadata: {
				version: 4.4,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
		if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
		if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;

		if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
		if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
		if ( this.bumpMap instanceof THREE.Texture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}
		if ( this.normalMap instanceof THREE.Texture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js

		}
		if ( this.displacementMap instanceof THREE.Texture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}
		if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.envMap instanceof THREE.Texture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap

		}

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
		if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
		if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
		if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;
		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.side = source.side;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blending = source.blending;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.alphaTest = source.alphaTest;

		this.overdraw = source.overdraw;

		this.visible = source.visible;

		return this;

	},

	update: function () {

		this.dispatchEvent( { type: 'update' } );

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	// Deprecated

	get wrapAround () {

		console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

	},

	set wrapAround ( boolean ) {

		console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

	},

	get wrapRGB () {

		console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
		return new THREE.Color();

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;
	this.linecap = source.linecap;
	this.linejoin = source.linejoin;

	this.vertexColors = source.vertexColors;

	this.fog = source.fog;

	return this;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineDashedMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	
	this.linewidth = source.linewidth;

	this.scale = source.scale;
	this.dashSize = source.dashSize;
	this.gapSize = source.gapSize;

	this.vertexColors = source.vertexColors;

	this.fog = source.fog;

	return this;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new THREE.Color( 0xffffff ); // emissive

	this.map = null;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.copy = function ( source ) {
	
	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.fog = source.fog;

	this.shading = source.shading;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	
	return this;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.emissive = new THREE.Color( 0x000000 );

	this.map = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.emissive.copy( source.emissive );

	this.map = source.map;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.fog = source.fog;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.emissive = new THREE.Color( 0x000000 );
	this.specular = new THREE.Color( 0x111111 );
	this.shininess = 30;

	this.metal = false;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.emissive.copy( source.emissive );
	this.specular.copy( source.specular );
	this.shininess = source.shininess;

	this.metal = source.metal;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissiveMap = source.emissiveMap;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.fog = source.fog;

	this.shading = source.shading;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.morphTargets = false;
	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	this.type = 'MeshNormalMaterial';

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

// File:src/materials/MultiMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MultiMaterial = function ( materials ) {

	this.uuid = THREE.Math.generateUUID();

	this.type = 'MultiMaterial';

	this.materials = materials instanceof Array ? materials : [];

	this.visible = true;

};

THREE.MultiMaterial.prototype = {

	constructor: THREE.MultiMaterial,

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type,
			materials: []
		};

		for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

			output.materials.push( this.materials[ i ].toJSON() );

		}

		output.visible = this.visible;

		return output;

	},

	clone: function () {

		var material = new this.constructor();

		for ( var i = 0; i < this.materials.length; i ++ ) {

			material.materials.push( this.materials[ i ].clone() );

		}

		material.visible = this.visible;

		return material;

	}

};

// backwards compatibility

THREE.MeshFaceMaterial = THREE.MultiMaterial;

// File:src/materials/PointsMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointsMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'PointsMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.vertexColors = THREE.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;

THREE.PointsMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.size = source.size;
	this.sizeAttenuation = source.sizeAttenuation;

	this.vertexColors = source.vertexColors;

	this.fog = source.fog;

	return this;

};

// backwards compatibility

THREE.PointCloudMaterial = function ( parameters ) {

	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
	return new THREE.PointsMaterial( parameters );

};

THREE.ParticleBasicMaterial = function ( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
	return new THREE.PointsMaterial( parameters );

};

THREE.ParticleSystemMaterial = function ( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
	return new THREE.PointsMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

	this.shading = THREE.SmoothShading;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog

	this.lights = false; // set to use scene lights

	this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

	this.skinning = false; // set to use skinning attribute streams

	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.derivatives = false; // set to use derivatives

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = THREE.UniformsUtils.clone( source.uniforms );

	this.attributes = source.attributes;
	this.defines = source.defines;

	this.shading = source.shading;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.fog = source.fog;

	this.lights = source.lights;

	this.vertexColors = source.vertexColors;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.derivatives = source.derivatives;

	return this;

};

THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {

	var data = THREE.Material.prototype.toJSON.call( this, meta );

	data.uniforms = this.uniforms;
	data.attributes = this.attributes;
	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	return data;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

	THREE.ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new THREE.Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;

	// set parameters

	this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.map = source.map;

	this.rotation = source.rotation;

	this.fog = source.fog;

	return this;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.sourceFile = '';

	this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : THREE.RGBAFormat;
	this.type = type !== undefined ? type : THREE.UnsignedByteType;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	this.version = 0;
	this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {

	constructor: THREE.Texture,

	set needsUpdate ( value ) {

		if ( value === true ) this.version ++;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;

		return this;

	},

	toJSON: function ( meta ) {

		if ( meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		function getDataURL( image ) {

			var canvas;

			if ( image.toDataURL !== undefined ) {

				canvas = image;

			} else {

				canvas = document.createElement( 'canvas' );
				canvas.width = image.width;
				canvas.height = image.height;

				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

		var output = {
			metadata: {
				version: 4.4,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			wrap: [ this.wrapS, this.wrapT ],

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy
		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			var image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = THREE.Math.generateUUID(); // UGH

			}

			if ( meta.images[ image.uuid ] === undefined ) {

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: getDataURL( image )
				};

			}

			output.image = image.uuid;

		}

		meta.textures[ this.uuid ] = output;

		return output;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	transformUv: function ( uv ) {

		if ( this.mapping !== THREE.UVMapping )  return;

		uv.multiply( this.repeat );
		uv.add( this.offset );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case THREE.RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case THREE.ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case THREE.MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}
					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case THREE.RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case THREE.ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case THREE.MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}
					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CanvasTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.needsUpdate = true;

};

THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

	THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.images = images;
	this.flipY = false;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

THREE.CubeTexture.prototype.copy = function ( source ) {

	THREE.Texture.prototype.copy.call( this, source );
	
	this.images = source.images;
	
	return this;

};
// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { data: data, width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
	
	this.flipY = false;
	this.generateMipmaps  = false;

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DataTexture.prototype.constructor = THREE.DataTexture;

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.generateMipmaps = false;

	var scope = this;

	function update() {

		requestAnimationFrame( update );

		if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

			scope.needsUpdate = true;

		}

	}

	update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

	THREE.Object3D.call( this );

	this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
THREE.Group.prototype.constructor = THREE.Group;
// File:src/objects/Points.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Points = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'Points';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
THREE.Points.prototype.constructor = THREE.Points;

THREE.Points.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();

	return function raycast( raycaster, intersects ) {

		var object = this;
		var geometry = object.geometry;
		var threshold = raycaster.params.Points.threshold;

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		if ( geometry.boundingBox !== null ) {

			if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

				return;

			}

		}

		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		var localThresholdSq = localThreshold * localThreshold;
		var position = new THREE.Vector3();

		function testPoint( point, index ) {

			var rayPointDistanceSq = ray.distanceSqToPoint( point );

			if ( rayPointDistanceSq < localThresholdSq ) {

				var intersectPoint = ray.closestPointToPoint( point );
				intersectPoint.applyMatrix4( object.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				if ( distance < raycaster.near || distance > raycaster.far ) return;

				intersects.push( {

					distance: distance,
					distanceToRay: Math.sqrt( rayPointDistanceSq ),
					point: intersectPoint.clone(),
					index: index,
					face: null,
					object: object

				} );

			}

		}

		if ( geometry instanceof THREE.BufferGeometry ) {

			var index = geometry.index;
			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( index !== null ) {

				var indices = index.array;

				for ( var i = 0, il = indices.length; i < il; i ++ ) {

					var a = indices[ i ];

					position.fromArray( positions, a * 3 );

					testPoint( position, a );

				}

			} else {

				for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

					position.fromArray( positions, i * 3 );

					testPoint( position, i );

				}

			}

		} else {

			var vertices = geometry.vertices;

			for ( var i = 0, l = vertices.length; i < l; i ++ ) {

				testPoint( vertices[ i ], i );

			}

		}

	};

}() );

THREE.Points.prototype.clone = function () {

	return new this.constructor( this.geometry, this.material ).copy( this );

};

// Backwards compatibility

THREE.PointCloud = function ( geometry, material ) {

	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
	return new THREE.Points( geometry, material );

};

THREE.ParticleSystem = function ( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
	return new THREE.Points( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

	if ( mode === 1 ) {

		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
		return new THREE.LineSegments( geometry, material );

	}

	THREE.Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
THREE.Line.prototype.constructor = THREE.Line;

THREE.Line.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();
	var sphere = new THREE.Sphere();

	return function raycast( raycaster, intersects ) {

		var precision = raycaster.linePrecision;
		var precisionSq = precision * precision;

		var geometry = this.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		// Checking boundingSphere distance to ray

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( this.matrixWorld );

		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

			return;

		}

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		var vStart = new THREE.Vector3();
		var vEnd = new THREE.Vector3();
		var interSegment = new THREE.Vector3();
		var interRay = new THREE.Vector3();
		var step = this instanceof THREE.LineSegments ? 2 : 1;

		if ( geometry instanceof THREE.BufferGeometry ) {

			var index = geometry.index;
			var attributes = geometry.attributes;

			if ( index !== null ) {

				var indices = index.array;
				var positions = attributes.position.array;

				for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

					var a = indices[ i ];
					var b = indices[ i + 1 ];

					vStart.fromArray( positions, a * 3 );
					vEnd.fromArray( positions, b * 3 );

					var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			} else {

				var positions = attributes.position.array;

				for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

					vStart.fromArray( positions, 3 * i );
					vEnd.fromArray( positions, 3 * i + 3 );

					var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry instanceof THREE.Geometry ) {

			var vertices = geometry.vertices;
			var nbVertices = vertices.length;

			for ( var i = 0; i < nbVertices - 1; i += step ) {

				var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

				if ( distSq > precisionSq ) continue;

				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

				var distance = raycaster.ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					index: i,
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		}

	};

}() );

THREE.Line.prototype.clone = function () {

	return new this.constructor( this.geometry, this.material ).copy( this );

};

// DEPRECATED

THREE.LineStrip = 0;
THREE.LinePieces = 1;

// File:src/objects/LineSegments.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LineSegments = function ( geometry, material ) {

	THREE.Line.call( this, geometry, material );

	this.type = 'LineSegments';

};

THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
THREE.LineSegments.prototype.constructor = THREE.LineSegments;

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'Mesh';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
THREE.Mesh.prototype.constructor = THREE.Mesh;

THREE.Mesh.prototype.updateMorphTargets = function () {

	if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

		this.morphTargetBase = - 1;
		this.morphTargetInfluences = [];
		this.morphTargetDictionary = {};

		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

			this.morphTargetInfluences.push( 0 );
			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

		}

	}

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

	if ( this.morphTargetDictionary[ name ] !== undefined ) {

		return this.morphTargetDictionary[ name ];

	}

	console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

	return 0;

};


THREE.Mesh.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();
	var sphere = new THREE.Sphere();

	var vA = new THREE.Vector3();
	var vB = new THREE.Vector3();
	var vC = new THREE.Vector3();

	var tempA = new THREE.Vector3();
	var tempB = new THREE.Vector3();
	var tempC = new THREE.Vector3();

	var uvA = new THREE.Vector2();
	var uvB = new THREE.Vector2();
	var uvC = new THREE.Vector2();

	var barycoord = new THREE.Vector3();

	var intersectionPoint = new THREE.Vector3();
	var intersectionPointWorld = new THREE.Vector3();

	function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

		THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

		uv1.multiplyScalar( barycoord.x );
		uv2.multiplyScalar( barycoord.y );
		uv3.multiplyScalar( barycoord.z );

		uv1.add( uv2 ).add( uv3 );

		return uv1.clone();

	}

	function checkIntersection( object, raycaster, ray, pA, pB, pC, point ){

		var intersect;
		var material = object.material;

		if ( material.side === THREE.BackSide ) {

			intersect = ray.intersectTriangle( pC, pB, pA, true, point );

		} else {

			intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );

		}

		if ( intersect === null ) return null;

		intersectionPointWorld.copy( point );
		intersectionPointWorld.applyMatrix4( object.matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

		if ( distance < raycaster.near || distance > raycaster.far ) return null;

		return {
			distance: distance,
			point: intersectionPointWorld.clone(),
			object: object
		};

	}

	function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

		vA.fromArray( positions, a * 3 );
		vB.fromArray( positions, b * 3 );
		vC.fromArray( positions, c * 3 );

		var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

		if ( intersection ) {

			if ( uvs ) {

				uvA.fromArray( uvs, a * 2 );
				uvB.fromArray( uvs, b * 2 );
				uvC.fromArray( uvs, c * 2 );

				intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

			}

			intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
			intersection.faceIndex = a;

		}

		return intersection;

	}

	return function raycast( raycaster, intersects ) {

		var geometry = this.geometry;
		var material = this.material;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		var matrixWorld = this.matrixWorld;

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) return;

		// Check boundingBox before continuing

		inverseMatrix.getInverse( matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		if ( geometry.boundingBox !== null ) {

			if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) return;

		}

		var uvs, intersection;

		if ( geometry instanceof THREE.BufferGeometry ) {

			var a, b, c;
			var index = geometry.index;
			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( attributes.uv !== undefined ){

				uvs = attributes.uv.array;

			}

			if ( index !== null ) {

				var indices = index.array;

				for ( var i = 0, l = indices.length; i < l; i += 3 ) {

					a = indices[ i ];
					b = indices[ i + 1 ];
					c = indices[ i + 2 ];

					intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
						intersects.push( intersection );

					}

				}

			} else {


				for ( var i = 0, l = positions.length; i < l; i += 9 ) {

					a = i / 3;
					b = a + 1;
					c = a + 2;

					intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

					if ( intersection ) {

						intersection.index = a; // triangle number in positions buffer semantics
						intersects.push( intersection );

					}

				}

			}

		} else if ( geometry instanceof THREE.Geometry ) {

			var fvA, fvB, fvC;
			var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
			var materials = isFaceMaterial === true ? material.materials : null;

			var vertices = geometry.vertices;
			var faces = geometry.faces;
			var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
			if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

			for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

				var face = faces[ f ];
				var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

				if ( faceMaterial === undefined ) continue;

				fvA = vertices[ face.a ];
				fvB = vertices[ face.b ];
				fvC = vertices[ face.c ];

				if ( faceMaterial.morphTargets === true ) {

					var morphTargets = geometry.morphTargets;
					var morphInfluences = this.morphTargetInfluences;

					vA.set( 0, 0, 0 );
					vB.set( 0, 0, 0 );
					vC.set( 0, 0, 0 );

					for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

						var influence = morphInfluences[ t ];

						if ( influence === 0 ) continue;

						var targets = morphTargets[ t ].vertices;

						vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
						vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
						vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

					}

					vA.add( fvA );
					vB.add( fvB );
					vC.add( fvC );

					fvA = vA;
					fvB = vB;
					fvC = vC;

				}

				intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

				if ( intersection ) {

					if ( uvs ) {

						var uvs_f = uvs[ f ];
						uvA.copy( uvs_f[ 0 ] );
						uvB.copy( uvs_f[ 1 ] );
						uvC.copy( uvs_f[ 2 ] );

						intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

					}

					intersection.face = face;
					intersection.faceIndex = f;
					intersects.push( intersection );

				}

			}

		}

	};

}() );

THREE.Mesh.prototype.clone = function () {

	return new this.constructor( this.geometry, this.material ).copy( this );

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( skin ) {

	THREE.Object3D.call( this );

	this.type = 'Bone';

	this.skin = skin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
THREE.Bone.prototype.constructor = THREE.Bone;

THREE.Bone.prototype.copy = function ( source ) {
	
	THREE.Object3D.prototype.copy.call( this, source );
	
	this.skin = source.skin;
	
	return this;

};

// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	this.identityMatrix = new THREE.Matrix4();

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );

	// create a bone texture or an array of floats

	if ( this.useVertexTexture ) {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

		
		var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
		size = Math.max( size, 4 );

		this.boneTextureWidth = size;
		this.boneTextureHeight = size;

		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
		this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );

	} else {

		this.boneMatrices = new Float32Array( 16 * this.bones.length );

	}

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				this.boneInverses.push( new THREE.Matrix4() );

			}

		}

	}

};

THREE.Skeleton.prototype.calculateInverses = function () {

	this.boneInverses = [];

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		var inverse = new THREE.Matrix4();

		if ( this.bones[ b ] ) {

			inverse.getInverse( this.bones[ b ].matrixWorld );

		}

		this.boneInverses.push( inverse );

	}

};

THREE.Skeleton.prototype.pose = function () {

	var bone;

	// recover the bind-time world matrices

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			bone.matrixWorld.getInverse( this.boneInverses[ b ] );

		}

	}

	// compute the local matrices, positions, rotations and scales

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			if ( bone.parent ) {

				bone.matrix.getInverse( bone.parent.matrixWorld );
				bone.matrix.multiply( bone.matrixWorld );

			} else {

				bone.matrix.copy( bone.matrixWorld );

			}

			bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

		}

	}

};

THREE.Skeleton.prototype.update = ( function () {

	var offsetMatrix = new THREE.Matrix4();

	return function update() {

		// flatten bone matrices to array

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			// compute the offset between the current and the original transform

			var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

			offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
			offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

		}

		if ( this.useVertexTexture ) {

			this.boneTexture.needsUpdate = true;

		}

	};

} )();

THREE.Skeleton.prototype.clone = function () {

	return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

};

// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

	THREE.Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = "attached";
	this.bindMatrix = new THREE.Matrix4();
	this.bindMatrixInverse = new THREE.Matrix4();

	// init bones

	// TODO: remove bone creation as there is no reason (other than
	// convenience) for THREE.SkinnedMesh to do this.

	var bones = [];

	if ( this.geometry && this.geometry.bones !== undefined ) {

		var bone, gbone;

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

			gbone = this.geometry.bones[ b ];

			bone = new THREE.Bone( this );
			bones.push( bone );

			bone.name = gbone.name;
			bone.position.fromArray( gbone.pos );
			bone.quaternion.fromArray( gbone.rotq );
			if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

		}

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

			gbone = this.geometry.bones[ b ];

			if ( gbone.parent !== - 1 && gbone.parent !== null) {

				bones[ gbone.parent ].add( bones[ b ] );

			} else {

				this.add( bones[ b ] );

			}

		}

	}

	this.normalizeSkinWeights();

	this.updateMatrixWorld( true );
	this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

	this.skeleton = skeleton;

	if ( bindMatrix === undefined ) {

		this.updateMatrixWorld( true );
		
		this.skeleton.calculateInverses();

		bindMatrix = this.matrixWorld;

	}

	this.bindMatrix.copy( bindMatrix );
	this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function () {

	this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

	if ( this.geometry instanceof THREE.Geometry ) {

		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

			var sw = this.geometry.skinWeights[ i ];

			var scale = 1.0 / sw.lengthManhattan();

			if ( scale !== Infinity ) {

				sw.multiplyScalar( scale );

			} else {

				sw.set( 1 ); // this will be normalized by the shader anyway

			}

		}

	} else {

		// skinning weights assumed to be normalized for THREE.BufferGeometry

	}

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

	THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

	if ( this.bindMode === "attached" ) {

		this.bindMatrixInverse.getInverse( this.matrixWorld );

	} else if ( this.bindMode === "detached" ) {

		this.bindMatrixInverse.getInverse( this.bindMatrix );

	} else {

		console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

	}

};

THREE.SkinnedMesh.prototype.clone = function() {

	return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

	THREE.Object3D.call( this );

	this.type = 'LOD';

	Object.defineProperties( this, {
		levels: {
			enumerable: true,
			value: []
		},
		objects: {
			get: function () {

				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
				return this.levels;

			}
		}
	} );

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
THREE.LOD.prototype.constructor = THREE.LOD;

THREE.LOD.prototype.addLevel = function ( object, distance ) {

	if ( distance === undefined ) distance = 0;

	distance = Math.abs( distance );

	var levels = this.levels;

	for ( var l = 0; l < levels.length; l ++ ) {

		if ( distance < levels[ l ].distance ) {

			break;

		}

	}

	levels.splice( l, 0, { distance: distance, object: object } );

	this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

	var levels = this.levels;

	for ( var i = 1, l = levels.length; i < l; i ++ ) {

		if ( distance < levels[ i ].distance ) {

			break;

		}

	}

	return levels[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function () {

	var matrixPosition = new THREE.Vector3();

	return function raycast( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( matrixPosition );

		this.getObjectForDistance( distance ).raycast( raycaster, intersects );

	};

}() );

THREE.LOD.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function update( camera ) {

		var levels = this.levels;

		if ( levels.length > 1 ) {

			v1.setFromMatrixPosition( camera.matrixWorld );
			v2.setFromMatrixPosition( this.matrixWorld );

			var distance = v1.distanceTo( v2 );

			levels[ 0 ].object.visible = true;

			for ( var i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance >= levels[ i ].distance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	};

}();

THREE.LOD.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source, false );

	var levels = source.levels;

	for ( var i = 0, l = levels.length; i < l; i ++ ) {

		var level = levels[ i ];

		this.addLevel( level.object.clone(), level.distance );

	}

	return this;

};

THREE.LOD.prototype.toJSON = function ( meta ) {

	var data = THREE.Object3D.prototype.toJSON.call( this, meta );

	data.object.levels = [];

	var levels = this.levels;

	for ( var i = 0, l = levels.length; i < l; i ++ ) {

		var level = levels[ i ];

		data.object.levels.push( {
			object: level.object.uuid,
			distance: level.distance
		} );

	}

	return data;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

	var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
	var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
	var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

	var geometry = new THREE.BufferGeometry();
	geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	return function Sprite( material ) {

		THREE.Object3D.call( this );

		this.type = 'Sprite';

		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

	};

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
THREE.Sprite.prototype.constructor = THREE.Sprite;

THREE.Sprite.prototype.raycast = ( function () {

	var matrixPosition = new THREE.Vector3();

	return function raycast( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
		var guessSizeSq = this.scale.x * this.scale.y;

		if ( distanceSq > guessSizeSq ) {

			return;

		}

		intersects.push( {

			distance: Math.sqrt( distanceSq ),
			point: this.position,
			face: null,
			object: this

		} );

	};

}() );

THREE.Sprite.prototype.clone = function () {

	return new this.constructor( this.material ).copy( this );

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

	THREE.Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new THREE.Vector3();
	this.customUpdateCallback = undefined;

	if ( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
THREE.LensFlare.prototype.constructor = THREE.LensFlare;


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

	if ( size === undefined ) size = - 1;
	if ( distance === undefined ) distance = 0;
	if ( opacity === undefined ) opacity = 1;
	if ( color === undefined ) color = new THREE.Color( 0xffffff );
	if ( blending === undefined ) blending = THREE.NormalBlending;

	distance = Math.min( distance, Math.max( 0, distance ) );

	this.lensFlares.push( {
		texture: texture,	// THREE.Texture
		size: size, 		// size in pixels (-1 = use texture.width)
		distance: distance, 	// distance (0-1) from light source (0=at light source)
		x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
		scale: 1, 		// scale
		rotation: 0, 		// rotation
		opacity: opacity,	// opacity
		color: color,		// color
		blending: blending	// blending
	} );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

	var f, fl = this.lensFlares.length;
	var flare;
	var vecX = - this.positionScreen.x * 2;
	var vecY = - this.positionScreen.y * 2;

	for ( f = 0; f < fl; f ++ ) {

		flare = this.lensFlares[ f ];

		flare.x = this.positionScreen.x + vecX * flare.distance;
		flare.y = this.positionScreen.y + vecY * flare.distance;

		flare.wantedRotation = flare.x * Math.PI * 0.25;
		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

	}

};

THREE.LensFlare.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source );

	this.positionScreen.copy( source.positionScreen );
	this.customUpdateCallback = source.customUpdateCallback;

	for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

		this.lensFlares.push( source.lensFlares[ i ] );

	}

	return this;

};

// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

	THREE.Object3D.call( this );

	this.type = 'Scene';

	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source );

	if ( source.fog !== null ) this.fog = source.fog.clone();
	if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

	this.autoUpdate = source.autoUpdate;
	this.matrixAutoUpdate = source.matrixAutoUpdate;

	return this;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

	this.name = '';

	this.color = new THREE.Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

	return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

	this.name = '';

	this.color = new THREE.Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

	return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

THREE.ShaderChunk[ 'aomap_fragment'] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

THREE.ShaderChunk[ 'aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

THREE.ShaderChunk[ 'begin_vertex'] = "\nvec3 transformed = vec3( position );\n";

// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

THREE.ShaderChunk[ 'beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/common.glsl

THREE.ShaderChunk[ 'common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/hemilight_fragment.glsl

THREE.ShaderChunk[ 'hemilight_fragment'] = "#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalAmbientLight += lightColor;\n\n	}\n\n#endif\n\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment'] = "vec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normal_phong_fragment.glsl

THREE.ShaderChunk[ 'normal_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

THREE.ShaderChunk[ 'project_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		float texelSizeY =  1.0 / shadowMapSize[ i ].y;\n\n		float shadow = 0.0;\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		bool isPointLight = shadowDarkness[ i ] < 0.0;\n\n		if ( isPointLight ) {\n\n			float realShadowDarkness = abs( shadowDarkness[ i ] );\n\n			vec3 lightToPosition = vShadowCoord[ i ].xyz;\n\n	#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n			const float Dr = 1.25;\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			const float Dr = 2.25;\n	#endif\n\n			float os = Dr *  2.0 * texelSizeY;\n\n			const vec3 Gsd = vec3( - 1, 0, 1 );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness * ( 1.0 / 21.0 );\n\n	#else \n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness;\n\n	#endif\n\n		} else {\n\n#endif \n			float texelSizeX =  1.0 / shadowMapSize[ i ].x;\n\n			vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\n			bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n			bool inFrustum = all( inFrustumVec );\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n			bool frustumTest = all( frustumTestVec );\n\n			if ( frustumTest ) {\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n\n\n				/*\n					for ( float y = -1.25; y <= 1.25; y += 1.25 )\n						for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n							vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n							float fDepth = unpackDepth( rgbaDepth );\n							if ( fDepth < shadowCoord.z )\n								shadow += 1.0;\n					}\n					shadow /= 9.0;\n				*/\n\n				shadowCoord.z += shadowBias[ i ];\n\n				const float ShadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.25 * xPixelOffset;\n				float dy0 = - 1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				float fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				shadow *= shadowDarkness[ i ];\n\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\n				shadowCoord.z += shadowBias[ i ];\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.0 * xPixelOffset;\n				float dy0 = - 1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[ 0 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[ 0 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[ 0 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[ 1 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[ 1 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[ 1 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[ 2 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[ 2 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[ 2 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[ 0 ] = vec3( lessThan( depthKernel[ 0 ], shadowZ ) );\n				shadowKernel[ 0 ] *= vec3( 0.25 );\n\n				shadowKernel[ 1 ] = vec3( lessThan( depthKernel[ 1 ], shadowZ ) );\n				shadowKernel[ 1 ] *= vec3( 0.25 );\n\n				shadowKernel[ 2 ] = vec3( lessThan( depthKernel[ 2 ], shadowZ ) );\n				shadowKernel[ 2 ] *= vec3( 0.25 );\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[ i ].xy );\n\n				shadowKernel[ 0 ] = mix( shadowKernel[ 1 ], shadowKernel[ 0 ], fractionalCoord.x );\n				shadowKernel[ 1 ] = mix( shadowKernel[ 2 ], shadowKernel[ 1 ], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[ 0 ][ 1 ], shadowKernel[ 0 ][ 0 ], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[ 0 ][ 2 ], shadowKernel[ 0 ][ 1 ], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[ 1 ][ 1 ], shadowKernel[ 1 ][ 0 ], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[ 1 ][ 2 ], shadowKernel[ 1 ][ 1 ], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) ) * shadowDarkness[ i ];\n\n	#else \n				shadowCoord.z += shadowBias[ i ];\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n					shadow = shadowDarkness[ i ];\n\n	#endif\n\n			}\n\n#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) {\n\n				if ( i == 0 ) {\n\n					outgoingLight *= vec3( 1.0, 0.5, 0.0 );\n\n				} else if ( i == 1 ) {\n\n					outgoingLight *= vec3( 0.0, 1.0, 0.8 );\n\n				} else {\n\n					outgoingLight *= vec3( 0.0, 0.5, 1.0 );\n\n				}\n\n			}\n\n#endif\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		}\n\n#endif\n\n		shadowMask = shadowMask * vec3( 1.0 - shadow );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n	#if defined(POINT_LIGHT_SHADOWS)\n\n\n		void adjustShadowValue1K( const float testDepth, const vec4 textureData, const float bias, inout float shadowValue ) {\n\n			const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n			if ( testDepth >= dot( textureData, bitSh ) * 1000.0 + bias )\n				shadowValue += 1.0;\n\n		}\n\n\n		vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\n			vec3 absV = abs( v );\n\n\n			float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n			absV *= scaleToCube;\n\n\n			v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\n\n			vec2 planar = v.xy;\n\n			float almostATexel = 1.5 * texelSizeY;\n			float almostOne = 1.0 - almostATexel;\n\n			if ( absV.z >= almostOne ) {\n\n				if ( v.z > 0.0 )\n					planar.x = 4.0 - v.x;\n\n			} else if ( absV.x >= almostOne ) {\n\n				float signX = sign( v.x );\n				planar.x = v.z * signX + 2.0 * signX;\n\n			} else if ( absV.y >= almostOne ) {\n\n				float signY = sign( v.y );\n				planar.x = v.x + 2.0 * signY + 2.0;\n				planar.y = v.z * signY - 2.0;\n\n			}\n\n\n			return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

THREE.ShaderChunk[ 'uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

THREE.ShaderChunk[ 'uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

THREE.ShaderChunk[ 'uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

THREE.ShaderChunk[ 'uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

THREE.ShaderChunk[ 'uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

THREE.ShaderChunk[ 'uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

	merge: function ( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = this.clone( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var uniforms_dst = {};

		for ( var u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( var p in uniforms_src[ u ] ) {

				var parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof THREE.Color ||
					 parameter_src instanceof THREE.Vector2 ||
					 parameter_src instanceof THREE.Vector3 ||
					 parameter_src instanceof THREE.Vector4 ||
					 parameter_src instanceof THREE.Matrix3 ||
					 parameter_src instanceof THREE.Matrix4 ||
					 parameter_src instanceof THREE.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( Array.isArray( parameter_src ) ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

	common: {

		"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },

		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"specularMap" : { type: "t", value: null },
		"alphaMap" : { type: "t", value: null },

		"envMap" : { type: "t", value: null },
		"flipEnvMap" : { type: "f", value: - 1 },
		"reflectivity" : { type: "f", value: 1.0 },
		"refractionRatio" : { type: "f", value: 0.98 }

	},

	aomap: {

		"aoMap" : { type: "t", value: null },
		"aoMapIntensity" : { type: "f", value: 1 },

	},

	lightmap: {

		"lightMap" : { type: "t", value: null },
		"lightMapIntensity" : { type: "f", value: 1 },

	},

	emissivemap: {

		"emissiveMap" : { type: "t", value: null },

	},

	bumpmap: {

		"bumpMap" : { type: "t", value: null },
		"bumpScale" : { type: "f", value: 1 }

	},

	normalmap: {

		"normalMap" : { type: "t", value: null },
		"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }

	},

	displacementmap: {

		"displacementMap" : { type: "t", value: null },
		"displacementScale" : { type: "f", value: 1 },
		"displacementBias" : { type: "f", value: 0 }

	},

	fog : {

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor" : { type: "fv", value: [] },

		"directionalLightDirection" : { type: "fv", value: [] },
		"directionalLightColor" : { type: "fv", value: [] },

		"hemisphereLightDirection" : { type: "fv", value: [] },
		"hemisphereLightSkyColor" : { type: "fv", value: [] },
		"hemisphereLightGroundColor" : { type: "fv", value: [] },

		"pointLightColor" : { type: "fv", value: [] },
		"pointLightPosition" : { type: "fv", value: [] },
		"pointLightDistance" : { type: "fv1", value: [] },
		"pointLightDecay" : { type: "fv1", value: [] },

		"spotLightColor" : { type: "fv", value: [] },
		"spotLightPosition" : { type: "fv", value: [] },
		"spotLightDirection" : { type: "fv", value: [] },
		"spotLightDistance" : { type: "fv1", value: [] },
		"spotLightAngleCos" : { type: "fv1", value: [] },
		"spotLightExponent" : { type: "fv1", value: [] },
		"spotLightDecay" : { type: "fv1", value: [] }

	},

	points: {

		"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },
		"size" : { type: "f", value: 1.0 },
		"scale" : { type: "f", value: 1.0 },
		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	shadowmap: {

		"shadowMap": { type: "tv", value: [] },
		"shadowMapSize": { type: "v2v", value: [] },

		"shadowBias" : { type: "fv1", value: [] },
		"shadowDarkness": { type: "fv1", value: [] },

		"shadowMatrix" : { type: "m4v", value: [] }

	}

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

	'basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "aomap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "uv_pars_vertex" ],
			THREE.ShaderChunk[ "uv2_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "uv_vertex" ],
				THREE.ShaderChunk[ "uv2_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],

			"	#ifdef USE_ENVMAP",

				THREE.ShaderChunk[ "beginnormal_vertex" ],
				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"	#endif",

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "uv_pars_fragment" ],
			THREE.ShaderChunk[ "uv2_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "aomap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	vec3 outgoingLight = vec3( 0.0 );",
			"	vec4 diffuseColor = vec4( diffuse, opacity );",
			"	vec3 totalAmbientLight = vec3( 1.0 );", // hardwired
			"	vec3 shadowMask = vec3( 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "aomap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

			"	outgoingLight = diffuseColor.rgb * totalAmbientLight * shadowMask;",

				THREE.ShaderChunk[ "envmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'lambert': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
			}

		] ),

		vertexShader: [

			"#define LAMBERT",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

			"	varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "uv_pars_vertex" ],
			THREE.ShaderChunk[ "uv2_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "uv_vertex" ],
				THREE.ShaderChunk[ "uv2_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "beginnormal_vertex" ],
				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform vec3 emissive;",
			"uniform float opacity;",

			"uniform vec3 ambientLightColor;",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

			"	varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "uv_pars_fragment" ],
			THREE.ShaderChunk[ "uv2_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	vec3 outgoingLight = vec3( 0.0 );",	// outgoing light does not have an alpha, the surface does
			"	vec4 diffuseColor = vec4( diffuse, opacity );",
			"	vec3 totalAmbientLight = ambientLightColor;",
			"	vec3 shadowMask = vec3( 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

			"	#ifdef DOUBLE_SIDED",

			"		if ( gl_FrontFacing )",
			"			outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;",
			"		else",
			"			outgoingLight += diffuseColor.rgb * ( vLightBack * shadowMask + totalAmbientLight ) + emissive;",

			"	#else",

			"		outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;",

			"	#endif",

				THREE.ShaderChunk[ "envmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'phong': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "aomap" ],
			THREE.UniformsLib[ "lightmap" ],
			THREE.UniformsLib[ "emissivemap" ],
			THREE.UniformsLib[ "bumpmap" ],
			THREE.UniformsLib[ "normalmap" ],
			THREE.UniformsLib[ "displacementmap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
				"shininess": { type: "f", value: 30 }
			}

		] ),

		vertexShader: [

			"#define PHONG",

			"varying vec3 vViewPosition;",

			"#ifndef FLAT_SHADED",

			"	varying vec3 vNormal;",

			"#endif",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "uv_pars_vertex" ],
			THREE.ShaderChunk[ "uv2_pars_vertex" ],
			THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "uv_vertex" ],
				THREE.ShaderChunk[ "uv2_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "beginnormal_vertex" ],
				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

			"	vNormal = normalize( transformedNormal );",

			"#endif",

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "displacementmap_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"	vViewPosition = - mvPosition.xyz;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_phong_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"#define PHONG",

			"uniform vec3 diffuse;",
			"uniform vec3 emissive;",
			"uniform vec3 specular;",
			"uniform float shininess;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "uv_pars_fragment" ],
			THREE.ShaderChunk[ "uv2_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "aomap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
			THREE.ShaderChunk[ "normalmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	vec3 outgoingLight = vec3( 0.0 );",
			"	vec4 diffuseColor = vec4( diffuse, opacity );",
			"	vec3 totalAmbientLight = ambientLightColor;",
			"	vec3 totalEmissiveLight = emissive;",
			"	vec3 shadowMask = vec3( 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "normal_phong_fragment" ],
				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "hemilight_fragment" ],
				THREE.ShaderChunk[ "aomap_fragment" ],
				THREE.ShaderChunk[ "emissivemap_fragment" ],

				THREE.ShaderChunk[ "lights_phong_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				"totalDiffuseLight *= shadowMask;",
				"totalSpecularLight *= shadowMask;",

				"#ifdef METAL",

				"	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;",

				"#else",

				"	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;",

				"#endif",

				THREE.ShaderChunk[ "envmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'points': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "points" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			"uniform float size;",
			"uniform float scale;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

			"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

			"	#ifdef USE_SIZEATTENUATION",
			"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
			"	#else",
			"		gl_PointSize = size;",
			"	#endif",

			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],
				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 psColor;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_particle_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	vec3 outgoingLight = vec3( 0.0 );",
			"	vec4 diffuseColor = vec4( psColor, opacity );",
			"	vec3 shadowMask = vec3( 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_particle_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

			"	outgoingLight = diffuseColor.rgb * shadowMask;",

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'dashed': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],

			{
				"scale"    : { type: "f", value: 1 },
				"dashSize" : { type: "f", value: 1 },
				"totalSize": { type: "f", value: 2 }
			}

		] ),

		vertexShader: [

			"uniform float scale;",
			"attribute float lineDistance;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

			"	vLineDistance = scale * lineDistance;",

			"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform float dashSize;",
			"uniform float totalSize;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

			"		discard;",

			"	}",

			"	vec3 outgoingLight = vec3( 0.0 );",
			"	vec4 diffuseColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],

			"	outgoingLight = diffuseColor.rgb;", // simple shader

				THREE.ShaderChunk[ "fog_fragment" ],

			"	gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

			"}"

		].join( "\n" )

	},

	'depth': {

		uniforms: {

			"mNear": { type: "f", value: 1.0 },
			"mFar" : { type: "f", value: 2000.0 },
			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform float mNear;",
			"uniform float mFar;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	#ifdef USE_LOGDEPTHBUF_EXT",

			"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

			"	#else",

			"		float depth = gl_FragCoord.z / gl_FragCoord.w;",

			"	#endif",

			"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
			"	gl_FragColor = vec4( vec3( color ), opacity );",

			"}"

		].join( "\n" )

	},

	'normal': {

		uniforms: {

			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vNormal = normalize( normalMatrix * normal );",

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform float opacity;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join( "\n" )

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'cube': {

		uniforms: { "tCube": { type: "t", value: null },
					"tFlip": { type: "f", value: - 1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vWorldPosition = transformDirection( position, modelMatrix );",

			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform samplerCube tCube;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join( "\n" )

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'equirect': {

		uniforms: { "tEquirect": { type: "t", value: null },
					"tFlip": { type: "f", value: - 1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vWorldPosition = transformDirection( position, modelMatrix );",

			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform sampler2D tEquirect;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

				// "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
				"vec3 direction = normalize( vWorldPosition );",
				"vec2 sampleUV;",
				"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
				"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
				"gl_FragColor = texture2D( tEquirect, sampleUV );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join( "\n" )

	},

	/* Depth encoding into RGBA texture
	 *
	 * based on SpiderGL shadow map example
	 * http://spidergl.org/example.php?id=6
	 *
	 * originally from
	 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	 *
	 * see also
	 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
	 */

	'depthRGBA': {

		uniforms: {},

		vertexShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],

				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join( "\n" ),

		fragmentShader: [

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"vec4 pack_depth( const in float depth ) {",

			"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
			"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
			"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
			"	res -= res.xxyz * bit_mask;",
			"	return res;",

			"}",

			"void main() {",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	#ifdef USE_LOGDEPTHBUF_EXT",

			"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

			"	#else",

			"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

			"	#endif",

				//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
				//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
				//"gl_FragData[ 0 ] = pack_depth( z );",
				//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

			"}"

		].join( "\n" )

	},


	'distanceRGBA': {

		uniforms: {

			"lightPos": { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) }

		},

		vertexShader: [

			"varying vec4 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "begin_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "project_vertex" ],
				THREE.ShaderChunk[ "worldpos_vertex" ],

				"vWorldPosition = worldPosition;",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 lightPos;",
			"varying vec4 vWorldPosition;",

			THREE.ShaderChunk[ "common" ],

			"vec4 pack1K ( float depth ) {",

			"   depth /= 1000.0;",
			"   const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
  			"	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
   			"	vec4 res = fract( depth * bitSh );",
   			"	res -= res.xxyz * bitMsk;",
   			"	return res; ",

			"}",

			"float unpack1K ( vec4 color ) {",

			"	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
			"	return dot( color, bitSh ) * 1000.0;",

			"}",

			"void main () {",

			"	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );",

			"}"

		].join( "\n" )

	}

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

	console.log( 'THREE.WebGLRenderer', THREE.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
	_context = parameters.context !== undefined ? parameters.context : null,

	_width = _canvas.width,
	_height = _canvas.height,

	pixelRatio = 1,

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_depth = parameters.depth !== undefined ? parameters.depth : true,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0;

	var lights = [];

	var opaqueObjects = [];
	var opaqueObjectsLastIndex = - 1;
	var transparentObjects = [];
	var transparentObjectsLastIndex = - 1;

	var morphInfluences = new Float32Array( 8 );


	var sprites = [];
	var lensFlares = [];

	// public properties

	this.domElement = _canvas;
	this.context = null;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.gammaInput = false;
	this.gammaOutput = false;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// internal properties

	var _this = this,

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = - 1,
	_currentGeometryProgram = '',
	_currentCamera = null,

	_usedTextureUnits = 0,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = _canvas.width,
	_viewportHeight = _canvas.height,
	_currentWidth = 0,
	_currentHeight = 0,

	// frustum

	_frustum = new THREE.Frustum(),

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),

	// light arrays cache

	_direction = new THREE.Vector3(),

	_lightsNeedUpdate = true,

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors: [], positions: [] },
		point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
		spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
		hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

	},

	// info

	_infoMemory = {

		geometries: 0,
		textures: 0

	},

	_infoRender = {

		calls: 0,
		vertices: 0,
		faces: 0,
		points: 0

	};

	this.info = {

		render: _infoRender,
		memory: _infoMemory,
		programs: null

	};


	// initialize

	var _gl;

	try {

		var attributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer
		};

		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl' ) !== null ) {

				throw 'Error creating WebGL context with your selected attributes.';

			} else {

				throw 'Error creating WebGL context.';

			}

		}

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error );

	}

	var extensions = new THREE.WebGLExtensions( _gl );

	extensions.get( 'OES_texture_float' );
	extensions.get( 'OES_texture_float_linear' );
	extensions.get( 'OES_texture_half_float' );
	extensions.get( 'OES_texture_half_float_linear' );
	extensions.get( 'OES_standard_derivatives' );
	extensions.get( 'ANGLE_instanced_arrays' );

	if ( extensions.get( 'OES_element_index_uint' ) ) {

		THREE.BufferGeometry.MaxIndex = 4294967296;

	}

	var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );

	var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
	var properties = new THREE.WebGLProperties();
	var objects = new THREE.WebGLObjects( _gl, properties, this.info );
	var programCache = new THREE.WebGLPrograms( this, capabilities );

	this.info.programs = programCache.programs;

	var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
	var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

	//

	function glClearColor( r, g, b, a ) {

		if ( _premultipliedAlpha === true ) {

			r *= a; g *= a; b *= a;

		}

		_gl.clearColor( r, g, b, a );

	}

	function setDefaultGLState() {

		state.init();

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	}

	function resetGLState() {

		_currentProgram = null;
		_currentCamera = null;

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;

		_lightsNeedUpdate = true;

		state.reset();

	}

	setDefaultGLState();

	this.context = _gl;
	this.capabilities = capabilities;
	this.extensions = extensions;
	this.state = state;

	// shadow map

	var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );

	this.shadowMap = shadowMap;


	// Plugins

	var spritePlugin = new THREE.SpritePlugin( this, sprites );
	var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		extensions.get( 'WEBGL_lose_context' ).loseContext();

	};

	this.getMaxAnisotropy = ( function () {

		var value;

		return function getMaxAnisotropy() {

			if ( value !== undefined ) return value;

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension !== null ) {

				value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				value = 0;

			}

			return value;

		}

	} )();

	this.getPrecision = function () {

		return capabilities.precision;

	};

	this.getPixelRatio = function () {

		return pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value !== undefined ) pixelRatio = value;

	};

	this.getSize = function () {

		return {
			width: _width,
			height: _height
		};

	};

	this.setSize = function ( width, height, updateStyle ) {

		_width = width;
		_height = height;

		_canvas.width = width * pixelRatio;
		_canvas.height = height * pixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewportX = x * pixelRatio;
		_viewportY = y * pixelRatio;

		_viewportWidth = width * pixelRatio;
		_viewportHeight = height * pixelRatio;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	};

	this.getViewport = function ( dimensions ) {

		dimensions.x = _viewportX / pixelRatio;
		dimensions.y = _viewportY / pixelRatio;

		dimensions.z = _viewportWidth / pixelRatio;
		dimensions.w = _viewportHeight / pixelRatio;

	};

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor(
			x * pixelRatio,
			y * pixelRatio,
			width * pixelRatio,
			height * pixelRatio
		);

	};

	this.enableScissorTest = function ( boolean ) {

		state.setScissorTest( boolean );

	};

	// Clearing

	this.getClearColor = function () {

		return _clearColor;

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );

		_clearAlpha = alpha !== undefined ? alpha : 1;

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.setClearAlpha = function ( alpha ) {

		_clearAlpha = alpha;

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		_gl.clear( _gl.COLOR_BUFFER_BIT );

	};

	this.clearDepth = function () {

		_gl.clear( _gl.DEPTH_BUFFER_BIT );

	};

	this.clearStencil = function () {

		_gl.clear( _gl.STENCIL_BUFFER_BIT );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Reset

	this.resetGLState = resetGLState;

	this.dispose = function() {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		resetGLState();
		setDefaultGLState();

		properties.clear();

	};

	function onTextureDispose( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_infoMemory.textures --;


	}

	function onRenderTargetDispose( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_infoMemory.textures --;

	}

	function onMaterialDispose( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateTexture( texture ) {

		var textureProperties = properties.get( texture );

		if ( texture.image && textureProperties.__image__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

		} else {

			// 2D texture

			if ( textureProperties.__webglInit === undefined ) return;

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		// remove all webgl properties
		properties.delete( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		if ( ! renderTarget || textureProperties.__webglTexture === undefined ) return;

		_gl.deleteTexture( textureProperties.__webglTexture );

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTargetProperties.__webglRenderbuffer );

		}

		properties.delete( renderTarget.texture );
		properties.delete( renderTarget );

	}

	function deallocateMaterial( material ) {

		releaseMaterialProgramReference( material );

		properties.delete( material );

	}


	function releaseMaterialProgramReference( material ) {

		var programInfo = properties.get( material ).program;

		material.program = undefined;

		if ( programInfo !== undefined ) {

			programCache.releaseProgram( programInfo );

		}

	}

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		state.initAttributes();

		var buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		var attributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

			if ( material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading ) {

				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

					var array = object.normalArray;

					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

					array[ i + 0 ] = nx;
					array[ i + 1 ] = ny;
					array[ i + 2 ] = nz;

					array[ i + 3 ] = nx;
					array[ i + 4 ] = ny;
					array[ i + 5 ] = nz;

					array[ i + 6 ] = nx;
					array[ i + 7 ] = ny;
					array[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.normal );

			_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.uv );

			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.color );

			_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		state.disableUnusedAttributes();

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, lights, fog, geometry, material, object, group ) {

		setMaterial( material );

		var program = setProgram( camera, lights, fog, material, object );

		var updateBuffers = false;
		var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

		if ( geometryProgram !== _currentGeometryProgram ) {

			_currentGeometryProgram = geometryProgram;
			updateBuffers = true;

		}

		// morph targets

		var morphTargetInfluences = object.morphTargetInfluences;

		if ( morphTargetInfluences !== undefined ) {

			var activeInfluences = [];

			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

				var influence = morphTargetInfluences[ i ];
				activeInfluences.push( [ influence, i ] );

			}

			activeInfluences.sort( numericalSort );

			if ( activeInfluences.length > 8 ) {

				activeInfluences.length = 8;

			}

			var morphAttributes = geometry.morphAttributes;

			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

				var influence = activeInfluences[ i ];
				morphInfluences[ i ] = influence[ 0 ];

				if ( influence[ 0 ] !== 0 ) {

					var index = influence[ 1 ];

					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

				} else {

					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

				}

			}

			var uniforms = program.getUniforms();

			if ( uniforms.morphTargetInfluences !== null ) {

				_gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );

			}

			updateBuffers = true;

		}

		//

		var index = geometry.index;
		var position = geometry.attributes.position;

		if ( material.wireframe === true ) {

			index = objects.getWireframeAttribute( geometry );

		}

		var renderer;

		if ( index !== null ) {

			renderer = indexedBufferRenderer;
			renderer.setIndex( index );

		} else {

			renderer = bufferRenderer;

		}

		if ( updateBuffers ) {

			setupVertexAttributes( material, program, geometry );

			if ( index !== null ) {

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

			}

		}

		//

		var dataStart = 0;
		var dataCount = Infinity;

		if ( index !== null ) {

			dataCount = index.count

		} else if ( position !== undefined ) {

			dataCount = position.count;

		}

		var rangeStart = geometry.drawRange.start;
		var rangeCount = geometry.drawRange.count;

		var groupStart = group !== null ? group.start : 0;
		var groupCount = group !== null ? group.count : Infinity;

		var drawStart = Math.max( dataStart, rangeStart, groupStart );
		var drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		//

		if ( object instanceof THREE.Mesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * pixelRatio );
				renderer.setMode( _gl.LINES );

			} else {

				renderer.setMode( _gl.TRIANGLES );

			}

			if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

				renderer.renderInstances( geometry );

			} else {

				renderer.render( drawStart, drawCount );

			}

		} else if ( object instanceof THREE.Line ) {

			var lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * pixelRatio );

			if ( object instanceof THREE.LineSegments ) {

				renderer.setMode( _gl.LINES );

			} else {

				renderer.setMode( _gl.LINE_STRIP );

			}

			renderer.render( drawStart, drawCount );

		} else if ( object instanceof THREE.Points ) {

			renderer.setMode( _gl.POINTS );
			renderer.render( drawStart, drawCount );

		}

	};

	function setupVertexAttributes( material, program, geometry, startIndex ) {

		var extension;

		if ( geometry instanceof THREE.InstancedBufferGeometry ) {

			extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		if ( startIndex === undefined ) startIndex = 0;

		state.initAttributes();

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.getAttributes();

		var materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( var name in programAttributes ) {

			var programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					var size = geometryAttribute.itemSize;
					var buffer = objects.getAttributeBuffer( geometryAttribute );

					if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

						var data = geometryAttribute.data;
						var stride = data.stride;
						var offset = geometryAttribute.offset;

						if ( data instanceof THREE.InstancedInterleavedBuffer ) {

							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

					} else {

						if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					var value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								_gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								_gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								_gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								_gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		state.disableUnusedAttributes();

	}

	// Sorting

	function numericalSort ( a, b ) {

		return b[ 0 ] - a[ 0 ];

	}

	function painterSortStable ( a, b ) {

		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable ( a, b ) {

		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		} if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		var fog = scene.fog;

		// reset caching for this frame

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;
		_currentCamera = null;
		_lightsNeedUpdate = true;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		lights.length = 0;

		opaqueObjectsLastIndex = - 1;
		transparentObjectsLastIndex = - 1;

		sprites.length = 0;
		lensFlares.length = 0;

		projectObject( scene, camera );

		opaqueObjects.length = opaqueObjectsLastIndex + 1;
		transparentObjects.length = transparentObjectsLastIndex + 1;

		if ( _this.sortObjects === true ) {

			opaqueObjects.sort( painterSortStable );
			transparentObjects.sort( reversePainterSortStable );

		}

		//

		shadowMap.render( scene );

		//

		_infoRender.calls = 0;
		_infoRender.vertices = 0;
		_infoRender.faces = 0;
		_infoRender.points = 0;

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		//

		if ( scene.overrideMaterial ) {

			var overrideMaterial = scene.overrideMaterial;

			renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
			renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );

		} else {

			// opaque pass (front-to-back order)

			state.setBlending( THREE.NoBlending );
			renderObjects( opaqueObjects, camera, lights, fog );

			// transparent pass (back-to-front order)

			renderObjects( transparentObjects, camera, lights, fog );

		}

		// custom render plugins (post pass)

		spritePlugin.render( scene, camera );
		lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget ) {

			var texture = renderTarget.texture;
			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
			if ( texture.generateMipmaps && isTargetPowerOfTwo && texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

				 updateRenderTargetMipmap( renderTarget );

			}

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.setDepthTest( true );
		state.setDepthWrite( true );
		state.setColorWrite( true );

		// _gl.finish();

	};

	function pushRenderItem( object, geometry, material, z, group ) {

		var array, index;

		// allocate the next position in the appropriate array

		if ( material.transparent ) {

			array = transparentObjects;
			index = ++ transparentObjectsLastIndex;

		} else {

			array = opaqueObjects;
			index = ++ opaqueObjectsLastIndex;

		}

		// recycle existing render item or grow the array

		var renderItem = array[ index ];

		if ( renderItem !== undefined ) {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.z = _vector3.z;
			renderItem.group = group;

		} else {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				z: _vector3.z,
				group: group
			};

			// assert( index === array.length );
			array.push( renderItem );

		}

	}

	function projectObject( object, camera ) {

		if ( object.visible === false ) return;

		if ( ( object.channels.mask & camera.channels.mask ) !== 0 ) {

			if ( object instanceof THREE.Light ) {

				lights.push( object );

			} else if ( object instanceof THREE.Sprite ) {

				sprites.push( object );

			} else if ( object instanceof THREE.LensFlare ) {

				lensFlares.push( object );

			} else if ( object instanceof THREE.ImmediateRenderObject ) {

				if ( _this.sortObjects === true ) {

					_vector3.setFromMatrixPosition( object.matrixWorld );
					_vector3.applyProjection( _projScreenMatrix );

				}

				pushRenderItem( object, null, object.material, _vector3.z, null );

			} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

				if ( object instanceof THREE.SkinnedMesh ) {

					object.skeleton.update();

				}

				if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

					var material = object.material;

					if ( material.visible === true ) {

						if ( _this.sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

						}

						var geometry = objects.update( object );

						if ( material instanceof THREE.MeshFaceMaterial ) {

							var groups = geometry.groups;
							var materials = material.materials;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = materials[ group.materialIndex ];

								if ( groupMaterial.visible === true ) {

									pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

								}

							}

						} else {

							pushRenderItem( object, geometry, material, _vector3.z, null );

						}

					}

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera );

		}

	}

	function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

			var renderItem = renderList[ i ];

			var object = renderItem.object;
			var geometry = renderItem.geometry;
			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
			var group = renderItem.group;

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object instanceof THREE.ImmediateRenderObject ) {

				setMaterial( material );

				var program = setProgram( camera, lights, fog, material, object );

				_currentGeometryProgram = '';

				object.render( function ( object ) {

					_this.renderBufferImmediate( object, program, material );

				} );

			} else {

				_this.renderBufferDirect( camera, lights, fog, geometry, material, object, group );

			}

		}

	}

	function initMaterial( material, lights, fog, object ) {

		var materialProperties = properties.get( material );

		var parameters = programCache.getParameters( material, lights, fog, object );
		var code = programCache.getProgramCode( material, parameters );

		var program = materialProperties.program;
		var programChange = true;

		if ( program === undefined ) {

			// new material
			material.addEventListener( 'dispose', onMaterialDispose );

		} else if ( program.code !== code ) {

			// changed glsl or parameters
			releaseMaterialProgramReference( material );

		} else if ( parameters.shaderID !== undefined ) {

			// same glsl and uniform list
			return;

		} else {

			// only rebuild uniform list
			programChange = false;

		}

		if ( programChange ) {

			if ( parameters.shaderID ) {

				var shader = THREE.ShaderLib[ parameters.shaderID ];

				materialProperties.__webglShader = {
					name: material.type,
					uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				};

			} else {

				materialProperties.__webglShader = {
					name: material.type,
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				};

			}

			material.__webglShader = materialProperties.__webglShader;

			program = programCache.acquireProgram( material, parameters, code );

			materialProperties.program = program;
			material.program = program;

		}

		var attributes = program.getAttributes();

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				if ( attributes[ 'morphTarget' + i ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

				if ( attributes[ 'morphNormal' + i ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		materialProperties.uniformsList = [];

		var uniformLocations = materialProperties.program.getUniforms();

		for ( var u in materialProperties.__webglShader.uniforms ) {

			var location = uniformLocations[ u ];

			if ( location ) {

				materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );

			}

		}

	}

	function setMaterial( material ) {

		setMaterialFaces( material );

		if ( material.transparent === true ) {

			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

		} else {

			state.setBlending( THREE.NoBlending );

		}

		state.setDepthFunc( material.depthFunc );
		state.setDepthTest( material.depthTest );
		state.setDepthWrite( material.depthWrite );
		state.setColorWrite( material.colorWrite );
		state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

	}

	function setMaterialFaces( material ) {

		material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
		state.setFlipSided( material.side === THREE.BackSide );

	}

	function setProgram( camera, lights, fog, material, object ) {

		_usedTextureUnits = 0;

		var materialProperties = properties.get( material );

		if ( material.needsUpdate || ! materialProperties.program ) {

			initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = materialProperties.program,
			p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.__webglShader.uniforms;

		if ( program.id !== _currentProgram ) {

			_gl.useProgram( program.program );
			_currentProgram = program.id;

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			if ( _currentMaterialId === - 1 ) refreshLights = true;
			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			if ( capabilities.logarithmicDepthBuffer ) {

				_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}


			if ( camera !== _currentCamera ) _currentCamera = camera;

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material.envMap ) {

				if ( p_uniforms.cameraPosition !== undefined ) {

					_vector3.setFromMatrixPosition( camera.matrixWorld );
					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms.viewMatrix !== undefined ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

				}

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {

				_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

			}

			if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {

				_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

			}

			if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {

				if ( p_uniforms.boneTexture !== undefined ) {

					var textureUnit = getTextureUnit();

					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
					_this.setTexture( object.skeleton.boneTexture, textureUnit );

				}

				if ( p_uniforms.boneTextureWidth !== undefined ) {

					_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

				}

				if ( p_uniforms.boneTextureHeight !== undefined ) {

					_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

				}

			} else if ( object.skeleton && object.skeleton.boneMatrices ) {

				if ( p_uniforms.boneGlobalMatrices !== undefined ) {

					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

				}

			}

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					refreshLights = true;
					setupLights( lights, camera );
					_lightsNeedUpdate = false;

				}

				if ( refreshLights ) {

					refreshUniformsLights( m_uniforms, _lights );
					markUniformsLightsNeedsUpdate( m_uniforms, true );

				} else {

					markUniformsLightsNeedsUpdate( m_uniforms, false );

				}

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.PointsMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights, camera );

			}

			// load common uniforms

			loadUniformsGeneric( materialProperties.uniformsList );

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms.modelMatrix !== undefined ) {

			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

		}

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		uniforms.diffuse.value = material.color;

		if ( material.emissive ) {

			uniforms.emissive.value = material.emissive;

		}

		uniforms.map.value = material.map;
		uniforms.specularMap.value = material.specularMap;
		uniforms.alphaMap.value = material.alphaMap;

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. normal map
		// 4. bump map
		// 5. alpha map
		// 6. emissive map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap instanceof THREE.WebGLRenderTarget ) uvScaleMap = uvScaleMap.texture;
			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;
		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

		uniforms.reflectivity.value = material.reflectivity;
		uniforms.refractionRatio.value = material.refractionRatio;

	}

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsParticle ( uniforms, material ) {

		uniforms.psColor.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size;
		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

		uniforms.map.value = material.map;

		if ( material.map !== null ) {

			var offset = material.map.offset;
			var repeat = material.map.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

	}

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.specular.value = material.specular;
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;
		uniforms.pointLightDecay.value = lights.point.decays;

		uniforms.spotLightColor.value = lights.spot.colors;
		uniforms.spotLightPosition.value = lights.spot.positions;
		uniforms.spotLightDistance.value = lights.spot.distances;
		uniforms.spotLightDirection.value = lights.spot.directions;
		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
		uniforms.spotLightExponent.value = lights.spot.exponents;
		uniforms.spotLightDecay.value = lights.spot.decays;

		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
		uniforms.hemisphereLightDirection.value = lights.hemi.positions;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate ( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;

		uniforms.directionalLightColor.needsUpdate = value;
		uniforms.directionalLightDirection.needsUpdate = value;

		uniforms.pointLightColor.needsUpdate = value;
		uniforms.pointLightPosition.needsUpdate = value;
		uniforms.pointLightDistance.needsUpdate = value;
		uniforms.pointLightDecay.needsUpdate = value;

		uniforms.spotLightColor.needsUpdate = value;
		uniforms.spotLightPosition.needsUpdate = value;
		uniforms.spotLightDistance.needsUpdate = value;
		uniforms.spotLightDirection.needsUpdate = value;
		uniforms.spotLightAngleCos.needsUpdate = value;
		uniforms.spotLightExponent.needsUpdate = value;
		uniforms.spotLightDecay.needsUpdate = value;

		uniforms.hemisphereLightSkyColor.needsUpdate = value;
		uniforms.hemisphereLightGroundColor.needsUpdate = value;
		uniforms.hemisphereLightDirection.needsUpdate = value;

	}

	function refreshUniformsShadow ( uniforms, lights, camera ) {

		if ( uniforms.shadowMatrix ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];

				if ( light.castShadow === true ) {

					if ( light instanceof THREE.PointLight || light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight ) {

						var shadow = light.shadow;

						if ( light instanceof THREE.PointLight ) {

							// for point lights we set the shadow matrix to be a translation-only matrix
							// equal to inverse of the light's position
							_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
							shadow.matrix.identity().setPosition( _vector3 );

							// for point lights we set the sign of the shadowDarkness uniform to be negative
							uniforms.shadowDarkness.value[ j ] = - shadow.darkness;

						} else {

							uniforms.shadowDarkness.value[ j ] = shadow.darkness;

						}

						uniforms.shadowMatrix.value[ j ] = shadow.matrix;
						uniforms.shadowMap.value[ j ] = shadow.map;
						uniforms.shadowMapSize.value[ j ] = shadow.mapSize;
						uniforms.shadowBias.value[ j ] = shadow.bias;

						j ++;

					}

				}

			}

		}

	}

	// Uniforms (load to GPU)

	function loadUniformsMatrices ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );

		if ( uniforms.normalMatrix ) {

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );

		}

	}

	function getTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= capabilities.maxTextures ) {

			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	}

	function loadUniformsGeneric ( uniforms ) {

		var texture, textureUnit;

		for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

			var uniform = uniforms[ j ][ 0 ];

			// needsUpdate property is not added to all uniforms.
			if ( uniform.needsUpdate === false ) continue;

			var type = uniform.type;
			var value = uniform.value;
			var location = uniforms[ j ][ 1 ];

			switch ( type ) {

				case '1i':
					_gl.uniform1i( location, value );
					break;

				case '1f':
					_gl.uniform1f( location, value );
					break;

				case '2f':
					_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
					break;

				case '3f':
					_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
					break;

				case '4f':
					_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
					break;

				case '1iv':
					_gl.uniform1iv( location, value );
					break;

				case '3iv':
					_gl.uniform3iv( location, value );
					break;

				case '1fv':
					_gl.uniform1fv( location, value );
					break;

				case '2fv':
					_gl.uniform2fv( location, value );
					break;

				case '3fv':
					_gl.uniform3fv( location, value );
					break;

				case '4fv':
					_gl.uniform4fv( location, value );
					break;

				case 'Matrix3fv':
					_gl.uniformMatrix3fv( location, false, value );
					break;

				case 'Matrix4fv':
					_gl.uniformMatrix4fv( location, false, value );
					break;

				//

				case 'i':

					// single integer
					_gl.uniform1i( location, value );

					break;

				case 'f':

					// single float
					_gl.uniform1f( location, value );

					break;

				case 'v2':

					// single THREE.Vector2
					_gl.uniform2f( location, value.x, value.y );

					break;

				case 'v3':

					// single THREE.Vector3
					_gl.uniform3f( location, value.x, value.y, value.z );

					break;

				case 'v4':

					// single THREE.Vector4
					_gl.uniform4f( location, value.x, value.y, value.z, value.w );

					break;

				case 'c':

					// single THREE.Color
					_gl.uniform3f( location, value.r, value.g, value.b );

					break;

				case 'iv1':

					// flat array of integers (JS or typed array)
					_gl.uniform1iv( location, value );

					break;

				case 'iv':

					// flat array of integers with 3 x N size (JS or typed array)
					_gl.uniform3iv( location, value );

					break;

				case 'fv1':

					// flat array of floats (JS or typed array)
					_gl.uniform1fv( location, value );

					break;

				case 'fv':

					// flat array of floats with 3 x N size (JS or typed array)
					_gl.uniform3fv( location, value );

					break;

				case 'v2v':

					// array of THREE.Vector2

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 2 * value.length );

					}

					for ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {

						uniform._array[ i2 + 0 ] = value[ i ].x;
						uniform._array[ i2 + 1 ] = value[ i ].y;

					}

					_gl.uniform2fv( location, uniform._array );

					break;

				case 'v3v':

					// array of THREE.Vector3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 3 * value.length );

					}

					for ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {

						uniform._array[ i3 + 0 ] = value[ i ].x;
						uniform._array[ i3 + 1 ] = value[ i ].y;
						uniform._array[ i3 + 2 ] = value[ i ].z;

					}

					_gl.uniform3fv( location, uniform._array );

					break;

				case 'v4v':

					// array of THREE.Vector4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 4 * value.length );

					}

					for ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {

						uniform._array[ i4 + 0 ] = value[ i ].x;
						uniform._array[ i4 + 1 ] = value[ i ].y;
						uniform._array[ i4 + 2 ] = value[ i ].z;
						uniform._array[ i4 + 3 ] = value[ i ].w;

					}

					_gl.uniform4fv( location, uniform._array );

					break;

				case 'm3':

					// single THREE.Matrix3
					_gl.uniformMatrix3fv( location, false, value.elements );

					break;

				case 'm3v':

					// array of THREE.Matrix3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 9 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

					}

					_gl.uniformMatrix3fv( location, false, uniform._array );

					break;

				case 'm4':

					// single THREE.Matrix4
					_gl.uniformMatrix4fv( location, false, value.elements );

					break;

				case 'm4v':

					// array of THREE.Matrix4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 16 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

					}

					_gl.uniformMatrix4fv( location, false, uniform._array );

					break;

				case 't':

					// single THREE.Texture (2d or cube)

					texture = value;
					textureUnit = getTextureUnit();

					_gl.uniform1i( location, textureUnit );

					if ( ! texture ) continue;

					if ( texture instanceof THREE.CubeTexture ||
						 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

						// CompressedTexture can have Array in image :/

						setCubeTexture( texture, textureUnit );

					} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

						setCubeTextureDynamic( texture.texture, textureUnit );

					} else if ( texture instanceof THREE.WebGLRenderTarget ) {

						_this.setTexture( texture.texture, textureUnit );

					} else {

						_this.setTexture( texture, textureUnit );

					}

					break;

				case 'tv':

					// array of THREE.Texture (2d or cube)

					if ( uniform._array === undefined ) {

						uniform._array = [];

					}

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						uniform._array[ i ] = getTextureUnit();

					}

					_gl.uniform1iv( location, uniform._array );

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						texture = uniform.value[ i ];
						textureUnit = uniform._array[ i ];

						if ( ! texture ) continue;

						if ( texture instanceof THREE.CubeTexture ||
							 ( texture.image instanceof Array && texture.image.length === 6 ) ) {

							// CompressedTexture can have Array in image :/

							setCubeTexture( texture, textureUnit );

						} else if ( texture instanceof THREE.WebGLRenderTarget ) {

							_this.setTexture( texture.texture, textureUnit );

						} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

							setCubeTextureDynamic( texture.texture, textureUnit );

						} else {

							_this.setTexture( texture, textureUnit );

						}

					}

					break;

				default:

					console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

			}

		}

	}

	function setColorLinear( array, offset, color, intensity ) {

		array[ offset + 0 ] = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	}

	function setupLights ( lights, camera ) {

		var l, ll, light,
		r = 0, g = 0, b = 0,
		color, skyColor, groundColor,
		intensity,
		distance,

		zlights = _lights,

		viewMatrix = camera.matrixWorldInverse,

		dirColors = zlights.directional.colors,
		dirPositions = zlights.directional.positions,

		pointColors = zlights.point.colors,
		pointPositions = zlights.point.positions,
		pointDistances = zlights.point.distances,
		pointDecays = zlights.point.decays,

		spotColors = zlights.spot.colors,
		spotPositions = zlights.spot.positions,
		spotDistances = zlights.spot.distances,
		spotDirections = zlights.spot.directions,
		spotAnglesCos = zlights.spot.anglesCos,
		spotExponents = zlights.spot.exponents,
		spotDecays = zlights.spot.decays,

		hemiSkyColors = zlights.hemi.skyColors,
		hemiGroundColors = zlights.hemi.groundColors,
		hemiPositions = zlights.hemi.positions,

		dirLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0,

		dirCount = 0,
		pointCount = 0,
		spotCount = 0,
		hemiCount = 0,

		dirOffset = 0,
		pointOffset = 0,
		spotOffset = 0,
		hemiOffset = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( ! light.visible ) continue;

				r += color.r;
				g += color.g;
				b += color.b;

			} else if ( light instanceof THREE.DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.transformDirection( viewMatrix );

				dirOffset = dirLength * 3;

				dirPositions[ dirOffset + 0 ] = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;

				setColorLinear( dirColors, dirOffset, color, intensity );

				dirLength += 1;

			} else if ( light instanceof THREE.PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

				setColorLinear( pointColors, pointOffset, color, intensity );

				_vector3.setFromMatrixPosition( light.matrixWorld );
				_vector3.applyMatrix4( viewMatrix );

				pointPositions[ pointOffset + 0 ] = _vector3.x;
				pointPositions[ pointOffset + 1 ] = _vector3.y;
				pointPositions[ pointOffset + 2 ] = _vector3.z;

				// distance is 0 if decay is 0, because there is no attenuation at all.
				pointDistances[ pointLength ] = distance;
				pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

				pointLength += 1;

			} else if ( light instanceof THREE.SpotLight ) {

				spotCount += 1;

				if ( ! light.visible ) continue;

				spotOffset = spotLength * 3;

				setColorLinear( spotColors, spotOffset, color, intensity );

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.copy( _direction ).applyMatrix4( viewMatrix );

				spotPositions[ spotOffset + 0 ] = _vector3.x;
				spotPositions[ spotOffset + 1 ] = _vector3.y;
				spotPositions[ spotOffset + 2 ] = _vector3.z;

				spotDistances[ spotLength ] = distance;

				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.transformDirection( viewMatrix );

				spotDirections[ spotOffset + 0 ] = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;
				spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

				spotLength += 1;

			} else if ( light instanceof THREE.HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_direction.transformDirection( viewMatrix );

				hemiOffset = hemiLength * 3;

				hemiPositions[ hemiOffset + 0 ] = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
				setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights.directional.length = dirLength;
		zlights.point.length = pointLength;
		zlights.spot.length = spotLength;
		zlights.hemi.length = hemiLength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	}

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === THREE.CullFaceNone ) {

			state.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === THREE.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			state.enable( _gl.CULL_FACE );

		}

	};

	// Textures

	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		var extension;

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

			}

		}

		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension ) {

			if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
			if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			_infoMemory.textures ++;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

		texture.image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false ) {

			texture.image = makePowerOfTwo( texture.image );

		}

		var image = texture.image,
		isImagePowerOfTwo = isPowerOfTwo( image ),
		glFormat = paramThreeToGL( texture.format ),
		glType = paramThreeToGL( texture.type );

		setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture instanceof THREE.DataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

			}

		} else if ( texture instanceof THREE.CompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

					}

				} else {

					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

			}

		}

		if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	this.setTexture = function ( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			var image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
				return;

			}

			if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
				return;

			}

			uploadTexture( textureProperties, texture, slot );

			return;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

	};

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width > maxSize || image.height > maxSize ) {

			// Warning: Scaling through the canvas will only work with images that use
			// premultiplied alpha.

			var scale = maxSize / Math.max( image.width, image.height );

			var canvas = document.createElement( 'canvas' );
			canvas.width = Math.floor( image.width * scale );
			canvas.height = Math.floor( image.height * scale );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;
		if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;

		return false;

	}

	function makePowerOfTwo( image ) {

		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

			var canvas = document.createElement( 'canvas' );
			canvas.width = THREE.Math.nearestPowerOfTwo( image.width );
			canvas.height = THREE.Math.nearestPowerOfTwo( image.height );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, canvas.width, canvas.height );

			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function setCubeTexture ( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.image.length === 6 ) {

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				if ( ! textureProperties.__image__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					textureProperties.__image__webglTextureCube = _gl.createTexture();

					_infoMemory.textures ++;

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture;
				var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed ) {

						if ( isDataTexture ) {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

						}

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];

							if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								} else {

									console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

				if ( texture.generateMipmaps && isImagePowerOfTwo ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				textureProperties.__version = texture.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			} else {

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

			}

		}

	}

	function setCubeTextureDynamic ( texture, slot ) {

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

	}

	// Render targets

	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );

	}

	function setupRenderBuffer ( renderbuffer, renderTarget ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	}

	this.setRenderTarget = function ( renderTarget ) {

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			_infoMemory.textures ++;

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget ),
				glFormat = paramThreeToGL( renderTarget.texture.format ),
				glType = paramThreeToGL( renderTarget.texture.type );

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];
				renderTargetProperties.__webglRenderbuffer = [];

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTargetProperties.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();
					state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTargetProperties.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if ( renderTarget.shareDepthFrom ) {

					renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

				} else {

					renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();

				}

				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				setupFrameBuffer( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

				if ( renderTarget.shareDepthFrom ) {

					if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

					} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer );

					}

				} else {

					setupRenderBuffer( renderTargetProperties.__webglRenderbuffer, renderTarget );

				}

				if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				state.bindTexture( _gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			if ( isCube ) {

				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTargetProperties.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

		if ( framebuffer !== _currentFramebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		if ( isCube ) {

			var textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, 0 );

		}

		_currentWidth = width;
		_currentHeight = height;

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

		if ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( framebuffer ) {

			var restore = false;

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				restore = true;

			}

			try {

				var texture = renderTarget.texture;

				if ( texture.format !== THREE.RGBAFormat
					&& paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				if ( texture.type !== THREE.UnsignedByteType
					&& paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE )
					&& ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) )
					&& ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

					_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				if ( restore ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

				}

			}

		}

	};

	function updateRenderTargetMipmap( renderTarget ) {

		var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
		var texture = properties.get( renderTarget.texture ).__webglTexture;

		state.bindTexture( target, texture );
		_gl.generateMipmap( target );
		state.bindTexture( target, null );

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		var extension;

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;

		extension = extensions.get( 'OES_texture_half_float' );

		if ( extension !== null ) {

			if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

		}

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

		}

		extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			if ( p === THREE.MinEquation ) return extension.MIN_EXT;
			if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

		}

		return 0;

	}

	// DEPRECATED

	this.supportsFloatTextures = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
		return extensions.get( 'OES_texture_float' );

	};

	this.supportsHalfFloatTextures = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
		return extensions.get( 'OES_texture_half_float' );

	};

	this.supportsStandardDerivatives = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
		return extensions.get( 'OES_standard_derivatives' );

	};

	this.supportsCompressedTextureS3TC = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
		return extensions.get( 'WEBGL_compressed_texture_s3tc' );

	};

	this.supportsCompressedTexturePVRTC = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
		return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	};

	this.supportsBlendMinMax = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
		return extensions.get( 'EXT_blend_minmax' );

	};

	this.supportsVertexTextures = function () {

		return capabilities.vertexTextures;

	};

	this.supportsInstancedArrays = function () {

		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
		return extensions.get( 'ANGLE_instanced_arrays' );

	};

	//

	this.initMaterial = function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	};

	this.addPrePlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	};

	this.addPostPlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	};

	this.updateShadowMap = function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	};

	Object.defineProperties( this, {
		shadowMapEnabled: {
			get: function () {

				return shadowMap.enabled;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				shadowMap.enabled = value;

			}
		},
		shadowMapType: {
			get: function () {

				return shadowMap.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				shadowMap.type = value;

			}
		},
		shadowMapCullFace: {
			get: function () {

				return shadowMap.cullFace;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
				shadowMap.cullFace = value;

			}
		},
		shadowMapDebug: {
			get: function () {

				return shadowMap.debug;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
				shadowMap.debug = value;

			}
		}
	} );

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

	this.uuid = THREE.Math.generateUUID();

	this.width = width;
	this.height = height;

	options = options || {};

	if ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;

	this.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy );

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

	this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

};

THREE.WebGLRenderTarget.prototype = {

	constructor: THREE.WebGLRenderTarget,

	get wrapS() {

		console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );

		return this.texture.wrapS;

	},

	set wrapS( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );

		this.texture.wrapS = value;

	},

	get wrapT() {

		console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );

		return this.texture.wrapT;

	},

	set wrapT( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );

		this.texture.wrapT = value;

	},

	get magFilter() {

		console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );

		return this.texture.magFilter;

	},

	set magFilter( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );

		this.texture.magFilter = value;

	},

	get minFilter() {

		console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );

		return this.texture.minFilter;

	},

	set minFilter( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );

		this.texture.minFilter = value;

	},

	get anisotropy() {

		console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );

		return this.texture.anisotropy;

	},

	set anisotropy( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );

		this.texture.anisotropy = value;

	},

	get offset() {

		console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );

		return this.texture.offset;

	},

	set offset( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );

		this.texture.offset = value;

	},

	get repeat() {

		console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );

		return this.texture.repeat;

	},

	set repeat( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );

		this.texture.repeat = value;

	},

	get format() {

		console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );

		return this.texture.format;

	},

	set format( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );

		this.texture.format = value;

	},

	get type() {

		console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );

		return this.texture.type;

	},

	set type( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );

		this.texture.type = value;

	},

	get generateMipmaps() {

		console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );

		return this.texture.generateMipmaps;

	},

	set generateMipmaps( value ) {

		console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );

		this.texture.generateMipmaps = value;

	},

	//

	setSize: function ( width, height ) {

		if ( this.width !== width || this.height !== height ) {

			this.width = width;
			this.height = height;

			this.dispose();

		}

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.width = source.width;
		this.height = source.height;

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;

		this.shareDepthFrom = source.shareDepthFrom;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

	THREE.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLBufferRenderer.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		_gl.drawArrays( mode, start, count );

		_infoRender.calls ++;
		_infoRender.vertices += count;
		if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

	}

	function renderInstances( geometry ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		var position = geometry.attributes.position;

		if ( position instanceof THREE.InterleavedBufferAttribute ) {

			extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );

		} else {

			extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );

		}

	}

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	var type, size;

	function setIndex( index ) {

		if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

			type = _gl.UNSIGNED_INT;
			size = 4;

		} else {

			type = _gl.UNSIGNED_SHORT;
			size = 2;

		}

	}

	function render( start, count ) {

		_gl.drawElements( mode, count, type, start * size );

		_infoRender.calls ++;
		_infoRender.vertices += count;
		if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

	}

	function renderInstances( geometry ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		var index = geometry.index;

		extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount );

	}

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLExtensions.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLExtensions = function ( gl ) {

	var extensions = {};

	this.get = function ( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		var extension;

		switch ( name ) {

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		if ( extension === null ) {

			console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

		}

		extensions[ name ] = extension;

		return extension;

	};

};

// File:src/renderers/webgl/WebGLCapabilities.js

THREE.WebGLCapabilities = function ( gl, extensions, parameters ) {

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	this.getMaxPrecision = getMaxPrecision;

	this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
	this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

	this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
	this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
	this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
	this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

	this.vertexTextures = this.maxVertexTextures > 0;
	this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
	this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

	var _maxPrecision = getMaxPrecision( this.precision );

	if ( _maxPrecision !== this.precision ) {

		console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
		this.precision = _maxPrecision;

	}

	if ( this.logarithmicDepthBuffer ) {

		this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );

	}

};

// File:src/renderers/webgl/WebGLGeometries.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLGeometries = function ( gl, properties, info ) {

	var geometries = {};

	function get( object ) {

		var geometry = object.geometry;

		if ( geometries[ geometry.id ] !== undefined ) {

			return geometries[ geometry.id ];

		}

		geometry.addEventListener( 'dispose', onGeometryDispose );

		var buffergeometry;

		if ( geometry instanceof THREE.BufferGeometry ) {

			buffergeometry = geometry;

		} else if ( geometry instanceof THREE.Geometry ) {

			if ( geometry._bufferGeometry === undefined ) {

				geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );

			}

			buffergeometry = geometry._bufferGeometry;

		}

		geometries[ geometry.id ] = buffergeometry;

		info.memory.geometries ++;

		return buffergeometry;

	}

	function onGeometryDispose( event ) {

		var geometry = event.target;
		var buffergeometry = geometries[ geometry.id ];

		deleteAttributes( buffergeometry.attributes );

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		var property = properties.get( geometry );
		if ( property.wireframe ) deleteAttribute( property.wireframe );

		info.memory.geometries --;

	}

	function getAttributeBuffer( attribute ) {

		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

			return properties.get( attribute.data ).__webglBuffer;

		}

		return properties.get( attribute ).__webglBuffer;

	}

	function deleteAttribute( attribute ) {

		var buffer = getAttributeBuffer( attribute );

		if ( buffer !== undefined ) {

			gl.deleteBuffer( buffer );
			removeAttributeBuffer( attribute );

		}

	}

	function deleteAttributes( attributes ) {

		for ( var name in attributes ) {

			deleteAttribute( attributes[ name ] );

		}

	}

	function removeAttributeBuffer( attribute ) {

		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

			properties.delete( attribute.data );

		} else {

			properties.delete( attribute );

		}

	}

	this.get = get;

};

// File:src/renderers/webgl/WebGLObjects.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLObjects = function ( gl, properties, info ) {

	var geometries = new THREE.WebGLGeometries( gl, properties, info );

	//

	function update( object ) {

		// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

		var geometry = geometries.get( object );

		if ( object.geometry instanceof THREE.Geometry ) {

			geometry.updateFromObject( object );

		}

		var index = geometry.index;
		var attributes = geometry.attributes;

		if ( index !== null ) {

			updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

		}

		for ( var name in attributes ) {

			updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

		}

		// morph targets

		var morphAttributes = geometry.morphAttributes;

		for ( var name in morphAttributes ) {

			var array = morphAttributes[ name ];

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				updateAttribute( array[ i ], gl.ARRAY_BUFFER );

			}

		}

		return geometry;

	}

	function updateAttribute( attribute, bufferType ) {

		var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

		var attributeProperties = properties.get( data );

		if ( attributeProperties.__webglBuffer === undefined ) {

			createBuffer( attributeProperties, data, bufferType );

		} else if ( attributeProperties.version !== data.version ) {

			updateBuffer( attributeProperties, data, bufferType );

		}

	}

	function createBuffer( attributeProperties, data, bufferType ) {

		attributeProperties.__webglBuffer = gl.createBuffer();
		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

		var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

		gl.bufferData( bufferType, data.array, usage );

		attributeProperties.version = data.version;

	}

	function updateBuffer( attributeProperties, data, bufferType ) {

		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

		if ( data.dynamic === false || data.updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, data.array );

		} else if ( data.updateRange.count === 0 ) {

			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

		} else {

			gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
							  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

			data.updateRange.count = 0; // reset range

		}

		attributeProperties.version = data.version;

	}

	function getAttributeBuffer( attribute ) {

		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

			return properties.get( attribute.data ).__webglBuffer;

		}

		return properties.get( attribute ).__webglBuffer;

	}

	function getWireframeAttribute( geometry ) {

		var property = properties.get( geometry );

		if ( property.wireframe !== undefined ) {

			return property.wireframe;

		}

		var indices = [];

		var index = geometry.index;
		var attributes = geometry.attributes;
		var position = attributes.position;

		// console.time( 'wireframe' );

		if ( index !== null ) {

			var edges = {};
			var array = index.array;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var a = array[ i + 0 ];
				var b = array[ i + 1 ];
				var c = array[ i + 2 ];

				if ( checkEdge( edges, a, b ) ) indices.push( a, b );
				if ( checkEdge( edges, b, c ) ) indices.push( b, c );
				if ( checkEdge( edges, c, a ) ) indices.push( c, a );

			}

		} else {

			var array = attributes.position.array;

			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				var a = i + 0;
				var b = i + 1;
				var c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		// console.timeEnd( 'wireframe' );

		var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
		var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );

		updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

		property.wireframe = attribute;

		return attribute;

	}

	function checkEdge( edges, a, b ) {

		if ( a > b ) {

			var tmp = a;
			a = b;
			b = tmp;

		}

		var list = edges[ a ];

		if ( list === undefined ) {

			edges[ a ] = [ b ];
			return true;

		} else if ( list.indexOf( b ) === -1 ) {

			list.push( b );
			return true;

		}

		return false;

	}

	this.getAttributeBuffer = getAttributeBuffer;
	this.getWireframeAttribute = getWireframeAttribute;

	this.update = update;

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

	var programIdCount = 0;

	function generateDefines( defines ) {

		var chunks = [];

		for ( var name in defines ) {

			var value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchUniformLocations( gl, program, identifiers ) {

		var uniforms = {};

		var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveUniform( program, i );
			var name = info.name;
			var location = gl.getUniformLocation( program, name );

			// console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

			var suffixPos = name.lastIndexOf( '[0]' );
			if ( suffixPos !== - 1 && suffixPos === name.length - 3 ) {

				uniforms[ name.substr( 0, suffixPos ) ] = location;

			}

			uniforms[ name ] = location;

		}

		return uniforms;

	}

	function fetchAttributeLocations( gl, program, identifiers ) {

		var attributes = {};

		var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveAttrib( program, i );
			var name = info.name;

			// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	return function WebGLProgram( renderer, code, material, parameters ) {

		var gl = renderer.context;

		var defines = material.defines;

		var vertexShader = material.__webglShader.vertexShader;
		var fragmentShader = material.__webglShader.fragmentShader;

		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		}

		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

		if ( parameters.envMap ) {

			switch ( material.envMap.mapping ) {

				case THREE.CubeReflectionMapping:
				case THREE.CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case THREE.EquirectangularReflectionMapping:
				case THREE.EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;

				case THREE.SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;

			}

			switch ( material.envMap.mapping ) {

				case THREE.CubeRefractionMapping:
				case THREE.EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

			switch ( material.combine ) {

				case THREE.MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case THREE.MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case THREE.AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		// console.log( 'building new program ' );

		//

		var customDefines = generateDefines( defines );

		//

		var program = gl.createProgram();

		var prefixVertex, prefixFragment;

		if ( material instanceof THREE.RawShaderMaterial ) {

			prefixVertex = '';
			prefixFragment = '';

		} else {

			prefixVertex = [

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + material.__webglShader.name,

				customDefines,

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				renderer.gammaInput ? '#define GAMMA_INPUT' : '',
				renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
				'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
				'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
				'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

				'#define MAX_SHADOWS ' + parameters.maxShadows,

				'#define MAX_BONES ' + parameters.maxBones,

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
				parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
				parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',


				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '',
				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + material.__webglShader.name,

				customDefines,

				'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
				'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
				'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
				'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

				'#define MAX_SHADOWS ' + parameters.maxShadows,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

				renderer.gammaInput ? '#define GAMMA_INPUT' : '',
				renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.metal ? '#define METAL' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
				parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
				parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		var vertexGlsl = prefixVertex + vertexShader;
		var fragmentGlsl = prefixFragment + fragmentShader;

		var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( material.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, material.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		var programLog = gl.getProgramInfoLog( program );
		var vertexLog = gl.getShaderInfoLog( glVertexShader );
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

		var runnable = true;
		var haveDiagnostics = true;

		if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

			runnable = false;

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,
				material: material,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

		// clean up

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function() {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = fetchUniformLocations( gl, program );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		var cachedAttributes;

		this.getAttributes = function() {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function() {

			gl.deleteProgram( program );
			this.program = undefined;

		};

		// DEPRECATED

		Object.defineProperties( this, {

			uniforms: {
				get: function() {

					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
					return this.getUniforms();

				}
			},

			attributes: {
				get: function() {

					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
					return this.getAttributes();

				}
			}

		} );


		//

		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	};

} )();

// File:src/renderers/webgl/WebGLPrograms.js

THREE.WebGLPrograms = function ( renderer, capabilities ) {

	var programs = [];

	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points'
	};

	var parameterNames = [
		"precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
		"lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap",
		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
		"maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights",
		"maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled", "pointLightShadows",
		"shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided",
		"flipSided"
	];


	function allocateBones ( object ) {

		if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = capabilities.maxVertexUniforms;
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

				maxBones = Math.min( object.skeleton.bones.length, maxBones );

				if ( maxBones < object.skeleton.bones.length ) {

					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

				}

			}

			return maxBones;

		}

	}

	function allocateLights( lights ) {

		var dirLights = 0;
		var pointLights = 0;
		var spotLights = 0;
		var hemiLights = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( light.visible === false ) continue;

			if ( light instanceof THREE.DirectionalLight ) dirLights ++;
			if ( light instanceof THREE.PointLight ) pointLights ++;
			if ( light instanceof THREE.SpotLight ) spotLights ++;
			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

		}

		return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

	}

	function allocateShadows( lights ) {

		var maxShadows = 0;
		var pointLightShadows = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight ) maxShadows ++;
			if ( light instanceof THREE.PointLight ) {

				maxShadows ++;
				pointLightShadows ++;

			}

		}

		return { 'maxShadows': maxShadows, 'pointLightShadows': pointLightShadows };

	}

	this.getParameters = function ( material, lights, fog, object ) {

		var shaderID = shaderIDs[ material.type ];
		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxLightCount = allocateLights( lights );
		var allocatedShadows = allocateShadows( lights );
		var maxBones = allocateBones( object );
		var precision = renderer.getPrecision();

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		var parameters = {

			shaderID: shaderID,

			precision: precision,
			supportsVertexTextures: capabilities.vertexTextures,

			map: !! material.map,
			envMap: !! material.envMap,
			envMapMode: material.envMap && material.envMap.mapping,
			lightMap: !! material.lightMap,
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			displacementMap: !! material.displacementMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			combine: material.combine,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			flatShading: material.shading === THREE.FlatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,

			maxDirLights: maxLightCount.directional,
			maxPointLights: maxLightCount.point,
			maxSpotLights: maxLightCount.spot,
			maxHemiLights: maxLightCount.hemi,

			maxShadows: allocatedShadows.maxShadows,
			pointLightShadows: allocatedShadows.pointLightShadows,
			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && allocatedShadows.maxShadows > 0,
			shadowMapType: renderer.shadowMap.type,
			shadowMapDebug: renderer.shadowMap.debug,

			alphaTest: material.alphaTest,
			metal: material.metal,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide

		};

		return parameters;

	};

	this.getProgramCode = function ( material, parameters ) {

		var chunks = [];

		if ( parameters.shaderID ) {

			chunks.push( parameters.shaderID );

		} else {

			chunks.push( material.fragmentShader );
			chunks.push( material.vertexShader );

		}

		if ( material.defines !== undefined ) {

			for ( var name in material.defines ) {

				chunks.push( name );
				chunks.push( material.defines[ name ] );

			}

		}

		for ( var i = 0; i < parameterNames.length; i ++ ) {

			var parameterName = parameterNames[ i ];
			chunks.push( parameterName );
			chunks.push( parameters[ parameterName ] );

		}

		return chunks.join();

	};

	this.acquireProgram = function ( material, parameters, code ) {

		var program;

		// Check if code has been already compiled
		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

			var programInfo = programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new THREE.WebGLProgram( renderer, code, material, parameters );
			programs.push( program );

		}

		return program;

	};

	this.releaseProgram = function( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			var i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	};

	// Exposed for resource monitoring & error feedback via renderer.info:
	this.programs = programs;

};

// File:src/renderers/webgl/WebGLProperties.js

/**
* @author fordacious / fordacious.github.io
*/

THREE.WebGLProperties = function () {

	var properties = {};

	this.get = function ( object ) {

		var uuid = object.uuid;
		var map = properties[ uuid ];

		if ( map === undefined ) {

			map = {};
			properties[ uuid ] = map;

		}

		return map;

	};

	this.delete = function ( object ) {

		delete properties[ object.uuid ];

	};

	this.clear = function () {

		properties = {};

	};

};

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

	function addLineNumbers( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	return function WebGLShader( gl, type, string ) {

		var shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	};

} )();

// File:src/renderers/webgl/WebGLShadowMap.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {

	var _gl = _renderer.context,
	_state = _renderer.state,
	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4(),

	_min = new THREE.Vector3(),
	_max = new THREE.Vector3(),

	_lookTarget = new THREE.Vector3(),
	_lightPositionWorld = new THREE.Vector3(),

	_renderList = [],

	_MorphingFlag = 1,
	_SkinningFlag = 2,

	_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

	_depthMaterials = new Array( _NumberOfMaterialVariants ),
	_distanceMaterials = new Array( _NumberOfMaterialVariants );

	var cubeDirections = [
		new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),
		new THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )
	];

	var cubeUps = [
		new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),
		new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),	new THREE.Vector3( 0, 0, - 1 )
	];

	var cube2DViewPorts = [
		new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
		new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
	];

	var _vector4 = new THREE.Vector4();

	// init

	var depthShader = THREE.ShaderLib[ "depthRGBA" ];
	var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

	var distanceShader = THREE.ShaderLib[ "distanceRGBA" ];
	var distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );

	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

		var useMorphing = ( i & _MorphingFlag ) !== 0;
		var useSkinning = ( i & _SkinningFlag ) !== 0;

		var depthMaterial = new THREE.ShaderMaterial( {
			uniforms: depthUniforms,
			vertexShader: depthShader.vertexShader,
			fragmentShader: depthShader.fragmentShader,
			morphTargets: useMorphing,
			skinning: useSkinning
		} );

		depthMaterial._shadowPass = true;

		_depthMaterials[ i ] = depthMaterial;

		var distanceMaterial = new THREE.ShaderMaterial( {
			uniforms: distanceUniforms,
			vertexShader: distanceShader.vertexShader,
			fragmentShader: distanceShader.fragmentShader,
			morphTargets: useMorphing,
			skinning: useSkinning
		} );

		distanceMaterial._shadowPass = true;

		_distanceMaterials[ i ] = distanceMaterial;

	}

	//

	var scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = THREE.PCFShadowMap;
	this.cullFace = THREE.CullFaceFront;

	this.render = function ( scene ) {

		var faceCount, isPointLight;

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		// Set GL state for depth map.
		_gl.clearColor( 1, 1, 1, 1 );
		_state.disable( _gl.BLEND );
		_state.enable( _gl.CULL_FACE );
		_gl.frontFace( _gl.CCW );
		_gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );
		_state.setDepthTest( true );

		// save the existing viewport so it can be restored later
		_renderer.getViewport( _vector4 );

		// render depth map

		for ( var i = 0, il = _lights.length; i < il; i ++ ) {

			var light = _lights[ i ];

			if ( light.castShadow === true ) {

				var shadow = light.shadow;
				var shadowCamera = shadow.camera;
				var shadowMapSize = shadow.mapSize;

				if ( light instanceof THREE.PointLight ) {

					faceCount = 6;
					isPointLight = true;

					var vpWidth = shadowMapSize.x / 4.0;
					var vpHeight = shadowMapSize.y / 2.0;

					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction

					// positive X
					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
					// negative X
					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
					// positive Z
					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
					// negative Z
					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
					// positive Y
					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
					// negative Y
					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

				} else {

					faceCount = 1;
					isPointLight = false;

				}

				if ( shadow.map === null ) {

					var shadowFilter = THREE.LinearFilter;

					if ( scope.type === THREE.PCFSoftShadowMap ) {

						shadowFilter = THREE.NearestFilter;

					}

					var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

					shadow.map = new THREE.WebGLRenderTarget( shadowMapSize.x, shadowMapSize.y, pars );
					shadow.matrix = new THREE.Matrix4();

					//

					if ( light instanceof THREE.SpotLight ) {

						shadowCamera.aspect = shadowMapSize.x / shadowMapSize.y;

					}

					shadowCamera.updateProjectionMatrix();

				}

				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;

				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( _lightPositionWorld );

				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();

				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not

				for ( var face = 0; face < faceCount; face ++ ) {

					if ( isPointLight ) {

						_lookTarget.copy( shadowCamera.position );
						_lookTarget.add( cubeDirections[ face ] );
						shadowCamera.up.copy( cubeUps[ face ] );
						shadowCamera.lookAt( _lookTarget );
						var vpDimensions = cube2DViewPorts[ face ];
						_renderer.setViewport( vpDimensions.x, vpDimensions.y, vpDimensions.z, vpDimensions.w );

					} else {

						_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
						shadowCamera.lookAt( _lookTarget );

					}

					shadowCamera.updateMatrixWorld();
					shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

					// compute shadow matrix

					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);

					shadowMatrix.multiply( shadowCamera.projectionMatrix );
					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

					// update camera matrices and frustum

					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
					_frustum.setFromMatrix( _projScreenMatrix );

					// set object matrices & frustum culling

					_renderList.length = 0;

					projectObject( scene, shadowCamera );

					// render shadow map
					// render regular objects

					for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

						var object = _renderList[ j ];
						var geometry = _objects.update( object );
						var material = object.material;

						if ( material instanceof THREE.MeshFaceMaterial ) {

							var groups = geometry.groups;
							var materials = material.materials;

							for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

								var group = groups[ k ];
								var groupMaterial = materials[ group.materialIndex ];

								if ( groupMaterial.visible === true ) {

									var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
									_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, depthMaterial, object, group );

								}

							}

						} else {

							var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
							_renderer.renderBufferDirect( shadowCamera, _lights, null, geometry, depthMaterial, object, null );

						}

					}

				}

				// We must call _renderer.resetGLState() at the end of each iteration of
				// the light loop in order to force material updates for each light.
				_renderer.resetGLState();

			}

		}

		_renderer.setViewport( _vector4.x, _vector4.y, _vector4.z, _vector4.w );

		// Restore GL state.
		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();
		_renderer.setClearColor( clearColor, clearAlpha );
		_state.enable( _gl.BLEND );

		if ( scope.cullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.resetGLState();

		scope.needsUpdate = false;

	};

	function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

		var geometry = object.geometry;

		var newMaterial = null;

		var materialVariants = _depthMaterials;
		var customMaterial = object.customDepthMaterial;

		if ( isPointLight ) {

			materialVariants = _distanceMaterials;
			customMaterial = object.customDistanceMaterial;

		}

		if ( ! customMaterial ) {

			var useMorphing = geometry.morphTargets !== undefined &&
					geometry.morphTargets.length > 0 && material.morphTargets;

			var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

			var variantIndex = 0;

			if ( useMorphing ) variantIndex |= _MorphingFlag;
			if ( useSkinning ) variantIndex |= _SkinningFlag;

			newMaterial = materialVariants[ variantIndex ];

		} else {

			newMaterial = customMaterial;

		}

		newMaterial.visible = material.visible;
		newMaterial.wireframe = material.wireframe;
		newMaterial.wireframeLinewidth = material.wireframeLinewidth;

		if ( isPointLight && newMaterial.uniforms.lightPos !== undefined ) {

			newMaterial.uniforms.lightPos.value.copy( lightPositionWorld );

		}

		return newMaterial;

	}

	function projectObject( object, camera ) {

		if ( object.visible === false ) return;

		if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

			if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

				var material = object.material;

				if ( material.visible === true ) {

					object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
					_renderList.push( object );

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera );

		}

	}

};

// File:src/renderers/webgl/WebGLState.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {

	var _this = this;

	var newAttributes = new Uint8Array( 16 );
	var enabledAttributes = new Uint8Array( 16 );
	var attributeDivisors = new Uint8Array( 16 );

	var capabilities = {};

	var compressedTextureFormats = null;

	var currentBlending = null;
	var currentBlendEquation = null;
	var currentBlendSrc = null;
	var currentBlendDst = null;
	var currentBlendEquationAlpha = null;
	var currentBlendSrcAlpha = null;
	var currentBlendDstAlpha = null;

	var currentDepthFunc = null;
	var currentDepthWrite = null;

	var currentColorWrite = null;

	var currentFlipSided = null;

	var currentLineWidth = null;

	var currentPolygonOffsetFactor = null;
	var currentPolygonOffsetUnits = null;

	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

	var currentTextureSlot = undefined;
	var currentBoundTextures = {};

	this.init = function () {

		gl.clearColor( 0, 0, 0, 1 );
		gl.clearDepth( 1 );
		gl.clearStencil( 0 );

		this.enable( gl.DEPTH_TEST );
		gl.depthFunc( gl.LEQUAL );

		gl.frontFace( gl.CCW );
		gl.cullFace( gl.BACK );
		this.enable( gl.CULL_FACE );

		this.enable( gl.BLEND );
		gl.blendEquation( gl.FUNC_ADD );
		gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

	};

	this.initAttributes = function () {

		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

			newAttributes[ i ] = 0;

		}

	};

	this.enableAttribute = function ( attribute ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== 0 ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			extension.vertexAttribDivisorANGLE( attribute, 0 );
			attributeDivisors[ attribute ] = 0;

		}

	};

	this.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	};

	this.disableUnusedAttributes = function () {

		for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	};

	this.enable = function ( id ) {

		if ( capabilities[ id ] !== true ) {

			gl.enable( id );
			capabilities[ id ] = true;

		}

	};

	this.disable = function ( id ) {

		if ( capabilities[ id ] !== false ) {

			gl.disable( id );
			capabilities[ id ] = false;

		}

	};

	this.getCompressedTextureFormats = function () {

		if ( compressedTextureFormats === null ) {

			compressedTextureFormats = [];

			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

				for ( var i = 0; i < formats.length; i ++ ) {

					compressedTextureFormats.push( formats[ i ] );

				}

			}

		}

		return compressedTextureFormats;

	};

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

		if ( blending !== currentBlending ) {

			if ( blending === THREE.NoBlending ) {

				this.disable( gl.BLEND );

			} else if ( blending === THREE.AdditiveBlending ) {

				this.enable( gl.BLEND );
				gl.blendEquation( gl.FUNC_ADD );
				gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

			} else if ( blending === THREE.SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination

				this.enable( gl.BLEND );
				gl.blendEquation( gl.FUNC_ADD );
				gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending === THREE.MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination

				this.enable( gl.BLEND );
				gl.blendEquation( gl.FUNC_ADD );
				gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

			} else if ( blending === THREE.CustomBlending ) {

				this.enable( gl.BLEND );

			} else {

				this.enable( gl.BLEND );
				gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
				gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

			}

			currentBlending = blending;

		}

		if ( blending === THREE.CustomBlending ) {

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

		} else {

			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;

		}

	};

	this.setDepthFunc = function ( depthFunc ) {

		if ( currentDepthFunc !== depthFunc ) {

			if ( depthFunc ) {

				switch ( depthFunc ) {

					case THREE.NeverDepth:

						gl.depthFunc( gl.NEVER );
						break;

					case THREE.AlwaysDepth:

						gl.depthFunc( gl.ALWAYS );
						break;

					case THREE.LessDepth:

						gl.depthFunc( gl.LESS );
						break;

					case THREE.LessEqualDepth:

						gl.depthFunc( gl.LEQUAL );
						break;

					case THREE.EqualDepth:

						gl.depthFunc( gl.EQUAL );
						break;

					case THREE.GreaterEqualDepth:

						gl.depthFunc( gl.GEQUAL );
						break;

					case THREE.GreaterDepth:

						gl.depthFunc( gl.GREATER );
						break;

					case THREE.NotEqualDepth:

						gl.depthFunc( gl.NOTEQUAL );
						break;

					default:

						gl.depthFunc( gl.LEQUAL );

				}

			} else {

				gl.depthFunc( gl.LEQUAL );

			}

			currentDepthFunc = depthFunc;

		}

	};

	this.setDepthTest = function ( depthTest ) {

		if ( depthTest ) {

			this.enable( gl.DEPTH_TEST );

		} else {

			this.disable( gl.DEPTH_TEST );

		}

	};

	this.setDepthWrite = function ( depthWrite ) {

		if ( currentDepthWrite !== depthWrite ) {

			gl.depthMask( depthWrite );
			currentDepthWrite = depthWrite;

		}

	};

	this.setColorWrite = function ( colorWrite ) {

		if ( currentColorWrite !== colorWrite ) {

			gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
			currentColorWrite = colorWrite;

		}

	};

	this.setFlipSided = function ( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			currentFlipSided = flipSided;

		}

	};

	this.setLineWidth = function ( width ) {

		if ( width !== currentLineWidth ) {

			gl.lineWidth( width );

			currentLineWidth = width;

		}

	};

	this.setPolygonOffset = function ( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			this.enable( gl.POLYGON_OFFSET_FILL );

		} else {

			this.disable( gl.POLYGON_OFFSET_FILL );

		}

		if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

			gl.polygonOffset( factor, units );

			currentPolygonOffsetFactor = factor;
			currentPolygonOffsetUnits = units;

		}

	};

	this.setScissorTest = function ( scissorTest ) {

		if ( scissorTest ) {

			this.enable( gl.SCISSOR_TEST );

		} else {

			this.disable( gl.SCISSOR_TEST );

		}

	};

	// texture

	this.activeTexture = function ( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	this.bindTexture = function ( webglType, webglTexture ) {

		if ( currentTextureSlot === undefined ) {

			_this.activeTexture();

		}

		var boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	};

	this.compressedTexImage2D = function () {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( error );

		}

	};

	this.texImage2D = function () {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( error );

		}

	};

	//

	this.reset = function () {

		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

			if ( enabledAttributes[ i ] === 1 ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

		capabilities = {};

		compressedTextureFormats = null;

		currentBlending = null;

		currentDepthWrite = null;
		currentColorWrite = null;

		currentFlipSided = null;

	};

};

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;
	var hasVertexTexture;

	var tempTexture, occlusionTexture;

	function init() {

		var vertices = new Float32Array( [
			- 1, - 1,  0, 0,
			 1, - 1,  1, 0,
			 1,  1,  1, 1,
			- 1,  1,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		// buffers

		vertexBuffer     = gl.createBuffer();
		elementBuffer    = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		// textures

		tempTexture      = gl.createTexture();
		occlusionTexture = gl.createTexture();

		state.bindTexture( gl.TEXTURE_2D, tempTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

		var shader;

		if ( hasVertexTexture ) {

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"uniform sampler2D occlusionMap;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

						"vUV = uv;",

						"vec2 pos = position;",

						"if ( renderType == 2 ) {",

							"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

							"vVisibility =        visibility.r / 9.0;",
							"vVisibility *= 1.0 - visibility.g / 9.0;",
							"vVisibility *=       visibility.b / 9.0;",
							"vVisibility *= 1.0 - visibility.a / 9.0;",

							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

						"}",

						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join( "\n" ),

				fragmentShader: [

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

						// pink square

						"if ( renderType == 0 ) {",

							"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

						// restore

						"} else if ( renderType == 1 ) {",

							"gl_FragColor = texture2D( map, vUV );",

						// flare

						"} else {",

							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * vVisibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",

						"}",

					"}"

				].join( "\n" )

			};

		} else {

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",

					"void main() {",

						"vUV = uv;",

						"vec2 pos = position;",

						"if ( renderType == 2 ) {",

							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

						"}",

						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join( "\n" ),

				fragmentShader: [

					"precision mediump float;",

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform sampler2D occlusionMap;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",

					"void main() {",

						// pink square

						"if ( renderType == 0 ) {",

							"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

						// restore

						"} else if ( renderType == 1 ) {",

							"gl_FragColor = texture2D( map, vUV );",

						// flare

						"} else {",

							"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
							"visibility = ( 1.0 - visibility / 4.0 );",

							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * visibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",

						"}",

					"}"

				].join( "\n" )

			};

		}

		program = createProgram( shader );

		attributes = {
			vertex: gl.getAttribLocation ( program, "position" ),
			uv:     gl.getAttribLocation ( program, "uv" )
		};

		uniforms = {
			renderType:     gl.getUniformLocation( program, "renderType" ),
			map:            gl.getUniformLocation( program, "map" ),
			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
			opacity:        gl.getUniformLocation( program, "opacity" ),
			color:          gl.getUniformLocation( program, "color" ),
			scale:          gl.getUniformLocation( program, "scale" ),
			rotation:       gl.getUniformLocation( program, "rotation" ),
			screenPosition: gl.getUniformLocation( program, "screenPosition" )
		};

	}

	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 */

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		if ( flares.length === 0 ) return;

		var tempPosition = new THREE.Vector3();

		var invAspect = viewportHeight / viewportWidth,
			halfViewportWidth = viewportWidth * 0.5,
			halfViewportHeight = viewportHeight * 0.5;

		var size = 16 / viewportHeight,
			scale = new THREE.Vector2( size * invAspect, size );

		var screenPosition = new THREE.Vector3( 1, 1, 0 ),
			screenPositionPixels = new THREE.Vector2( 1, 1 );

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.vertex );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/uniforms

		gl.uniform1i( uniforms.occlusionMap, 0 );
		gl.uniform1i( uniforms.map, 1 );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		state.disable( gl.CULL_FACE );
		gl.depthMask( false );

		for ( var i = 0, l = flares.length; i < l; i ++ ) {

			size = 16 / viewportHeight;
			scale.set( size * invAspect, size );

			// calc object screen position

			var flare = flares[ i ];

			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition );

			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

			// screen cull

			if ( hasVertexTexture || (
				screenPositionPixels.x > 0 &&
				screenPositionPixels.x < viewportWidth &&
				screenPositionPixels.y > 0 &&
				screenPositionPixels.y < viewportHeight ) ) {

				// save current RGB to temp texture

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, null );
				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// render pink quad

				gl.uniform1i( uniforms.renderType, 0 );
				gl.uniform2f( uniforms.scale, scale.x, scale.y );
				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				state.disable( gl.BLEND );
				state.enable( gl.DEPTH_TEST );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// restore graphics

				gl.uniform1i( uniforms.renderType, 1 );
				state.disable( gl.DEPTH_TEST );

				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition );

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				gl.uniform1i( uniforms.renderType, 2 );
				state.enable( gl.BLEND );

				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					var sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewportHeight;

						scale.x = size * invAspect;
						scale.y = size;

						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform1f( uniforms.rotation, sprite.rotation );

						gl.uniform1f( uniforms.opacity, sprite.opacity );
						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						renderer.setTexture( sprite.texture, 1 );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		state.enable( gl.CULL_FACE );
		state.enable( gl.DEPTH_TEST );
		gl.depthMask( true );

		renderer.resetGLState();

	};

	function createProgram ( shader ) {

		var program = gl.createProgram();

		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

		var prefix = "precision " + renderer.getPrecision() + " float;\n";

		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		gl.compileShader( fragmentShader );
		gl.compileShader( vertexShader );

		gl.attachShader( program, fragmentShader );
		gl.attachShader( program, vertexShader );

		gl.linkProgram( program );

		return program;

	}

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	var texture;

	// decompose matrixWorld

	var spritePosition = new THREE.Vector3();
	var spriteRotation = new THREE.Quaternion();
	var spriteScale = new THREE.Vector3();

	function init() {

		var vertices = new Float32Array( [
			- 0.5, - 0.5,  0, 0,
			  0.5, - 0.5,  1, 0,
			  0.5,   0.5,  1, 1,
			- 0.5,   0.5,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = gl.createBuffer();
		elementBuffer = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			gl.getAttribLocation ( program, 'position' ),
			uv:					gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

			rotation:			gl.getUniformLocation( program, 'rotation' ),
			scale:				gl.getUniformLocation( program, 'scale' ),

			color:				gl.getUniformLocation( program, 'color' ),
			map:				gl.getUniformLocation( program, 'map' ),
			opacity:			gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElement( 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = 'white';
		context.fillRect( 0, 0, 8, 8 );

		texture = new THREE.Texture( canvas );
		texture.needsUpdate = true;

	}

	this.render = function ( scene, camera ) {

		if ( sprites.length === 0 ) return;

		// setup gl

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.position );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		state.disable( gl.CULL_FACE );
		state.enable( gl.BLEND );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		state.activeTexture( gl.TEXTURE0 );
		gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog instanceof THREE.Fog ) {

				gl.uniform1f( uniforms.fogNear, fog.near );
				gl.uniform1f( uniforms.fogFar, fog.far );

				gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog instanceof THREE.FogExp2 ) {

				gl.uniform1f( uniforms.fogDensity, fog.density );

				gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];

			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

		}

		sprites.sort( painterSortStable );

		// render all sprites

		var scale = [];

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];
			var material = sprite.material;

			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

			scale[ 0 ] = spriteScale.x;
			scale[ 1 ] = spriteScale.y;

			var fogType = 0;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			}

			if ( oldFogType !== fogType ) {

				gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				gl.uniform2f( uniforms.uvOffset, 0, 0 );
				gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			gl.uniform1f( uniforms.opacity, material.opacity );
			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			gl.uniform1f( uniforms.rotation, material.rotation );
			gl.uniform2fv( uniforms.scale, scale );

			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );

			if ( material.map && material.map.image && material.map.image.width ) {

				renderer.setTexture( material.map, 0 );

			} else {

				renderer.setTexture( texture, 0 );

			}

			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		state.enable( gl.CULL_FACE );

		renderer.resetGLState();

	};

	function createProgram () {

		var program = gl.createProgram();

		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

		gl.shaderSource( vertexShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		gl.shaderSource( fragmentShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		gl.compileShader( vertexShader );
		gl.compileShader( fragmentShader );

		gl.attachShader( program, vertexShader );
		gl.attachShader( program, fragmentShader );

		gl.linkProgram( program );

		return program;

	}

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	}

};

// File:src/extras/CurveUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.CurveUtils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

		return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
			3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
			6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
			3 * t * t * p3;

	},

	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
		var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3 − t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

		var matrix;

		if ( geometry2 instanceof THREE.Mesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTexture is being deprecated. Use THREE.TextureLoader() instead.' );

		var loader = new THREE.TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( url, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadTextureCube: function ( urls, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTextureCube is being deprecated. Use THREE.CubeTextureLoader() instead.' );

		var loader = new THREE.CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( urls, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadCompressedTexture: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

	},

	loadCompressedTextureCube: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

	}

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new THREE.Group();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new THREE.Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach: function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new THREE.Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

// File:src/extras/ShapeUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.ShapeUtils = {

	// calculate area of the contour polygon

	area: function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	},

	triangulate: ( function () {

		/**
		 * This code is a quick port of code written in C++ which was submitted to
		 * flipcode.com by John W. Ratcliff  // July 22, 2000
		 * See original code and more information here:
		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
		 *
		 * ported to actionscript by Zevan Rosser
		 * www.actionsnippet.com
		 *
		 * ported to javascript by Joshua Koo
		 * http://www.lab4games.net/zz85/blog
		 *
		 */

		function snip( contour, u, v, w, n, verts ) {

			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;

			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;

			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;

			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;

			if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			for ( p = 0; p < n; p ++ ) {

				px = contour[ verts[ p ] ].x;
				py = contour[ verts[ p ] ].y;

				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;

				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

			}

			return true;

		}

		// takes in an contour array and returns

		return function ( contour, indices ) {

			var n = contour.length;

			if ( n < 3 ) return null;

			var result = [],
				verts = [],
				vertIndices = [];

			/* we want a counter-clockwise polygon in verts */

			var u, v, w;

			if ( THREE.ShapeUtils.area( contour ) > 0.0 ) {

				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

			} else {

				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

			}

			var nv = n;

			/*  remove nv - 2 vertices, creating 1 triangle every time */

			var count = 2 * nv;   /* error detection */

			for ( v = nv - 1; nv > 2; ) {

				/* if we loop, it is probably a non-simple polygon */

				if ( ( count -- ) <= 0 ) {

					//** Triangulate: ERROR - probable bad polygon!

					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

					if ( indices ) return vertIndices;
					return result;

				}

				/* three consecutive vertices in current polygon, <u,v,w> */

				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

				if ( snip( contour, u, v, w, nv, verts ) ) {

					var a, b, c, s, t;

					/* true names of the vertices */

					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];

					/* output Triangle */

					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );


					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

					/* remove v from the remaining polygon */

					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

						verts[ s ] = verts[ t ];

					}

					nv --;

					/* reset error detection counter */

					count = 2 * nv;

				}

			}

			if ( indices ) return vertIndices;
			return result;

		}

	} )(),

	triangulateShape: function ( contour, holes ) {

		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

			// inOtherPt needs to be collinear to the inSegment
			if ( inSegPt1.x !== inSegPt2.x ) {

				if ( inSegPt1.x < inSegPt2.x ) {

					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

				} else {

					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

				}

			} else {

				if ( inSegPt1.y < inSegPt2.y ) {

					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

				} else {

					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

				}

			}

		}

		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

			if ( Math.abs( limit ) > Number.EPSILON ) {

				// not parallel

				var perpSeg2;
				if ( limit > 0 ) {

					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

				} else {

					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

				}

				// i.e. to reduce rounding errors
				// intersection at endpoint of segment#1?
				if ( perpSeg2 === 0 ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt1 ];

				}
				if ( perpSeg2 === limit ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt2 ];

				}
				// intersection at endpoint of segment#2?
				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

				// return real intersection point
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

			} else {

				// parallel or collinear
				if ( ( perpSeg1 !== 0 ) ||
					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

				// they are collinear or degenerate
				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
				// both segments are points
				if ( seg1Pt && seg2Pt ) {

					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
					return [ inSeg1Pt1 ];                 						// they are the same point

				}
				// segment#1  is a single point
				if ( seg1Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
					return [ inSeg1Pt1 ];

				}
				// segment#2  is a single point
				if ( seg2Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
					return [ inSeg2Pt1 ];

				}

				// they are collinear segments, which might overlap
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if ( seg1dx !== 0 ) {

					// the segments are NOT on a vertical line
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

					}

				} else {

					// the segments are on a vertical line
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

					}

				}
				if ( seg1minVal <= seg2minVal ) {

					if ( seg1maxVal <  seg2minVal )	return [];
					if ( seg1maxVal === seg2minVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];

				} else {

					if ( seg1minVal >  seg2maxVal )	return [];
					if ( seg1minVal === seg2maxVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];

				}

			}

		}

		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

			// The order of legs is important

			// translation of all points, so that Vertex is at (0,0)
			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

				// angle != 180 deg.

				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

				if ( from2toAngle > 0 ) {

					// main angle < 180 deg.
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

				} else {

					// main angle > 180 deg.
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

				}

			} else {

				// angle == 180 deg.
				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
				return	( from2otherAngle > 0 );

			}

		}


		function removeHoles( contour, holes ) {

			var shape = contour.concat(); // work on this shape
			var hole;

			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

				// Check if hole point lies within angle around shape point
				var lastShapeIdx = shape.length - 1;

				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
					return	false;

				}

				// Check if shape point lies within angle around hole point
				var lastHoleIdx = hole.length - 1;

				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
					return	false;

				}

				return	true;

			}

			function intersectsShapeEdge( inShapePt, inHolePt ) {

				// checks for intersections with shape edges
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

					nextIdx = sIdx + 1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
					if ( intersection.length > 0 )		return	true;

				}

				return	false;

			}

			var indepHoles = [];

			function intersectsHoleEdge( inShapePt, inHolePt ) {

				// checks for intersections with hole edges
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

					chkHole = holes[ indepHoles[ ihIdx ]];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;

					}

				}
				return	false;

			}

			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				indepHoles.push( h );

			}

			var minShapeIndex = 0;
			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {

				counter --;
				if ( counter < 0 ) {

					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
					break;

				}

				// search for shape-vertex and hole-vertex,
				// which can be connected without intersections
				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

					shapePt = shape[ shapeIndex ];
					holeIndex	= - 1;

					// search for hole which can be reached without intersections
					for ( var h = 0; h < indepHoles.length; h ++ ) {

						holeIdx = indepHoles[ h ];

						// prevent multiple checks
						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
						if ( failedCuts[ cutKey ] !== undefined )			continue;

						hole = holes[ holeIdx ];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

							holePt = hole[ h2 ];
							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

							holeIndex = h2;
							indepHoles.splice( h, 1 );

							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex + 1 );

							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

							minShapeIndex = shapeIndex;

							// Debug only, to show the selected cuts
							// glob_CutLines.push( [ shapePt, holePt ] );

							break;

						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

						failedCuts[ cutKey ] = true;			// remember failure

					}
					if ( holeIndex >= 0 )	break;		// hole-vertex found

				}

			}

			return shape; 			/* shape with no holes */

		}


		var i, il, f, face,
			key, index,
			allPointsMap = {};

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		var allpoints = contour.concat();

		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

			Array.prototype.push.apply( allpoints, holes[ h ] );

		}

		//console.log( "allpoints",allpoints, allpoints.length );

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.warn( "THREE.Shape: Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// remove holes by cutting paths to holes and adding them to the shape
		var shapeWithoutHoles = removeHoles( contour, holes );

		var triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
		//console.log( "triangles",triangles, triangles.length );

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat();

	},

	isClockWise: function ( pts ) {

		return THREE.ShapeUtils.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2: ( function () {

		function b2p0( t, p ) {

			var k = 1 - t;
			return k * k * p;

		}

		function b2p1( t, p ) {

			return 2 * ( 1 - t ) * t * p;

		}

		function b2p2( t, p ) {

			return t * t * p;

		}

		return function ( t, p0, p1, p2 ) {

			return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

		};

	} )(),

	// Cubic Bezier Functions

	b3: ( function () {

		function b3p0( t, p ) {

			var k = 1 - t;
			return k * k * k * p;

		}

		function b3p1( t, p ) {

			var k = 1 - t;
			return 3 * k * k * t * p;

		}

		function b3p2( t, p ) {

			var k = 1 - t;
			return 3 * k * t * t * p;

		}

		function b3p3( t, p ) {

			return t * t * t * p;

		}

		return function ( t, p0, p1, p2, p3 ) {

			return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

		};

	} )()

};

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function ( listener ) {

	THREE.Object3D.call( this );

	this.type = 'Audio';

	this.context = listener.context;
	this.source = this.context.createBufferSource();
	this.source.onended = this.onEnded.bind( this );

	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );

	this.panner = this.context.createPanner();
	this.panner.connect( this.gain );

	this.autoplay = false;

	this.startTime = 0;
	this.playbackRate = 1;
	this.isPlaying = false;

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
THREE.Audio.prototype.constructor = THREE.Audio;

THREE.Audio.prototype.load = function ( file ) {

	var scope = this;

	var request = new XMLHttpRequest();
	request.open( 'GET', file, true );
	request.responseType = 'arraybuffer';
	request.onload = function ( e ) {

		scope.context.decodeAudioData( this.response, function ( buffer ) {

			scope.source.buffer = buffer;

			if ( scope.autoplay ) scope.play();

		} );

	};
	request.send();

	return this;

};

THREE.Audio.prototype.play = function () {

	if ( this.isPlaying === true ) {

		console.warn( 'THREE.Audio: Audio is already playing.' );
		return;

	}

	var source = this.context.createBufferSource();

	source.buffer = this.source.buffer;
	source.loop = this.source.loop;
	source.onended = this.source.onended;
	source.start( 0, this.startTime );
	source.playbackRate.value = this.playbackRate;

	this.isPlaying = true;

	this.source = source;

	this.connect();

};

THREE.Audio.prototype.pause = function () {

	this.source.stop();
	this.startTime = this.context.currentTime;

};

THREE.Audio.prototype.stop = function () {

	this.source.stop();
	this.startTime = 0;

};

THREE.Audio.prototype.connect = function () {

	if ( this.filter !== undefined ) {

		this.source.connect( this.filter );
		this.filter.connect( this.panner );

	} else {

		this.source.connect( this.panner );

	}

};

THREE.Audio.prototype.disconnect = function () {

	if ( this.filter !== undefined ) {

		this.source.disconnect( this.filter );
		this.filter.disconnect( this.panner );

	} else {

		this.source.disconnect( this.panner );

	}

};

THREE.Audio.prototype.setFilter = function ( value ) {

	if ( this.isPlaying === true ) {

		this.disconnect();
		this.filter = value;
		this.connect();

	} else {

		this.filter = value;

	}

};

THREE.Audio.prototype.getFilter = function () {

	return this.filter;

};

THREE.Audio.prototype.setPlaybackRate = function ( value ) {

	this.playbackRate = value;

	if ( this.isPlaying === true ) {

		this.source.playbackRate.value = this.playbackRate;

	}

};

THREE.Audio.prototype.getPlaybackRate = function () {

	return this.playbackRate;

};

THREE.Audio.prototype.onEnded = function() {

	this.isPlaying = false;

};

THREE.Audio.prototype.setLoop = function ( value ) {

	this.source.loop = value;

};

THREE.Audio.prototype.getLoop = function () {

	return this.source.loop;

};

THREE.Audio.prototype.setRefDistance = function ( value ) {

	this.panner.refDistance = value;

};

THREE.Audio.prototype.getRefDistance = function () {

	return this.panner.refDistance;

};

THREE.Audio.prototype.setRolloffFactor = function ( value ) {

	this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.getRolloffFactor = function () {

	return this.panner.rolloffFactor;

};

THREE.Audio.prototype.setVolume = function ( value ) {

	this.gain.gain.value = value;

};

THREE.Audio.prototype.getVolume = function () {

	return this.gain.gain.value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function () {

	var position = new THREE.Vector3();

	return function updateMatrixWorld( force ) {

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		position.setFromMatrixPosition( this.matrixWorld );

		this.panner.setPosition( position.x, position.y, position.z );

	};

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

	THREE.Object3D.call( this );

	this.type = 'AudioListener';

	this.context = new ( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
THREE.AudioListener.prototype.constructor = THREE.AudioListener;

THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

	var position = new THREE.Vector3();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3();

	var orientation = new THREE.Vector3();

	return function updateMatrixWorld( force ) {

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		var listener = this.context.listener;
		var up = this.up;

		this.matrixWorld.decompose( position, quaternion, scale );

		orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

		listener.setPosition( position.x, position.y, position.z );
		listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

	};

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

THREE.Curve.prototype = {

	constructor: THREE.Curve,

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint: function ( t ) {

		console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
		return null;

	},

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t );

	},

	// Get sequence of points using getPoint( t )

	getPoints: function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPoint( d / divisions ) );

		}

		return pts;

	},

	// Get sequence of points using getPointAt( u )

	getSpacedPoints: function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPointAt( d / divisions ) );

		}

		return pts;

	},

	// Get total curve arc length

	getLength: function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	},

	// Get list of cumulative segment lengths

	getLengths: function ( divisions ) {

		if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length === divisions + 1 )
			&& ! this.needsUpdate ) {

			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

	},

	updateArcLengths: function() {

		this.needsUpdate = true;
		this.getLengths();

	},

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping: function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		//var time = Date.now();

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		//console.log('b' , i, low, high, Date.now()- time);

		if ( arcLengths[ i ] === targetArcLength ) {

			var t = i / ( il - 1 );
			return t;

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];

		var segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		var t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	},

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent: function( t ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var vec = pt2.clone().sub( pt1 );
		return vec.normalize();

	},

	getTangentAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t );

	}

}

THREE.Curve.Utils = THREE.CurveUtils; // backwards compatibility

// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( THREE.Curve.prototype );
	constructor.prototype.constructor = constructor;
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

	this.curves = [];

	this.autoClose = false; // Automatically closes the path

};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function ( curve ) {

	this.curves.push( curve );

};

/*
THREE.CurvePath.prototype.checkConnection = function() {
	// TODO
	// If the ending of curve is not connected to the starting
	// or the next curve, then, this is not a real path
};
*/

THREE.CurvePath.prototype.closePath = function() {

	// TODO Test
	// and verify for vector3 (needs to implement equals)
	// Add a line curve if start and end of lines are not connected
	var startPoint = this.curves[ 0 ].getPoint( 0 );
	var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

	if ( ! startPoint.equals( endPoint ) ) {

		this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );

	}

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

	var d = t * this.getLength();
	var curveLengths = this.getCurveLengths();
	var i = 0;

	// To think about boundaries points.

	while ( i < curveLengths.length ) {

		if ( curveLengths[ i ] >= d ) {

			var diff = curveLengths[ i ] - d;
			var curve = this.curves[ i ];

			var u = 1 - diff / curve.getLength();

			return curve.getPointAt( u );

		}

		i ++;

	}

	return null;

	// loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};
*/

// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

	var lens = this.getCurveLengths();
	return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

	// We use cache values if curves and cache array are same length

	if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

		return this.cacheLengths;

	}

	// Get length of sub-curve
	// Push sums into cached array

	var lengths = [], sums = 0;

	for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

		sums += this.curves[ i ].getLength();
		lengths.push( sums );

	}

	this.cacheLengths = lengths;

	return lengths;

};



/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

	var pts = this.getPoints( divisions, true );
	return this.createGeometry( pts );

};

// Generate geometry from equidistant sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

	var pts = this.getSpacedPoints( divisions, true );
	return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

	var geometry = new THREE.Geometry();

	for ( var i = 0, l = points.length; i < l; i ++ ) {

		var point = points[ i ];
		geometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );

	}

	return geometry;

};

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

	THREE.CurvePath.call( this );

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
THREE.Path.prototype.constructor = THREE.Path;

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

	for ( var i = 1, l = vectors.length; i < l; i ++ ) {

		this.lineTo( vectors[ i ].x, vectors[ i ].y );

	}

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

	this.actions.push( { action: 'moveTo', args: [ x, y ] } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
	this.curves.push( curve );

	this.actions.push( { action: 'lineTo', args: [ x, y ] } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.QuadraticBezierCurve(
		new THREE.Vector2( x0, y0 ),
		new THREE.Vector2( aCPx, aCPy ),
		new THREE.Vector2( aX, aY )
	);

	this.curves.push( curve );

	this.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.CubicBezierCurve(
		new THREE.Vector2( x0, y0 ),
		new THREE.Vector2( aCP1x, aCP1y ),
		new THREE.Vector2( aCP2x, aCP2y ),
		new THREE.Vector2( aX, aY )
	);

	this.curves.push( curve );

	this.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var npts = [ new THREE.Vector2( x0, y0 ) ];
	Array.prototype.push.apply( npts, pts );

	var curve = new THREE.SplineCurve( npts );
	this.curves.push( curve );

	this.actions.push( { action: 'splineThru', args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absarc( aX + x0, aY + y0, aRadius,
		aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	var lastargs = this.actions[ this.actions.length - 1 ].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	var args = [
		aX, aY,
		xRadius, yRadius,
		aStartAngle, aEndAngle,
		aClockwise,
		aRotation || 0 // aRotation is optional.
	];

	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	this.curves.push( curve );

	var lastPoint = curve.getPoint( 1 );
	args.push( lastPoint.x );
	args.push( lastPoint.y );

	this.actions.push( { action: 'ellipse', args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

	if ( ! divisions ) divisions = 40;

	var points = [];

	for ( var i = 0; i < divisions; i ++ ) {

		points.push( this.getPoint( i / divisions ) );

		//if ( !this.getPoint( i / divisions ) ) throw "DIE";

	}

	// if ( closedPath ) {
	//
	// 	points.push( points[ 0 ] );
	//
	// }

	return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

	divisions = divisions || 12;

	var b2 = THREE.ShapeUtils.b2;
	var b3 = THREE.ShapeUtils.b3;

	var points = [];

	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
		laste, tx, ty;

	for ( var i = 0, l = this.actions.length; i < l; i ++ ) {

		var item = this.actions[ i ];

		var action = item.action;
		var args = item.args;

		switch ( action ) {

		case 'moveTo':

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case 'lineTo':

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case 'quadraticCurveTo':

			cpx  = args[ 2 ];
			cpy  = args[ 3 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}

			for ( var j = 1; j <= divisions; j ++ ) {

				var t = j / divisions;

				tx = b2( t, cpx0, cpx1, cpx );
				ty = b2( t, cpy0, cpy1, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case 'bezierCurveTo':

			cpx  = args[ 4 ];
			cpy  = args[ 5 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			cpx2 = args[ 2 ];
			cpy2 = args[ 3 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}


			for ( var j = 1; j <= divisions; j ++ ) {

				var t = j / divisions;

				tx = b3( t, cpx0, cpx1, cpx2, cpx );
				ty = b3( t, cpy0, cpy1, cpy2, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case 'splineThru':

			laste = this.actions[ i - 1 ].args;

			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
			var spts = [ last ];

			var n = divisions * args[ 0 ].length;

			spts = spts.concat( args[ 0 ] );

			var spline = new THREE.SplineCurve( spts );

			for ( var j = 1; j <= n; j ++ ) {

				points.push( spline.getPointAt( j / n ) );

			}

			break;

		case 'arc':

			var aX = args[ 0 ], aY = args[ 1 ],
				aRadius = args[ 2 ],
				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
				aClockwise = !! args[ 5 ];

			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( var j = 1; j <= tdivisions; j ++ ) {

				var t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + aRadius * Math.cos( angle );
				ty = aY + aRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

			break;

		case 'ellipse':

			var aX = args[ 0 ], aY = args[ 1 ],
				xRadius = args[ 2 ],
				yRadius = args[ 3 ],
				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
				aClockwise = !! args[ 6 ],
				aRotation = args[ 7 ];


			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			var cos, sin;
			if ( aRotation !== 0 ) {

				cos = Math.cos( aRotation );
				sin = Math.sin( aRotation );

			}

			for ( var j = 1; j <= tdivisions; j ++ ) {

				var t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + xRadius * Math.cos( angle );
				ty = aY + yRadius * Math.sin( angle );

				if ( aRotation !== 0 ) {

					var x = tx, y = ty;

					// Rotate the point about the center of the ellipse.
					tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
					ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

				}

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

			break;

		} // end switch

	}



	// Normalize to remove the closing point by default.
	var lastPoint = points[ points.length - 1 ];
	if ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&
			 Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )
		points.splice( points.length - 1, 1 );
	if ( closedPath ) {

		points.push( points[ 0 ] );

	}

	return points;

};

//
// Breaks path into shapes
//
//	Assumptions (if parameter isCCW==true the opposite holds):
//	- solid shapes are defined clockwise (CW)
//	- holes are defined counterclockwise (CCW)
//
//	If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

	function extractSubpaths( inActions ) {

		var subPaths = [], lastPath = new THREE.Path();

		for ( var i = 0, l = inActions.length; i < l; i ++ ) {

			var item = inActions[ i ];

			var args = item.args;
			var action = item.action;

			if ( action === 'moveTo' ) {

				if ( lastPath.actions.length !== 0 ) {

					subPaths.push( lastPath );
					lastPath = new THREE.Path();

				}

			}

			lastPath[ action ].apply( lastPath, args );

		}

		if ( lastPath.actions.length !== 0 ) {

			subPaths.push( lastPath );

		}

		// console.log(subPaths);

		return	subPaths;

	}

	function toShapesNoHoles( inSubpaths ) {

		var shapes = [];

		for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

			var tmpPath = inSubpaths[ i ];

			var tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;

			shapes.push( tmpShape );

		}

		//console.log("shape", shapes);

		return shapes;

	}

	function isPointInsidePolygon( inPt, inPolygon ) {

		var polyLen = inPolygon.length;

		// inPt on polygon contour => immediate success    or
		// toggling of inside/outside at every single! intersection point of an edge
		//  with the horizontal line through inPt, left of inPt
		//  not counting lowerY endpoints of edges and whole edges on that line
		var inside = false;
		for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

			var edgeLowPt  = inPolygon[ p ];
			var edgeHighPt = inPolygon[ q ];

			var edgeDx = edgeHighPt.x - edgeLowPt.x;
			var edgeDy = edgeHighPt.y - edgeLowPt.y;

			if ( Math.abs( edgeDy ) > Number.EPSILON ) {

				// not parallel
				if ( edgeDy < 0 ) {

					edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
					edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

				}
				if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

				if ( inPt.y === edgeLowPt.y ) {

					if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
					// continue;				// no intersection or edgeLowPt => doesn't count !!!

				} else {

					var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
					if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
					if ( perpEdge < 0 ) 				continue;
					inside = ! inside;		// true intersection left of inPt

				}

			} else {

				// parallel or collinear
				if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
				// edge lies on the same horizontal line as inPt
				if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
					 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
				// continue;

			}

		}

		return	inside;

	}

	var isClockWise = THREE.ShapeUtils.isClockWise;

	var subPaths = extractSubpaths( this.actions );
	if ( subPaths.length === 0 ) return [];

	if ( noHoles === true )	return	toShapesNoHoles( subPaths );


	var solid, tmpPath, tmpShape, shapes = [];

	if ( subPaths.length === 1 ) {

		tmpPath = subPaths[ 0 ];
		tmpShape = new THREE.Shape();
		tmpShape.actions = tmpPath.actions;
		tmpShape.curves = tmpPath.curves;
		shapes.push( tmpShape );
		return shapes;

	}

	var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
	holesFirst = isCCW ? ! holesFirst : holesFirst;

	// console.log("Holes first", holesFirst);

	var betterShapeHoles = [];
	var newShapes = [];
	var newShapeHoles = [];
	var mainIdx = 0;
	var tmpPoints;

	newShapes[ mainIdx ] = undefined;
	newShapeHoles[ mainIdx ] = [];

	for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

		tmpPath = subPaths[ i ];
		tmpPoints = tmpPath.getPoints();
		solid = isClockWise( tmpPoints );
		solid = isCCW ? ! solid : solid;

		if ( solid ) {

			if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

			newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
			newShapes[ mainIdx ].s.actions = tmpPath.actions;
			newShapes[ mainIdx ].s.curves = tmpPath.curves;

			if ( holesFirst )	mainIdx ++;
			newShapeHoles[ mainIdx ] = [];

			//console.log('cw', i);

		} else {

			newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

			//console.log('ccw', i);

		}

	}

	// only Holes? -> probably all Shapes with wrong orientation
	if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


	if ( newShapes.length > 1 ) {

		var ambiguous = false;
		var toChange = [];

		for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

			betterShapeHoles[ sIdx ] = [];

		}

		for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

			var sho = newShapeHoles[ sIdx ];

			for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

				var ho = sho[ hIdx ];
				var hole_unassigned = true;

				for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

					if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

						if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
						if ( hole_unassigned ) {

							hole_unassigned = false;
							betterShapeHoles[ s2Idx ].push( ho );

						} else {

							ambiguous = true;

						}

					}

				}
				if ( hole_unassigned ) {

					betterShapeHoles[ sIdx ].push( ho );

				}

			}

		}
		// console.log("ambiguous: ", ambiguous);
		if ( toChange.length > 0 ) {

			// console.log("to change: ", toChange);
			if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

		}

	}

	var tmpHoles;

	for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

		tmpShape = newShapes[ i ].s;
		shapes.push( tmpShape );
		tmpHoles = newShapeHoles[ i ];

		for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

			tmpShape.holes.push( tmpHoles[ j ].h );

		}

	}

	//console.log("shape", shapes);

	return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

	THREE.Path.apply( this, arguments );

	this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );
THREE.Shape.prototype.constructor = THREE.Shape;

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

	return new THREE.ExtrudeGeometry( this, options );

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

	return new THREE.ShapeGeometry( this, options );

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

	var holesPts = [];

	for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getPoints( divisions );

	}

	return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

	return {

		shape: this.getPoints( divisions ),
		holes: this.getPointsHoles( divisions )

	};

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

	return this.extractAllPoints( divisions );

};

THREE.Shape.Utils = THREE.ShapeUtils; // backwards compatibility

// File:src/extras/curves/LineCurve.js

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function ( t ) {

	var point = this.v2.clone().sub( this.v1 );
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub( this.v1 );

	return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var b2 = THREE.ShapeUtils.b2;

	return new THREE.Vector2(
		b2( t, this.v0.x, this.v1.x, this.v2.x ),
		b2( t, this.v0.y, this.v1.y, this.v2.y )
	);

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;

	return new THREE.Vector2(
		tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
		tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
	).normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var b3 = THREE.ShapeUtils.b3;

	return new THREE.Vector2( 
		b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
		b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
	);

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;

	return new THREE.Vector2( 
		tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
		tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
	).normalize();

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function ( t ) {

	var points = this.points;
	var point = ( points.length - 1 ) * t;

	var intPoint = Math.floor( point );
	var weight = point - intPoint;

	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
	var point1 = points[ intPoint ];
	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

	var interpolate = THREE.CurveUtils.interpolate;

	return new THREE.Vector2(
		interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
		interpolate( point0.y, point1.y, point2.y, point3.y, weight )
	);

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;
	
	this.aRotation = aRotation || 0;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

	var angle;

	if ( this.aClockwise === true ) {

		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

	} else {

		angle = this.aStartAngle + t * deltaAngle;

	}
	
	var x = this.aX + this.xRadius * Math.cos( angle );
	var y = this.aY + this.yRadius * Math.sin( angle );

	if ( this.aRotation !== 0 ) {

		var cos = Math.cos( this.aRotation );
		var sin = Math.sin( this.aRotation );

		var tx = x, ty = y;

		// Rotate the point about the center of the ellipse.
		x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
		y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

	}

	return new THREE.Vector2( x, y );

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.subVectors( this.v2, this.v1 ); // diff
		vector.multiplyScalar( t );
		vector.add( this.v1 );

		return vector;

	}

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var b2 = THREE.ShapeUtils.b2;		

		return new THREE.Vector3(
			b2( t, this.v0.x, this.v1.x, this.v2.x ),
			b2( t, this.v0.y, this.v1.y, this.v2.y ),
			b2( t, this.v0.z, this.v1.z, this.v2.z )
		);

	}

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var b3 = THREE.ShapeUtils.b3;

		return new THREE.Vector3(
			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
			b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
		);

	}

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */ ) {

		console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		var interpolate = THREE.CurveUtils.interpolate;

		return new THREE.Vector3(
			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
			interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
			interpolate( point0.z, point1.z, point2.z, point3.z, weight )
		);

	}

);

// File:src/extras/curves/CatmullRomCurve3.js

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

THREE.CatmullRomCurve3 = ( function() {

	var
		tmp = new THREE.Vector3(),
		px = new CubicPoly(),
		py = new CubicPoly(),
		pz = new CubicPoly();

	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

	}

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

		this.c0 = x0;
		this.c1 = t0;
		this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

	};

	CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

		// compute tangents when parameterized in [t1,t2]
		var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
		var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

		// rescale tangents for parametrization in [0,1]
		t1 *= dt1;
		t2 *= dt1;

		// initCubicPoly
		this.init( x1, x2, t1, t2 );

	};

	// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
	CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

		this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

	};

	CubicPoly.prototype.calc = function( t ) {

		var t2 = t * t;
		var t3 = t2 * t;
		return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

	};

	// Subclass Three.js curve
	return THREE.Curve.create(

		function ( p /* array of Vector3 */ ) {

			this.points = p || [];

		},

		function ( t ) {

			var points = this.points,
				point, intPoint, weight, l;

			l = points.length;

			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

			point = ( l - 1 ) * t;
			intPoint = Math.floor( point );
			weight = point - intPoint;

			if ( weight === 0 && intPoint === l - 1 ) {

				intPoint = l - 2;
				weight = 1;

			}

			var p0, p1, p2, p3;

			if ( intPoint === 0 ) {

				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;

			} else {

				p0 = points[ intPoint - 1 ];

			}

			p1 = points[ intPoint ];
			p2 = points[ intPoint + 1 ];

			if ( intPoint + 2 < l ) {

				p3 = points[ intPoint + 2 ]

			} else {

				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
				p3 = tmp;

			}

			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

				// init Centripetal / Chordal Catmull-Rom
				var pow = this.type === 'chordal' ? 0.5 : 0.25;
				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

				// safety check for repeated points
				if ( dt1 < 1e-4 ) dt1 = 1.0;
				if ( dt0 < 1e-4 ) dt0 = dt1;
				if ( dt2 < 1e-4 ) dt2 = dt1;

				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

			} else if ( this.type === 'catmullrom' ) {

				var tension = this.tension !== undefined ? this.tension : 0.5;
				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

			}

			var v = new THREE.Vector3(
				px.calc( weight ),
				py.calc( weight ),
				pz.calc( weight )
			);

			return v;

		}

	);

} )();

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */ ) {

		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

		var point0 = points[ ( intPoint - 1 ) % points.length ];
		var point1 = points[ ( intPoint     ) % points.length ];
		var point2 = points[ ( intPoint + 1 ) % points.length ];
		var point3 = points[ ( intPoint + 2 ) % points.length ];

		var interpolate = THREE.CurveUtils.interpolate;

		return new THREE.Vector3(
			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
			interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
			interpolate( point0.z, point1.z, point2.z, point3.z, weight )
		);

	}

);

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	THREE.Geometry.call( this );

	this.type = 'BoxGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;
	this.depthSegments = depthSegments || 1;

	var scope = this;

	var width_half = width / 2;
	var height_half = height / 2;
	var depth_half = depth / 2;

	buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
	buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
	buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
	buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
	buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
	buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

		var w, ix, iy,
		gridX = scope.widthSegments,
		gridY = scope.heightSegments,
		width_half = width / 2,
		height_half = height / 2,
		offset = scope.vertices.length;

		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

			w = 'z';

		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

			w = 'y';
			gridY = scope.depthSegments;

		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

			w = 'x';
			gridX = scope.depthSegments;

		}

		var gridX1 = gridX + 1,
		gridY1 = gridY + 1,
		segment_width = width / gridX,
		segment_height = height / gridY,
		normal = new THREE.Vector3();

		normal[ w ] = depth > 0 ? 1 : - 1;

		for ( iy = 0; iy < gridY1; iy ++ ) {

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var vector = new THREE.Vector3();
				vector[ u ] = ( ix * segment_width - width_half ) * udir;
				vector[ v ] = ( iy * segment_height - height_half ) * vdir;
				vector[ w ] = depth;

				scope.vertices.push( vector );

			}

		}

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

				var face = new THREE.Face3( a + offset, b + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				face = new THREE.Face3( b + offset, c + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

	}

	this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

THREE.BoxGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.BoxGeometry(
		parameters.width,
		parameters.height,
		parameters.depth,
		parameters.widthSegments,
		parameters.heightSegments,
		parameters.depthSegments
	);

};

THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'CircleGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

THREE.CircleGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.CircleGeometry(
		parameters.radius,
		parameters.segments,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/CircleBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.BufferGeometry.call( this );

	this.type = 'CircleBufferGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;
	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	var vertices = segments + 2;

	var positions = new Float32Array( vertices * 3 );
	var normals = new Float32Array( vertices * 3 );
	var uvs = new Float32Array( vertices * 2 );

	// center data is already zero, but need to set a few extras
	normals[ 2 ] = 1.0;
	uvs[ 0 ] = 0.5;
	uvs[ 1 ] = 0.5;

	for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

		var segment = thetaStart + s / segments * thetaLength;

		positions[ i ] = radius * Math.cos( segment );
		positions[ i + 1 ] = radius * Math.sin( segment );

		normals[ i + 2 ] = 1; // normal z

		uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
		uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

	}

	var indices = [];

	for ( var i = 1; i <= segments; i ++ ) {

		indices.push( i, i + 1, 0 );

	}

	this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
	this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

THREE.CircleBufferGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.CircleBufferGeometry(
		parameters.radius,
		parameters.segments,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'CylinderGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radiusTop = radiusTop !== undefined ? radiusTop : 20;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	height = height !== undefined ? height : 100;

	radialSegments = radialSegments || 8;
	heightSegments = heightSegments || 1;

	openEnded = openEnded !== undefined ? openEnded : false;
	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

	var heightHalf = height / 2;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		var v = y / heightSegments;
		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;

			var vertex = new THREE.Vector3();
			vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
			vertex.y = - v * height + heightHalf;
			vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	var tanTheta = ( radiusBottom - radiusTop ) / height;
	var na, nb;

	for ( x = 0; x < radialSegments; x ++ ) {

		if ( radiusTop !== 0 ) {

			na = this.vertices[ vertices[ 0 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

		} else {

			na = this.vertices[ vertices[ 1 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

		}

		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

		for ( y = 0; y < heightSegments; y ++ ) {

			var v1 = vertices[ y ][ x ];
			var v2 = vertices[ y + 1 ][ x ];
			var v3 = vertices[ y + 1 ][ x + 1 ];
			var v4 = vertices[ y ][ x + 1 ];

			var n1 = na.clone();
			var n2 = na.clone();
			var n3 = nb.clone();
			var n4 = nb.clone();

			var uv1 = uvs[ y ][ x ].clone();
			var uv2 = uvs[ y + 1 ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
			var uv4 = uvs[ y ][ x + 1 ].clone();

			this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

			this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

		}

	}

	// top cap

	if ( openEnded === false && radiusTop > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ 0 ][ x ];
			var v2 = vertices[ 0 ][ x + 1 ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, 1, 0 );
			var n2 = new THREE.Vector3( 0, 1, 0 );
			var n3 = new THREE.Vector3( 0, 1, 0 );

			var uv1 = uvs[ 0 ][ x ].clone();
			var uv2 = uvs[ 0 ][ x + 1 ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 0 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	// bottom cap

	if ( openEnded === false && radiusBottom > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ heightSegments ][ x + 1 ];
			var v2 = vertices[ heightSegments ][ x ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, - 1, 0 );
			var n2 = new THREE.Vector3( 0, - 1, 0 );
			var n3 = new THREE.Vector3( 0, - 1, 0 );

			var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
			var uv2 = uvs[ heightSegments ][ x ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 1 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	this.computeFaceNormals();

};

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

THREE.CylinderGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.CylinderGeometry(
		parameters.radiusTop,
		parameters.radiusBottom,
		parameters.height,
		parameters.radialSegments,
		parameters.heightSegments,
		parameters.openEnded,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/EdgesGeometry.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {

	THREE.BufferGeometry.call( this );

	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

	var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

	var edge = [ 0, 0 ], hash = {};

	function sortFunction( a, b ) {

		return a - b;

	}

	var keys = [ 'a', 'b', 'c' ];

	var geometry2;

	if ( geometry instanceof THREE.BufferGeometry ) {

		geometry2 = new THREE.Geometry();
		geometry2.fromBufferGeometry( geometry );

	} else {

		geometry2 = geometry.clone();

	}

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	var coords = [];

	for ( var key in hash ) {

		var h = hash[ key ];

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

			var vertex = vertices[ h.vert1 ];
			coords.push( vertex.x );
			coords.push( vertex.y );
			coords.push( vertex.z );

			vertex = vertices[ h.vert2 ];
			coords.push( vertex.x );
			coords.push( vertex.y );
			coords.push( vertex.z );

		}

	}

	this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

};

THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {

		shapes = [];
		return;

	}

	THREE.Geometry.call( this );

	this.type = 'ExtrudeGeometry';

	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {

		var shape = shapes[ s ];
		this.addShape( shape, options );

	}

};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// Reuse TNB from TubeGeomtry for now.
		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new THREE.Vector3();
		normal = new THREE.Vector3();
		position2 = new THREE.Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initialization

	var ahole, h, hl; // looping of holes
	var scope = this;

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( THREE.ShapeUtils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2 ( pt, vec, size ) {

		if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length;


	// Find directions for point movement


	function getBevelVec( inPt, inPrev, inNext ) {

		// computes for inPt the corresponding point inPt' on a new contour
		//   shifted by 1 unit (length of normalized vector) to the left
		// if we walk along contour clockwise, this new contour is outside the old one
		//
		// inPt' is the intersection of the two lines parallel to the two
		//  adjacent edges of inPt at a distance of 1 unit on the left side.

		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

		// good reading for geometry algorithms (here: line-line intersection)
		// http://geomalgorithms.com/a05-_intersect-1.html

		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

		// check for collinear edges
		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

			// not collinear

			// length of vectors for normalizing

			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

			// shift adjacent points by unit vectors to the left

			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

			// scaling factor for v_prev to intersection point

			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

			// vector from inPt to intersection point

			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

			// Don't normalize!, otherwise sharp corners become ugly
			//  but prevent crazy spikes
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
			if ( v_trans_lensq <= 2 ) {

				return	new THREE.Vector2( v_trans_x, v_trans_y );

			} else {

				shrink_by = Math.sqrt( v_trans_lensq / 2 );

			}

		} else {

			// handle special case of collinear edges

			var direction_eq = false;		// assumes: opposite
			if ( v_prev_x > Number.EPSILON ) {

				if ( v_next_x > Number.EPSILON ) {

					direction_eq = true;

				}

			} else {

				if ( v_prev_x < - Number.EPSILON ) {

					if ( v_next_x < - Number.EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

						direction_eq = true;

					}

				}

			}

			if ( direction_eq ) {

				// console.log("Warning: lines are a straight sequence");
				v_trans_x = - v_prev_y;
				v_trans_y =  v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );

			} else {

				// console.log("Warning: lines are a straight spike");
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );

			}

		}

		return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

	}


	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {

		//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
		//bs = bevelSize * t; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( ! extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI / 2 );

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

			}

		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( -- i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}

		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	}

	function f3( a, b, c ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		scope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );

		var uvs = uvgen.generateTopUV( scope, a, b, c );

		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

		scope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );
		scope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );

		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];

		return [
			new THREE.Vector2( a.x, a.y ),
			new THREE.Vector2( b.x, b.y ),
			new THREE.Vector2( c.x, c.y )
		];

	},

	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];
		var d = vertices[ indexD ];

		if ( Math.abs( a.y - b.y ) < 0.01 ) {

			return [
				new THREE.Vector2( a.x, 1 - a.z ),
				new THREE.Vector2( b.x, 1 - b.z ),
				new THREE.Vector2( c.x, 1 - c.z ),
				new THREE.Vector2( d.x, 1 - d.z )
			];

		} else {

			return [
				new THREE.Vector2( a.y, 1 - a.z ),
				new THREE.Vector2( b.y, 1 - b.z ),
				new THREE.Vector2( c.y, 1 - c.z ),
				new THREE.Vector2( d.y, 1 - d.z )
			];

		}

	}
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

	THREE.Geometry.call( this );

	this.type = 'ShapeGeometry';

	if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

		this.addShape( shapes[ i ], options );

	}

	return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

	if ( options === undefined ) options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

	//

	var i, l, hole;

	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe...

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];

			if ( THREE.ShapeUtils.isClockWise( hole ) ) {

				holes[ i ] = hole.reverse();

			}

		}

		reverse = false;

	}

	var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

	// Vertices

	for ( i = 0, l = holes.length; i < l; i ++ ) {

		hole = holes[ i ];
		vertices = vertices.concat( hole );

	}

	//

	var vert, vlen = vertices.length;
	var face, flen = faces.length;

	for ( i = 0; i < vlen; i ++ ) {

		vert = vertices[ i ];

		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

	}

	for ( i = 0; i < flen; i ++ ) {

		face = faces[ i ];

		var a = face[ 0 ] + shapesOffset;
		var b = face[ 1 ] + shapesOffset;
		var c = face[ 2 ] + shapesOffset;

		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

	}

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 */

// points - to create a closed torus, one must use a set of points 
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

	THREE.Geometry.call( this );

	this.type = 'LatheGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	segments = segments || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || 2 * Math.PI;

	var inversePointLength = 1.0 / ( points.length - 1 );
	var inverseSegments = 1.0 / segments;

	for ( var i = 0, il = segments; i <= il; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var c = Math.cos( phi ),
			s = Math.sin( phi );

		for ( var j = 0, jl = points.length; j < jl; j ++ ) {

			var pt = points[ j ];

			var vertex = new THREE.Vector3();

			vertex.x = c * pt.x - s * pt.y;
			vertex.y = s * pt.x + c * pt.y;
			vertex.z = pt.z;

			this.vertices.push( vertex );

		}

	}

	var np = points.length;

	for ( var i = 0, il = segments; i < il; i ++ ) {

		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

			var base = j + np * i;
			var a = base;
			var b = base + np;
			var c = base + 1 + np;
			var d = base + 1;

			var u0 = i * inverseSegments;
			var v0 = j * inversePointLength;
			var u1 = u0 + inverseSegments;
			var v1 = v0 + inversePointLength;

			this.faces.push( new THREE.Face3( a, b, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u0, v0 ),
				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u0, v1 )

			] );

			this.faces.push( new THREE.Face3( b, c, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u1, v1 ),
				new THREE.Vector2( u0, v1 )

			] );


		}

	}

	this.mergeVertices();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

THREE.PlaneGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.PlaneGeometry(
		parameters.width,
		parameters.height,
		parameters.widthSegments,
		parameters.heightSegments
	);

};

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = Math.floor( widthSegments ) || 1;
	var gridY = Math.floor( heightSegments ) || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var vertices = new Float32Array( gridX1 * gridY1 * 3 );
	var normals = new Float32Array( gridX1 * gridY1 * 3 );
	var uvs = new Float32Array( gridX1 * gridY1 * 2 );

	var offset = 0;
	var offset2 = 0;

	for ( var iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;

		for ( var ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices[ offset ] = x;
			vertices[ offset + 1 ] = - y;

			normals[ offset + 2 ] = 1;

			uvs[ offset2 ] = ix / gridX;
			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

			offset += 3;
			offset2 += 2;

		}

	}

	offset = 0;

	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

	for ( var iy = 0; iy < gridY; iy ++ ) {

		for ( var ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			indices[ offset ] = a;
			indices[ offset + 1 ] = b;
			indices[ offset + 2 ] = d;

			indices[ offset + 3 ] = b;
			indices[ offset + 4 ] = c;
			indices[ offset + 5 ] = d;

			offset += 6;

		}

	}

	this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

THREE.PlaneBufferGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.PlaneBufferGeometry(
		parameters.width,
		parameters.height,
		parameters.widthSegments,
		parameters.heightSegments
	);

};

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'RingGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	innerRadius = innerRadius || 0;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

	var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

	for ( i = 0; i < phiSegments + 1; i ++ ) {

		// concentric circles inside ring

		for ( o = 0; o < thetaSegments + 1; o ++ ) {

			// number of segments per circle

			var vertex = new THREE.Vector3();
			var segment = thetaStart + o / thetaSegments * thetaLength;
			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );

		}

		radius += radiusStep;

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 0; i < phiSegments; i ++ ) {

		// concentric circles inside ring

		var thetaSegment = i * ( thetaSegments + 1 );

		for ( o = 0; o < thetaSegments ; o ++ ) {

			// number of segments per circle

			var segment = o + thetaSegment;

			var v1 = segment;
			var v2 = segment + thetaSegments + 1;
			var v3 = segment + thetaSegments + 2;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

			v1 = segment;
			v2 = segment + thetaSegments + 2;
			v3 = segment + 1;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

		}

	}

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

THREE.RingGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.RingGeometry(
		parameters.innerRadius,
		parameters.outerRadius,
		parameters.thetaSegments,
		parameters.phiSegments,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'SphereGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

THREE.SphereGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.SphereGeometry(
		parameters.radius,
		parameters.widthSegments,
		parameters.heightSegments,
		parameters.phiStart,
		parameters.phiLength,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.BufferGeometry.call( this );

	this.type = 'SphereBufferGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;

	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var thetaEnd = thetaStart + thetaLength;

	var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

	var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	var index = 0, vertices = [], normal = new THREE.Vector3();

	for ( var y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];

		var v = y / heightSegments;

		for ( var x = 0; x <= widthSegments; x ++ ) {

			var u = x / widthSegments;

			var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			var py = radius * Math.cos( thetaStart + v * thetaLength );
			var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			normal.set( px, py, pz ).normalize();

			positions.setXYZ( index, px, py, pz );
			normals.setXYZ( index, normal.x, normal.y, normal.z );
			uvs.setXY( index, u, 1 - v );

			verticesRow.push( index );

			index ++;

		}

		vertices.push( verticesRow );

	}

	var indices = [];

	for ( var y = 0; y < heightSegments; y ++ ) {

		for ( var x = 0; x < widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
			if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

		}

	}

	this.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );
	this.addAttribute( 'position', positions );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

THREE.SphereBufferGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.SphereBufferGeometry(
		parameters.radius,
		parameters.widthSegments,
		parameters.heightSegments,
		parameters.phiStart,
		parameters.phiLength,
		parameters.thetaStart,
		parameters.thetaLength
	);

};

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	THREE.Geometry.call( this );

	this.type = 'TorusGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = radialSegments || 8;
	tubularSegments = tubularSegments || 6;
	arc = arc || Math.PI * 2;

	var center = new THREE.Vector3(), uvs = [], normals = [];

	for ( var j = 0; j <= radialSegments; j ++ ) {

		for ( var i = 0; i <= tubularSegments; i ++ ) {

			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;

			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );

			var vertex = new THREE.Vector3();
			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );

			this.vertices.push( vertex );

			uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
			normals.push( vertex.clone().sub( center ).normalize() );

		}

	}

	for ( var j = 1; j <= radialSegments; j ++ ) {

		for ( var i = 1; i <= tubularSegments; i ++ ) {

			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;

			var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

			face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

		}

	}

	this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

THREE.TorusGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.TorusGeometry(
		parameters.radius,
		parameters.tube,
		parameters.radialSegments,
		parameters.tubularSegments,
		parameters.arc
	);

};

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

	THREE.Geometry.call( this );

	this.type = 'TorusKnotGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		p: p,
		q: q,
		heightScale: heightScale
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = radialSegments || 64;
	tubularSegments = tubularSegments || 8;
	p = p || 2;
	q = q || 3;
	heightScale = heightScale || 1;

	var grid = new Array( radialSegments );
	var tang = new THREE.Vector3();
	var n = new THREE.Vector3();
	var bitan = new THREE.Vector3();

	for ( var i = 0; i < radialSegments; ++ i ) {

		grid[ i ] = new Array( tubularSegments );
		var u = i / radialSegments * 2 * p * Math.PI;
		var p1 = getPos( u, q, p, radius, heightScale );
		var p2 = getPos( u + 0.01, q, p, radius, heightScale );
		tang.subVectors( p2, p1 );
		n.addVectors( p2, p1 );

		bitan.crossVectors( tang, n );
		n.crossVectors( bitan, tang );
		bitan.normalize();
		n.normalize();

		for ( var j = 0; j < tubularSegments; ++ j ) {

			var v = j / tubularSegments * 2 * Math.PI;
			var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			var cy = tube * Math.sin( v );

			var pos = new THREE.Vector3();
			pos.x = p1.x + cx * n.x + cy * bitan.x;
			pos.y = p1.y + cx * n.y + cy * bitan.y;
			pos.z = p1.z + cx * n.z + cy * bitan.z;

			grid[ i ][ j ] = this.vertices.push( pos ) - 1;

		}

	}

	for ( var i = 0; i < radialSegments; ++ i ) {

		for ( var j = 0; j < tubularSegments; ++ j ) {

			var ip = ( i + 1 ) % radialSegments;
			var jp = ( j + 1 ) % tubularSegments;

			var a = grid[ i ][ j ];
			var b = grid[ ip ][ j ];
			var c = grid[ ip ][ jp ];
			var d = grid[ i ][ jp ];

			var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
			var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
			var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
			var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	this.computeFaceNormals();
	this.computeVertexNormals();

	function getPos( u, in_q, in_p, radius, heightScale ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = in_q / in_p * u;
		var cs = Math.cos( quOverP );

		var tx = radius * ( 2 + cs ) * 0.5 * cu;
		var ty = radius * ( 2 + cs ) * su * 0.5;
		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

		return new THREE.Vector3( tx, ty, tz );

	}

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

THREE.TorusKnotGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.TorusKnotGeometry(
		parameters.radius,
		parameters.tube,
		parameters.radialSegments,
		parameters.tubularSegments,
		parameters.p,
		parameters.q,
		parameters.heightScale
	);

};

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

	THREE.Geometry.call( this );

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		segments: segments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed,
		taper: taper
	};

	segments = segments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;
	taper = taper || THREE.TubeGeometry.NoTaper;

	var grid = [];

	var scope = this,

		tangent,
		normal,
		binormal,

		numpoints = segments + 1,

		u, v, r,

		cx, cy,
		pos, pos2 = new THREE.Vector3(),
		i, j,
		ip, jp,
		a, b, c, d,
		uva, uvb, uvc, uvd;

	var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
		tangents = frames.tangents,
		normals = frames.normals,
		binormals = frames.binormals;

	// proxy internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

	}

	// construct the grid

	for ( i = 0; i < numpoints; i ++ ) {

		grid[ i ] = [];

		u = i / ( numpoints - 1 );

		pos = path.getPointAt( u );

		tangent = tangents[ i ];
		normal = normals[ i ];
		binormal = binormals[ i ];

		r = radius * taper( u );

		for ( j = 0; j < radialSegments; j ++ ) {

			v = j / radialSegments * 2 * Math.PI;

			cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = r * Math.sin( v );

			pos2.copy( pos );
			pos2.x += cx * normal.x + cy * binormal.x;
			pos2.y += cx * normal.y + cy * binormal.y;
			pos2.z += cx * normal.z + cy * binormal.z;

			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

		}

	}


	// construct the mesh

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < radialSegments; j ++ ) {

			ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
			jp = ( j + 1 ) % radialSegments;

			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
			b = grid[ ip ][ j ];
			c = grid[ ip ][ jp ];
			d = grid[ i ][ jp ];

			uva = new THREE.Vector2( i / segments, j / radialSegments );
			uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
			uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
			uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
THREE.TubeGeometry.prototype.clone = function() {

	return new this.constructor( this.parameters.path,
		this.parameters.segments, this.parameters.radius, this.parameters.radialSegments,
		this.parameters.closed, this.parameters.taper
	);

};

THREE.TubeGeometry.NoTaper = function ( u ) {

	return 1;

};

THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

	return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

	var	normal = new THREE.Vector3(),

		tangents = [],
		normals = [],
		binormals = [],

		vec = new THREE.Vector3(),
		mat = new THREE.Matrix4(),

		numpoints = segments + 1,
		theta,
		smallest,

		tx, ty, tz,
		i, u;


	// expose internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	// compute the tangent vectors for each segment on the path

	for ( i = 0; i < numpoints; i ++ ) {

		u = i / ( numpoints - 1 );

		tangents[ i ] = path.getTangentAt( u );
		tangents[ i ].normalize();

	}

	initialNormal3();

	/*
	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}
	*/

	function initialNormal3() {

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the smallest tangent xyz component

		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		smallest = Number.MAX_VALUE;
		tx = Math.abs( tangents[ 0 ].x );
		ty = Math.abs( tangents[ 0 ].y );
		tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= smallest ) {

			smallest = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= smallest ) {

			smallest = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= smallest ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

	}


	// compute the slowly-varying normal and binormal vectors for each segment on the path

	for ( i = 1; i < numpoints; i ++ ) {

		normals[ i ] = normals[ i - 1 ].clone();

		binormals[ i ] = binormals[ i - 1 ].clone();

		vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

		if ( vec.length() > Number.EPSILON ) {

			vec.normalize();

			theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}


	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed ) {

		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
		theta /= ( numpoints - 1 );

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

			theta = - theta;

		}

		for ( i = 1; i < numpoints; i ++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}

};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

	THREE.Geometry.call( this );

	this.type = 'PolyhedronGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	radius = radius || 1;
	detail = detail || 0;

	var that = this;

	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

		prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

	}

	var p = this.vertices;

	var faces = [];

	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

		var v1 = p[ indices[ i ] ];
		var v2 = p[ indices[ i + 1 ] ];
		var v3 = p[ indices[ i + 2 ] ];

		faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );

	}

	var centroid = new THREE.Vector3();

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		subdivide( faces[ i ], detail );

	}


	// Handle case when face straddles the seam

	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

		var uvs = this.faceVertexUvs[ 0 ][ i ];

		var x0 = uvs[ 0 ].x;
		var x1 = uvs[ 1 ].x;
		var x2 = uvs[ 2 ].x;

		var max = Math.max( x0, x1, x2 );
		var min = Math.min( x0, x1, x2 );

		if ( max > 0.9 && min < 0.1 ) {

			// 0.9 is somewhat arbitrary

			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

		}

	}


	// Apply radius

	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

		this.vertices[ i ].multiplyScalar( radius );

	}


	// Merge vertices

	this.mergeVertices();

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


	// Project vector onto sphere's surface

	function prepare( vector ) {

		var vertex = vector.normalize().clone();
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new THREE.Vector2( u, 1 - v );

		return vertex;

	}


	// Approximate a curved face with recursively sub-divided triangles.

	function make( v1, v2, v3, materialIndex ) {

		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
		that.faces.push( face );

		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

		var azi = azimuth( centroid );

		that.faceVertexUvs[ 0 ].push( [
			correctUV( v1.uv, v1, azi ),
			correctUV( v2.uv, v2, azi ),
			correctUV( v3.uv, v3, azi )
		] );

	}


	// Analytically subdivide a face to the required detail level.

	function subdivide( face, detail ) {

		var cols = Math.pow( 2, detail );
		var a = prepare( that.vertices[ face.a ] );
		var b = prepare( that.vertices[ face.b ] );
		var c = prepare( that.vertices[ face.c ] );
		var v = [];

		var materialIndex = face.materialIndex;

		// Construct all of the vertices for this subdivision.

		for ( var i = 0 ; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = prepare( a.clone().lerp( c, i / cols ) );
			var bj = prepare( b.clone().lerp( c, i / cols ) );
			var rows = cols - i;

			for ( var j = 0; j <= rows; j ++ ) {

				if ( j === 0 && i === cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

				}

			}

		}

		// Construct all of the faces.

		for ( var i = 0; i < cols ; i ++ ) {

			for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 === 0 ) {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1 ][ k ],
						v[ i ][ k ],
						materialIndex
					);

				} else {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1 ][ k + 1 ],
						v[ i + 1 ][ k ],
						materialIndex
					);

				}

			}

		}

	}


	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, - vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}


	// Texture fixing helper. Spheres have some odd behaviours.

	function correctUV( uv, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
		return uv.clone();

	}


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

THREE.PolyhedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.PolyhedronGeometry(
		parameters.vertices,
		parameters.indices,
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;

	var vertices = [

		// (±1, ±1, ±1)
		- 1, - 1, - 1,    - 1, - 1,  1,
		- 1,  1, - 1,    - 1,  1,  1,
		 1, - 1, - 1,     1, - 1,  1,
		 1,  1, - 1,     1,  1,  1,

		// (0, ±1/φ, ±φ)
		 0, - r, - t,     0, - r,  t,
		 0,  r, - t,     0,  r,  t,

		// (±1/φ, ±φ, 0)
		- r, - t,  0,    - r,  t,  0,
		 r, - t,  0,     r,  t,  0,

		// (±φ, 0, ±1/φ)
		- t,  0, - r,     t,  0, - r,
		- t,  0,  r,     t,  0,  r
	];

	var indices = [
		 3, 11,  7,      3,  7, 15,      3, 15, 13,
		 7, 19, 17,      7, 17,  6,      7,  6, 15,
		17,  4,  8,     17,  8, 10,     17, 10,  6,
		 8,  0, 16,      8, 16,  2,      8,  2, 10,
		 0, 12,  1,      0,  1, 18,      0, 18, 16,
		 6, 10,  2,      6,  2, 13,      6, 13, 15,
		 2, 16, 18,      2, 18,  3,      2,  3, 13,
		18,  1,  9,     18,  9, 11,     18, 11,  3,
		 4, 14, 12,      4, 12,  0,      4,  0,  8,
		11,  9,  5,     11,  5, 19,     11, 19,  7,
		19,  5, 14,     19, 14,  4,     19,  4, 17,
		 1, 12, 14,      1, 14,  5,      1,  5,  9
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'DodecahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

THREE.DodecahedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.DodecahedronGeometry(
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
	];

	var indices = [
		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'IcosahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

THREE.IcosahedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.IcosahedronGeometry(
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

	var vertices = [
		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
	];

	var indices = [
		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'OctahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

THREE.OctahedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.OctahedronGeometry(
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

	var vertices = [
		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
	];

	var indices = [
		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'TetrahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

THREE.TetrahedronGeometry.prototype.clone = function () {

	var parameters = this.parameters;

	return new THREE.TetrahedronGeometry(
		parameters.radius,
		parameters.detail
	);

};

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

	THREE.Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	var verts = this.vertices;
	var faces = this.faces;
	var uvs = this.faceVertexUvs[ 0 ];

	var i, j, p;
	var u, v;

	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			verts.push( p );

		}

	}

	var a, b, c, d;
	var uva, uvb, uvc, uvd;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = ( i + 1 ) * sliceCount + j + 1;
			d = ( i + 1 ) * sliceCount + j;

			uva = new THREE.Vector2( j / slices, i / stacks );
			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

			faces.push( new THREE.Face3( a, b, d ) );
			uvs.push( [ uva, uvb, uvd ] );

			faces.push( new THREE.Face3( b, c, d ) );
			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	// console.log(this);

	// magic bullet
	// var diff = this.mergeVertices();
	// console.log('removed ', diff, ' vertices by merging');

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

// File:src/extras/geometries/WireframeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeGeometry = function ( geometry ) {

	THREE.BufferGeometry.call( this );

	var edge = [ 0, 0 ], hash = {};

	function sortFunction( a, b ) {

		return a - b;

	}

	var keys = [ 'a', 'b', 'c' ];

	if ( geometry instanceof THREE.Geometry ) {

		var vertices = geometry.vertices;
		var faces = geometry.faces;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 6 * faces.length );

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					edges[ 2 * numEdges ] = edge[ 0 ];
					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
					hash[ key ] = true;
					numEdges ++;

				}

			}

		}

		var coords = new Float32Array( numEdges * 2 * 3 );

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var vertex = vertices[ edges [ 2 * i + j ] ];

				var index = 6 * i + 3 * j;
				coords[ index + 0 ] = vertex.x;
				coords[ index + 1 ] = vertex.y;
				coords[ index + 2 ] = vertex.z;

			}

		}

		this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

	} else if ( geometry instanceof THREE.BufferGeometry ) {

		if ( geometry.index !== null ) {

			// Indexed BufferGeometry

			var indices = geometry.index.array;
			var vertices = geometry.attributes.position;
			var drawcalls = geometry.drawcalls;
			var numEdges = 0;

			if ( drawcalls.length === 0 ) {

				geometry.addGroup( 0, indices.length );

			}

			// allocate maximal size
			var edges = new Uint32Array( 2 * indices.length );

			for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

				var drawcall = drawcalls[ o ];

				var start = drawcall.start;
				var count = drawcall.count;

				for ( var i = start, il = start + count; i < il; i += 3 ) {

					for ( var j = 0; j < 3; j ++ ) {

						edge[ 0 ] = indices[ i + j ];
						edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
						edge.sort( sortFunction );

						var key = edge.toString();

						if ( hash[ key ] === undefined ) {

							edges[ 2 * numEdges ] = edge[ 0 ];
							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
							hash[ key ] = true;
							numEdges ++;

						}

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var index = 6 * i + 3 * j;
					var index2 = edges[ 2 * i + j ];

					coords[ index + 0 ] = vertices.getX( index2 );
					coords[ index + 1 ] = vertices.getY( index2 );
					coords[ index + 2 ] = vertices.getZ( index2 );

				}

			}

			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		} else {

			// non-indexed BufferGeometry

			var vertices = geometry.attributes.position.array;
			var numEdges = vertices.length / 3;
			var numTris = numEdges / 3;

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numTris; i < l; i ++ ) {

				for ( var j = 0; j < 3; j ++ ) {

					var index = 18 * i + 6 * j;

					var index1 = 9 * i + 3 * j;
					coords[ index + 0 ] = vertices[ index1 ];
					coords[ index + 1 ] = vertices[ index1 + 1 ];
					coords[ index + 2 ] = vertices[ index1 + 2 ];

					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
					coords[ index + 3 ] = vertices[ index2 ];
					coords[ index + 4 ] = vertices[ index2 + 1 ];
					coords[ index + 5 ] = vertices[ index2 + 2 ];

				}

			}

			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		}

	}

};

THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

	size = size || 1;

	var vertices = new Float32Array( [
		0, 0, 0,  size, 0, 0,
		0, 0, 0,  0, size, 0,
		0, 0, 0,  0, 0, size
	] );

	var colors = new Float32Array( [
		1, 0, 0,  1, 0.6, 0,
		0, 1, 0,  0.6, 1, 0,
		0, 0, 1,  0, 0.6, 1
	] );

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	THREE.LineSegments.call( this, geometry, material );

};

THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

	var lineGeometry = new THREE.Geometry();
	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

	var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
	coneGeometry.translate( 0, - 0.5, 0 );

	return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		THREE.Object3D.call( this );

		if ( color === undefined ) color = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.position.copy( origin );
		
		if ( headLength < length ) {
			this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );
		}

		this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = ( function () {

	var axis = new THREE.Vector3();
	var radians;

	return function setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	if ( headLength < length ){
		this.line.scale.set( 1, length - headLength, 1 );
		this.line.updateMatrix();
	}

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

	if ( this.line !== undefined ) this.line.material.color.set( color );
	this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
	var positions = new Float32Array( 8 * 3 );

	var geometry = new THREE.BufferGeometry();
	geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );

	if ( object !== undefined ) {

		this.update( object );

	}

};

THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = ( function () {

	var box = new THREE.Box3();

	return function ( object ) {

		box.setFromObject( object );

		if ( box.empty() ) return;

		var min = box.min;
		var max = box.max;

		/*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		var position = this.geometry.attributes.position;
		var array = position.array;

		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

	}

} )();

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0x888888;

	this.object = object;

	this.box = new THREE.Box3();

	THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function () {

	this.box.setFromObject( this.object );

	this.box.size( this.scale );

	this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

	var pointMap = {};

	// colors

	var hexFrustum = 0xffaa00;
	var hexCone = 0xff0000;
	var hexUp = 0x00aaff;
	var hexTarget = 0xffffff;
	var hexCross = 0x333333;

	// near

	addLine( "n1", "n2", hexFrustum );
	addLine( "n2", "n4", hexFrustum );
	addLine( "n4", "n3", hexFrustum );
	addLine( "n3", "n1", hexFrustum );

	// far

	addLine( "f1", "f2", hexFrustum );
	addLine( "f2", "f4", hexFrustum );
	addLine( "f4", "f3", hexFrustum );
	addLine( "f3", "f1", hexFrustum );

	// sides

	addLine( "n1", "f1", hexFrustum );
	addLine( "n2", "f2", hexFrustum );
	addLine( "n3", "f3", hexFrustum );
	addLine( "n4", "f4", hexFrustum );

	// cone

	addLine( "p", "n1", hexCone );
	addLine( "p", "n2", hexCone );
	addLine( "p", "n3", hexCone );
	addLine( "p", "n4", hexCone );

	// up

	addLine( "u1", "u2", hexUp );
	addLine( "u2", "u3", hexUp );
	addLine( "u3", "u1", hexUp );

	// target

	addLine( "c", "t", hexTarget );
	addLine( "p", "c", hexCross );

	// cross

	addLine( "cn1", "cn2", hexCross );
	addLine( "cn3", "cn4", hexCross );

	addLine( "cf1", "cf2", hexCross );
	addLine( "cf3", "cf4", hexCross );

	function addLine( a, b, hex ) {

		addPoint( a, hex );
		addPoint( b, hex );

	}

	function addPoint( id, hex ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.colors.push( new THREE.Color( hex ) );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( geometry.vertices.length - 1 );

	}

	THREE.LineSegments.call( this, geometry, material );

	this.camera = camera;
	this.camera.updateProjectionMatrix();

	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.update = function () {

	var geometry, pointMap;

	var vector = new THREE.Vector3();
	var camera = new THREE.Camera();

	function setPoint( point, x, y, z ) {

		vector.set( x, y, z ).unproject( camera );

		var points = pointMap[ point ];

		if ( points !== undefined ) {

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				geometry.vertices[ points[ i ] ].copy( vector );

			}

		}

	}

	return function () {

		geometry = this.geometry;
		pointMap = this.pointMap;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, - 1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", - w, - h, - 1 );
		setPoint( "n2",   w, - h, - 1 );
		setPoint( "n3", - w,   h, - 1 );
		setPoint( "n4",   w,   h, - 1 );

		// far

		setPoint( "f1", - w, - h, 1 );
		setPoint( "f2",   w, - h, 1 );
		setPoint( "f3", - w,   h, 1 );
		setPoint( "f4",   w,   h, 1 );

		// up

		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
		setPoint( "u3",         0, h * 2,   - 1 );

		// cross

		setPoint( "cf1", - w,   0, 1 );
		setPoint( "cf2",   w,   0, 1 );
		setPoint( "cf3",   0, - h, 1 );
		setPoint( "cf4",   0,   h, 1 );

		setPoint( "cn1", - w,   0, - 1 );
		setPoint( "cn2",   w,   0, - 1 );
		setPoint( "cn3",   0, - h, - 1 );
		setPoint( "cn4",   0,   h, - 1 );

		geometry.verticesNeedUpdate = true;

	};

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	size = size || 1;

	var geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3( - size,   size, 0 ),
		new THREE.Vector3(   size,   size, 0 ),
		new THREE.Vector3(   size, - size, 0 ),
		new THREE.Vector3( - size, - size, 0 ),
		new THREE.Vector3( - size,   size, 0 )
	);

	var material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.lightPlane = new THREE.Line( geometry, material );
	this.add( this.lightPlane );

	geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3(),
		new THREE.Vector3()
	);

	material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.targetLine = new THREE.Line( geometry, material );
	this.add( this.targetLine );

	this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function () {

	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();

};

THREE.DirectionalLightHelper.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var v3 = new THREE.Vector3();

	return function () {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		this.lightPlane.lookAt( v3 );
		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine.geometry.vertices[ 1 ].copy( v3 );
		this.targetLine.geometry.verticesNeedUpdate = true;
		this.targetLine.material.color.copy( this.lightPlane.material.color );

	};

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @param object THREE.Mesh whose geometry will be used
 * @param hex line color
 * @param thresholdAngle the minimum angle (in degrees),
 * between the face normals of adjacent faces,
 * that is required to render an edge. A value of 10 means
 * an edge is only rendered if the angle is at least 10 degrees.
 */

THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

	// FaceNormalsHelper only supports THREE.Geometry

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry instanceof THREE.Geometry ) {

		nNormals = objGeometry.faces.length;

	} else {

		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

	}

	//

	var geometry = new THREE.BufferGeometry();

	var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;
	this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = ( function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var normalMatrix = new THREE.Matrix3();

	return function update() {

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		var vertices = objGeometry.vertices;

		var faces = objGeometry.faces;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			var normal = face.normal;

			v1.copy( vertices[ face.a ] )
				.add( vertices[ face.b ] )
				.add( vertices[ face.c ] )
				.divideScalar( 3 )
				.applyMatrix4( matrixWorld );

			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

			position.setXYZ( idx, v1.x, v1.y, v1.z );

			idx = idx + 1;

			position.setXYZ( idx, v2.x, v2.y, v2.z );

			idx = idx + 1;

		}

		position.needsUpdate = true;

		return this;

	}

}() );

// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	this.color1 = new THREE.Color( 0x444444 );
	this.color2 = new THREE.Color( 0x888888 );

	for ( var i = - size; i <= size; i += step ) {

		geometry.vertices.push(
			new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
			new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
		);

		var color = i === 0 ? this.color1 : this.color2;

		geometry.colors.push( color, color, color, color );

	}

	THREE.LineSegments.call( this, geometry, material );

};

THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

	this.color1.set( colorCenterLine );
	this.color2.set( colorGrid );

	this.geometry.colorsNeedUpdate = true;

};

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.colors = [ new THREE.Color(), new THREE.Color() ];

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	geometry.rotateX( - Math.PI / 2 );

	for ( var i = 0, il = 8; i < il; i ++ ) {

		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

	}

	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

	this.lightSphere = new THREE.Mesh( geometry, material );
	this.add( this.lightSphere );

	this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function () {

	this.lightSphere.geometry.dispose();
	this.lightSphere.material.dispose();

};

THREE.HemisphereLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();

	return function () {

		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
		this.lightSphere.geometry.colorsNeedUpdate = true;

	}

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	THREE.Mesh.call( this, geometry, material );

	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();

};

THREE.PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

	this.bones = this.getBoneList( object );

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
			geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

		}

	}

	geometry.dynamic = true;

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

	THREE.LineSegments.call( this, geometry, material );

	this.root = object;

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

	this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

	var boneList = [];

	if ( object instanceof THREE.Bone ) {

		boneList.push( object );

	}

	for ( var i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

	}

	return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

	var geometry = this.geometry;

	var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

	var boneMatrix = new THREE.Matrix4();

	var j = 0;

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

			j += 2;

		}

	}

	geometry.verticesNeedUpdate = true;

	geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

	geometry.translate( 0, - 0.5, 0 );
	geometry.rotateX( - Math.PI / 2 );

	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

	this.cone = new THREE.Mesh( geometry, material );
	this.add( this.cone );

	this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function () {

	this.cone.geometry.dispose();
	this.cone.material.dispose();

};

THREE.SpotLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var vector2 = new THREE.Vector3();

	return function () {

		var coneLength = this.light.distance ? this.light.distance : 10000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry instanceof THREE.Geometry ) {

		nNormals = objGeometry.faces.length * 3;

	} else if ( objGeometry instanceof THREE.BufferGeometry ) {

		nNormals = objGeometry.attributes.normal.count

	}

	//

	var geometry = new THREE.BufferGeometry();

	var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;

	this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = ( function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var normalMatrix = new THREE.Matrix3();

	return function update() {

		var keys = [ 'a', 'b', 'c' ];

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		if ( objGeometry instanceof THREE.Geometry ) {

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					var vertex = vertices[ face[ keys[ j ] ] ];

					var normal = face.vertexNormals[ j ];

					v1.copy( vertex ).applyMatrix4( matrixWorld );

					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

		} else if ( objGeometry instanceof THREE.BufferGeometry ) {

			var objPos = objGeometry.attributes.position;

			var objNorm = objGeometry.attributes.normal;

			var idx = 0;

			// for simplicity, ignore index and drawcalls, and render every normal

			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

		}

		position.needsUpdate = true;

		return this;

	}

}() );

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function ( material ) {

	THREE.Object3D.call( this );

	this.material = material;
	this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		start: start,
		end: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)_?(\d+)/;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = - 1;
		animation.directionBackwards = true;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = - 1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

	}

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= - 1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		if ( animation.currentFrame !== animation.lastFrame ) {

			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

		} else {

			this.morphTargetInfluences[ animation.currentFrame ] = weight;

		}

	}

};


var Module;if(!Module)Module=(typeof Module!=="undefined"?Module:null)||{};var moduleOverrides={};for(var key in Module)if(Module.hasOwnProperty(key))moduleOverrides[key]=Module[key];var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof require==="function";var ENVIRONMENT_IS_WEB=typeof window==="object";var ENVIRONMENT_IS_WORKER=typeof importScripts==="function";var ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;
if(ENVIRONMENT_IS_NODE){if(!Module["print"])Module["print"]=function print(x){process["stdout"].write(x+"\n")};if(!Module["printErr"])Module["printErr"]=function printErr(x){process["stderr"].write(x+"\n")};var nodeFS=require("fs");var nodePath=require("path");Module["read"]=function read(filename,binary){filename=nodePath["normalize"](filename);var ret=nodeFS["readFileSync"](filename);if(!ret&&filename!=nodePath["resolve"](filename)){filename=path.join(__dirname,"..","src",filename);ret=nodeFS["readFileSync"](filename)}if(ret&&
!binary)ret=ret.toString();return ret};Module["readBinary"]=function readBinary(filename){return Module["read"](filename,true)};Module["load"]=function load(f){globalEval(read(f))};Module["arguments"]=process["argv"].slice(2);module["exports"]=Module}else if(ENVIRONMENT_IS_SHELL){if(!Module["print"])Module["print"]=print;if(typeof printErr!="undefined")Module["printErr"]=printErr;if(typeof read!="undefined")Module["read"]=read;else Module["read"]=function read(){throw"no read() available (jsc?)";
};Module["readBinary"]=function readBinary(f){return read(f,"binary")};if(typeof scriptArgs!="undefined")Module["arguments"]=scriptArgs;else if(typeof arguments!="undefined")Module["arguments"]=arguments;this["Module"]=Module}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){Module["read"]=function read(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(typeof arguments!="undefined")Module["arguments"]=arguments;if(typeof console!=="undefined"){if(!Module["print"])Module["print"]=
function print(x){console.log(x)};if(!Module["printErr"])Module["printErr"]=function printErr(x){console.log(x)}}else{var TRY_USE_DUMP=false;if(!Module["print"])Module["print"]=TRY_USE_DUMP&&typeof dump!=="undefined"?function(x){dump(x)}:function(x){}}if(ENVIRONMENT_IS_WEB)window["Module"]=Module;else Module["load"]=importScripts}else throw"Unknown runtime environment. Where are we?";function globalEval(x){eval.call(null,x)}if(!Module["load"]=="undefined"&&Module["read"])Module["load"]=function load(f){globalEval(Module["read"](f))};
if(!Module["print"])Module["print"]=function(){};if(!Module["printErr"])Module["printErr"]=Module["print"];if(!Module["arguments"])Module["arguments"]=[];Module.print=Module["print"];Module.printErr=Module["printErr"];Module["preRun"]=[];Module["postRun"]=[];for(var key in moduleOverrides)if(moduleOverrides.hasOwnProperty(key))Module[key]=moduleOverrides[key];
var Runtime={setTempRet0:function(value){tempRet0=value},getTempRet0:function(){return tempRet0},stackSave:function(){return STACKTOP},stackRestore:function(stackTop){STACKTOP=stackTop},forceAlign:function(target,quantum){quantum=quantum||4;if(quantum==1)return target;if(isNumber(target)&&isNumber(quantum))return Math.ceil(target/quantum)*quantum;else if(isNumber(quantum)&&isPowerOfTwo(quantum))return"((("+target+")+"+(quantum-1)+")&"+-quantum+")";return"Math.ceil(("+target+")/"+quantum+")*"+quantum},
isNumberType:function(type){return type in Runtime.INT_TYPES||type in Runtime.FLOAT_TYPES},isPointerType:function isPointerType(type){return type[type.length-1]=="*"},isStructType:function isStructType(type){if(isPointerType(type))return false;if(isArrayType(type))return true;if(/<?\{ ?[^}]* ?\}>?/.test(type))return true;return type[0]=="%"},INT_TYPES:{"i1":0,"i8":0,"i16":0,"i32":0,"i64":0},FLOAT_TYPES:{"float":0,"double":0},or64:function(x,y){var l=x|0|(y|0);var h=(Math.round(x/4294967296)|Math.round(y/
4294967296))*4294967296;return l+h},and64:function(x,y){var l=(x|0)&(y|0);var h=(Math.round(x/4294967296)&Math.round(y/4294967296))*4294967296;return l+h},xor64:function(x,y){var l=(x|0)^(y|0);var h=(Math.round(x/4294967296)^Math.round(y/4294967296))*4294967296;return l+h},getNativeTypeSize:function(type){switch(type){case "i1":case "i8":return 1;case "i16":return 2;case "i32":return 4;case "i64":return 8;case "float":return 4;case "double":return 8;default:if(type[type.length-1]==="*")return Runtime.QUANTUM_SIZE;
else if(type[0]==="i"){var bits=parseInt(type.substr(1));assert(bits%8===0);return bits/8}else return 0}},getNativeFieldSize:function(type){return Math.max(Runtime.getNativeTypeSize(type),Runtime.QUANTUM_SIZE)},dedup:function dedup(items,ident){var seen={};if(ident)return items.filter(function(item){if(seen[item[ident]])return false;seen[item[ident]]=true;return true});else return items.filter(function(item){if(seen[item])return false;seen[item]=true;return true})},set:function set(){var args=typeof arguments[0]===
"object"?arguments[0]:arguments;var ret={};for(var i=0;i<args.length;i++)ret[args[i]]=0;return ret},STACK_ALIGN:8,getAlignSize:function(type,size,vararg){if(!vararg&&(type=="i64"||type=="double"))return 8;if(!type)return Math.min(size,8);return Math.min(size||(type?Runtime.getNativeFieldSize(type):0),Runtime.QUANTUM_SIZE)},calculateStructAlignment:function calculateStructAlignment(type){type.flatSize=0;type.alignSize=0;var diffs=[];var prev=-1;var index=0;type.flatIndexes=type.fields.map(function(field){index++;
var size,alignSize;if(Runtime.isNumberType(field)||Runtime.isPointerType(field)){size=Runtime.getNativeTypeSize(field);alignSize=Runtime.getAlignSize(field,size)}else if(Runtime.isStructType(field))if(field[1]==="0"){size=0;if(Types.types[field])alignSize=Runtime.getAlignSize(null,Types.types[field].alignSize);else alignSize=type.alignSize||QUANTUM_SIZE}else{size=Types.types[field].flatSize;alignSize=Runtime.getAlignSize(null,Types.types[field].alignSize)}else if(field[0]=="b"){size=field.substr(1)|
0;alignSize=1}else if(field[0]==="<")size=alignSize=Types.types[field].flatSize;else if(field[0]==="i"){size=alignSize=parseInt(field.substr(1))/8;assert(size%1===0,"cannot handle non-byte-size field "+field)}else assert(false,"invalid type for calculateStructAlignment");if(type.packed)alignSize=1;type.alignSize=Math.max(type.alignSize,alignSize);var curr=Runtime.alignMemory(type.flatSize,alignSize);type.flatSize=curr+size;if(prev>=0)diffs.push(curr-prev);prev=curr;return curr});if(type.name_&&type.name_[0]===
"[")type.flatSize=parseInt(type.name_.substr(1))*type.flatSize/2;type.flatSize=Runtime.alignMemory(type.flatSize,type.alignSize);if(diffs.length==0)type.flatFactor=type.flatSize;else if(Runtime.dedup(diffs).length==1)type.flatFactor=diffs[0];type.needsFlattening=type.flatFactor!=1;return type.flatIndexes},generateStructInfo:function(struct,typeName,offset){var type,alignment;if(typeName){offset=offset||0;type=(typeof Types==="undefined"?Runtime.typeInfo:Types.types)[typeName];if(!type)return null;
if(type.fields.length!=struct.length){printErr("Number of named fields must match the type for "+typeName+": possibly duplicate struct names. Cannot return structInfo");return null}alignment=type.flatIndexes}else{var type={fields:struct.map(function(item){return item[0]})};alignment=Runtime.calculateStructAlignment(type)}var ret={__size__:type.flatSize};if(typeName)struct.forEach(function(item,i){if(typeof item==="string")ret[item]=alignment[i]+offset;else{var key;for(var k in item)key=k;ret[key]=
Runtime.generateStructInfo(item[key],type.fields[i],alignment[i])}});else struct.forEach(function(item,i){ret[item[1]]=alignment[i]});return ret},dynCall:function(sig,ptr,args){if(args&&args.length){if(!args.splice)args=Array.prototype.slice.call(args);args.splice(0,0,ptr);return Module["dynCall_"+sig].apply(null,args)}else return Module["dynCall_"+sig].call(null,ptr)},functionPointers:[],addFunction:function(func){for(var i=0;i<Runtime.functionPointers.length;i++)if(!Runtime.functionPointers[i]){Runtime.functionPointers[i]=
func;return 2*(1+i)}throw"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.";},removeFunction:function(index){Runtime.functionPointers[(index-2)/2]=null},getAsmConst:function(code,numArgs){if(!Runtime.asmConstCache)Runtime.asmConstCache={};var func=Runtime.asmConstCache[code];if(func)return func;var args=[];for(var i=0;i<numArgs;i++)args.push(String.fromCharCode(36)+i);var source=Pointer_stringify(code);if(source[0]==='"')if(source.indexOf('"',1)===source.length-
1)source=source.substr(1,source.length-2);else abort("invalid EM_ASM input |"+source+"|. Please use EM_ASM(..code..) (no quotes) or EM_ASM({ ..code($0).. }, input) (to input values)");try{var evalled=eval("(function("+args.join(",")+"){ "+source+" })")}catch(e){Module.printErr("error in executing inline EM_ASM code: "+e+" on: \n\n"+source+"\n\nwith args |"+args+"| (make sure to use the right one out of EM_ASM, EM_ASM_ARGS, etc.)");throw e;}return Runtime.asmConstCache[code]=evalled},warnOnce:function(text){if(!Runtime.warnOnce.shown)Runtime.warnOnce.shown=
{};if(!Runtime.warnOnce.shown[text]){Runtime.warnOnce.shown[text]=1;Module.printErr(text)}},funcWrappers:{},getFuncWrapper:function(func,sig){assert(sig);if(!Runtime.funcWrappers[func])Runtime.funcWrappers[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func,arguments)};return Runtime.funcWrappers[func]},UTF8Processor:function(){var buffer=[];var needed=0;this.processCChar=function(code){code=code&255;if(buffer.length==0){if((code&128)==0)return String.fromCharCode(code);buffer.push(code);
if((code&224)==192)needed=1;else if((code&240)==224)needed=2;else needed=3;return""}if(needed){buffer.push(code);needed--;if(needed>0)return""}var c1=buffer[0];var c2=buffer[1];var c3=buffer[2];var c4=buffer[3];var ret;if(buffer.length==2)ret=String.fromCharCode((c1&31)<<6|c2&63);else if(buffer.length==3)ret=String.fromCharCode((c1&15)<<12|(c2&63)<<6|c3&63);else{var codePoint=(c1&7)<<18|(c2&63)<<12|(c3&63)<<6|c4&63;ret=String.fromCharCode(Math.floor((codePoint-65536)/1024)+55296,(codePoint-65536)%
1024+56320)}buffer.length=0;return ret};this.processJSString=function processJSString(string){string=unescape(encodeURIComponent(string));var ret=[];for(var i=0;i<string.length;i++)ret.push(string.charCodeAt(i));return ret}},getCompilerSetting:function(name){throw"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work";},stackAlloc:function(size){var ret=STACKTOP;STACKTOP=STACKTOP+size|0;STACKTOP=STACKTOP+7&-8;return ret},staticAlloc:function(size){var ret=
STATICTOP;STATICTOP=STATICTOP+size|0;STATICTOP=STATICTOP+7&-8;return ret},dynamicAlloc:function(size){var ret=DYNAMICTOP;DYNAMICTOP=DYNAMICTOP+size|0;DYNAMICTOP=DYNAMICTOP+7&-8;if(DYNAMICTOP>=TOTAL_MEMORY)enlargeMemory();return ret},alignMemory:function(size,quantum){var ret=size=Math.ceil(size/(quantum?quantum:8))*(quantum?quantum:8);return ret},makeBigInt:function(low,high,unsigned){var ret=unsigned?+(low>>>0)+ +(high>>>0)*+4294967296:+(low>>>0)+ +(high|0)*+4294967296;return ret},GLOBAL_BASE:8,
QUANTUM_SIZE:4,__dummy__:0};Module["Runtime"]=Runtime;var __THREW__=0;var ABORT=false;var EXITSTATUS=0;var undef=0;var tempValue,tempInt,tempBigInt,tempInt2,tempBigInt2,tempPair,tempBigIntI,tempBigIntR,tempBigIntS,tempBigIntP,tempBigIntD,tempDouble,tempFloat;var tempI64,tempI64b;var tempRet0,tempRet1,tempRet2,tempRet3,tempRet4,tempRet5,tempRet6,tempRet7,tempRet8,tempRet9;function assert(condition,text){if(!condition)abort("Assertion failed: "+text)}var globalScope=this;
function getCFunc(ident){var func=Module["_"+ident];if(!func)try{func=eval("_"+ident)}catch(e){}assert(func,"Cannot call unknown function "+ident+" (perhaps LLVM optimizations or closure removed it?)");return func}var cwrap,ccall;
(function(){var stack=0;var JSfuncs={"stackSave":function(){stack=Runtime.stackSave()},"stackRestore":function(){Runtime.stackRestore(stack)},"arrayToC":function(arr){var ret=Runtime.stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret},"stringToC":function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=Runtime.stackAlloc(str.length+1);writeStringToMemory(str,ret)}return ret}};var toC={"string":JSfuncs["stringToC"],"array":JSfuncs["arrayToC"]};ccall=function ccallFunc(ident,
returnType,argTypes,args){var func=getCFunc(ident);var cArgs=[];if(args)for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=Runtime.stackSave();cArgs[i]=converter(args[i])}else cArgs[i]=args[i]}var ret=func.apply(null,cArgs);if(returnType==="string")ret=Pointer_stringify(ret);if(stack!==0)JSfuncs["stackRestore"]();return ret};var sourceRegex=/^function\s*\(([^)]*)\)\s*{\s*([^*]*?)[\s;]*(?:return\s*(.*?)[;\s]*)?}$/;function parseJSFunc(jsfunc){var parsed=
jsfunc.toString().match(sourceRegex).slice(1);return{arguments:parsed[0],body:parsed[1],returnValue:parsed[2]}}var JSsource={};for(var fun in JSfuncs)if(JSfuncs.hasOwnProperty(fun))JSsource[fun]=parseJSFunc(JSfuncs[fun]);cwrap=function cwrap(ident,returnType,argTypes){var cfunc=getCFunc(ident);var numericArgs=argTypes.every(function(type){return type==="number"});var numericRet=returnType!=="string";if(numericRet&&numericArgs)return cfunc;var argNames=argTypes.map(function(x,i){return"$"+i});var funcstr=
"(function("+argNames.join(",")+") {";var nargs=argTypes.length;if(!numericArgs){funcstr+=JSsource["stackSave"].body+";";for(var i=0;i<nargs;i++){var arg=argNames[i],type=argTypes[i];if(type==="number")continue;var convertCode=JSsource[type+"ToC"];funcstr+="var "+convertCode.arguments+" = "+arg+";";funcstr+=convertCode.body+";";funcstr+=arg+"="+convertCode.returnValue+";"}}var cfuncname=parseJSFunc(function(){return cfunc}).returnValue;funcstr+="var ret = "+cfuncname+"("+argNames.join(",")+");";if(!numericRet){var strgfy=
parseJSFunc(function(){return Pointer_stringify}).returnValue;funcstr+="ret = "+strgfy+"(ret);"}if(!numericArgs)funcstr+=JSsource["stackRestore"].body+";";funcstr+="return ret})";return eval(funcstr)}})();Module["cwrap"]=cwrap;Module["ccall"]=ccall;
function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case "i1":HEAP8[ptr>>0]=value;break;case "i8":HEAP8[ptr>>0]=value;break;case "i16":HEAP16[ptr>>1]=value;break;case "i32":HEAP32[ptr>>2]=value;break;case "i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=+1?tempDouble>+0?(Math_min(+Math_floor(tempDouble/+4294967296),+4294967295)|0)>>>0:~~+Math_ceil((tempDouble-+(~~tempDouble>>>0))/+4294967296)>>>0:0)],HEAP32[ptr>>2]=
tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case "float":HEAPF32[ptr>>2]=value;break;case "double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type)}}Module["setValue"]=setValue;
function getValue(ptr,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case "i1":return HEAP8[ptr>>0];case "i8":return HEAP8[ptr>>0];case "i16":return HEAP16[ptr>>1];case "i32":return HEAP32[ptr>>2];case "i64":return HEAP32[ptr>>2];case "float":return HEAPF32[ptr>>2];case "double":return HEAPF64[ptr>>3];default:abort("invalid type for setValue: "+type)}return null}Module["getValue"]=getValue;var ALLOC_NORMAL=0;var ALLOC_STACK=1;var ALLOC_STATIC=2;
var ALLOC_DYNAMIC=3;var ALLOC_NONE=4;Module["ALLOC_NORMAL"]=ALLOC_NORMAL;Module["ALLOC_STACK"]=ALLOC_STACK;Module["ALLOC_STATIC"]=ALLOC_STATIC;Module["ALLOC_DYNAMIC"]=ALLOC_DYNAMIC;Module["ALLOC_NONE"]=ALLOC_NONE;
function allocate(slab,types,allocator,ptr){var zeroinit,size;if(typeof slab==="number"){zeroinit=true;size=slab}else{zeroinit=false;size=slab.length}var singleType=typeof types==="string"?types:null;var ret;if(allocator==ALLOC_NONE)ret=ptr;else ret=[_malloc,Runtime.stackAlloc,Runtime.staticAlloc,Runtime.dynamicAlloc][allocator===undefined?ALLOC_STATIC:allocator](Math.max(size,singleType?1:types.length));if(zeroinit){var ptr=ret,stop;assert((ret&3)==0);stop=ret+(size&~3);for(;ptr<stop;ptr+=4)HEAP32[ptr>>
2]=0;stop=ret+size;while(ptr<stop)HEAP8[ptr++>>0]=0;return ret}if(singleType==="i8"){if(slab.subarray||slab.slice)HEAPU8.set(slab,ret);else HEAPU8.set(new Uint8Array(slab),ret);return ret}var i=0,type,typeSize,previousType;while(i<size){var curr=slab[i];if(typeof curr==="function")curr=Runtime.getFunctionIndex(curr);type=singleType||types[i];if(type===0){i++;continue}if(type=="i64")type="i32";setValue(ret+i,curr,type);if(previousType!==type){typeSize=Runtime.getNativeTypeSize(type);previousType=type}i+=
typeSize}return ret}Module["allocate"]=allocate;
function Pointer_stringify(ptr,length){var hasUtf=false;var t;var i=0;while(1){t=HEAPU8[ptr+i>>0];if(t>=128)hasUtf=true;else if(t==0&&!length)break;i++;if(length&&i==length)break}if(!length)length=i;var ret="";if(!hasUtf){var MAX_CHUNK=1024;var curr;while(length>0){curr=String.fromCharCode.apply(String,HEAPU8.subarray(ptr,ptr+Math.min(length,MAX_CHUNK)));ret=ret?ret+curr:curr;ptr+=MAX_CHUNK;length-=MAX_CHUNK}return ret}var utf8=new Runtime.UTF8Processor;for(i=0;i<length;i++){t=HEAPU8[ptr+i>>0];ret+=
utf8.processCChar(t)}return ret}Module["Pointer_stringify"]=Pointer_stringify;function UTF16ToString(ptr){var i=0;var str="";while(1){var codeUnit=HEAP16[ptr+i*2>>1];if(codeUnit==0)return str;++i;str+=String.fromCharCode(codeUnit)}}Module["UTF16ToString"]=UTF16ToString;function stringToUTF16(str,outPtr){for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr+i*2>>1]=codeUnit}HEAP16[outPtr+str.length*2>>1]=0}Module["stringToUTF16"]=stringToUTF16;
function UTF32ToString(ptr){var i=0;var str="";while(1){var utf32=HEAP32[ptr+i*4>>2];if(utf32==0)return str;++i;if(utf32>=65536){var ch=utf32-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}else str+=String.fromCharCode(utf32)}}Module["UTF32ToString"]=UTF32ToString;
function stringToUTF32(str,outPtr){var iChar=0;for(var iCodeUnit=0;iCodeUnit<str.length;++iCodeUnit){var codeUnit=str.charCodeAt(iCodeUnit);if(codeUnit>=55296&&codeUnit<=57343){var trailSurrogate=str.charCodeAt(++iCodeUnit);codeUnit=65536+((codeUnit&1023)<<10)|trailSurrogate&1023}HEAP32[outPtr+iChar*4>>2]=codeUnit;++iChar}HEAP32[outPtr+iChar*4>>2]=0}Module["stringToUTF32"]=stringToUTF32;
function demangle(func){var i=3;var basicTypes={"v":"void","b":"bool","c":"char","s":"short","i":"int","l":"long","f":"float","d":"double","w":"wchar_t","a":"signed char","h":"unsigned char","t":"unsigned short","j":"unsigned int","m":"unsigned long","x":"long long","y":"unsigned long long","z":"..."};var subs=[];var first=true;function dump(x){if(x)Module.print(x);Module.print(func);var pre="";for(var a=0;a<i;a++)pre+=" ";Module.print(pre+"^")}function parseNested(){i++;if(func[i]==="K")i++;var parts=
[];while(func[i]!=="E"){if(func[i]==="S"){i++;var next=func.indexOf("_",i);var num=func.substring(i,next)||0;parts.push(subs[num]||"?");i=next+1;continue}if(func[i]==="C"){parts.push(parts[parts.length-1]);i+=2;continue}var size=parseInt(func.substr(i));var pre=size.toString().length;if(!size||!pre){i--;break}var curr=func.substr(i+pre,size);parts.push(curr);subs.push(curr);i+=pre+size}i++;return parts}function parse(rawList,limit,allowVoid){limit=limit||Infinity;var ret="",list=[];function flushList(){return"("+
list.join(", ")+")"}var name;if(func[i]==="N"){name=parseNested().join("::");limit--;if(limit===0)return rawList?[name]:name}else{if(func[i]==="K"||first&&func[i]==="L")i++;var size=parseInt(func.substr(i));if(size){var pre=size.toString().length;name=func.substr(i+pre,size);i+=pre+size}}first=false;if(func[i]==="I"){i++;var iList=parse(true);var iRet=parse(true,1,true);ret+=iRet[0]+" "+name+"<"+iList.join(", ")+">"}else ret=name;paramLoop:while(i<func.length&&limit-- >0){var c=func[i++];if(c in basicTypes)list.push(basicTypes[c]);
else switch(c){case "P":list.push(parse(true,1,true)[0]+"*");break;case "R":list.push(parse(true,1,true)[0]+"&");break;case "L":i++;var end=func.indexOf("E",i);var size=end-i;list.push(func.substr(i,size));i+=size+2;break;case "A":var size=parseInt(func.substr(i));i+=size.toString().length;if(func[i]!=="_")throw"?";i++;list.push(parse(true,1,true)[0]+" ["+size+"]");break;case "E":break paramLoop;default:ret+="?"+c;break paramLoop}}if(!allowVoid&&list.length===1&&list[0]==="void")list=[];if(rawList){if(ret)list.push(ret+
"?");return list}else return ret+flushList()}try{if(func=="Object._main"||func=="_main")return"main()";if(typeof func==="number")func=Pointer_stringify(func);if(func[0]!=="_")return func;if(func[1]!=="_")return func;if(func[2]!=="Z")return func;switch(func[3]){case "n":return"operator new()";case "d":return"operator delete()"}return parse()}catch(e){return func}}function demangleAll(text){return text.replace(/__Z[\w\d_]+/g,function(x){var y=demangle(x);return x===y?x:x+" ["+y+"]"})}
function stackTrace(){var stack=(new Error).stack;return stack?demangleAll(stack):"(no stack trace available)"}var PAGE_SIZE=4096;function alignMemoryPage(x){return x+4095&-4096}var HEAP;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;var STATIC_BASE=0,STATICTOP=0,staticSealed=false;var STACK_BASE=0,STACKTOP=0,STACK_MAX=0;var DYNAMIC_BASE=0,DYNAMICTOP=0;
function enlargeMemory(){abort("Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value "+TOTAL_MEMORY+", (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.")}var TOTAL_STACK=Module["TOTAL_STACK"]||5242880;var TOTAL_MEMORY=Module["TOTAL_MEMORY"]||33554432;var FAST_MEMORY=Module["FAST_MEMORY"]||2097152;var totalMemory=4096;
while(totalMemory<TOTAL_MEMORY||totalMemory<2*TOTAL_STACK)if(totalMemory<16*1024*1024)totalMemory*=2;else totalMemory+=16*1024*1024;if(totalMemory!==TOTAL_MEMORY){Module.printErr("increasing TOTAL_MEMORY to "+totalMemory+" to be more reasonable");TOTAL_MEMORY=totalMemory}assert(typeof Int32Array!=="undefined"&&typeof Float64Array!=="undefined"&&!!(new Int32Array(1))["subarray"]&&!!(new Int32Array(1))["set"],"JS engine does not provide full typed array support");var buffer=new ArrayBuffer(TOTAL_MEMORY);
HEAP8=new Int8Array(buffer);HEAP16=new Int16Array(buffer);HEAP32=new Int32Array(buffer);HEAPU8=new Uint8Array(buffer);HEAPU16=new Uint16Array(buffer);HEAPU32=new Uint32Array(buffer);HEAPF32=new Float32Array(buffer);HEAPF64=new Float64Array(buffer);HEAP32[0]=255;assert(HEAPU8[0]===255&&HEAPU8[3]===0,"Typed arrays 2 must be run on a little-endian system");Module["HEAP"]=HEAP;Module["HEAP8"]=HEAP8;Module["HEAP16"]=HEAP16;Module["HEAP32"]=HEAP32;Module["HEAPU8"]=HEAPU8;Module["HEAPU16"]=HEAPU16;
Module["HEAPU32"]=HEAPU32;Module["HEAPF32"]=HEAPF32;Module["HEAPF64"]=HEAPF64;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number")if(callback.arg===undefined)Runtime.dynCall("v",func);else Runtime.dynCall("vi",func,[callback.arg]);else func(callback.arg===undefined?null:callback.arg)}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];
var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length)addOnPreRun(Module["preRun"].shift())}callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){if(runtimeInitialized)return;runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}
function exitRuntime(){callRuntimeCallbacks(__ATEXIT__)}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length)addOnPostRun(Module["postRun"].shift())}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}Module["addOnPreRun"]=Module.addOnPreRun=addOnPreRun;function addOnInit(cb){__ATINIT__.unshift(cb)}Module["addOnInit"]=Module.addOnInit=addOnInit;
function addOnPreMain(cb){__ATMAIN__.unshift(cb)}Module["addOnPreMain"]=Module.addOnPreMain=addOnPreMain;function addOnExit(cb){__ATEXIT__.unshift(cb)}Module["addOnExit"]=Module.addOnExit=addOnExit;function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}Module["addOnPostRun"]=Module.addOnPostRun=addOnPostRun;function intArrayFromString(stringy,dontAddNull,length){var ret=(new Runtime.UTF8Processor).processJSString(stringy);if(length)ret.length=length;if(!dontAddNull)ret.push(0);return ret}
Module["intArrayFromString"]=intArrayFromString;function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255)chr&=255;ret.push(String.fromCharCode(chr))}return ret.join("")}Module["intArrayToString"]=intArrayToString;function writeStringToMemory(string,buffer,dontAddNull){var array=intArrayFromString(string,dontAddNull);var i=0;while(i<array.length){var chr=array[i];HEAP8[buffer+i>>0]=chr;i=i+1}}Module["writeStringToMemory"]=writeStringToMemory;
function writeArrayToMemory(array,buffer){for(var i=0;i<array.length;i++)HEAP8[buffer+i>>0]=array[i]}Module["writeArrayToMemory"]=writeArrayToMemory;function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;i++)HEAP8[buffer+i>>0]=str.charCodeAt(i);if(!dontAddNull)HEAP8[buffer+str.length>>0]=0}Module["writeAsciiToMemory"]=writeAsciiToMemory;function unSign(value,bits,ignore){if(value>=0)return value;return bits<=32?2*Math.abs(1<<bits-1)+value:Math.pow(2,bits)+value}
function reSign(value,bits,ignore){if(value<=0)return value;var half=bits<=32?Math.abs(1<<bits-1):Math.pow(2,bits-1);if(value>=half&&(bits<=32||value>half))value=-2*half+value;return value}if(!Math["imul"]||Math["imul"](4294967295,5)!==-5)Math["imul"]=function imul(a,b){var ah=a>>>16;var al=a&65535;var bh=b>>>16;var bl=b&65535;return al*bl+(ah*bl+al*bh<<16)|0};Math.imul=Math["imul"];var Math_abs=Math.abs;var Math_cos=Math.cos;var Math_sin=Math.sin;var Math_tan=Math.tan;var Math_acos=Math.acos;
var Math_asin=Math.asin;var Math_atan=Math.atan;var Math_atan2=Math.atan2;var Math_exp=Math.exp;var Math_log=Math.log;var Math_sqrt=Math.sqrt;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_pow=Math.pow;var Math_imul=Math.imul;var Math_fround=Math.fround;var Math_min=Math.min;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;
function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"])Module["monitorRunDependencies"](runDependencies)}Module["addRunDependency"]=addRunDependency;
function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"])Module["monitorRunDependencies"](runDependencies);if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["removeRunDependency"]=removeRunDependency;Module["preloadedImages"]={};Module["preloadedAudios"]={};var memoryInitializer=null;
var __ZTVN10__cxxabiv117__class_type_infoE=9E3;var __ZTVN10__cxxabiv120__si_class_type_infoE=9040;STATIC_BASE=8;STATICTOP=STATIC_BASE+Runtime.alignMemory(9715);__ATINIT__.push({func:function(){__GLOBAL__I_a()}});
allocate([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,152,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,49,53,82,97,121,67,97,115,116,67,97,108,108,98,97,99,107,0,0,0,0,0,0,0,49,55,98,50,82,97,121,67,97,115,116,67,97,108,108,98,97,99,107,0,0,0,0,0,48,35,0,0,120,0,0,0,88,35,0,0,96,0,0,0,144,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,3,0,0,0,4,0,0,0,2,0,0,0,1,0,0,0,3,0,0,0,0,0,0,0,49,55,81,117,101,114,121,65,65,66,66,67,97,108,108,
98,97,99,107,0,0,0,0,0,49,53,98,50,81,117,101,114,121,67,97,108,108,98,97,99,107,0,0,0,0,0,0,0,48,35,0,0,224,0,0,0,88,35,0,0,200,0,0,0,248,0,0,0,0,0,0,0,0,0,0,0,128,1,0,0,5,0,0,0,6,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,50,50,98,50,87,111,114,108,100,67,111,110,116,97,99,116,76,105,115,116,101,110,101,114,0,0,0,0,0,0,0,0,49,55,98,50,67,111,110,116,97,99,116,76,105,115,116,101,110,101,114,0,0,0,0,0,48,35,0,0,96,1,0,0,88,35,0,0,64,1,0,0,120,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,2,0,0,7,0,0,0,8,0,0,0,4,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,1,0,0,0,3,0,0,0,1,0,0,0,0,0,0,0,49,49,98,50,69,100,103,101,83,104,97,112,101,0,0,0,55,98,50,83,104,97,112,101,0,0,0,0,0,0,0,0,48,35,0,0,32,2,0,0,88,35,0,0,16,2,0,0,48,2,0,0,0,0,0,0,0,0,0,0,144,2,0,0,9,0,0,0,10,0,0,0,5,0,0,0,2,0,0,0,3,0,0,0,2,0,0,0,2,0,0,0,4,0,0,0,2,0,0,0,0,0,0,0,49,52,98,50,
80,111,108,121,103,111,110,83,104,97,112,101,0,0,0,0,0,0,0,0,88,35,0,0,120,2,0,0,48,2,0,0,0,0,0,0,0,0,0,0,224,2,0,0,11,0,0,0,12,0,0,0,6,0,0,0,3,0,0,0,4,0,0,0,3,0,0,0,3,0,0,0,5,0,0,0,3,0,0,0,0,0,0,0,49,51,98,50,67,105,114,99,108,101,83,104,97,112,101,0,88,35,0,0,208,2,0,0,48,2,0,0,0,0,0,0,0,0,0,0,48,3,0,0,13,0,0,0,14,0,0,0,7,0,0,0,4,0,0,0,5,0,0,0,4,0,0,0,4,0,0,0,6,0,0,0,4,0,0,0,0,0,0,0,49,50,98,50,67,104,97,105,110,83,104,97,112,101,0,0,88,35,0,0,32,3,0,0,48,2,0,0,0,0,0,0,0,0,0,0,120,3,0,0,15,0,0,
0,16,0,0,0,6,0,0,0,1,0,0,0,2,0,0,0,0,0,0,0,49,53,98,50,67,111,110,116,97,99,116,70,105,108,116,101,114,0,0,0,0,0,0,0,48,35,0,0,96,3,0,0,0,0,0,0,224,3,0,0,3,0,0,0,4,0,0,0,5,0,0,0,1,0,0,0,17,0,0,0,5,0,0,0,18,0,0,0,19,0,0,0,6,0,0,0,7,0,0,0,8,0,0,0,0,0,0,0,49,50,98,50,77,111,117,115,101,74,111,105,110,116,0,0,55,98,50,74,111,105,110,116,0,0,0,0,0,0,0,0,48,35,0,0,200,3,0,0,88,35,0,0,184,3,0,0,216,3,0,0,0,0,0,0,77,111,117,115,101,32,106,111,105,110,116,32,100,117,109,112,105,110,103,32,105,115,32,110,111,
116,32,115,117,112,112,111,114,116,101,100,46,10,0,0,0,0,0,0,200,5,0,0,8,0,0,0,9,0,0,0,6,0,0,0,2,0,0,0,20,0,0,0,10,0,0,0,21,0,0,0,22,0,0,0,11,0,0,0,12,0,0,0,9,0,0,0,0,0,0,0,32,32,98,50,77,111,116,111,114,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,
111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,105,110,101,97,114,79,102,102,115,101,116,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,97,110,103,117,108,97,114,79,102,102,115,101,116,32,61,32,37,46,49,53,108,101,102,59,10,0,0,32,32,106,100,46,109,97,120,70,111,114,99,101,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,0,32,32,106,100,46,109,97,120,84,111,114,113,117,101,
32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,32,32,106,100,46,99,111,114,114,101,99,116,105,111,110,70,97,99,116,111,114,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,50,98,50,77,111,116,111,114,74,111,105,110,116,0,0,88,35,0,0,184,5,0,0,216,3,0,0,0,0,0,0,0,0,0,0,152,7,0,0,13,0,0,0,14,0,0,0,7,0,0,0,3,0,0,0,23,0,0,0,10,0,0,
0,24,0,0,0,25,0,0,0,15,0,0,0,16,0,0,0,10,0,0,0,0,0,0,0,32,32,98,50,68,105,115,116,97,110,99,101,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,
46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,101,110,103,116,104,32,61,32,37,46,49,53,108,101,102,59,10,0,32,32,106,100,46,102,114,101,113,117,101,110,99,121,72,122,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,32,32,106,100,46,100,
97,109,112,105,110,103,82,97,116,105,111,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,53,98,50,68,105,115,116,97,110,99,101,74,111,105,110,116,0,0,0,0,0,0,0,88,35,0,0,128,7,0,0,216,3,0,0,0,0,0,0,0,0,0,0,80,9,0,0,17,0,0,0,18,0,0,0,8,0,0,0,4,0,0,0,26,0,0,0,10,0,0,0,27,0,0,0,28,0,0,0,19,0,0,0,20,0,0,0,11,0,0,0,0,0,0,0,32,32,98,50,70,114,105,
99,116,105,111,110,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,
108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,109,97,120,70,111,114,99,101,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,0,32,32,106,100,46,109,97,120,84,111,114,113,117,101,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,
62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,53,98,50,70,114,105,99,116,105,111,110,74,111,105,110,116,0,0,0,0,0,0,0,88,35,0,0,56,9,0,0,216,3,0,0,0,0,0,0,0,0,0,0,24,11,0,0,21,0,0,0,22,0,0,0,9,0,0,0,5,0,0,0,29,0,0,0,10,0,0,0,30,0,0,0,31,0,0,0,23,0,0,0,24,0,0,0,12,0,0,0,0,0,0,0,32,32,98,50,87,101,108,100,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,
100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,
102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,114,101,102,101,114,101,110,99,101,65,110,103,108,101,32,61,32,37,46,49,53,108,101,102,59,10,0,32,32,106,100,46,102,114,101,113,117,101,110,99,121,72,122,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,32,32,106,100,46,100,97,109,112,105,110,103,82,97,116,105,111,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,
0,0,0,0,0,0,49,49,98,50,87,101,108,100,74,111,105,110,116,0,0,0,88,35,0,0,8,11,0,0,216,3,0,0,0,0,0,0,0,0,0,0,120,12,0,0,25,0,0,0,26,0,0,0,10,0,0,0,6,0,0,0,32,0,0,0,10,0,0,0,33,0,0,0,34,0,0,0,27,0,0,0,28,0,0,0,13,0,0,0,0,0,0,0,32,32,98,50,71,101,97,114,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,
0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,106,111,105,110,116,49,32,61,32,106,111,105,110,116,115,91,37,100,93,59,10,0,0,0,0,0,0,32,32,106,100,46,106,111,105,110,116,50,32,61,32,106,111,105,110,116,115,91,37,100,93,59,10,0,0,0,0,0,0,32,32,106,100,46,114,97,116,105,111,32,61,32,37,46,49,53,108,101,102,59,10,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,
45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,49,98,50,71,101,97,114,74,111,105,110,116,0,0,0,88,35,0,0,104,12,0,0,216,3,0,0,0,0,0,0,0,0,0,0,8,15,0,0,29,0,0,0,30,0,0,0,11,0,0,0,7,0,0,0,35,0,0,0,10,0,0,0,36,0,0,0,37,0,0,0,31,0,0,0,32,0,0,0,14,0,0,0,0,0,0,0,32,32,98,50,80,114,105,115,109,97,116,105,99,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,
32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,
108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,120,105,115,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,32,32,106,100,46,114,101,102,101,114,101,110,99,101,65,110,103,108,101,32,61,32,37,46,49,53,108,101,102,59,10,0,32,32,106,100,46,101,110,97,98,108,101,76,105,109,105,116,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,32,32,106,100,46,108,111,119,101,114,84,114,97,110,115,108,97,116,105,111,110,32,61,32,37,46,49,53,108,101,102,59,
10,0,0,0,0,0,0,0,32,32,106,100,46,117,112,112,101,114,84,114,97,110,115,108,97,116,105,111,110,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,0,32,32,106,100,46,101,110,97,98,108,101,77,111,116,111,114,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,32,32,106,100,46,109,111,116,111,114,83,112,101,101,100,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,32,32,106,100,46,109,97,120,77,111,116,111,114,70,111,114,99,101,32,61,32,37,46,49,53,108,101,102,59,10,0,0,32,32,106,111,105,110,116,115,91,
37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,54,98,50,80,114,105,115,109,97,116,105,99,74,111,105,110,116,0,0,0,0,0,0,88,35,0,0,240,14,0,0,216,3,0,0,0,0,0,0,0,0,0,0,144,16,0,0,33,0,0,0,34,0,0,0,12,0,0,0,8,0,0,0,38,0,0,0,10,0,0,0,39,0,0,0,40,0,0,0,35,0,0,0,36,0,0,0,15,0,0,0,0,0,0,0,32,32,98,50,82,111,112,101,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,
105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,46,83,101,
116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,109,97,120,76,101,110,103,116,104,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,49,98,50,82,111,112,101,74,111,105,110,116,0,0,0,88,35,0,0,128,16,0,0,216,3,0,0,0,0,0,0,0,0,0,0,216,3,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,41,0,0,0,10,0,
0,0,42,0,0,0,43,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,47,47,32,68,117,109,112,32,105,115,32,110,111,116,32,115,117,112,112,111,114,116,101,100,32,102,111,114,32,116,104,105,115,32,106,111,105,110,116,32,116,121,112,101,46,10,0,0,0,0,0,0,80,19,0,0,37,0,0,0,38,0,0,0,13,0,0,0,9,0,0,0,44,0,0,0,10,0,0,0,45,0,0,0,46,0,0,0,39,0,0,0,40,0,0,0,16,0,0,0,0,0,0,0,32,32,98,50,82,101,118,111,108,117,116,101,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,
98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,
46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,114,101,102,101,114,101,110,99,101,65,110,103,108,101,32,61,32,37,46,49,53,108,101,102,59,10,0,32,32,106,100,46,101,110,97,98,108,101,76,105,109,105,116,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,32,32,106,100,46,108,111,119,101,114,65,110,103,108,101,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,32,32,106,100,46,117,112,112,101,114,65,110,103,108,101,32,61,32,37,46,49,53,108,101,
102,59,10,0,0,0,0,0,32,32,106,100,46,101,110,97,98,108,101,77,111,116,111,114,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,32,32,106,100,46,109,111,116,111,114,83,112,101,101,100,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,32,32,106,100,46,109,97,120,77,111,116,111,114,84,111,114,113,117,101,32,61,32,37,46,49,53,108,101,102,59,10,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,
0,49,53,98,50,82,101,118,111,108,117,116,101,74,111,105,110,116,0,0,0,0,0,0,0,88,35,0,0,56,19,0,0,216,3,0,0,0,0,0,0,0,0,0,0,128,21,0,0,41,0,0,0,42,0,0,0,14,0,0,0,10,0,0,0,47,0,0,0,10,0,0,0,48,0,0,0,49,0,0,0,43,0,0,0,44,0,0,0,17,0,0,0,0,0,0,0,32,32,98,50,87,104,101,101,108,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,
93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,
120,105,115,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,32,32,106,100,46,101,110,97,98,108,101,77,111,116,111,114,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,32,32,106,100,46,109,111,116,111,114,83,112,101,101,100,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,32,32,106,100,46,109,97,120,77,111,116,111,114,84,111,114,113,117,101,32,61,32,37,46,49,53,108,101,102,59,10,0,32,32,106,100,46,102,114,101,113,117,101,110,99,121,72,122,32,61,32,37,46,49,53,108,
101,102,59,10,0,0,0,0,32,32,106,100,46,100,97,109,112,105,110,103,82,97,116,105,111,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,50,98,50,87,104,101,101,108,74,111,105,110,116,0,0,88,35,0,0,112,21,0,0,216,3,0,0,0,0,0,0,0,0,0,0,160,23,0,0,45,0,0,0,46,0,0,0,15,0,0,0,11,0,0,0,50,0,0,0,47,0,0,0,51,0,0,0,52,0,0,0,48,0,0,0,49,0,0,0,18,0,0,0,
0,0,0,0,32,32,98,50,80,117,108,108,101,121,74,111,105,110,116,68,101,102,32,106,100,59,10,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,103,114,111,117,110,100,65,110,99,104,111,114,65,46,83,101,
116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,32,32,106,100,46,103,114,111,117,110,100,65,110,99,104,111,114,66,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,46,83,101,116,40,37,46,49,53,108,101,102,44,32,
37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,101,110,103,116,104,65,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,0,0,32,32,106,100,46,108,101,110,103,116,104,66,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,0,0,32,32,106,100,46,114,97,116,105,111,32,61,32,37,46,49,53,108,101,102,59,10,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,51,98,50,80,117,
108,108,101,121,74,111,105,110,116,0,88,35,0,0,144,23,0,0,216,3,0,0,0,0,0,0,0,0,0,0,0,24,0,0,7,0,0,0,53,0,0,0,54,0,0,0,0,0,0,0,50,52,98,50,67,104,97,105,110,65,110,100,80,111,108,121,103,111,110,67,111,110,116,97,99,116,0,0,0,0,0,0,57,98,50,67,111,110,116,97,99,116,0,0,0,0,0,0,48,35,0,0,232,23,0,0,88,35,0,0,200,23,0,0,248,23,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,23,0,0,1,0,0,0,55,0,0,0,56,0,0,0,0,0,0,0,0,0,0,0,40,25,0,0,8,0,0,0,57,0,0,0,58,0,0,0,0,0,0,0,50,53,98,50,80,111,108,121,103,111,110,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,0,0,0,0,0,88,35,0,0,8,25,0,0,248,23,0,0,0,0,0,0,0,0,0,0,104,25,
0,0,9,0,0,0,59,0,0,0,60,0,0,0,0,0,0,0,49,53,98,50,67,105,114,99,108,101,67,111,110,116,97,99,116,0,0,0,0,0,0,0,88,35,0,0,80,25,0,0,248,23,0,0,0,0,0,0,0,0,0,0,176,25,0,0,10,0,0,0,61,0,0,0,62,0,0,0,0,0,0,0,50,50,98,50,69,100,103,101,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,0,0,0,0,0,0,0,0,88,35,0,0,144,25,0,0,248,23,0,0,0,0,0,0,0,0,0,0,248,25,0,0,11,0,0,0,63,0,0,0,64,0,0,0,0,0,0,0,50,51,98,50,67,104,97,105,110,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,0,0,0,0,0,0,0,
88,35,0,0,216,25,0,0,248,23,0,0,0,0,0,0,0,0,0,0,64,26,0,0,12,0,0,0,65,0,0,0,66,0,0,0,0,0,0,0,50,51,98,50,69,100,103,101,65,110,100,80,111,108,121,103,111,110,67,111,110,116,97,99,116,0,0,0,0,0,0,0,88,35,0,0,32,26,0,0,248,23,0,0,0,0,0,0,0,0,0,0,128,26,0,0,13,0,0,0,67,0,0,0,68,0,0,0,0,0,0,0,49,54,98,50,80,111,108,121,103,111,110,67,111,110,116,97,99,116,0,0,0,0,0,0,88,35,0,0,104,26,0,0,248,23,0,0,0,0,0,0,72,3,0,0,0,0,0,0,168,26,0,0,0,0,0,0,0,0,0,0,120,1,0,0,69,0,0,0,70,0,0,0,50,0,0,0,51,0,0,0,1,0,0,
0,1,0,0,0,2,0,0,0,2,0,0,0,5,0,0,0,6,0,0,0,0,0,0,0,120,27,0,0,71,0,0,0,72,0,0,0,19,0,0,0,1,0,0,0,20,0,0,0,14,0,0,0,90,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,49,52,83,111,108,118,101,67,111,108,108,105,115,105,111,110,69,82,75,49,48,98,50,84,105,109,101,83,116,101,112,69,50,50,83,111,108,118,101,67,111,108,108,105,115,105,111,110,67,97,108,108,98,97,99,107,0,0,0,0,51,48,98,50,70,105,120,116,117,114,101,80,97,114,116,105,99,108,101,81,117,101,114,121,67,97,108,108,98,97,99,
107,0,0,0,0,0,0,0,0,88,35,0,0,64,27,0,0,248,0,0,0,0,0,0,0,88,35,0,0,240,26,0,0,104,27,0,0,0,0,0,0,0,0,0,0,240,27,0,0,73,0,0,0,74,0,0,0,19,0,0,0,1,0,0,0,20,0,0,0,15,0,0,0,90,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,49,56,85,112,100,97,116,101,66,111,100,121,67,111,110,116,97,99,116,115,69,118,69,50,54,85,112,100,97,116,101,66,111,100,121,67,111,110,116,97,99,116,115,67,97,108,108,98,97,99,107,0,88,35,0,0,168,27,0,0,104,27,0,0,0,0,0,0,0,0,0,0,168,28,0,0,75,0,0,0,76,0,0,0,16,
0,0,0,0,0,0,0,90,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,50,48,85,112,100,97,116,101,80,97,105,114,115,65,110,100,84,114,105,97,100,115,69,105,105,82,75,78,83,95,49,54,67,111,110,110,101,99,116,105,111,110,70,105,108,116,101,114,69,69,50,48,85,112,100,97,116,101,84,114,105,97,100,115,67,97,108,108,98,97,99,107,0,0,0,0,78,49,54,98,50,86,111,114,111,110,111,105,68,105,97,103,114,97,109,49,50,78,111,100,101,67,97,108,108,98,97,99,107,69,0,0,0,0,0,0,48,35,0,0,120,28,0,0,88,
35,0,0,24,28,0,0,160,28,0,0,0,0,0,0,0,0,0,0,96,29,0,0,77,0,0,0,78,0,0,0,21,0,0,0,7,0,0,0,3,0,0,0,0,0,0,0,90,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,52,49,85,112,100,97,116,101,80,97,105,114,115,65,110,100,84,114,105,97,100,115,87,105,116,104,82,101,97,99,116,105,118,101,80,97,114,116,105,99,108,101,115,69,118,69,49,52,82,101,97,99,116,105,118,101,70,105,108,116,101,114,0,0,0,0,0,0,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,49,54,67,111,110,110,101,
99,116,105,111,110,70,105,108,116,101,114,69,0,0,48,35,0,0,48,29,0,0,88,35,0,0,216,28,0,0,88,29,0,0,0,0,0,0,0,0,0,0,88,29,0,0,79,0,0,0,80,0,0,0,22,0,0,0,7,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,16,30,0,0,81,0,0,0,82,0,0,0,22,0,0,0,8,0,0,0,4,0,0,0,0,0,0,0,90,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,49,56,74,111,105,110,80,97,114,116,105,99,108,101,71,114,111,117,112,115,69,80,49,53,98,50,80,97,114,116,105,99,108,101,71,114,111,117,112,83,49,95,69,50,52,74,111,105,110,80,97,114,116,
105,99,108,101,71,114,111,117,112,115,70,105,108,116,101,114,0,0,0,0,0,0,0,88,35,0,0,176,29,0,0,88,29,0,0,0,0,0,0,0,0,0,0,208,30,0,0,83,0,0,0,84,0,0,0,23,0,0,0,5,0,0,0,9,0,0,0,5,0,0,0,5,0,0,0,17,0,0,0,16,0,0,0,0,0,0,0,90,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,51,51,67,114,101,97,116,101,80,97,114,116,105,99,108,101,115,87,105,116,104,83,104,97,112,101,115,70,111,114,71,114,111,117,112,69,80,75,80,75,55,98,50,83,104,97,112,101,105,82,75,49,56,98,50,80,97,114,116,105,99,
108,101,71,114,111,117,112,68,101,102,82,75,49,49,98,50,84,114,97,110,115,102,111,114,109,69,49,52,67,111,109,112,111,115,105,116,101,83,104,97,112,101,0,0,0,0,0,88,35,0,0,80,30,0,0,48,2,0,0,0,0,0,0,0,0,0,0,112,31,0,0,85,0,0,0,86,0,0,0,24,0,0,0,10,0,0,0,3,0,0,0,0,0,0,0,90,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,50,51,68,101,115,116,114,111,121,80,97,114,116,105,99,108,101,115,73,110,83,104,97,112,101,69,82,75,55,98,50,83,104,97,112,101,82,75,49,49,98,50,84,114,97,110,115,
102,111,114,109,98,69,51,49,68,101,115,116,114,111,121,80,97,114,116,105,99,108,101,115,73,110,83,104,97,112,101,67,97,108,108,98,97,99,107,0,0,0,0,0,0,88,35,0,0,0,31,0,0,248,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,16,0,0,0,32,0,0,0,64,0,0,0,96,0,0,0,128,0,0,0,160,0,0,0,192,0,0,0,224,0,0,0,0,1,0,0,64,1,0,0,128,1,0,0,192,1,0,0,0,2,0,0,128,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,76,105,113,117,105,100,70,117,110,32,49,46,49,46,48,0,104,34,0,0,0,0,0,0,25,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,83,116,57,116,121,112,101,95,105,110,102,111,0,0,0,0,48,35,0,0,160,34,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,54,95,95,115,104,105,109,95,116,121,112,101,95,105,110,
102,111,69,0,0,0,0,0,0,0,0,88,35,0,0,184,34,0,0,176,34,0,0,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,55,95,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,88,35,0,0,240,34,0,0,224,34,0,0,0,0,0,0,0,0,0,0,24,35,0,0,87,0,0,0,88,0,0,0,89,0,0,0,90,0,0,0,11,0,0,0,6,0,0,0,1,0,0,0,18,0,0,0,0,0,0,0,160,35,0,0,87,0,0,0,91,0,0,0,89,0,0,0,90,0,0,0,11,0,0,0,7,0,0,0,2,0,0,0,19,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,50,48,95,95,115,105,95,99,108,97,115,115,95,116,
121,112,101,95,105,110,102,111,69,0,0,0,0,88,35,0,0,120,35,0,0,24,35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,232,37,0,0,92,0,0,0,93,0,0,0,6,0,0,0,0,0,0,0,115,116,100,58,58,98,97,100,95,97,108,108,111,99,0,0,83,116,57,98,97,100,95,97,108,108,111,99,0,0,0,0,88,35,0,0,216,37,0,0,0,0,0,0,0,0,0,0],"i8",ALLOC_NONE,Runtime.GLOBAL_BASE);var tempDoublePtr=Runtime.alignMemory(allocate(12,"i8",ALLOC_STATIC),8);assert(tempDoublePtr%8==0);
function copyTempFloat(ptr){HEAP8[tempDoublePtr]=HEAP8[ptr];HEAP8[tempDoublePtr+1]=HEAP8[ptr+1];HEAP8[tempDoublePtr+2]=HEAP8[ptr+2];HEAP8[tempDoublePtr+3]=HEAP8[ptr+3]}function copyTempDouble(ptr){HEAP8[tempDoublePtr]=HEAP8[ptr];HEAP8[tempDoublePtr+1]=HEAP8[ptr+1];HEAP8[tempDoublePtr+2]=HEAP8[ptr+2];HEAP8[tempDoublePtr+3]=HEAP8[ptr+3];HEAP8[tempDoublePtr+4]=HEAP8[ptr+4];HEAP8[tempDoublePtr+5]=HEAP8[ptr+5];HEAP8[tempDoublePtr+6]=HEAP8[ptr+6];HEAP8[tempDoublePtr+7]=HEAP8[ptr+7]}
function _cosf(){return Math_cos.apply(null,arguments)}function ___cxa_pure_virtual(){ABORT=true;throw"Pure virtual function called!";}function _b2WorldEndContactBody(contactPtr){b2World.EndContactBody(contactPtr)}function _floorf(){return Math_floor.apply(null,arguments)}function __ZSt18uncaught_exceptionv(){return!!__ZSt18uncaught_exceptionv.uncaught_exception}
function ___cxa_is_number_type(type){var isNumber=false;try{if(type==__ZTIi)isNumber=true}catch(e){}try{if(type==__ZTIj)isNumber=true}catch(e){}try{if(type==__ZTIl)isNumber=true}catch(e){}try{if(type==__ZTIm)isNumber=true}catch(e){}try{if(type==__ZTIx)isNumber=true}catch(e){}try{if(type==__ZTIy)isNumber=true}catch(e){}try{if(type==__ZTIf)isNumber=true}catch(e){}try{if(type==__ZTId)isNumber=true}catch(e){}try{if(type==__ZTIe)isNumber=true}catch(e){}try{if(type==__ZTIc)isNumber=true}catch(e){}try{if(type==
__ZTIa)isNumber=true}catch(e){}try{if(type==__ZTIh)isNumber=true}catch(e){}try{if(type==__ZTIs)isNumber=true}catch(e){}try{if(type==__ZTIt)isNumber=true}catch(e){}return isNumber}
function ___cxa_does_inherit(definiteType,possibilityType,possibility){if(possibility==0)return false;if(possibilityType==0||possibilityType==definiteType)return true;var possibility_type_info;if(___cxa_is_number_type(possibilityType))possibility_type_info=possibilityType;else{var possibility_type_infoAddr=HEAP32[possibilityType>>2]-8;possibility_type_info=HEAP32[possibility_type_infoAddr>>2]}switch(possibility_type_info){case 0:var definite_type_infoAddr=HEAP32[definiteType>>2]-8;var definite_type_info=
HEAP32[definite_type_infoAddr>>2];if(definite_type_info==0){var defPointerBaseAddr=definiteType+8;var defPointerBaseType=HEAP32[defPointerBaseAddr>>2];var possPointerBaseAddr=possibilityType+8;var possPointerBaseType=HEAP32[possPointerBaseAddr>>2];return ___cxa_does_inherit(defPointerBaseType,possPointerBaseType,possibility)}else return false;case 1:return false;case 2:var parentTypeAddr=possibilityType+8;var parentType=HEAP32[parentTypeAddr>>2];return ___cxa_does_inherit(definiteType,parentType,
possibility);default:return false}}var ___cxa_last_thrown_exception=0;function ___resumeException(ptr){if(!___cxa_last_thrown_exception)___cxa_last_thrown_exception=ptr;throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";}var ___cxa_exception_header_size=8;
function ___cxa_find_matching_catch(thrown,throwntype){if(thrown==-1)thrown=___cxa_last_thrown_exception;header=thrown-___cxa_exception_header_size;if(throwntype==-1)throwntype=HEAP32[header>>2];var typeArray=Array.prototype.slice.call(arguments,2);if(throwntype!=0&&!___cxa_is_number_type(throwntype)){var throwntypeInfoAddr=HEAP32[throwntype>>2]-8;var throwntypeInfo=HEAP32[throwntypeInfoAddr>>2];if(throwntypeInfo==0)thrown=HEAP32[thrown>>2]}for(var i=0;i<typeArray.length;i++)if(___cxa_does_inherit(typeArray[i],
throwntype,thrown))return(asm["setTempRet0"](typeArray[i]),thrown)|0;return(asm["setTempRet0"](throwntype),thrown)|0}
function ___cxa_throw(ptr,type,destructor){if(!___cxa_throw.initialized){try{HEAP32[__ZTVN10__cxxabiv119__pointer_type_infoE>>2]=0}catch(e){}try{HEAP32[__ZTVN10__cxxabiv117__class_type_infoE>>2]=1}catch(e){}try{HEAP32[__ZTVN10__cxxabiv120__si_class_type_infoE>>2]=2}catch(e){}___cxa_throw.initialized=true}var header=ptr-___cxa_exception_header_size;HEAP32[header>>2]=type;HEAP32[header+4>>2]=destructor;___cxa_last_thrown_exception=ptr;if(!("uncaught_exception"in __ZSt18uncaught_exceptionv))__ZSt18uncaught_exceptionv.uncaught_exception=
1;else __ZSt18uncaught_exceptionv.uncaught_exception++;throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";}Module["_memset"]=_memset;function _b2WorldRayCastCallback(fixturePtr,pointX,pointY,normalX,normalY,fraction){return b2World.RayCast(fixturePtr,pointX,pointY,normalX,normalY,fraction)}var _FtoIHigh=true;function __exit(status){Module["exit"](status)}
function _exit(status){__exit(status)}function __ZSt9terminatev(){_exit(-1234)}function _abort(){Module["abort"]()}function _b2WorldBeginContactBody(contactPtr){b2World.BeginContactBody(contactPtr)}var ___cxa_caught_exceptions=[];function ___cxa_begin_catch(ptr){__ZSt18uncaught_exceptionv.uncaught_exception--;___cxa_caught_exceptions.push(___cxa_last_thrown_exception);return ptr}function _sinf(){return Math_sin.apply(null,arguments)}
function _b2WorldPostSolve(contactPtr,impulsePtr){b2World.PostSolve(contactPtr,impulsePtr)}Module["_strlen"]=_strlen;function _sqrtf(){return Math_sqrt.apply(null,arguments)}function _b2WorldQueryAABB(fixturePtr){return b2World.QueryAABB(fixturePtr)}Module["_i64Add"]=_i64Add;
function _sbrk(bytes){var self=_sbrk;if(!self.called){DYNAMICTOP=alignMemoryPage(DYNAMICTOP);self.called=true;assert(Runtime.dynamicAlloc);self.alloc=Runtime.dynamicAlloc;Runtime.dynamicAlloc=function(){abort("cannot dynamically allocate, sbrk now has control")}}var ret=DYNAMICTOP;if(bytes!=0)self.alloc(bytes);return ret}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);return dest}Module["_memcpy"]=_memcpy;Module["_memmove"]=_memmove;var ___errno_state=0;
function ___setErrNo(value){HEAP32[___errno_state>>2]=value;return value}function ___errno_location(){return ___errno_state}var _FtoILow=true;function __ZNSt9exceptionD2Ev(){}function _b2WorldPreSolve(contactPtr,oldManifoldPtr){b2World.PreSolve(contactPtr,oldManifoldPtr)}
var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,
ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,
ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};
var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",
23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",
43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",
64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",
81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",
98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can't send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",
115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};
var TTY={ttys:[],init:function(){},shutdown:function(){},register:function(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open:function(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty)throw new FS.ErrnoError(ERRNO_CODES.ENODEV);stream.tty=tty;stream.seekable=false},close:function(stream){if(stream.tty.output.length)stream.tty.ops.put_char(stream.tty,10)},read:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char)throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO);}if(result===undefined&&bytesRead===0)throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead)stream.node.timestamp=Date.now();return bytesRead},write:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char)throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
for(var i=0;i<length;i++)try{stream.tty.ops.put_char(stream.tty,buffer[offset+i])}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO);}if(length)stream.node.timestamp=Date.now();return i}},default_tty_ops:{get_char:function(tty){if(!tty.input.length){var result=null;if(ENVIRONMENT_IS_NODE){result=process["stdin"]["read"]();if(!result){if(process["stdin"]["_readableState"]&&process["stdin"]["_readableState"]["ended"])return null;return undefined}}else if(typeof window!="undefined"&&typeof window.prompt==
"function"){result=window.prompt("Input: ");if(result!==null)result+="\n"}else if(typeof readline=="function"){result=readline();if(result!==null)result+="\n"}if(!result)return null;tty.input=intArrayFromString(result,true)}return tty.input.shift()},put_char:function(tty,val){if(val===null||val===10){Module["print"](tty.output.join(""));tty.output=[]}else tty.output.push(TTY.utf8.processCChar(val))}},default_tty1_ops:{put_char:function(tty,val){if(val===null||val===10){Module["printErr"](tty.output.join(""));
tty.output=[]}else tty.output.push(TTY.utf8.processCChar(val))}}};
var MEMFS={ops_table:null,mount:function(mount){return MEMFS.createNode(null,"/",16384|511,0)},createNode:function(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode))throw new FS.ErrnoError(ERRNO_CODES.EPERM);if(!MEMFS.ops_table)MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},
stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};
var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;
node.stream_ops=MEMFS.ops_table.chrdev.stream}node.timestamp=Date.now();if(parent)parent.contents[name]=node;return node},getFileDataAsRegularArray:function(node){if(node.contents&&node.contents.subarray){var arr=[];for(var i=0;i<node.usedBytes;++i)arr.push(node.contents[i]);return arr}return node.contents},getFileDataAsTypedArray:function(node){if(node.contents&&node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage:function(node,
newCapacity){if(node.contents&&node.contents.subarray&&newCapacity>node.contents.length){node.contents=MEMFS.getFileDataAsRegularArray(node);node.usedBytes=node.contents.length}if(!node.contents||node.contents.subarray){var prevCapacity=node.contents?node.contents.buffer.byteLength:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)|0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,
256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0);return}if(!node.contents&&newCapacity>0)node.contents=[];while(node.contents.length<newCapacity)node.contents.push(0)},resizeFileStorage:function(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0;return}if(!node.contents||node.contents.subarray){var oldContents=node.contents;node.contents=new Uint8Array(new ArrayBuffer(newSize));
node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)));node.usedBytes=newSize;return}if(!node.contents)node.contents=[];if(node.contents.length>newSize)node.contents.length=newSize;else while(node.contents.length<newSize)node.contents.push(0);node.usedBytes=newSize},node_ops:{getattr:function(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode))attr.size=4096;
else if(FS.isFile(node.mode))attr.size=node.usedBytes;else if(FS.isLink(node.mode))attr.size=node.link.length;else attr.size=0;attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr:function(node,attr){if(attr.mode!==undefined)node.mode=attr.mode;if(attr.timestamp!==undefined)node.timestamp=attr.timestamp;if(attr.size!==undefined)MEMFS.resizeFileStorage(node,attr.size)},
lookup:function(parent,name){throw FS.genericErrors[ERRNO_CODES.ENOENT];},mknod:function(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename:function(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node)for(var i in new_node.contents)throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);}delete old_node.parent.contents[old_node.name];old_node.name=new_name;new_dir.contents[new_name]=old_node;old_node.parent=
new_dir},unlink:function(parent,name){delete parent.contents[name]},rmdir:function(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents)throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);delete parent.contents[name]},readdir:function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key))continue;entries.push(key)}return entries},symlink:function(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;
return node},readlink:function(node){if(!FS.isLink(node.mode))throw new FS.ErrnoError(ERRNO_CODES.EINVAL);return node.link}},stream_ops:{read:function(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);assert(size>=0);if(size>8&&contents.subarray)buffer.set(contents.subarray(position,position+size),offset);else for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i];return size},
write:function(stream,buffer,offset,length,position,canOwn){if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray))if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=new Uint8Array(buffer.subarray(offset,offset+length));node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,
offset+length),position);return length}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray)node.contents.set(buffer.subarray(offset,offset+length),position);else for(var i=0;i<length;i++)node.contents[position+i]=buffer[offset+i];node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek:function(stream,offset,whence){var position=offset;if(whence===1)position+=stream.position;else if(whence===2)if(FS.isFile(stream.node.mode))position+=stream.node.usedBytes;
if(position<0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);stream.ungotten=[];stream.position=position;return position},allocate:function(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length)},mmap:function(stream,buffer,offset,length,position,prot,flags){if(!FS.isFile(stream.node.mode))throw new FS.ErrnoError(ERRNO_CODES.ENODEV);var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&(contents.buffer===
buffer||contents.buffer===buffer.buffer)){allocated=false;ptr=contents.byteOffset}else{if(position>0||position+length<stream.node.usedBytes)if(contents.subarray)contents=contents.subarray(position,position+length);else contents=Array.prototype.slice.call(contents,position,position+length);allocated=true;ptr=_malloc(length);if(!ptr)throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);buffer.set(contents,ptr)}return{ptr:ptr,allocated:allocated}}}};
var IDBFS={dbs:{},indexedDB:function(){return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:function(mount){return MEMFS.mount.apply(null,arguments)},syncfs:function(mount,populate,callback){IDBFS.getLocalSet(mount,function(err,local){if(err)return callback(err);IDBFS.getRemoteSet(mount,function(err,remote){if(err)return callback(err);var src=populate?remote:local;var dst=populate?local:remote;IDBFS.reconcile(src,dst,
callback)})})},getDB:function(name,callback){var db=IDBFS.dbs[name];if(db)return callback(null,db);var req;try{req=IDBFS.indexedDB().open(name,IDBFS.DB_VERSION)}catch(e){return callback(e)}req.onupgradeneeded=function(e){var db=e.target.result;var transaction=e.target.transaction;var fileStore;if(db.objectStoreNames.contains(IDBFS.DB_STORE_NAME))fileStore=transaction.objectStore(IDBFS.DB_STORE_NAME);else fileStore=db.createObjectStore(IDBFS.DB_STORE_NAME);fileStore.createIndex("timestamp","timestamp",
{unique:false})};req.onsuccess=function(){db=req.result;IDBFS.dbs[name]=db;callback(null,db)};req.onerror=function(){callback(this.error)}},getLocalSet:function(mount,callback){var entries={};function isRealDir(p){return p!=="."&&p!==".."}function toAbsolute(root){return function(p){return PATH.join2(root,p)}}var check=FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));while(check.length){var path=check.pop();var stat;try{stat=FS.stat(path)}catch(e){return callback(e)}if(FS.isDir(stat.mode))check.push.apply(check,
FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));entries[path]={timestamp:stat.mtime}}return callback(null,{type:"local",entries:entries})},getRemoteSet:function(mount,callback){var entries={};IDBFS.getDB(mount.mountpoint,function(err,db){if(err)return callback(err);var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readonly");transaction.onerror=function(){callback(this.error)};var store=transaction.objectStore(IDBFS.DB_STORE_NAME);var index=store.index("timestamp");index.openKeyCursor().onsuccess=
function(event){var cursor=event.target.result;if(!cursor)return callback(null,{type:"remote",db:db,entries:entries});entries[cursor.primaryKey]={timestamp:cursor.key};cursor.continue()}})},loadLocalEntry:function(path,callback){var stat,node;try{var lookup=FS.lookupPath(path);node=lookup.node;stat=FS.stat(path)}catch(e){return callback(e)}if(FS.isDir(stat.mode))return callback(null,{timestamp:stat.mtime,mode:stat.mode});else if(FS.isFile(stat.mode)){node.contents=MEMFS.getFileDataAsTypedArray(node);
return callback(null,{timestamp:stat.mtime,mode:stat.mode,contents:node.contents})}else return callback(new Error("node type not supported"))},storeLocalEntry:function(path,entry,callback){try{if(FS.isDir(entry.mode))FS.mkdir(path,entry.mode);else if(FS.isFile(entry.mode))FS.writeFile(path,entry.contents,{encoding:"binary",canOwn:true});else return callback(new Error("node type not supported"));FS.utime(path,entry.timestamp,entry.timestamp)}catch(e){return callback(e)}callback(null)},removeLocalEntry:function(path,
callback){try{var lookup=FS.lookupPath(path);var stat=FS.stat(path);if(FS.isDir(stat.mode))FS.rmdir(path);else if(FS.isFile(stat.mode))FS.unlink(path)}catch(e){return callback(e)}callback(null)},loadRemoteEntry:function(store,path,callback){var req=store.get(path);req.onsuccess=function(event){callback(null,event.target.result)};req.onerror=function(){callback(this.error)}},storeRemoteEntry:function(store,path,entry,callback){var req=store.put(entry,path);req.onsuccess=function(){callback(null)};
req.onerror=function(){callback(this.error)}},removeRemoteEntry:function(store,path,callback){var req=store.delete(path);req.onsuccess=function(){callback(null)};req.onerror=function(){callback(this.error)}},reconcile:function(src,dst,callback){var total=0;var create=[];Object.keys(src.entries).forEach(function(key){var e=src.entries[key];var e2=dst.entries[key];if(!e2||e.timestamp>e2.timestamp){create.push(key);total++}});var remove=[];Object.keys(dst.entries).forEach(function(key){var e=dst.entries[key];
var e2=src.entries[key];if(!e2){remove.push(key);total++}});if(!total)return callback(null);var errored=false;var completed=0;var db=src.type==="remote"?src.db:dst.db;var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readwrite");var store=transaction.objectStore(IDBFS.DB_STORE_NAME);function done(err){if(err){if(!done.errored){done.errored=true;return callback(err)}return}if(++completed>=total)return callback(null)}transaction.onerror=function(){done(this.error)};create.sort().forEach(function(path){if(dst.type===
"local")IDBFS.loadRemoteEntry(store,path,function(err,entry){if(err)return done(err);IDBFS.storeLocalEntry(path,entry,done)});else IDBFS.loadLocalEntry(path,function(err,entry){if(err)return done(err);IDBFS.storeRemoteEntry(store,path,entry,done)})});remove.sort().reverse().forEach(function(path){if(dst.type==="local")IDBFS.removeLocalEntry(path,done);else IDBFS.removeRemoteEntry(store,path,done)})}};
var NODEFS={isWindows:false,staticInit:function(){NODEFS.isWindows=!!process.platform.match(/^win/)},mount:function(mount){assert(ENVIRONMENT_IS_NODE);return NODEFS.createNode(null,"/",NODEFS.getMode(mount.opts.root),0)},createNode:function(parent,name,mode,dev){if(!FS.isDir(mode)&&!FS.isFile(mode)&&!FS.isLink(mode))throw new FS.ErrnoError(ERRNO_CODES.EINVAL);var node=FS.createNode(parent,name,mode);node.node_ops=NODEFS.node_ops;node.stream_ops=NODEFS.stream_ops;return node},getMode:function(path){var stat;
try{stat=fs.lstatSync(path);if(NODEFS.isWindows)stat.mode=stat.mode|(stat.mode&146)>>1}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}return stat.mode},realPath:function(node){var parts=[];while(node.parent!==node){parts.push(node.name);node=node.parent}parts.push(node.mount.opts.root);parts.reverse();return PATH.join.apply(null,parts)},flagsToPermissionStringMap:{0:"r",1:"r+",2:"r+",64:"r",65:"r+",66:"r+",129:"rx+",193:"rx+",514:"w+",577:"w",578:"w+",705:"wx",706:"wx+",
1024:"a",1025:"a",1026:"a+",1089:"a",1090:"a+",1153:"ax",1154:"ax+",1217:"ax",1218:"ax+",4096:"rs",4098:"rs+"},flagsToPermissionString:function(flags){if(flags in NODEFS.flagsToPermissionStringMap)return NODEFS.flagsToPermissionStringMap[flags];else return flags},node_ops:{getattr:function(node){var path=NODEFS.realPath(node);var stat;try{stat=fs.lstatSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}if(NODEFS.isWindows&&!stat.blksize)stat.blksize=4096;if(NODEFS.isWindows&&
!stat.blocks)stat.blocks=(stat.size+stat.blksize-1)/stat.blksize|0;return{dev:stat.dev,ino:stat.ino,mode:stat.mode,nlink:stat.nlink,uid:stat.uid,gid:stat.gid,rdev:stat.rdev,size:stat.size,atime:stat.atime,mtime:stat.mtime,ctime:stat.ctime,blksize:stat.blksize,blocks:stat.blocks}},setattr:function(node,attr){var path=NODEFS.realPath(node);try{if(attr.mode!==undefined){fs.chmodSync(path,attr.mode);node.mode=attr.mode}if(attr.timestamp!==undefined){var date=new Date(attr.timestamp);fs.utimesSync(path,
date,date)}if(attr.size!==undefined)fs.truncateSync(path,attr.size)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}},lookup:function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);var mode=NODEFS.getMode(path);return NODEFS.createNode(parent,name,mode)},mknod:function(parent,name,mode,dev){var node=NODEFS.createNode(parent,name,mode,dev);var path=NODEFS.realPath(node);try{if(FS.isDir(node.mode))fs.mkdirSync(path,node.mode);else fs.writeFileSync(path,"",{mode:node.mode})}catch(e){if(!e.code)throw e;
throw new FS.ErrnoError(ERRNO_CODES[e.code]);}return node},rename:function(oldNode,newDir,newName){var oldPath=NODEFS.realPath(oldNode);var newPath=PATH.join2(NODEFS.realPath(newDir),newName);try{fs.renameSync(oldPath,newPath)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}},unlink:function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.unlinkSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}},rmdir:function(parent,
name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.rmdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}},readdir:function(node){var path=NODEFS.realPath(node);try{return fs.readdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}},symlink:function(parent,newName,oldPath){var newPath=PATH.join2(NODEFS.realPath(parent),newName);try{fs.symlinkSync(oldPath,newPath)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);
}},readlink:function(node){var path=NODEFS.realPath(node);try{return fs.readlinkSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}}},stream_ops:{open:function(stream){var path=NODEFS.realPath(stream.node);try{if(FS.isFile(stream.node.mode))stream.nfd=fs.openSync(path,NODEFS.flagsToPermissionString(stream.flags))}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}},close:function(stream){try{if(FS.isFile(stream.node.mode)&&stream.nfd)fs.closeSync(stream.nfd)}catch(e){if(!e.code)throw e;
throw new FS.ErrnoError(ERRNO_CODES[e.code]);}},read:function(stream,buffer,offset,length,position){var nbuffer=new Buffer(length);var res;try{res=fs.readSync(stream.nfd,nbuffer,0,length,position)}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code]);}if(res>0)for(var i=0;i<res;i++)buffer[offset+i]=nbuffer[i];return res},write:function(stream,buffer,offset,length,position){var nbuffer=new Buffer(buffer.subarray(offset,offset+length));var res;try{res=fs.writeSync(stream.nfd,nbuffer,0,length,position)}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code]);
}return res},llseek:function(stream,offset,whence){var position=offset;if(whence===1)position+=stream.position;else if(whence===2)if(FS.isFile(stream.node.mode))try{var stat=fs.fstatSync(stream.nfd);position+=stat.size}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code]);}if(position<0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);stream.position=position;return position}}};var _stdin=allocate(1,"i32*",ALLOC_STATIC);var _stdout=allocate(1,"i32*",ALLOC_STATIC);var _stderr=allocate(1,"i32*",ALLOC_STATIC);
function _fflush(stream){}
var FS={root:null,mounts:[],devices:[null],streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},handleFSError:function(e){if(!(e instanceof FS.ErrnoError))throw e+" : "+stackTrace();return ___setErrNo(e.errno)},lookupPath:function(path,opts){path=PATH.resolve(FS.cwd(),path);opts=opts||{};var defaults={follow_mount:true,recurse_count:0};for(var key in defaults)if(opts[key]===undefined)opts[key]=
defaults[key];if(opts.recurse_count>8)throw new FS.ErrnoError(ERRNO_CODES.ELOOP);var parts=PATH.normalizeArray(path.split("/").filter(function(p){return!!p}),false);var current=FS.root;var current_path="/";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent)break;current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current))if(!islast||islast&&opts.follow_mount)current=current.mounted.root;if(!islast||opts.follow){var count=
0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count});current=lookup.node;if(count++>40)throw new FS.ErrnoError(ERRNO_CODES.ELOOP);}}}return{path:current_path,node:current}},getPath:function(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!=="/"?mount+"/"+path:mount+path}path=
path?node.name+"/"+path:node.name;node=node.parent}},hashName:function(parentid,name){var hash=0;for(var i=0;i<name.length;i++)hash=(hash<<5)-hash+name.charCodeAt(i)|0;return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode:function(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode:function(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node)FS.nameTable[hash]=node.name_next;else{var current=
FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode:function(parent,name){var err=FS.mayLookup(parent);if(err)throw new FS.ErrnoError(err);var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name)return node}return FS.lookup(parent,name)},createNode:function(parent,name,mode,rdev){if(!FS.FSNode){FS.FSNode=
function(parent,name,mode,rdev){if(!parent)parent=this;this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev};FS.FSNode.prototype={};var readMode=292|73;var writeMode=146;Object.defineProperties(FS.FSNode.prototype,{read:{get:function(){return(this.mode&readMode)===readMode},set:function(val){val?this.mode|=readMode:this.mode&=~readMode}},write:{get:function(){return(this.mode&writeMode)===
writeMode},set:function(val){val?this.mode|=writeMode:this.mode&=~writeMode}},isFolder:{get:function(){return FS.isDir(this.mode)}},isDevice:{get:function(){return FS.isChrdev(this.mode)}}})}var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode:function(node){FS.hashRemoveNode(node)},isRoot:function(node){return node===node.parent},isMountpoint:function(node){return!!node.mounted},isFile:function(mode){return(mode&61440)===32768},isDir:function(mode){return(mode&
61440)===16384},isLink:function(mode){return(mode&61440)===40960},isChrdev:function(mode){return(mode&61440)===8192},isBlkdev:function(mode){return(mode&61440)===24576},isFIFO:function(mode){return(mode&61440)===4096},isSocket:function(mode){return(mode&49152)===49152},flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function(str){var flags=FS.flagModes[str];if(typeof flags===
"undefined")throw new Error("Unknown file open mode: "+str);return flags},flagsToPermissionString:function(flag){var accmode=flag&2097155;var perms=["r","w","rw"][accmode];if(flag&512)perms+="w";return perms},nodePermissions:function(node,perms){if(FS.ignorePermissions)return 0;if(perms.indexOf("r")!==-1&&!(node.mode&292))return ERRNO_CODES.EACCES;else if(perms.indexOf("w")!==-1&&!(node.mode&146))return ERRNO_CODES.EACCES;else if(perms.indexOf("x")!==-1&&!(node.mode&73))return ERRNO_CODES.EACCES;
return 0},mayLookup:function(dir){return FS.nodePermissions(dir,"x")},mayCreate:function(dir,name){try{var node=FS.lookupNode(dir,name);return ERRNO_CODES.EEXIST}catch(e){}return FS.nodePermissions(dir,"wx")},mayDelete:function(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var err=FS.nodePermissions(dir,"wx");if(err)return err;if(isdir){if(!FS.isDir(node.mode))return ERRNO_CODES.ENOTDIR;if(FS.isRoot(node)||FS.getPath(node)===FS.cwd())return ERRNO_CODES.EBUSY}else if(FS.isDir(node.mode))return ERRNO_CODES.EISDIR;
return 0},mayOpen:function(node,flags){if(!node)return ERRNO_CODES.ENOENT;if(FS.isLink(node.mode))return ERRNO_CODES.ELOOP;else if(FS.isDir(node.mode))if((flags&2097155)!==0||flags&512)return ERRNO_CODES.EISDIR;return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},MAX_OPEN_FDS:4096,nextfd:function(fd_start,fd_end){fd_start=fd_start||0;fd_end=fd_end||FS.MAX_OPEN_FDS;for(var fd=fd_start;fd<=fd_end;fd++)if(!FS.streams[fd])return fd;throw new FS.ErrnoError(ERRNO_CODES.EMFILE);},getStream:function(fd){return FS.streams[fd]},
createStream:function(stream,fd_start,fd_end){if(!FS.FSStream){FS.FSStream=function(){};FS.FSStream.prototype={};Object.defineProperties(FS.FSStream.prototype,{object:{get:function(){return this.node},set:function(val){this.node=val}},isRead:{get:function(){return(this.flags&2097155)!==1}},isWrite:{get:function(){return(this.flags&2097155)!==0}},isAppend:{get:function(){return this.flags&1024}}})}var newStream=new FS.FSStream;for(var p in stream)newStream[p]=stream[p];stream=newStream;var fd=FS.nextfd(fd_start,
fd_end);stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream:function(fd){FS.streams[fd]=null},getStreamFromPtr:function(ptr){return FS.streams[ptr-1]},getPtrForStream:function(stream){return stream?stream.fd+1:0},chrdev_stream_ops:{open:function(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;if(stream.stream_ops.open)stream.stream_ops.open(stream)},llseek:function(){throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);}},major:function(dev){return dev>>8},minor:function(dev){return dev&
255},makedev:function(ma,mi){return ma<<8|mi},registerDevice:function(dev,ops){FS.devices[dev]={stream_ops:ops}},getDevice:function(dev){return FS.devices[dev]},getMounts:function(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push.apply(check,m.mounts)}return mounts},syncfs:function(populate,callback){if(typeof populate==="function"){callback=populate;populate=false}var mounts=FS.getMounts(FS.root.mount);var completed=0;function done(err){if(err){if(!done.errored){done.errored=
true;return callback(err)}return}if(++completed>=mounts.length)callback(null)}mounts.forEach(function(mount){if(!mount.type.syncfs)return done(null);mount.type.syncfs(mount,populate,done)})},mount:function(type,opts,mountpoint){var root=mountpoint==="/";var pseudo=!mountpoint;var node;if(root&&FS.root)throw new FS.ErrnoError(ERRNO_CODES.EBUSY);else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node))throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
if(!FS.isDir(node.mode))throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root)FS.root=mountRoot;else if(node){node.mounted=mount;if(node.mount)node.mount.mounts.push(mount)}return mountRoot},unmount:function(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node))throw new FS.ErrnoError(ERRNO_CODES.EINVAL);var node=
lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(function(hash){var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.indexOf(current.mount)!==-1)FS.destroyNode(current);current=next}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);assert(idx!==-1);node.mount.mounts.splice(idx,1)},lookup:function(parent,name){return parent.node_ops.lookup(parent,name)},mknod:function(path,mode,dev){var lookup=FS.lookupPath(path,
{parent:true});var parent=lookup.node;var name=PATH.basename(path);var err=FS.mayCreate(parent,name);if(err)throw new FS.ErrnoError(err);if(!parent.node_ops.mknod)throw new FS.ErrnoError(ERRNO_CODES.EPERM);return parent.node_ops.mknod(parent,name,mode,dev)},create:function(path,mode){mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir:function(path,mode){mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdev:function(path,
mode,dev){if(typeof dev==="undefined"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink:function(oldpath,newpath){var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;var newname=PATH.basename(newpath);var err=FS.mayCreate(parent,newname);if(err)throw new FS.ErrnoError(err);if(!parent.node_ops.symlink)throw new FS.ErrnoError(ERRNO_CODES.EPERM);return parent.node_ops.symlink(parent,newname,oldpath)},rename:function(old_path,new_path){var old_dirname=PATH.dirname(old_path);
var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;try{lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EBUSY);}if(old_dir.mount!==new_dir.mount)throw new FS.ErrnoError(ERRNO_CODES.EXDEV);var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH.relative(old_path,new_dirname);if(relative.charAt(0)!==
".")throw new FS.ErrnoError(ERRNO_CODES.EINVAL);relative=PATH.relative(new_path,old_dirname);if(relative.charAt(0)!==".")throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node)return;var isdir=FS.isDir(old_node.mode);var err=FS.mayDelete(old_dir,old_name,isdir);if(err)throw new FS.ErrnoError(err);err=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(err)throw new FS.ErrnoError(err);if(!old_dir.node_ops.rename)throw new FS.ErrnoError(ERRNO_CODES.EPERM);
if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node))throw new FS.ErrnoError(ERRNO_CODES.EBUSY);if(new_dir!==old_dir){err=FS.nodePermissions(old_dir,"w");if(err)throw new FS.ErrnoError(err);}try{if(FS.trackingDelegate["willMovePath"])FS.trackingDelegate["willMovePath"](old_path,new_path)}catch(e){console.log("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message)}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name)}catch(e){throw e;
}finally{FS.hashAddNode(old_node)}try{if(FS.trackingDelegate["onMovePath"])FS.trackingDelegate["onMovePath"](old_path,new_path)}catch(e){console.log("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message)}},rmdir:function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,true);if(err)throw new FS.ErrnoError(err);if(!parent.node_ops.rmdir)throw new FS.ErrnoError(ERRNO_CODES.EPERM);
if(FS.isMountpoint(node))throw new FS.ErrnoError(ERRNO_CODES.EBUSY);try{if(FS.trackingDelegate["willDeletePath"])FS.trackingDelegate["willDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message)}},
readdir:function(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir)throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);return node.node_ops.readdir(node)},unlink:function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,false);if(err){if(err===ERRNO_CODES.EISDIR)err=ERRNO_CODES.EPERM;throw new FS.ErrnoError(err);}if(!parent.node_ops.unlink)throw new FS.ErrnoError(ERRNO_CODES.EPERM);
if(FS.isMountpoint(node))throw new FS.ErrnoError(ERRNO_CODES.EBUSY);try{if(FS.trackingDelegate["willDeletePath"])FS.trackingDelegate["willDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message)}parent.node_ops.unlink(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message)}},
readlink:function(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link.node_ops.readlink)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);return link.node_ops.readlink(link)},stat:function(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node.node_ops.getattr)throw new FS.ErrnoError(ERRNO_CODES.EPERM);return node.node_ops.getattr(node)},lstat:function(path){return FS.stat(path,true)},chmod:function(path,mode,dontFollow){var node;if(typeof path===
"string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else node=path;if(!node.node_ops.setattr)throw new FS.ErrnoError(ERRNO_CODES.EPERM);node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()})},lchmod:function(path,mode){FS.chmod(path,mode,true)},fchmod:function(fd,mode){var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);FS.chmod(stream.node,mode)},chown:function(path,uid,gid,dontFollow){var node;if(typeof path==="string"){var lookup=
FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else node=path;if(!node.node_ops.setattr)throw new FS.ErrnoError(ERRNO_CODES.EPERM);node.node_ops.setattr(node,{timestamp:Date.now()})},lchown:function(path,uid,gid){FS.chown(path,uid,gid,true)},fchown:function(fd,uid,gid){var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);FS.chown(stream.node,uid,gid)},truncate:function(path,len){if(len<0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);var node;if(typeof path===
"string"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else node=path;if(!node.node_ops.setattr)throw new FS.ErrnoError(ERRNO_CODES.EPERM);if(FS.isDir(node.mode))throw new FS.ErrnoError(ERRNO_CODES.EISDIR);if(!FS.isFile(node.mode))throw new FS.ErrnoError(ERRNO_CODES.EINVAL);var err=FS.nodePermissions(node,"w");if(err)throw new FS.ErrnoError(err);node.node_ops.setattr(node,{size:len,timestamp:Date.now()})},ftruncate:function(fd,len){var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);
if((stream.flags&2097155)===0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);FS.truncate(stream.node,len)},utime:function(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)})},open:function(path,flags,mode,fd_start,fd_end){flags=typeof flags==="string"?FS.modeStringToFlags(flags):flags;mode=typeof mode==="undefined"?438:mode;if(flags&64)mode=mode&4095|32768;else mode=0;var node;if(typeof path==="object")node=
path;else{path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node}catch(e){}}if(flags&64)if(node){if(flags&128)throw new FS.ErrnoError(ERRNO_CODES.EEXIST);}else node=FS.mknod(path,mode,0);if(!node)throw new FS.ErrnoError(ERRNO_CODES.ENOENT);if(FS.isChrdev(node.mode))flags&=~512;var err=FS.mayOpen(node,flags);if(err)throw new FS.ErrnoError(err);if(flags&512)FS.truncate(node,0);flags&=~(128|512);var stream=FS.createStream({node:node,path:FS.getPath(node),
flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false},fd_start,fd_end);if(stream.stream_ops.open)stream.stream_ops.open(stream);if(Module["logReadFiles"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1;Module["printErr"]("read file: "+path)}}try{if(FS.trackingDelegate["onOpenFile"]){var trackingFlags=0;if((flags&2097155)!==1)trackingFlags|=FS.tracking.openFlags.READ;if((flags&2097155)!==0)trackingFlags|=FS.tracking.openFlags.WRITE;
FS.trackingDelegate["onOpenFile"](path,trackingFlags)}}catch(e){console.log("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: "+e.message)}return stream},close:function(stream){try{if(stream.stream_ops.close)stream.stream_ops.close(stream)}catch(e){throw e;}finally{FS.closeStream(stream.fd)}},llseek:function(stream,offset,whence){if(!stream.seekable||!stream.stream_ops.llseek)throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);return stream.stream_ops.llseek(stream,offset,whence)},
read:function(stream,buffer,offset,length,position){if(length<0||position<0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);if((stream.flags&2097155)===1)throw new FS.ErrnoError(ERRNO_CODES.EBADF);if(FS.isDir(stream.node.mode))throw new FS.ErrnoError(ERRNO_CODES.EISDIR);if(!stream.stream_ops.read)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);var seeking=true;if(typeof position==="undefined"){position=stream.position;seeking=false}else if(!stream.seekable)throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);var bytesRead=
stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write:function(stream,buffer,offset,length,position,canOwn){if(length<0||position<0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);if((stream.flags&2097155)===0)throw new FS.ErrnoError(ERRNO_CODES.EBADF);if(FS.isDir(stream.node.mode))throw new FS.ErrnoError(ERRNO_CODES.EISDIR);if(!stream.stream_ops.write)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);if(stream.flags&1024)FS.llseek(stream,
0,2);var seeking=true;if(typeof position==="undefined"){position=stream.position;seeking=false}else if(!stream.seekable)throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;try{if(stream.path&&FS.trackingDelegate["onWriteToFile"])FS.trackingDelegate["onWriteToFile"](stream.path)}catch(e){console.log("FS.trackingDelegate['onWriteToFile']('"+path+"') threw an exception: "+e.message)}return bytesWritten},
allocate:function(stream,offset,length){if(offset<0||length<=0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);if((stream.flags&2097155)===0)throw new FS.ErrnoError(ERRNO_CODES.EBADF);if(!FS.isFile(stream.node.mode)&&!FS.isDir(node.mode))throw new FS.ErrnoError(ERRNO_CODES.ENODEV);if(!stream.stream_ops.allocate)throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);stream.stream_ops.allocate(stream,offset,length)},mmap:function(stream,buffer,offset,length,position,prot,flags){if((stream.flags&2097155)===1)throw new FS.ErrnoError(ERRNO_CODES.EACCES);
if(!stream.stream_ops.mmap)throw new FS.ErrnoError(ERRNO_CODES.ENODEV);return stream.stream_ops.mmap(stream,buffer,offset,length,position,prot,flags)},ioctl:function(stream,cmd,arg){if(!stream.stream_ops.ioctl)throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);return stream.stream_ops.ioctl(stream,cmd,arg)},readFile:function(path,opts){opts=opts||{};opts.flags=opts.flags||"r";opts.encoding=opts.encoding||"binary";if(opts.encoding!=="utf8"&&opts.encoding!=="binary")throw new Error('Invalid encoding type "'+
opts.encoding+'"');var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding==="utf8"){ret="";var utf8=new Runtime.UTF8Processor;for(var i=0;i<length;i++)ret+=utf8.processCChar(buf[i])}else if(opts.encoding==="binary")ret=buf;FS.close(stream);return ret},writeFile:function(path,data,opts){opts=opts||{};opts.flags=opts.flags||"w";opts.encoding=opts.encoding||"utf8";if(opts.encoding!=="utf8"&&
opts.encoding!=="binary")throw new Error('Invalid encoding type "'+opts.encoding+'"');var stream=FS.open(path,opts.flags,opts.mode);if(opts.encoding==="utf8"){var utf8=new Runtime.UTF8Processor;var buf=new Uint8Array(utf8.processJSString(data));FS.write(stream,buf,0,buf.length,0,opts.canOwn)}else if(opts.encoding==="binary")FS.write(stream,data,0,data.length,0,opts.canOwn);FS.close(stream)},cwd:function(){return FS.currentPath},chdir:function(path){var lookup=FS.lookupPath(path,{follow:true});if(!FS.isDir(lookup.node.mode))throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
var err=FS.nodePermissions(lookup.node,"x");if(err)throw new FS.ErrnoError(err);FS.currentPath=lookup.path},createDefaultDirectories:function(){FS.mkdir("/tmp")},createDefaultDevices:function(){FS.mkdir("/dev");FS.registerDevice(FS.makedev(1,3),{read:function(){return 0},write:function(){return 0}});FS.mkdev("/dev/null",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev("/dev/tty",FS.makedev(5,0));FS.mkdev("/dev/tty1",FS.makedev(6,
0));FS.mkdir("/dev/shm");FS.mkdir("/dev/shm/tmp")},createStandardStreams:function(){if(Module["stdin"])FS.createDevice("/dev","stdin",Module["stdin"]);else FS.symlink("/dev/tty","/dev/stdin");if(Module["stdout"])FS.createDevice("/dev","stdout",null,Module["stdout"]);else FS.symlink("/dev/tty","/dev/stdout");if(Module["stderr"])FS.createDevice("/dev","stderr",null,Module["stderr"]);else FS.symlink("/dev/tty1","/dev/stderr");var stdin=FS.open("/dev/stdin","r");HEAP32[_stdin>>2]=FS.getPtrForStream(stdin);
assert(stdin.fd===0,"invalid handle for stdin ("+stdin.fd+")");var stdout=FS.open("/dev/stdout","w");HEAP32[_stdout>>2]=FS.getPtrForStream(stdout);assert(stdout.fd===1,"invalid handle for stdout ("+stdout.fd+")");var stderr=FS.open("/dev/stderr","w");HEAP32[_stderr>>2]=FS.getPtrForStream(stderr);assert(stderr.fd===2,"invalid handle for stderr ("+stderr.fd+")")},ensureErrnoError:function(){if(FS.ErrnoError)return;FS.ErrnoError=function ErrnoError(errno){this.errno=errno;for(var key in ERRNO_CODES)if(ERRNO_CODES[key]===
errno){this.code=key;break}this.message=ERRNO_MESSAGES[errno]};FS.ErrnoError.prototype=new Error;FS.ErrnoError.prototype.constructor=FS.ErrnoError;[ERRNO_CODES.ENOENT].forEach(function(code){FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack="<generic error, no stack>"})},staticInit:function(){FS.ensureErrnoError();FS.nameTable=new Array(4096);FS.mount(MEMFS,{},"/");FS.createDefaultDirectories();FS.createDefaultDevices()},init:function(input,output,error){assert(!FS.init.initialized,
"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");FS.init.initialized=true;FS.ensureErrnoError();Module["stdin"]=input||Module["stdin"];Module["stdout"]=output||Module["stdout"];Module["stderr"]=error||Module["stderr"];FS.createStandardStreams()},quit:function(){FS.init.initialized=false;for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream)continue;FS.close(stream)}},
getMode:function(canRead,canWrite){var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode},joinPath:function(parts,forceRelative){var path=PATH.join.apply(null,parts);if(forceRelative&&path[0]=="/")path=path.substr(1);return path},absolutePath:function(relative,base){return PATH.resolve(base,relative)},standardizePath:function(path){return PATH.normalize(path)},findObject:function(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(ret.exists)return ret.object;
else{___setErrNo(ret.error);return null}},analyzePath:function(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});
ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path==="/"}catch(e){ret.error=e.errno}return ret},createFolder:function(parent,name,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.mkdir(path,mode)},createPath:function(parent,path,canRead,canWrite){parent=typeof parent==="string"?parent:FS.getPath(parent);var parts=path.split("/").reverse();while(parts.length){var part=
parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){}parent=current}return current},createFile:function(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile:function(parent,name,data,canRead,canWrite,canOwn){var path=name?PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name):parent;var mode=FS.getMode(canRead,
canWrite);var node=FS.create(path,mode);if(data){if(typeof data==="string"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,"w");FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}return node},createDevice:function(parent,name,input,output){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=
64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open:function(stream){stream.seekable=false},close:function(stream){if(output&&output.buffer&&output.buffer.length)output(10)},read:function(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO);}if(result===undefined&&bytesRead===0)throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);if(result===null||result===undefined)break;bytesRead++;
buffer[offset+i]=result}if(bytesRead)stream.node.timestamp=Date.now();return bytesRead},write:function(stream,buffer,offset,length,pos){for(var i=0;i<length;i++)try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO);}if(length)stream.node.timestamp=Date.now();return i}});return FS.mkdev(path,mode,dev)},createLink:function(parent,name,target,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);return FS.symlink(target,path)},forceLoadFile:function(obj){if(obj.isDevice||
obj.isFolder||obj.link||obj.contents)return true;var success=true;if(typeof XMLHttpRequest!=="undefined")throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");else if(Module["read"])try{obj.contents=intArrayFromString(Module["read"](obj.url),true);obj.usedBytes=obj.contents.length}catch(e){success=false}else throw new Error("Cannot load without read() or XMLHttpRequest.");
if(!success)___setErrNo(ERRNO_CODES.EIO);return success},createLazyFile:function(parent,name,url,canRead,canWrite){function LazyUint8Array(){this.lengthKnown=false;this.chunks=[]}LazyUint8Array.prototype.get=function LazyUint8Array_get(idx){if(idx>this.length-1||idx<0)return undefined;var chunkOffset=idx%this.chunkSize;var chunkNum=Math.floor(idx/this.chunkSize);return this.getter(chunkNum)[chunkOffset]};LazyUint8Array.prototype.setDataGetter=function LazyUint8Array_setDataGetter(getter){this.getter=
getter};LazyUint8Array.prototype.cacheLength=function LazyUint8Array_cacheLength(){var xhr=new XMLHttpRequest;xhr.open("HEAD",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);var datalength=Number(xhr.getResponseHeader("Content-length"));var header;var hasByteServing=(header=xhr.getResponseHeader("Accept-Ranges"))&&header==="bytes";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=
function(from,to){if(from>to)throw new Error("invalid range ("+from+", "+to+") or no bytes requested!");if(to>datalength-1)throw new Error("only "+datalength+" bytes available! programmer error!");var xhr=new XMLHttpRequest;xhr.open("GET",url,false);if(datalength!==chunkSize)xhr.setRequestHeader("Range","bytes="+from+"-"+to);if(typeof Uint8Array!="undefined")xhr.responseType="arraybuffer";if(xhr.overrideMimeType)xhr.overrideMimeType("text/plain; charset=x-user-defined");xhr.send(null);if(!(xhr.status>=
200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);if(xhr.response!==undefined)return new Uint8Array(xhr.response||[]);else return intArrayFromString(xhr.responseText||"",true)};var lazyArray=this;lazyArray.setDataGetter(function(chunkNum){var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==="undefined")lazyArray.chunks[chunkNum]=doXHR(start,end);if(typeof lazyArray.chunks[chunkNum]===
"undefined")throw new Error("doXHR failed!");return lazyArray.chunks[chunkNum]});this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true};if(typeof XMLHttpRequest!=="undefined"){if(!ENVIRONMENT_IS_WORKER)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var lazyArray=new LazyUint8Array;Object.defineProperty(lazyArray,"length",{get:function(){if(!this.lengthKnown)this.cacheLength();return this._length}});Object.defineProperty(lazyArray,
"chunkSize",{get:function(){if(!this.lengthKnown)this.cacheLength();return this._chunkSize}});var properties={isDevice:false,contents:lazyArray}}else var properties={isDevice:false,url:url};var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents)node.contents=properties.contents;else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperty(node,"usedBytes",{get:function(){return this.contents.length}});var stream_ops={};var keys=Object.keys(node.stream_ops);
keys.forEach(function(key){var fn=node.stream_ops[key];stream_ops[key]=function forceLoadLazyFile(){if(!FS.forceLoadFile(node))throw new FS.ErrnoError(ERRNO_CODES.EIO);return fn.apply(null,arguments)}});stream_ops.read=function stream_ops_read(stream,buffer,offset,length,position){if(!FS.forceLoadFile(node))throw new FS.ErrnoError(ERRNO_CODES.EIO);var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);assert(size>=0);if(contents.slice)for(var i=
0;i<size;i++)buffer[offset+i]=contents[position+i];else for(var i=0;i<size;i++)buffer[offset+i]=contents.get(position+i);return size};node.stream_ops=stream_ops;return node},createPreloadedFile:function(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn){Browser.init();var fullname=name?PATH.resolve(PATH.join2(parent,name)):parent;function processData(byteArray){function finish(byteArray){if(!dontCreateFile)FS.createDataFile(parent,name,byteArray,canRead,canWrite,canOwn);if(onload)onload();
removeRunDependency("cp "+fullname)}var handled=false;Module["preloadPlugins"].forEach(function(plugin){if(handled)return;if(plugin["canHandle"](fullname)){plugin["handle"](byteArray,fullname,finish,function(){if(onerror)onerror();removeRunDependency("cp "+fullname)});handled=true}});if(!handled)finish(byteArray)}addRunDependency("cp "+fullname);if(typeof url=="string")Browser.asyncLoad(url,function(byteArray){processData(byteArray)},onerror);else processData(url)},indexedDB:function(){return window.indexedDB||
window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_NAME:function(){return"EM_FS_"+window.location.pathname},DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function(paths,onload,onerror){onload=onload||function(){};onerror=onerror||function(){};var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=function openRequest_onupgradeneeded(){console.log("creating db");var db=openRequest.result;
db.createObjectStore(FS.DB_STORE_NAME)};openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;var transaction=db.transaction([FS.DB_STORE_NAME],"readwrite");var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach(function(path){var putRequest=files.put(FS.analyzePath(path).object.contents,path);putRequest.onsuccess=function putRequest_onsuccess(){ok++;if(ok+fail==total)finish()};
putRequest.onerror=function putRequest_onerror(){fail++;if(ok+fail==total)finish()}});transaction.onerror=onerror};openRequest.onerror=onerror},loadFilesFromDB:function(paths,onload,onerror){onload=onload||function(){};onerror=onerror||function(){};var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=onerror;openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;try{var transaction=
db.transaction([FS.DB_STORE_NAME],"readonly")}catch(e){onerror(e);return}var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach(function(path){var getRequest=files.get(path);getRequest.onsuccess=function getRequest_onsuccess(){if(FS.analyzePath(path).exists)FS.unlink(path);FS.createDataFile(PATH.dirname(path),PATH.basename(path),getRequest.result,true,true,true);ok++;if(ok+fail==total)finish()};getRequest.onerror=
function getRequest_onerror(){fail++;if(ok+fail==total)finish()}});transaction.onerror=onerror};openRequest.onerror=onerror}};
var PATH={splitPath:function(filename){var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:function(parts,allowAboveRoot){var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last===".")parts.splice(i,1);else if(last===".."){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot)for(;up--;up)parts.unshift("..");return parts},normalize:function(path){var isAbsolute=path.charAt(0)===
"/",trailingSlash=path.substr(-1)==="/";path=PATH.normalizeArray(path.split("/").filter(function(p){return!!p}),!isAbsolute).join("/");if(!path&&!isAbsolute)path=".";if(path&&trailingSlash)path+="/";return(isAbsolute?"/":"")+path},dirname:function(path){var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir)return".";if(dir)dir=dir.substr(0,dir.length-1);return root+dir},basename:function(path){if(path==="/")return"/";var lastSlash=path.lastIndexOf("/");if(lastSlash===-1)return path;
return path.substr(lastSlash+1)},extname:function(path){return PATH.splitPath(path)[3]},join:function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join("/"))},join2:function(l,r){return PATH.normalize(l+"/"+r)},resolve:function(){var resolvedPath="",resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:FS.cwd();if(typeof path!=="string")throw new TypeError("Arguments to path.resolve must be strings");else if(!path)continue;
resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=path.charAt(0)==="/"}resolvedPath=PATH.normalizeArray(resolvedPath.split("/").filter(function(p){return!!p}),!resolvedAbsolute).join("/");return(resolvedAbsolute?"/":"")+resolvedPath||"."},relative:function(from,to){from=PATH.resolve(from).substr(1);to=PATH.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++)if(arr[start]!=="")break;var end=arr.length-1;for(;end>=0;end--)if(arr[end]!=="")break;if(start>end)return[];
return arr.slice(start,end-start+1)}var fromParts=trim(from.split("/"));var toParts=trim(to.split("/"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++)if(fromParts[i]!==toParts[i]){samePartsLength=i;break}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++)outputParts.push("..");outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join("/")}};
var Browser={mainLoop:{scheduler:null,method:"",shouldPause:false,paused:false,queue:[],pause:function(){Browser.mainLoop.shouldPause=true},resume:function(){if(Browser.mainLoop.paused){Browser.mainLoop.paused=false;Browser.mainLoop.scheduler()}Browser.mainLoop.shouldPause=false},updateStatus:function(){if(Module["setStatus"]){var message=Module["statusMessage"]||"Please wait...";var remaining=Browser.mainLoop.remainingBlockers;var expected=Browser.mainLoop.expectedBlockers;if(remaining)if(remaining<
expected)Module["setStatus"](message+" ("+(expected-remaining)+"/"+expected+")");else Module["setStatus"](message);else Module["setStatus"]("")}}},isFullScreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function(){if(!Module["preloadPlugins"])Module["preloadPlugins"]=[];if(Browser.initted||ENVIRONMENT_IS_WORKER)return;Browser.initted=true;try{new Blob;Browser.hasBlobConstructor=true}catch(e){Browser.hasBlobConstructor=false;console.log("warning: no blob constructor, cannot create blobs with mimetypes")}Browser.BlobBuilder=
typeof MozBlobBuilder!="undefined"?MozBlobBuilder:typeof WebKitBlobBuilder!="undefined"?WebKitBlobBuilder:!Browser.hasBlobConstructor?console.log("warning: no BlobBuilder"):null;Browser.URLObject=typeof window!="undefined"?window.URL?window.URL:window.webkitURL:undefined;if(!Module.noImageDecoding&&typeof Browser.URLObject==="undefined"){console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");Module.noImageDecoding=true}var imagePlugin=
{};imagePlugin["canHandle"]=function imagePlugin_canHandle(name){return!Module.noImageDecoding&&/\.(jpg|jpeg|png|bmp)$/i.test(name)};imagePlugin["handle"]=function imagePlugin_handle(byteArray,name,onload,onerror){var b=null;if(Browser.hasBlobConstructor)try{b=new Blob([byteArray],{type:Browser.getMimetype(name)});if(b.size!==byteArray.length)b=new Blob([(new Uint8Array(byteArray)).buffer],{type:Browser.getMimetype(name)})}catch(e){Runtime.warnOnce("Blob constructor present but fails: "+e+"; falling back to blob builder")}if(!b){var bb=
new Browser.BlobBuilder;bb.append((new Uint8Array(byteArray)).buffer);b=bb.getBlob()}var url=Browser.URLObject.createObjectURL(b);var img=new Image;img.onload=function img_onload(){assert(img.complete,"Image "+name+" could not be decoded");var canvas=document.createElement("canvas");canvas.width=img.width;canvas.height=img.height;var ctx=canvas.getContext("2d");ctx.drawImage(img,0,0);Module["preloadedImages"][name]=canvas;Browser.URLObject.revokeObjectURL(url);if(onload)onload(byteArray)};img.onerror=
function img_onerror(event){console.log("Image "+url+" could not be decoded");if(onerror)onerror()};img.src=url};Module["preloadPlugins"].push(imagePlugin);var audioPlugin={};audioPlugin["canHandle"]=function audioPlugin_canHandle(name){return!Module.noAudioDecoding&&name.substr(-4)in{".ogg":1,".wav":1,".mp3":1}};audioPlugin["handle"]=function audioPlugin_handle(byteArray,name,onload,onerror){var done=false;function finish(audio){if(done)return;done=true;Module["preloadedAudios"][name]=audio;if(onload)onload(byteArray)}
function fail(){if(done)return;done=true;Module["preloadedAudios"][name]=new Audio;if(onerror)onerror()}if(Browser.hasBlobConstructor){try{var b=new Blob([byteArray],{type:Browser.getMimetype(name)})}catch(e){return fail()}var url=Browser.URLObject.createObjectURL(b);var audio=new Audio;audio.addEventListener("canplaythrough",function(){finish(audio)},false);audio.onerror=function audio_onerror(event){if(done)return;console.log("warning: browser could not fully decode audio "+name+", trying slower base64 approach");
function encode64(data){var BASE="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";var PAD="=";var ret="";var leftchar=0;var leftbits=0;for(var i=0;i<data.length;i++){leftchar=leftchar<<8|data[i];leftbits+=8;while(leftbits>=6){var curr=leftchar>>leftbits-6&63;leftbits-=6;ret+=BASE[curr]}}if(leftbits==2){ret+=BASE[(leftchar&3)<<4];ret+=PAD+PAD}else if(leftbits==4){ret+=BASE[(leftchar&15)<<2];ret+=PAD}return ret}audio.src="data:audio/x-"+name.substr(-3)+";base64,"+encode64(byteArray);
finish(audio)};audio.src=url;Browser.safeSetTimeout(function(){finish(audio)},1E4)}else return fail()};Module["preloadPlugins"].push(audioPlugin);var canvas=Module["canvas"];if(canvas){canvas.requestPointerLock=canvas["requestPointerLock"]||canvas["mozRequestPointerLock"]||canvas["webkitRequestPointerLock"]||canvas["msRequestPointerLock"]||function(){};canvas.exitPointerLock=document["exitPointerLock"]||document["mozExitPointerLock"]||document["webkitExitPointerLock"]||document["msExitPointerLock"]||
function(){};canvas.exitPointerLock=canvas.exitPointerLock.bind(document);function pointerLockChange(){Browser.pointerLock=document["pointerLockElement"]===canvas||document["mozPointerLockElement"]===canvas||document["webkitPointerLockElement"]===canvas||document["msPointerLockElement"]===canvas}document.addEventListener("pointerlockchange",pointerLockChange,false);document.addEventListener("mozpointerlockchange",pointerLockChange,false);document.addEventListener("webkitpointerlockchange",pointerLockChange,
false);document.addEventListener("mspointerlockchange",pointerLockChange,false);if(Module["elementPointerLock"])canvas.addEventListener("click",function(ev){if(!Browser.pointerLock&&canvas.requestPointerLock){canvas.requestPointerLock();ev.preventDefault()}},false)}},createContext:function(canvas,useWebGL,setInModule,webGLContextAttributes){var ctx;var errorInfo="?";function onContextCreationError(event){errorInfo=event.statusMessage||errorInfo}try{if(useWebGL){var contextAttributes={antialias:false,
alpha:false};if(webGLContextAttributes)for(var attribute in webGLContextAttributes)contextAttributes[attribute]=webGLContextAttributes[attribute];canvas.addEventListener("webglcontextcreationerror",onContextCreationError,false);try{["experimental-webgl","webgl"].some(function(webglId){return ctx=canvas.getContext(webglId,contextAttributes)})}finally{canvas.removeEventListener("webglcontextcreationerror",onContextCreationError,false)}}else ctx=canvas.getContext("2d");if(!ctx)throw":(";}catch(e){Module.print("Could not create canvas: "+
[errorInfo,e]);return null}if(useWebGL)canvas.style.backgroundColor="black";if(setInModule){GLctx=Module.ctx=ctx;Module.useWebGL=useWebGL;Browser.moduleContextCreatedCallbacks.forEach(function(callback){callback()});Browser.init()}return ctx},destroyContext:function(canvas,useWebGL,setInModule){},fullScreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullScreen:function(lockPointer,resizeCanvas){Browser.lockPointer=lockPointer;Browser.resizeCanvas=resizeCanvas;if(typeof Browser.lockPointer===
"undefined")Browser.lockPointer=true;if(typeof Browser.resizeCanvas==="undefined")Browser.resizeCanvas=false;var canvas=Module["canvas"];function fullScreenChange(){Browser.isFullScreen=false;var canvasContainer=canvas.parentNode;if((document["webkitFullScreenElement"]||document["webkitFullscreenElement"]||document["mozFullScreenElement"]||document["mozFullscreenElement"]||document["fullScreenElement"]||document["fullscreenElement"]||document["msFullScreenElement"]||document["msFullscreenElement"]||
document["webkitCurrentFullScreenElement"])===canvasContainer){canvas.cancelFullScreen=document["cancelFullScreen"]||document["mozCancelFullScreen"]||document["webkitCancelFullScreen"]||document["msExitFullscreen"]||document["exitFullscreen"]||function(){};canvas.cancelFullScreen=canvas.cancelFullScreen.bind(document);if(Browser.lockPointer)canvas.requestPointerLock();Browser.isFullScreen=true;if(Browser.resizeCanvas)Browser.setFullScreenCanvasSize()}else{canvasContainer.parentNode.insertBefore(canvas,
canvasContainer);canvasContainer.parentNode.removeChild(canvasContainer);if(Browser.resizeCanvas)Browser.setWindowedCanvasSize()}if(Module["onFullScreen"])Module["onFullScreen"](Browser.isFullScreen);Browser.updateCanvasDimensions(canvas)}if(!Browser.fullScreenHandlersInstalled){Browser.fullScreenHandlersInstalled=true;document.addEventListener("fullscreenchange",fullScreenChange,false);document.addEventListener("mozfullscreenchange",fullScreenChange,false);document.addEventListener("webkitfullscreenchange",
fullScreenChange,false);document.addEventListener("MSFullscreenChange",fullScreenChange,false)}var canvasContainer=document.createElement("div");canvas.parentNode.insertBefore(canvasContainer,canvas);canvasContainer.appendChild(canvas);canvasContainer.requestFullScreen=canvasContainer["requestFullScreen"]||canvasContainer["mozRequestFullScreen"]||canvasContainer["msRequestFullscreen"]||(canvasContainer["webkitRequestFullScreen"]?function(){canvasContainer["webkitRequestFullScreen"](Element["ALLOW_KEYBOARD_INPUT"])}:
null);canvasContainer.requestFullScreen()},requestAnimationFrame:function requestAnimationFrame(func){if(typeof window==="undefined")setTimeout(func,1E3/60);else{if(!window.requestAnimationFrame)window.requestAnimationFrame=window["requestAnimationFrame"]||window["mozRequestAnimationFrame"]||window["webkitRequestAnimationFrame"]||window["msRequestAnimationFrame"]||window["oRequestAnimationFrame"]||window["setTimeout"];window.requestAnimationFrame(func)}},safeCallback:function(func){return function(){if(!ABORT)return func.apply(null,
arguments)}},safeRequestAnimationFrame:function(func){return Browser.requestAnimationFrame(function(){if(!ABORT)func()})},safeSetTimeout:function(func,timeout){Module["noExitRuntime"]=true;return setTimeout(function(){if(!ABORT)func()},timeout)},safeSetInterval:function(func,timeout){Module["noExitRuntime"]=true;return setInterval(function(){if(!ABORT)func()},timeout)},getMimetype:function(name){return{"jpg":"image/jpeg","jpeg":"image/jpeg","png":"image/png","bmp":"image/bmp","ogg":"audio/ogg","wav":"audio/wav",
"mp3":"audio/mpeg"}[name.substr(name.lastIndexOf(".")+1)]},getUserMedia:function(func){if(!window.getUserMedia)window.getUserMedia=navigator["getUserMedia"]||navigator["mozGetUserMedia"];window.getUserMedia(func)},getMovementX:function(event){return event["movementX"]||event["mozMovementX"]||event["webkitMovementX"]||0},getMovementY:function(event){return event["movementY"]||event["mozMovementY"]||event["webkitMovementY"]||0},getMouseWheelDelta:function(event){var delta=0;switch(event.type){case "DOMMouseScroll":delta=
event.detail;break;case "mousewheel":delta=-event.wheelDelta;break;case "wheel":delta=event.deltaY;break;default:throw"unrecognized mouse wheel event: "+event.type;}return Math.max(-1,Math.min(1,delta))},mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function(event){if(Browser.pointerLock){if(event.type!="mousemove"&&"mozMovementX"in event)Browser.mouseMovementX=Browser.mouseMovementY=0;else{Browser.mouseMovementX=Browser.getMovementX(event);Browser.mouseMovementY=
Browser.getMovementY(event)}if(typeof SDL!="undefined"){Browser.mouseX=SDL.mouseX+Browser.mouseMovementX;Browser.mouseY=SDL.mouseY+Browser.mouseMovementY}else{Browser.mouseX+=Browser.mouseMovementX;Browser.mouseY+=Browser.mouseMovementY}}else{var rect=Module["canvas"].getBoundingClientRect();var cw=Module["canvas"].width;var ch=Module["canvas"].height;var scrollX=typeof window.scrollX!=="undefined"?window.scrollX:window.pageXOffset;var scrollY=typeof window.scrollY!=="undefined"?window.scrollY:window.pageYOffset;
if(event.type==="touchstart"||event.type==="touchend"||event.type==="touchmove"){var touch=event.touch;if(touch===undefined)return;var adjustedX=touch.pageX-(scrollX+rect.left);var adjustedY=touch.pageY-(scrollY+rect.top);adjustedX=adjustedX*(cw/rect.width);adjustedY=adjustedY*(ch/rect.height);var coords={x:adjustedX,y:adjustedY};if(event.type==="touchstart"){Browser.lastTouches[touch.identifier]=coords;Browser.touches[touch.identifier]=coords}else if(event.type==="touchend"||event.type==="touchmove"){Browser.lastTouches[touch.identifier]=
Browser.touches[touch.identifier];Browser.touches[touch.identifier]={x:adjustedX,y:adjustedY}}return}var x=event.pageX-(scrollX+rect.left);var y=event.pageY-(scrollY+rect.top);x=x*(cw/rect.width);y=y*(ch/rect.height);Browser.mouseMovementX=x-Browser.mouseX;Browser.mouseMovementY=y-Browser.mouseY;Browser.mouseX=x;Browser.mouseY=y}},xhrLoad:function(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function xhr_onload(){if(xhr.status==
200||xhr.status==0&&xhr.response)onload(xhr.response);else onerror()};xhr.onerror=onerror;xhr.send(null)},asyncLoad:function(url,onload,onerror,noRunDep){Browser.xhrLoad(url,function(arrayBuffer){assert(arrayBuffer,'Loading data file "'+url+'" failed (no arrayBuffer).');onload(new Uint8Array(arrayBuffer));if(!noRunDep)removeRunDependency("al "+url)},function(event){if(onerror)onerror();else throw'Loading data file "'+url+'" failed.';});if(!noRunDep)addRunDependency("al "+url)},resizeListeners:[],
updateResizeListeners:function(){var canvas=Module["canvas"];Browser.resizeListeners.forEach(function(listener){listener(canvas.width,canvas.height)})},setCanvasSize:function(width,height,noUpdates){var canvas=Module["canvas"];Browser.updateCanvasDimensions(canvas,width,height);if(!noUpdates)Browser.updateResizeListeners()},windowedWidth:0,windowedHeight:0,setFullScreenCanvasSize:function(){if(typeof SDL!="undefined"){var flags=HEAPU32[SDL.screen+Runtime.QUANTUM_SIZE*0>>2];flags=flags|8388608;HEAP32[SDL.screen+
Runtime.QUANTUM_SIZE*0>>2]=flags}Browser.updateResizeListeners()},setWindowedCanvasSize:function(){if(typeof SDL!="undefined"){var flags=HEAPU32[SDL.screen+Runtime.QUANTUM_SIZE*0>>2];flags=flags&~8388608;HEAP32[SDL.screen+Runtime.QUANTUM_SIZE*0>>2]=flags}Browser.updateResizeListeners()},updateCanvasDimensions:function(canvas,wNative,hNative){if(wNative&&hNative){canvas.widthNative=wNative;canvas.heightNative=hNative}else{wNative=canvas.widthNative;hNative=canvas.heightNative}var w=wNative;var h=hNative;
if(Module["forcedAspectRatio"]&&Module["forcedAspectRatio"]>0)if(w/h<Module["forcedAspectRatio"])w=Math.round(h*Module["forcedAspectRatio"]);else h=Math.round(w/Module["forcedAspectRatio"]);if((document["webkitFullScreenElement"]||document["webkitFullscreenElement"]||document["mozFullScreenElement"]||document["mozFullscreenElement"]||document["fullScreenElement"]||document["fullscreenElement"]||document["msFullScreenElement"]||document["msFullscreenElement"]||document["webkitCurrentFullScreenElement"])===
canvas.parentNode&&typeof screen!="undefined"){var factor=Math.min(screen.width/w,screen.height/h);w=Math.round(w*factor);h=Math.round(h*factor)}if(Browser.resizeCanvas){if(canvas.width!=w)canvas.width=w;if(canvas.height!=h)canvas.height=h;if(typeof canvas.style!="undefined"){canvas.style.removeProperty("width");canvas.style.removeProperty("height")}}else{if(canvas.width!=wNative)canvas.width=wNative;if(canvas.height!=hNative)canvas.height=hNative;if(typeof canvas.style!="undefined")if(w!=wNative||
h!=hNative){canvas.style.setProperty("width",w+"px","important");canvas.style.setProperty("height",h+"px","important")}else{canvas.style.removeProperty("width");canvas.style.removeProperty("height")}}}};function _time(ptr){var ret=Math.floor(Date.now()/1E3);if(ptr)HEAP32[ptr>>2]=ret;return ret}
function _sysconf(name){switch(name){case 30:return PAGE_SIZE;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 80:case 81:case 79:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:return-1;
case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1E3;case 89:return 700;case 71:return 256;
case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return 1}___setErrNo(ERRNO_CODES.EINVAL);return-1}function _malloc(bytes){var ptr=Runtime.dynamicAlloc(bytes+8);return ptr+8&4294967288}Module["_malloc"]=_malloc;function ___cxa_allocate_exception(size){var ptr=_malloc(size+___cxa_exception_header_size);return ptr+___cxa_exception_header_size}
var __ZTISt9exception=allocate([allocate([1,0,0,0,0,0,0],"i8",ALLOC_STATIC)+8,0],"i32",ALLOC_STATIC);___errno_state=Runtime.staticAlloc(4);HEAP32[___errno_state>>2]=0;Module["requestFullScreen"]=function Module_requestFullScreen(lockPointer,resizeCanvas){Browser.requestFullScreen(lockPointer,resizeCanvas)};Module["requestAnimationFrame"]=function Module_requestAnimationFrame(func){Browser.requestAnimationFrame(func)};
Module["setCanvasSize"]=function Module_setCanvasSize(width,height,noUpdates){Browser.setCanvasSize(width,height,noUpdates)};Module["pauseMainLoop"]=function Module_pauseMainLoop(){Browser.mainLoop.pause()};Module["resumeMainLoop"]=function Module_resumeMainLoop(){Browser.mainLoop.resume()};Module["getUserMedia"]=function Module_getUserMedia(){Browser.getUserMedia()};FS.staticInit();__ATINIT__.unshift({func:function(){if(!Module["noFSInit"]&&!FS.init.initialized)FS.init()}});
__ATMAIN__.push({func:function(){FS.ignorePermissions=false}});__ATEXIT__.push({func:function(){FS.quit()}});Module["FS_createFolder"]=FS.createFolder;Module["FS_createPath"]=FS.createPath;Module["FS_createDataFile"]=FS.createDataFile;Module["FS_createPreloadedFile"]=FS.createPreloadedFile;Module["FS_createLazyFile"]=FS.createLazyFile;Module["FS_createLink"]=FS.createLink;Module["FS_createDevice"]=FS.createDevice;__ATINIT__.unshift({func:function(){TTY.init()}});__ATEXIT__.push({func:function(){TTY.shutdown()}});
TTY.utf8=new Runtime.UTF8Processor;if(ENVIRONMENT_IS_NODE){var fs=require("fs");NODEFS.staticInit()}STACK_BASE=STACKTOP=Runtime.alignMemory(STATICTOP);staticSealed=true;STACK_MAX=STACK_BASE+5242880;DYNAMIC_BASE=DYNAMICTOP=Runtime.alignMemory(STACK_MAX);assert(DYNAMIC_BASE<TOTAL_MEMORY,"TOTAL_MEMORY not big enough for stack");
var ctlz_i8=allocate([8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"i8",ALLOC_DYNAMIC);
var cttz_i8=allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0],"i8",ALLOC_DYNAMIC);var Math_min=Math.min;function invoke_diiiiid(index,a1,a2,a3,a4,a5,a6){try{return Module["dynCall_diiiiid"](index,a1,a2,a3,a4,a5,a6)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_ii(index,a1){try{return Module["dynCall_ii"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}
function invoke_viiiii(index,a1,a2,a3,a4,a5){try{Module["dynCall_viiiii"](index,a1,a2,a3,a4,a5)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_did(index,a1,a2){try{return Module["dynCall_did"](index,a1,a2)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_vi(index,a1){try{Module["dynCall_vi"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}
function invoke_diiiid(index,a1,a2,a3,a4,a5){try{return Module["dynCall_diiiid"](index,a1,a2,a3,a4,a5)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_vii(index,a1,a2){try{Module["dynCall_vii"](index,a1,a2)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_iiii(index,a1,a2,a3){try{return Module["dynCall_iiii"](index,a1,a2,a3)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}
function invoke_viii(index,a1,a2,a3){try{Module["dynCall_viii"](index,a1,a2,a3)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_v(index){try{Module["dynCall_v"](index)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_viid(index,a1,a2,a3){try{Module["dynCall_viid"](index,a1,a2,a3)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}
function invoke_iiiii(index,a1,a2,a3,a4){try{return Module["dynCall_iiiii"](index,a1,a2,a3,a4)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6){try{Module["dynCall_viiiiii"](index,a1,a2,a3,a4,a5,a6)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}
function invoke_iii(index,a1,a2){try{return Module["dynCall_iii"](index,a1,a2)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_iiiiii(index,a1,a2,a3,a4,a5){try{return Module["dynCall_iiiiii"](index,a1,a2,a3,a4,a5)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}
function invoke_viiii(index,a1,a2,a3,a4){try{Module["dynCall_viiii"](index,a1,a2,a3,a4)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function asmPrintInt(x,y){Module.print("int "+x+","+y)}function asmPrintFloat(x,y){Module.print("float "+x+","+y)}
var asm=function(global,env,buffer){"use asm";var a=new global.Int8Array(buffer);var b=new global.Int16Array(buffer);var c=new global.Int32Array(buffer);var d=new global.Uint8Array(buffer);var e=new global.Uint16Array(buffer);var f=new global.Uint32Array(buffer);var g=new global.Float32Array(buffer);var h=new global.Float64Array(buffer);var i=env.STACKTOP|0;var j=env.STACK_MAX|0;var k=env.tempDoublePtr|0;var l=env.ABORT|0;var m=env.cttz_i8|0;var n=env.ctlz_i8|0;var o=env.__ZTISt9exception|0;var p=
0;var q=0;var r=0;var s=0;var t=+env.NaN,u=+env.Infinity;var v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0;var E=0;var F=0;var G=0;var H=0;var I=0;var J=0;var K=0;var L=0;var M=0;var N=0;var O=global.Math.floor;var P=global.Math.abs;var Q=global.Math.sqrt;var R=global.Math.pow;var S=global.Math.cos;var T=global.Math.sin;var U=global.Math.tan;var V=global.Math.acos;var W=global.Math.asin;var X=global.Math.atan;var Y=global.Math.atan2;var Z=global.Math.exp;var _=global.Math.log;var $=global.Math.ceil;var aa=
global.Math.imul;var ba=env.abort;var ca=env.assert;var da=env.asmPrintInt;var ea=env.asmPrintFloat;var fa=env.min;var ga=env.invoke_diiiiid;var ha=env.invoke_ii;var ia=env.invoke_viiiii;var ja=env.invoke_did;var ka=env.invoke_vi;var la=env.invoke_diiiid;var ma=env.invoke_vii;var na=env.invoke_iiii;var oa=env.invoke_viii;var pa=env.invoke_v;var qa=env.invoke_viid;var ra=env.invoke_iiiii;var sa=env.invoke_viiiiii;var ta=env.invoke_iii;var ua=env.invoke_iiiiii;var va=env.invoke_viiii;var wa=env._cosf;
var xa=env.__ZSt9terminatev;var ya=env._b2WorldPreSolve;var za=env.___cxa_is_number_type;var Aa=env.___cxa_allocate_exception;var Ba=env.___cxa_find_matching_catch;var Ca=env._fflush;var Da=env._time;var Ea=env.__exit;var Fa=env.___setErrNo;var Ga=env._sbrk;var Ha=env.___cxa_begin_catch;var Ia=env._sinf;var Ja=env.___resumeException;var Ka=env.__ZSt18uncaught_exceptionv;var La=env._b2WorldRayCastCallback;var Ma=env._emscripten_memcpy_big;var Na=env._floorf;var Oa=env._sqrtf;var Pa=env._b2WorldBeginContactBody;
var Qa=env.___errno_location;var Ra=env.__ZNSt9exceptionD2Ev;var Sa=env.___cxa_throw;var Ta=env._sysconf;var Ua=env._abort;var Va=env.___cxa_does_inherit;var Wa=env._b2WorldEndContactBody;var Xa=env._b2WorldQueryAABB;var Ya=env._b2WorldPostSolve;var Za=env._exit;var _a=env.___cxa_pure_virtual;var $a=0;function $k(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;d=i;i=i+64|0;e=d;f=d+16|0;g[e>>2]=3.4028234663852886E38;g[e+4>>2]=3.4028234663852886E38;
h=e+8|0;g[h>>2]=-3.4028234663852886E38;g[e+12>>2]=-3.4028234663852886E38;j=c[a+44>>2]|0;if((j|0)>0){k=c[a+104>>2]|0;l=c[a+96>>2]|0;m=+g[b>>2];n=3.4028234663852886E38;o=3.4028234663852886E38;p=-3.4028234663852886E38;q=-3.4028234663852886E38;r=0;do{s=k+(r<<3)|0;t=+g[s>>2];u=+g[s+4>>2];s=l+(r<<3)|0;v=+g[s>>2];w=+g[s+4>>2];x=v+t*m;t=u*m+w;u=v<x?v:x;y=w<t?w:t;n=n<u?n:u;o=o<y?o:y;y=+n;u=+o;s=e;g[s>>2]=y;g[s+4>>2]=u;u=v>x?v:x;x=w>t?w:t;p=p>u?p:u;q=q>x?q:x;x=+p;u=+q;s=h;g[s>>2]=x;g[s+4>>2]=u;r=r+1|0}while((r|
0)<(j|0))}c[f+4>>2]=a;c[f>>2]=6872;j=f+8|0;c[j+0>>2]=c[b+0>>2];c[j+4>>2]=c[b+4>>2];c[j+8>>2]=c[b+8>>2];c[j+12>>2]=c[b+12>>2];c[j+16>>2]=c[b+16>>2];c[j+20>>2]=c[b+20>>2];c[j+24>>2]=c[b+24>>2];Dj(c[a+400>>2]|0,f,e);i=d;return}function al(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=
0;e=i;i=i+48|0;f=e;h=e+16|0;j=b+44|0;k=c[j>>2]|0;if((k|0)>0){l=c[b+88>>2]|0;m=b+104|0;n=0;do{if((c[l+(n<<2)>>2]&1028|0)==1028){o=c[m>>2]|0;g[o+(n<<3)>>2]=0;g[o+(n<<3)+4>>2]=0}n=n+1|0}while((n|0)<(k|0))}p=+g[d>>2]*2.5;k=b+252|0;if((c[k>>2]|0)<=0){i=e;return}n=b+248|0;m=b+96|0;l=f+8|0;o=b+144|0;q=b+104|0;r=h+16|0;s=h+20|0;t=h+4|0;u=b+32|0;v=b+320|0;w=d+4|0;d=b+88|0;x=b+21|0;y=b+112|0;z=0;do{A=c[n>>2]|0;a:do if((c[A+(z*20|0)+8>>2]&1024|0)!=0){B=c[A+(z*20|0)>>2]|0;C=c[A+(z*20|0)+4>>2]|0;D=c[m>>2]|0;E=
D+(B<<3)|0;F=+g[E>>2];G=+g[E+4>>2];E=D+(C<<3)|0;H=+g[E>>2];I=+g[E+4>>2];J=+(F<H?F:H);K=+(G<I?G:I);E=f;g[E>>2]=J;g[E+4>>2]=K;K=+(F>H?F:H);J=+(G>I?G:I);E=l;g[E>>2]=K;g[E+4>>2]=J;E=c[o>>2]|0;D=c[E+(B<<2)>>2]|0;L=c[E+(C<<2)>>2]|0;if((D|0)!=0?(c[D+12>>2]&2|0)!=0:0){nk(D);J=+g[D+56>>2];M=+g[D+48>>2]-J*(G-+g[D+44>>2]);N=J*(F-+g[D+40>>2])+ +g[D+52>>2]}else{E=(c[q>>2]|0)+(B<<3)|0;J=+g[E>>2];M=J;N=+g[E+4>>2]}if((L|0)!=0?(c[L+12>>2]&2|0)!=0:0){nk(L);J=+g[L+56>>2];O=+g[L+48>>2]-J*(I-+g[L+44>>2]);P=J*(H-+g[L+
40>>2])+ +g[L+52>>2]}else{E=(c[q>>2]|0)+(C<<3)|0;J=+g[E>>2];O=J;P=+g[E+4>>2]}J=H-F;H=I-G;I=O-M;K=P-N;Nk(h,b,f);E=c[r>>2]|0;C=c[s>>2]|0;if(E>>>0<C>>>0){B=c[h>>2]|0;R=c[t>>2]|0;S=E;while(1){E=c[S+4>>2]&1048575;T=S;S=S+8|0;c[r>>2]=S;if(E>>>0<B>>>0|E>>>0>R>>>0)if(S>>>0<C>>>0){S=S;continue}else break;E=c[T>>2]|0;if(!((E|0)>-1))break a;T=(c[m>>2]|0)+(E<<3)|0;U=+g[T>>2];V=+g[T+4>>2];T=c[(c[o>>2]|0)+(E<<2)>>2]|0;b:do if(!((D|0)==(T|0)|(L|0)==(T|0))){W=(T|0)==0;if(!W?(c[T+12>>2]&2|0)!=0:0){nk(T);X=+g[T+56>>
2];Y=+g[T+48>>2]-X*(V-+g[T+44>>2]);Z=X*(U-+g[T+40>>2])+ +g[T+52>>2]}else{_=(c[q>>2]|0)+(E<<3)|0;X=+g[_>>2];Y=X;Z=+g[_+4>>2]}X=U-F;$=V-G;aa=Y-M;ba=Z-N;ca=I*ba-K*aa;da=J*ba-H*aa-(K*X-I*$);ea=J*$-H*X;do if(ca==0){if(da==0)break b;fa=-ea/da;if(!(fa>=0&fa<p))break b;ga=J+I*fa;ha=H+K*fa;ia=(ga*(X+aa*fa)+ha*($+ba*fa))/(ga*ga+ha*ha);if(ia>=0&ia<=1)ja=ia;else break b}else{ia=da*da-ea*4*ca;if(ia<0)break b;ha=+Q(+ia);ia=ca*2;ga=(-da-ha)/ia;fa=(ha-da)/ia;_=ga>fa;ia=_?fa:ga;ha=_?ga:fa;fa=J+I*ia;ga=H+K*ia;ka=(fa*
(X+aa*ia)+ga*($+ba*ia))/(fa*fa+ga*ga);if(ia>=0&ia<p?ka>=0&ka<=1:0){ja=ka;break}if(!(ha>=0&ha<p))break b;ka=J+I*ha;ia=H+K*ha;ga=(ka*(X+aa*ha)+ia*($+ba*ha))/(ka*ka+ia*ia);if(ga>=0&ga<=1)ja=ga;else break b}while(0);ba=M+I*ja-Y;$=N+K*ja-Z;aa=+g[u>>2]*.75;X=aa*+g[v>>2]*aa;aa=ba*X;da=$*X;if(!W?(c[T+12>>2]&2|0)!=0:0){nk(T);X=+g[T+32>>2];nk(T);ca=+g[T+36>>2];if(X>0){ea=1/X;_=T+48|0;g[_>>2]=aa*ea+ +g[_>>2];_=T+52|0;g[_>>2]=da*ea+ +g[_>>2]}if(ca>0){nk(T);_=T+40|0;ea=+g[_>>2];la=T+56|0;g[la>>2]=(da*(U-ea)-aa*
(V-+g[_+4>>2]))/ca+ +g[la>>2]}}else{la=c[q>>2]|0;_=la+(E<<3)|0;g[_>>2]=ba+ +g[_>>2];_=la+(E<<3)+4|0;g[_>>2]=$+ +g[_>>2]}$=-+g[w>>2];ba=aa*$;aa=da*$;if(ba!=0|aa!=0?(c[(c[d>>2]|0)+(E<<2)>>2]&4|0)==0:0){if((a[x>>0]|0)==0){xn(c[y>>2]|0,0,c[j>>2]<<3|0)|0;a[x>>0]=1}_=c[y>>2]|0;la=_+(E<<3)|0;g[la>>2]=ba+ +g[la>>2];la=_+(E<<3)+4|0;g[la>>2]=aa+ +g[la>>2]}}while(0);if(!(S>>>0<C>>>0))break}}}while(0);z=z+1|0}while((z|0)<(c[k>>2]|0));i=e;return}function bl(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,
o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,aa=0,ba=0,ca=0,da=0,ea=0,ga=0;e=i;i=i+48|0;f=e+32|0;h=e+28|0;j=e;k=b+44|0;l=c[k>>2]|0;if((l|0)==0){i=e;return}m=c[b+280>>2]|0;a:do if((m|0)!=0){n=b+296|0;o=n;p=+g[d>>2]/+g[b+396>>2]*4294967296;q=zn(~~p>>>0|0,(+P(p)>=1?p>0?(fa(+O(p/4294967296),4294967295)|0)>>>0:~~+$((p-+(~~p>>>0))/4294967296)>>>0:0)|0,c[o>>2]|0,c[o+4>>2]|0)|0;o=E;r=n;c[r>>2]=q;c[r+4>>2]=o;r=c[b+
288>>2]|0;q=b+304|0;if((a[q>>0]|0)!=0){c[h>>2]=m;sl(r,r+(l<<2)|0,h);a[q>>0]=0}if((l|0)>0){q=b+88|0;n=l;do{n=n+-1|0;s=c[r+(n<<2)>>2]|0;t=c[m+(s<<2)>>2]|0;if((o|0)<(t|0)|(t|0)<1)break a;Ak(b,s,c[(c[q>>2]|0)+(s<<2)>>2]|2)}while((n|0)>0)}}while(0);m=b+8|0;if((c[m>>2]&2|0)!=0)xk(b);l=b+12|0;if((a[l>>0]|0)!=0){c[m>>2]=0;h=c[k>>2]|0;if((h|0)>0){n=c[b+88>>2]|0;q=0;o=0;do{q=c[n+(o<<2)>>2]|q;c[m>>2]=q;o=o+1|0}while((o|0)!=(h|0))}a[l>>0]=0}l=b+20|0;if((a[l>>0]|0)!=0){h=b+16|0;c[h>>2]=0;o=c[b+312>>2]|0;if((o|
0)!=0){q=0;n=o;do{q=c[n+12>>2]|q;c[h>>2]=q;n=c[n+24>>2]|0}while((n|0)!=0)}a[l>>0]=0}if((a[b>>0]|0)!=0){i=e;return}l=b+24|0;c[l>>2]=0;n=d+20|0;if((c[n>>2]|0)<=0){i=e;return}q=b+4|0;h=j+4|0;o=b+116|0;r=b+236|0;s=b+232|0;t=b+220|0;u=b+216|0;v=b+16|0;w=b+21|0;x=b+324|0;y=b+400|0;z=b+104|0;A=b+32|0;B=b+88|0;C=b+96|0;D=b+372|0;F=b+144|0;G=b+132|0;H=b+368|0;I=b+364|0;J=b+36|0;K=b+28|0;L=b+112|0;M=f+4|0;do{c[q>>2]=(c[q>>2]|0)+1;c[j+0>>2]=c[d+0>>2];c[j+4>>2]=c[d+4>>2];c[j+8>>2]=c[d+8>>2];c[j+12>>2]=c[d+12>>
2];c[j+16>>2]=c[d+16>>2];c[j+20>>2]=c[d+20>>2];c[j+24>>2]=c[d+24>>2];p=+(c[n>>2]|0);N=+g[j>>2]/p;g[j>>2]=N;R=+g[h>>2]*p;g[h>>2]=R;Gk(b,0);Yk(b);xn(c[o>>2]|0,0,c[k>>2]<<2|0)|0;S=c[r>>2]|0;if((S|0)>0){T=c[s>>2]|0;U=c[o>>2]|0;V=0;do{W=U+(c[T+(V*28|0)>>2]<<2)|0;g[W>>2]=+g[T+(V*28|0)+12>>2]+ +g[W>>2];V=V+1|0}while((V|0)!=(S|0))}S=c[t>>2]|0;if((S|0)>0){V=c[u>>2]|0;T=c[o>>2]|0;U=0;do{W=c[V+(U*24|0)+4>>2]|0;p=+g[V+(U*24|0)+8>>2];X=T+(c[V+(U*24|0)>>2]<<2)|0;g[X>>2]=p+ +g[X>>2];X=T+(W<<2)|0;g[X>>2]=p+ +g[X>>
2];U=U+1|0}while((U|0)!=(S|0))}if((c[v>>2]&16|0)!=0)Mk(b);S=c[m>>2]|0;if((S&4096|0)==0)Y=S;else{S=c[B>>2]|0;c[f>>2]=7360;c[M>>2]=S;Hk(b,0,c[k>>2]|0,f);if((c[k>>2]|0)>0){S=c[B>>2]|0;U=0;do{T=S+(U<<2)|0;c[T>>2]=c[T>>2]&-4097;U=U+1|0}while((U|0)<(c[k>>2]|0))}U=c[m>>2]&-4097;c[m>>2]=U;Y=U}if((a[w>>0]|0)!=0){p=+g[J>>2]*1.3333333730697632;Z=N*p*+g[K>>2]*p;U=c[k>>2]|0;if((U|0)>0){S=c[z>>2]|0;T=c[L>>2]|0;V=0;do{p=Z*+g[T+(V<<3)+4>>2];X=S+(V<<3)|0;g[X>>2]=Z*+g[T+(V<<3)>>2]+ +g[X>>2];X=S+(V<<3)+4|0;g[X>>2]=
p+ +g[X>>2];V=V+1|0}while((V|0)!=(U|0))}a[w>>0]=0}if((Y&32|0)==0)_=Y;else{cl(b);_=c[m>>2]|0}if((_&8192|0)!=0?(Z=+g[I>>2]*+g[A>>2]*R,U=c[t>>2]|0,(U|0)>0):0){V=c[u>>2]|0;S=0;do{do if((c[V+(S*24|0)+20>>2]&8192|0)!=0){T=c[V+(S*24|0)>>2]|0;X=c[V+(S*24|0)+4>>2]|0;W=c[F>>2]|0;if((c[W+(T<<2)>>2]|0)==(c[W+(X<<2)>>2]|0))break;W=V+(S*24|0)+12|0;N=+g[W>>2];p=Z*+g[V+(S*24|0)+8>>2];aa=p*N;N=p*+g[W+4>>2];W=c[z>>2]|0;ba=W+(T<<3)|0;g[ba>>2]=+g[ba>>2]-aa;ba=W+(T<<3)+4|0;g[ba>>2]=+g[ba>>2]-N;ba=W+(X<<3)|0;g[ba>>2]=
aa+ +g[ba>>2];ba=W+(X<<3)+4|0;g[ba>>2]=N+ +g[ba>>2]}while(0);S=S+1|0}while((S|0)!=(U|0))}if((_&64|0)!=0?(Z=+g[H>>2]*+g[A>>2]*R,U=c[t>>2]|0,(U|0)>0):0){S=c[u>>2]|0;V=0;do{do if((c[S+(V*24|0)+20>>2]&64|0)!=0){N=+g[S+(V*24|0)+8>>2];if(!(N>.25))break;ba=c[S+(V*24|0)>>2]|0;X=c[S+(V*24|0)+4>>2]|0;W=S+(V*24|0)+12|0;aa=+g[W>>2];p=Z*(N+-.25);N=p*aa;aa=p*+g[W+4>>2];W=c[z>>2]|0;T=W+(ba<<3)|0;g[T>>2]=+g[T>>2]-N;T=W+(ba<<3)+4|0;g[T>>2]=+g[T>>2]-aa;T=W+(X<<3)|0;g[T>>2]=N+ +g[T>>2];T=W+(X<<3)+4|0;g[T>>2]=aa+ +g[T>>
2]}while(0);V=V+1|0}while((V|0)!=(U|0))}if((_&128|0)!=0)dl(b,j);if((c[v>>2]&1|0)!=0?(Z=+g[h>>2]*+g[D>>2],U=c[t>>2]|0,(U|0)>0):0){V=c[u>>2]|0;S=c[F>>2]|0;T=0;do{X=c[V+(T*24|0)>>2]|0;W=c[V+(T*24|0)+4>>2]|0;if((c[S+(X<<2)>>2]|0)!=(c[S+(W<<2)>>2]|0)){ba=V+(T*24|0)+12|0;R=+g[ba>>2];ca=c[G>>2]|0;aa=+g[V+(T*24|0)+8>>2]*Z*(+g[ca+(X<<2)>>2]+ +g[ca+(W<<2)>>2]);N=R*aa;R=+g[ba+4>>2]*aa;ba=c[z>>2]|0;ca=ba+(X<<3)|0;g[ca>>2]=+g[ca>>2]-N;ca=ba+(X<<3)+4|0;g[ca>>2]=+g[ca>>2]-R;ca=ba+(W<<3)|0;g[ca>>2]=N+ +g[ca>>2];
ca=ba+(W<<3)+4|0;g[ca>>2]=R+ +g[ca>>2]}T=T+1|0}while((T|0)!=(U|0))}if((c[m>>2]&256|0)!=0)el(b);Z=+g[j>>2]*+g[x>>2];U=(c[y>>2]|0)+102980|0;R=+g[U>>2];N=Z*R;R=Z*+g[U+4>>2];U=c[k>>2]|0;if((U|0)>0){T=c[z>>2]|0;V=0;do{S=T+(V<<3)|0;g[S>>2]=N+ +g[S>>2];S=T+(V<<3)+4|0;g[S>>2]=R+ +g[S>>2];V=V+1|0}while((V|0)!=(U|0))}if((c[m>>2]&2048|0)!=0)fl(b,j);gl(b,j);hl(b,j);U=c[m>>2]|0;if((U&2048|0)==0)da=U;else{il(b);da=c[m>>2]|0}if((da&16|0)==0)ea=da;else{jl(b,j);ea=c[m>>2]|0}if((ea&8|0)!=0)kl(b,j);R=+g[A>>2]*+g[h>>
2];N=R*R;U=c[k>>2]|0;if((U|0)>0){V=c[z>>2]|0;T=0;do{S=V+(T<<3)|0;R=+g[S>>2];ca=V+(T<<3)+4|0;Z=+g[ca>>2];aa=R*R+Z*Z;if(aa>N){p=+Q(+(N/aa));g[S>>2]=R*p;g[ca>>2]=Z*p}T=T+1|0}while((T|0)!=(U|0))}if((c[v>>2]&2|0)!=0)ll(b);if((c[m>>2]&1024|0)!=0)al(b,j);$k(b,j);if((c[v>>2]&2|0)!=0)ml(b,j);U=c[k>>2]|0;do if((c[m>>2]&4|0)==0)ga=95;else{if((U|0)<=0)break;T=c[B>>2]|0;V=0;do{if((c[T+(V<<2)>>2]&4|0)!=0){ca=c[z>>2]|0;g[ca+(V<<3)>>2]=0;g[ca+(V<<3)+4>>2]=0}V=V+1|0}while((V|0)!=(U|0));ga=95}while(0);do if((ga|0)==
95){ga=0;if((U|0)<=0)break;V=c[C>>2]|0;N=+g[j>>2];T=c[z>>2]|0;ca=0;do{p=N*+g[T+(ca<<3)+4>>2];S=V+(ca<<3)|0;g[S>>2]=N*+g[T+(ca<<3)>>2]+ +g[S>>2];S=V+(ca<<3)+4|0;g[S>>2]=p+ +g[S>>2];ca=ca+1|0}while((ca|0)<(U|0))}while(0);U=(c[l>>2]|0)+1|0;c[l>>2]=U}while((U|0)<(c[n>>2]|0));i=e;return}function cl(a){a=a|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0;d=i;e=+g[a+352>>2];f=c[a+236>>2]|0;if((f|0)>0){h=a+96|0;j=a+104|0;k=a+36|0;l=
a+28|0;m=c[a+232>>2]|0;n=c[a+88>>2]|0;o=0;do{p=c[m+(o*28|0)>>2]|0;if((c[n+(p<<2)>>2]&32|0)!=0?(q=c[m+(o*28|0)+4>>2]|0,r=(c[h>>2]|0)+(p<<3)|0,s=+g[r>>2],t=+g[r+4>>2],r=q+88|0,u=+g[r>>2],v=q+60|0,w=q+64|0,x=q+80|0,y=q+84|0,z=c[j>>2]|0,A=z+(p<<3)|0,B=+g[A>>2],C=z+(p<<3)+4|0,D=+g[C>>2],E=+g[m+(o*28|0)+12>>2]*e*+g[m+(o*28|0)+24>>2],F=E*(+g[x>>2]-u*(t-+g[w>>2])-B),G=E*(u*(s-+g[v>>2])+ +g[y>>2]-D),u=+g[k>>2]*1.3333333730697632,E=u*+g[l>>2]*u,g[A>>2]=B+F*E,g[C>>2]=D+G*E,E=-F,F=-G,(c[q>>2]|0)==2):0){C=q+4|
0;A=b[C>>1]|0;if((A&2)==0?(p=A&65535,(p&2|0)==0):0){z=(p|2)&65535;b[C>>1]=z;g[q+160>>2]=0;H=z}else H=A;if(!((H&2)==0)){G=+g[q+136>>2];g[x>>2]=G*E+ +g[x>>2];g[y>>2]=G*F+ +g[y>>2];g[r>>2]=+g[r>>2]+ +g[q+144>>2]*((s-+g[v>>2])*F-(t-+g[w>>2])*E)}}o=o+1|0}while((o|0)<(f|0))}f=c[a+220>>2]|0;if((f|0)<=0){i=d;return}o=c[a+216>>2]|0;H=a+104|0;a=0;do{if((c[o+(a*24|0)+20>>2]&32|0)!=0){l=c[o+(a*24|0)>>2]|0;k=c[o+(a*24|0)+4>>2]|0;m=c[H>>2]|0;j=m+(k<<3)|0;h=m+(l<<3)|0;E=+g[h>>2];n=m+(k<<3)+4|0;k=m+(l<<3)+4|0;t=
+g[k>>2];F=e*+g[o+(a*24|0)+8>>2];s=F*(+g[j>>2]-E);G=F*(+g[n>>2]-t);g[h>>2]=E+s;g[k>>2]=t+G;g[j>>2]=+g[j>>2]-s;g[n>>2]=+g[n>>2]-G}a=a+1|0}while((a|0)<(f|0));i=d;return}function dl(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;d=i;e=a+44|0;if((c[e>>2]|0)>0){f=a+128|0;h=0;do{j=8784;k=c[j+4>>2]|0;l=(c[f>>2]|0)+(h<<3)|0;c[l>>2]=c[j>>2];c[l+4>>2]=k;h=h+1|0}while((h|0)<(c[e>>2]|0))}e=a+216|0;h=c[a+220>>2]|0;f=(h|0)>0;if(f){k=a+128|0;l=c[e>>2]|0;j=0;do{if((c[l+
(j*24|0)+20>>2]&128|0)!=0){m=c[l+(j*24|0)>>2]|0;n=c[l+(j*24|0)+4>>2]|0;o=+g[l+(j*24|0)+8>>2];p=l+(j*24|0)+12|0;q=+g[p>>2];r=o*(1-o);o=r*q;q=r*+g[p+4>>2];p=c[k>>2]|0;s=p+(m<<3)|0;g[s>>2]=+g[s>>2]-o;s=p+(m<<3)+4|0;g[s>>2]=+g[s>>2]-q;s=p+(n<<3)|0;g[s>>2]=o+ +g[s>>2];s=p+(n<<3)+4|0;g[s>>2]=q+ +g[s>>2]}j=j+1|0}while((j|0)<(h|0))}q=+g[a+32>>2]*+g[b+4>>2];o=+g[a+356>>2]*q;r=q*+g[a+360>>2];t=q*.5;if(!f){i=d;return}f=a+116|0;b=a+128|0;j=a+104|0;a=c[e>>2]|0;e=0;do{if((c[a+(e*24|0)+20>>2]&128|0)!=0){k=c[a+(e*
24|0)>>2]|0;l=c[a+(e*24|0)+4>>2]|0;s=a+(e*24|0)+12|0;q=+g[s>>2];u=+g[s+4>>2];s=c[f>>2]|0;n=c[b>>2]|0;v=o*(+g[s+(k<<2)>>2]+ +g[s+(l<<2)>>2]+-2)+r*(q*(+g[n+(l<<3)>>2]-+g[n+(k<<3)>>2])+u*(+g[n+(l<<3)+4>>2]-+g[n+(k<<3)+4>>2]));w=+g[a+(e*24|0)+8>>2]*(v<t?v:t);v=q*w;q=u*w;n=c[j>>2]|0;s=n+(k<<3)|0;g[s>>2]=+g[s>>2]-v;s=n+(k<<3)+4|0;g[s>>2]=+g[s>>2]-q;s=n+(l<<3)|0;g[s>>2]=+g[s>>2]+v;s=n+(l<<3)+4|0;g[s>>2]=+g[s>>2]+q}e=e+1|0}while((e|0)<(h|0));i=d;return}function el(b){b=b|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,
n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0;e=i;f=~~(+g[b+388>>2]*128);if((f|0)==0){i=e;return}h=b+220|0;j=c[h>>2]|0;if((j|0)<=0){i=e;return}k=b+216|0;l=b+88|0;m=b+136|0;b=d[8064]|0;n=j;j=0;while(1){o=c[k>>2]|0;p=c[o+(j*24|0)>>2]|0;q=c[o+(j*24|0)+4>>2]|0;o=c[l>>2]|0;if((c[o+(p<<2)>>2]&256&c[o+(q<<2)>>2]|0)==0)r=n;else{o=c[m>>2]|0;s=o+(q<<2)|0;t=o+(p<<2)|0;u=d[t>>0]|0;v=(aa((d[s>>0]|0)-u|0,f)|0)>>b;w=o+(q<<2)+1|0;x=o+(p<<2)+1|0;y=d[x>>0]|0;z=(aa((d[w>>0]|0)-y|0,f)|0)>>b;
A=o+(q<<2)+2|0;B=o+(p<<2)+2|0;C=d[B>>0]|0;D=(aa((d[A>>0]|0)-C|0,f)|0)>>b;E=o+(q<<2)+3|0;q=o+(p<<2)+3|0;p=d[q>>0]|0;o=(aa((d[E>>0]|0)-p|0,f)|0)>>b;a[t>>0]=v+u;a[x>>0]=z+y;a[B>>0]=D+C;a[q>>0]=o+p;a[s>>0]=(d[s>>0]|0)-v;a[w>>0]=(d[w>>0]|0)-z;a[A>>0]=(d[A>>0]|0)-D;a[E>>0]=(d[E>>0]|0)-o;r=c[h>>2]|0}j=j+1|0;if((j|0)>=(r|0))break;else n=r}i=e;return}function fl(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;d=i;e=a+120|0;f=c[e>>2]|0;if((f|0)==
0){h=a+48|0;j=c[h>>2]|0;if((j|0)==0){vk(a,256);k=c[h>>2]|0}else k=j;j=Em(c[a+400>>2]|0,k<<2)|0;xn(j|0,0,c[h>>2]<<2|0)|0;l=j}else l=f;c[e>>2]=l;m=+g[a+32>>2]*+g[b+4>>2];n=+g[a+320>>2]*m*m;m=+g[a+376>>2]*n;o=n*.25;n=+g[a+380>>2];b=a+384|0;if((c[b>>2]|0)<=0){i=d;return}l=a+124|0;f=a+44|0;j=a+220|0;h=a+116|0;k=a+88|0;p=a+216|0;a=c[f>>2]|0;q=1;while(1){xn(c[l>>2]|0,0,a<<2|0)|0;r=c[j>>2]|0;if((r|0)>0){s=c[p>>2]|0;t=0;do{if((c[s+(t*24|0)+20>>2]&2048|0)!=0){u=c[s+(t*24|0)>>2]|0;v=c[s+(t*24|0)+4>>2]|0;w=+g[s+
(t*24|0)+8>>2];x=c[e>>2]|0;y=c[l>>2]|0;z=y+(u<<2)|0;g[z>>2]=w*+g[x+(v<<2)>>2]+ +g[z>>2];z=y+(v<<2)|0;g[z>>2]=w*+g[x+(u<<2)>>2]+ +g[z>>2]}t=t+1|0}while((t|0)<(r|0))}r=c[f>>2]|0;if((r|0)>0){t=c[h>>2]|0;s=c[k>>2]|0;z=0;do{w=+g[t+(z<<2)>>2];if((c[s+(z<<2)>>2]&2048|0)==0)g[(c[e>>2]|0)+(z<<2)>>2]=0;else{A=(m*(w+-1)+ +g[(c[l>>2]|0)+(z<<2)>>2])/(n+w);w=A<o?A:o;g[(c[e>>2]|0)+(z<<2)>>2]=w<0?0:w}z=z+1|0}while((z|0)<(r|0))}if((q|0)>=(c[b>>2]|0))break;a=r;q=q+1|0}i=d;return}function gl(a,d){a=a|0;d=d|0;var e=
0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0;e=i;f=a+320|0;h=a+32|0;j=+g[h>>2]*+g[d+4>>2];k=+g[f>>2]*j*j;j=+g[a+336>>2]*k;l=k*.25;m=c[a+44>>2]|0;n=(m|0)>0;if(n){o=c[a+116>>2]|0;p=c[a+124>>2]|0;q=0;do{k=+g[o+(q<<2)>>2]+-1;r=j*(k<0?0:k);g[p+(q<<2)>>2]=r<l?r:l;q=q+1|0}while((q|0)<(m|0))}q=c[a+8>>2]|0;if(!((q&192|0)==0|n^1)){p=c[a+88>>2]|0;o=a+124|0;s=0;do{if((c[p+(s<<2)>>2]&192|0)!=0)g[(c[o>>2]|0)+(s<<2)>>2]=0;s=s+1|0}while((s|0)<(m|0))}if(!((q&2048|0)==0|n^1)){n=
c[a+88>>2]|0;q=a+120|0;s=a+124|0;o=0;do{if((c[n+(o<<2)>>2]&2048|0)!=0){p=(c[s>>2]|0)+(o<<2)|0;g[p>>2]=+g[(c[q>>2]|0)+(o<<2)>>2]+ +g[p>>2]}o=o+1|0}while((o|0)<(m|0))}l=+g[d>>2]/(+g[f>>2]*+g[h>>2]);h=c[a+236>>2]|0;if((h|0)>0){f=a+36|0;d=a+28|0;m=c[a+232>>2]|0;o=c[a+96>>2]|0;q=c[a+124>>2]|0;s=c[a+104>>2]|0;n=0;do{p=c[m+(n*28|0)>>2]|0;t=c[m+(n*28|0)+4>>2]|0;r=+g[m+(n*28|0)+12>>2];u=m+(n*28|0)+16|0;k=+g[u>>2];v=+g[u+4>>2];u=o+(p<<3)|0;w=+g[u>>2];x=+g[u+4>>2];y=l*r*+g[m+(n*28|0)+24>>2]*(j*r+ +g[q+(p<<2)>>
2]);r=k*y;k=v*y;y=+g[f>>2]*1.3333333730697632;v=y*+g[d>>2]*y;u=s+(p<<3)|0;g[u>>2]=+g[u>>2]-r*v;u=s+(p<<3)+4|0;g[u>>2]=+g[u>>2]-k*v;if((c[t>>2]|0)==2){u=t+4|0;p=b[u>>1]|0;if((p&2)==0?(z=p&65535,(z&2|0)==0):0){A=(z|2)&65535;b[u>>1]=A;g[t+160>>2]=0;B=A}else B=p;if(!((B&2)==0)){v=+g[t+136>>2];p=t+80|0;g[p>>2]=r*v+ +g[p>>2];p=t+84|0;g[p>>2]=k*v+ +g[p>>2];p=t+88|0;g[p>>2]=+g[p>>2]+ +g[t+144>>2]*(k*(w-+g[t+60>>2])-r*(x-+g[t+64>>2]))}}n=n+1|0}while((n|0)<(h|0))}h=c[a+220>>2]|0;if((h|0)<=0){i=e;return}n=c[a+
216>>2]|0;B=c[a+124>>2]|0;s=c[a+104>>2]|0;a=0;do{d=c[n+(a*24|0)>>2]|0;f=c[n+(a*24|0)+4>>2]|0;q=n+(a*24|0)+12|0;j=+g[q>>2];x=l*+g[n+(a*24|0)+8>>2]*(+g[B+(d<<2)>>2]+ +g[B+(f<<2)>>2]);r=j*x;j=+g[q+4>>2]*x;q=s+(d<<3)|0;g[q>>2]=+g[q>>2]-r;q=s+(d<<3)+4|0;g[q>>2]=+g[q>>2]-j;q=s+(f<<3)|0;g[q>>2]=r+ +g[q>>2];q=s+(f<<3)+4|0;g[q>>2]=j+ +g[q>>2];a=a+1|0}while((a|0)<(h|0));i=e;return}function hl(a,d){a=a|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=
0,E=0,F=0,G=0,H=0,I=0,J=0;e=i;f=+g[a+340>>2];h=1/(+g[a+32>>2]*+g[d+4>>2]);d=c[a+236>>2]|0;if((d|0)>0){j=a+36|0;k=a+28|0;l=c[a+232>>2]|0;m=c[a+96>>2]|0;n=c[a+104>>2]|0;o=0;do{p=c[l+(o*28|0)>>2]|0;q=c[l+(o*28|0)+4>>2]|0;r=l+(o*28|0)+16|0;s=+g[r>>2];t=+g[r+4>>2];r=m+(p<<3)|0;u=+g[r>>2];v=+g[r+4>>2];r=q+88|0;w=+g[r>>2];x=q+60|0;y=q+64|0;z=q+80|0;A=q+84|0;B=n+(p<<3)|0;C=+g[B>>2];D=n+(p<<3)+4|0;E=+g[D>>2];F=s*(+g[z>>2]-w*(v-+g[y>>2])-C)+t*(w*(u-+g[x>>2])+ +g[A>>2]-E);if(F<0?(w=f*+g[l+(o*28|0)+12>>2],G=
h*F,H=G>-.5?-G:.5,G=F*+g[l+(o*28|0)+24>>2]*(w>H?w:H),H=s*G,s=t*G,G=+g[j>>2]*1.3333333730697632,t=G*+g[k>>2]*G,g[B>>2]=C+t*H,g[D>>2]=E+t*s,t=-H,H=-s,(c[q>>2]|0)==2):0){D=q+4|0;B=b[D>>1]|0;if((B&2)==0?(p=B&65535,(p&2|0)==0):0){I=(p|2)&65535;b[D>>1]=I;g[q+160>>2]=0;J=I}else J=B;if(!((J&2)==0)){s=+g[q+136>>2];g[z>>2]=s*t+ +g[z>>2];g[A>>2]=s*H+ +g[A>>2];g[r>>2]=+g[r>>2]+ +g[q+144>>2]*((u-+g[x>>2])*H-(v-+g[y>>2])*t)}}o=o+1|0}while((o|0)<(d|0))}d=c[a+220>>2]|0;if((d|0)<=0){i=e;return}o=c[a+216>>2]|0;J=c[a+
104>>2]|0;a=0;do{k=c[o+(a*24|0)>>2]|0;j=c[o+(a*24|0)+4>>2]|0;l=o+(a*24|0)+12|0;t=+g[l>>2];v=+g[l+4>>2];l=J+(j<<3)|0;n=J+(k<<3)|0;H=+g[n>>2];m=J+(j<<3)+4|0;j=J+(k<<3)+4|0;u=+g[j>>2];s=t*(+g[l>>2]-H)+v*(+g[m>>2]-u);if(s<0){E=f*+g[o+(a*24|0)+8>>2];C=h*s;G=C>-.5?-C:.5;C=s*(E>G?E:G);G=t*C;t=v*C;g[n>>2]=H+G;g[j>>2]=u+t;g[l>>2]=+g[l>>2]-G;g[m>>2]=+g[m>>2]-t}a=a+1|0}while((a|0)<(d|0));i=e;return}function il(a){a=a|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=
0,B=0,C=0,D=0,E=0,F=0;d=i;e=c[a+236>>2]|0;if((e|0)<=0){i=d;return}f=a+96|0;h=a+104|0;j=a+36|0;k=a+28|0;l=c[a+232>>2]|0;m=c[a+88>>2]|0;a=0;do{n=c[l+(a*28|0)>>2]|0;if(((c[m+(n<<2)>>2]&2048|0)!=0?(o=c[l+(a*28|0)+4>>2]|0,p=l+(a*28|0)+16|0,q=+g[p>>2],r=+g[p+4>>2],p=(c[f>>2]|0)+(n<<3)|0,s=+g[p>>2],t=+g[p+4>>2],p=o+88|0,u=+g[p>>2],v=o+60|0,w=o+64|0,x=o+80|0,y=o+84|0,z=c[h>>2]|0,A=z+(n<<3)|0,B=+g[A>>2],C=z+(n<<3)+4|0,D=+g[C>>2],E=q*(+g[x>>2]-u*(t-+g[w>>2])-B)+r*(u*(s-+g[v>>2])+ +g[y>>2]-D),E<0):0)?(u=E*+g[l+
(a*28|0)+24>>2]*.5,E=q*u,q=r*u,u=+g[j>>2]*1.3333333730697632,r=u*+g[k>>2]*u,g[A>>2]=B+E*r,g[C>>2]=D+q*r,r=-E,E=-q,(c[o>>2]|0)==2):0){C=o+4|0;A=b[C>>1]|0;if((A&2)==0?(n=A&65535,(n&2|0)==0):0){z=(n|2)&65535;b[C>>1]=z;g[o+160>>2]=0;F=z}else F=A;if(!((F&2)==0)){q=+g[o+136>>2];g[x>>2]=q*r+ +g[x>>2];g[y>>2]=q*E+ +g[y>>2];g[p>>2]=+g[p>>2]+ +g[o+144>>2]*((s-+g[v>>2])*E-(t-+g[w>>2])*r)}}a=a+1|0}while((a|0)<(e|0));i=d;return}function jl(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=
0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0;d=i;e=+g[b+4>>2]*+g[a+344>>2];f=a+268|0;h=c[f>>2]|0;if((h|0)<=0){i=d;return}j=a+264|0;l=a+96|0;m=a+104|0;a=h;h=0;while(1){n=c[j>>2]|0;if((c[n+(h*60|0)+12>>2]&16|0)==0)o=a;else{p=c[n+(h*60|0)>>2]|0;q=c[n+(h*60|0)+4>>2]|0;r=c[n+(h*60|0)+8>>2]|0;s=c[l>>2]|0;t=s+(p<<3)|0;u=+g[t>>2];v=+g[t+4>>2];t=s+(q<<3)|0;w=+g[t>>2];x=+g[t+4>>2];t=s+(r<<3)|0;y=+g[t>>2];s=c[m>>2]|0;z=+g[b>>2];A=s+(p<<3)|0;B=+g[A>>2];C=s+(p<<3)+
4|0;D=+g[C>>2];E=u+z*B;u=v+z*D;p=s+(q<<3)|0;F=s+(q<<3)+4|0;v=w+z*+g[p>>2];w=x+z*+g[F>>2];q=s+(r<<3)|0;G=s+(r<<3)+4|0;x=y+z*+g[q>>2];y=+g[t+4>>2]+z*+g[G>>2];z=(E+v+x)*.3333333432674408;H=(u+w+y)*.3333333432674408;I=E-z;E=u-H;u=v-z;v=w-H;w=x-z;z=y-H;H=+g[n+(h*60|0)+20>>2];y=+g[n+(h*60|0)+24>>2];t=n+(h*60|0)+28|0;x=+g[t>>2];r=n+(h*60|0)+32|0;J=+g[r>>2];s=n+(h*60|0)+36|0;K=+g[s>>2];L=n+(h*60|0)+40|0;M=+g[L>>2];N=H*E-y*I+(x*v-J*u)+(K*z-w*M);O=H*I+y*E+(x*u+J*v)+(w*K+z*M);M=N*N+O*O;K=(c[k>>2]=1597463007-
((g[k>>2]=M,c[k>>2]|0)>>1),+g[k>>2]);J=K*(1.5-K*M*.5*K);K=N*J;N=O*J;J=e*+g[n+(h*60|0)+16>>2];g[A>>2]=B+J*(H*N-y*K-I);g[C>>2]=D+J*(H*K+y*N-E);E=+g[t>>2];y=+g[r>>2];g[p>>2]=+g[p>>2]+J*(E*N-y*K-u);g[F>>2]=+g[F>>2]+J*(E*K+y*N-v);v=+g[s>>2];y=+g[L>>2];g[q>>2]=+g[q>>2]+J*(v*N-y*K-w);g[G>>2]=+g[G>>2]+J*(v*K+y*N-z);o=c[f>>2]|0}h=h+1|0;if((h|0)>=(o|0))break;else a=o}i=d;return}function kl(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;d=i;e=+g[b+4>>2]*
+g[a+348>>2];f=c[a+252>>2]|0;if((f|0)<=0){i=d;return}h=a+96|0;j=a+104|0;k=c[a+248>>2]|0;a=0;do{if((c[k+(a*20|0)+8>>2]&8|0)!=0){l=c[k+(a*20|0)>>2]|0;m=c[k+(a*20|0)+4>>2]|0;n=c[h>>2]|0;o=n+(l<<3)|0;p=+g[o>>2];q=+g[o+4>>2];o=n+(m<<3)|0;r=+g[o>>2];n=c[j>>2]|0;s=+g[b>>2];t=n+(l<<3)|0;u=+g[t>>2];v=n+(l<<3)+4|0;w=+g[v>>2];l=n+(m<<3)|0;x=n+(m<<3)+4|0;y=r+s*+g[l>>2]-(p+s*u);p=+g[o+4>>2]+s*+g[x>>2]-(q+s*w);s=+Q(+(y*y+p*p));q=(+g[k+(a*20|0)+16>>2]-s)*e*+g[k+(a*20|0)+12>>2]/s;s=y*q;y=p*q;g[t>>2]=u-s;g[v>>2]=
w-y;g[l>>2]=s+ +g[l>>2];g[x>>2]=y+ +g[x>>2]}a=a+1|0}while((a|0)<(f|0));i=d;return}function ll(a){a=a|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0;d=i;e=+g[a+340>>2];f=a+236|0;if((c[f>>2]|0)>0){h=a+232|0;j=a+144|0;k=a+96|0;l=0;do{m=c[h>>2]|0;n=c[m+(l*28|0)>>2]|0;o=c[(c[j>>2]|0)+(n<<2)>>2]|0;if(((o|0)!=0?(c[o+12>>2]&2|0)!=
0:0)?(p=c[m+(l*28|0)+4>>2]|0,q=m+(l*28|0)+16|0,r=+g[q>>2],s=+g[q+4>>2],t=+g[m+(l*28|0)+12>>2],m=(c[k>>2]|0)+(n<<3)|0,u=+g[m>>2],v=+g[m+4>>2],m=p+88|0,w=+g[m>>2],n=p+60|0,q=p+64|0,x=p+80|0,y=+g[x>>2]-w*(v-+g[q>>2]),z=p+84|0,A=w*(u-+g[n>>2])+ +g[z>>2],nk(o),B=o+56|0,w=+g[B>>2],C=o+48|0,D=o+52|0,E=r*(y-(+g[C>>2]-w*(v-+g[o+44>>2])))+s*(A-(w*(u-+g[o+40>>2])+ +g[D>>2])),E<0):0){nk(o);w=+g[o+32>>2];nk(o);A=+g[o+36>>2];nk(o);F=o+40|0;y=+g[F>>2];if(w>0)G=1/w;else G=0;if(A>0)H=1/A;else H=0;A=s*(u-y)-r*(v-+g[F+
4>>2]);y=+g[p+132>>2];w=+g[p+44>>2];I=+g[p+48>>2];J=y*(w*w+I*I);I=+g[p+140>>2]+J-J;if(y>0)K=1/y;else K=0;if(I>0)L=1/I;else L=0;I=s*(u-+g[n>>2])-r*(v-+g[q>>2]);y=G+A*A*H+K+I*L*I;if(y>0)M=E/y;else M=0;y=e*(t<1?t:1)*M;t=G*y;g[C>>2]=+g[C>>2]+r*t;g[D>>2]=+g[D>>2]+s*t;g[B>>2]=H*A*y+ +g[B>>2];A=-y;y=r*A;r=s*A;if((c[p>>2]|0)==2){B=p+4|0;D=b[B>>1]|0;if((D&2)==0?(C=D&65535,(C&2|0)==0):0){F=(C|2)&65535;b[B>>1]=F;g[p+160>>2]=0;N=F}else N=D;if(!((N&2)==0)){A=+g[p+136>>2];g[x>>2]=y*A+ +g[x>>2];g[z>>2]=r*A+ +g[z>>
2];g[m>>2]=+g[m>>2]+ +g[p+144>>2]*(r*(u-+g[n>>2])-y*(v-+g[q>>2]))}}}l=l+1|0}while((l|0)<(c[f>>2]|0))}f=a+220|0;if((c[f>>2]|0)<=0){i=d;return}l=a+216|0;N=a+144|0;k=a+96|0;j=a+104|0;h=a+88|0;q=a+32|0;n=a+320|0;a=0;do{p=c[l>>2]|0;m=c[p+(a*24|0)>>2]|0;z=c[p+(a*24|0)+4>>2]|0;x=p+(a*24|0)+12|0;H=+g[x>>2];G=+g[x+4>>2];M=+g[p+(a*24|0)+8>>2];p=c[N>>2]|0;x=c[p+(m<<2)>>2]|0;D=c[p+(z<<2)>>2]|0;p=(x|0)==0;if(p)O=0;else O=(c[x+12>>2]&2|0)!=0;F=(D|0)==0;if(F)P=0;else P=(c[D+12>>2]&2|0)!=0;do if((x|0)!=(D|0)&(O|
P)){B=c[k>>2]|0;L=(+g[B+(m<<3)>>2]+ +g[B+(z<<3)>>2])*.5;K=(+g[B+(m<<3)+4>>2]+ +g[B+(z<<3)+4>>2])*.5;if(!F?(c[D+12>>2]&2|0)!=0:0){nk(D);v=+g[D+56>>2];Q=+g[D+48>>2]-v*(K-+g[D+44>>2]);R=v*(L-+g[D+40>>2])+ +g[D+52>>2]}else{B=(c[j>>2]|0)+(z<<3)|0;v=+g[B>>2];Q=v;R=+g[B+4>>2]}if(!p?(c[x+12>>2]&2|0)!=0:0){nk(x);v=+g[x+56>>2];S=+g[x+48>>2]-v*(K-+g[x+44>>2]);T=v*(L-+g[x+40>>2])+ +g[x+52>>2]}else{B=(c[j>>2]|0)+(m<<3)|0;v=+g[B>>2];S=v;T=+g[B+4>>2]}v=G*(R-T)+H*(Q-S);if(v<0){if(O){nk(x);y=+g[x+32>>2];nk(x);u=+g[x+
36>>2];nk(x);B=x+40|0;r=+g[B>>2];if(y>0)U=1/y;else U=0;if(u>0)V=1/u;else V=0;W=V;X=U;Y=G*(L-r)-H*(K-+g[B+4>>2])}else{if((c[(c[h>>2]|0)+(m<<2)>>2]&4|0)==0?(r=+g[q>>2]*.75,u=r*+g[n>>2]*r,u>0):0)Z=1/u;else Z=0;W=0;X=Z;Y=G*(L-L)-H*(K-K)}if(P){nk(D);u=+g[D+32>>2];nk(D);r=+g[D+36>>2];nk(D);B=D+40|0;y=+g[B>>2];if(u>0)_=1/u;else _=0;if(r>0)$=1/r;else $=0;aa=_;ba=$;ca=G*(L-y)-H*(K-+g[B+4>>2])}else{if((c[(c[h>>2]|0)+(z<<2)>>2]&4|0)==0?(y=+g[q>>2]*.75,r=y*+g[n>>2]*y,r>0):0)da=1/r;else da=0;aa=da;ba=0;ca=G*(L-
L)-H*(K-K)}K=X+Y*W*Y+aa+ca*ba*ca;if(K>0)ea=v/K;else ea=0;K=e*M*ea;if(O){v=X*K;B=x+48|0;g[B>>2]=H*v+ +g[B>>2];B=x+52|0;g[B>>2]=G*v+ +g[B>>2];B=x+56|0;g[B>>2]=W*Y*K+ +g[B>>2]}else{B=c[j>>2]|0;v=X*K;C=B+(m<<3)|0;g[C>>2]=H*v+ +g[C>>2];C=B+(m<<3)+4|0;g[C>>2]=G*v+ +g[C>>2]}v=-K;if(P){K=aa*v;C=D+48|0;g[C>>2]=H*K+ +g[C>>2];C=D+52|0;g[C>>2]=G*K+ +g[C>>2];C=D+56|0;g[C>>2]=ba*ca*v+ +g[C>>2];break}else{C=c[j>>2]|0;K=aa*v;B=C+(z<<3)|0;g[B>>2]=H*K+ +g[B>>2];B=C+(z<<3)+4|0;g[B>>2]=G*K+ +g[B>>2];break}}}while(0);
a=a+1|0}while((a|0)<(c[f>>2]|0));i=d;return}function ml(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;d=i;e=c[a+312>>2]|0;if((e|0)==0){i=d;return}f=b+4|0;h=a+104|0;j=a+96|0;a=e;do{if((c[a+12>>2]&2|0)!=0?(nk(a),k=+g[b>>2],l=k*+g[a+56>>2],m=+T(+l),n=+S(+l),l=+g[a+40>>2],o=+g[a+44>>2],p=k*+g[a+48>>2]+l-(n*l-m*o),q=k*+g[a+52>>2]+o-(m*l+n*o),e=a+60|0,o=+g[a+72>>2],l=+g[a+68>>2],k=+(m*o+n*l),r=+(n*o-m*l),l=+g[e>>2],o=+g[a+64>>2],s=+(p+(n*l-m*o)),t=+(q+(m*l+n*o)),
u=e,g[u>>2]=s,g[u+4>>2]=t,u=a+68|0,g[u>>2]=k,g[u+4>>2]=r,r=+g[f>>2],k=p*r,p=q*r,q=m*r,m=(n+-1)*r,u=c[a+4>>2]|0,e=a+8|0,(u|0)<(c[e>>2]|0)):0){v=u;do{u=c[j>>2]|0;r=+g[u+(v<<3)>>2];n=+g[u+(v<<3)+4>>2];t=+(k+(m*r-q*n));s=+(p+(q*r+m*n));u=(c[h>>2]|0)+(v<<3)|0;g[u>>2]=t;g[u+4>>2]=s;v=v+1|0}while((v|0)<(c[e>>2]|0))}a=c[a+24>>2]|0}while((a|0)!=0);i=d;return}function nl(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0;h=i;j=+(e-d|0);k=+g[f>>2]/j;l=+g[f+4>>2]/j;if(!(k!=0|l!=0)){i=h;return}f=b+21|0;if((a[f>>
0]|0)==0){xn(c[b+112>>2]|0,0,c[b+44>>2]<<3|0)|0;a[f>>0]=1}if((d|0)>=(e|0)){i=h;return}f=c[b+112>>2]|0;b=d;do{d=f+(b<<3)|0;g[d>>2]=k+ +g[d>>2];d=f+(b<<3)+4|0;g[d>>2]=l+ +g[d>>2];b=b+1|0}while((b|0)!=(e|0));i=h;return}function ol(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0;f=i;h=+g[a+32>>2]*.75;j=+(d-b|0)*h*+g[a+320>>2]*h;h=+g[e>>2]/j;k=+g[e+4>>2]/j;if((b|0)>=(d|0)){i=f;return}e=c[a+104>>2]|0;a=b;do{b=e+(a<<3)|0;g[b>>2]=h+ +g[b>>2];b=e+(a<<3)+4|0;g[b>>2]=k+ +g[b>>2];a=a+1|0}while((a|0)!=(d|
0));i=f;return}function pl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;e=i;f=c[a+204>>2]|0;if((f|0)==0){i=e;return}h=c[a+200>>2]|0;j=+g[a+36>>2];k=+g[d>>2];l=d+4|0;m=(~~(j*+g[l>>2]+2048)>>>0<<20)+(~~(j*k*256+524288)>>>0)|0;n=h;o=f<<3>>3;a:while(1){p=o;while(1){if((p|0)==0)break a;q=(p|0)/2|0;if((c[n+(q<<3)+4>>2]|0)>>>0<m>>>0)break;else p=q}n=n+(q+1<<3)|0;o=p+-1-q|0}q=d+8|0;o=d+12|0;m=(~~(j*+g[o>>2]+2048)>>>0<<20)+(~~(j*+g[q>>2]*256+524288)>>>0)|0;r=n;s=
h+(f<<3)-n>>3;b:while(1){f=s;while(1){if((f|0)==0)break b;t=(f|0)/2|0;if((c[r+(t<<3)+4>>2]|0)>>>0>m>>>0)f=t;else break}r=r+(t+1<<3)|0;s=f+-1-t|0}if(!(n>>>0<r>>>0)){i=e;return}t=a+96|0;j=k;s=n;while(1){n=c[s>>2]|0;m=c[t>>2]|0;k=+g[m+(n<<3)>>2];if((((j<k?k<+g[q>>2]:0)?(k=+g[m+(n<<3)+4>>2],+g[l>>2]<k):0)?k<+g[o>>2]:0)?!(hb[c[(c[b>>2]|0)+12>>2]&15](b,a,n)|0):0){u=21;break}n=s+8|0;if(!(n>>>0<r>>>0)){u=21;break}j=+g[d>>2];s=n}if((u|0)==21){i=e;return}}function ql(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=
0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0;f=i;i=i+64|0;h=f;j=f+32|0;k=f+24|0;l=f+16|0;if((c[a+204>>2]|0)==0){i=f;return}m=+g[d>>2];n=+g[e>>2];o=d+4|0;p=+g[o>>2];q=+g[e+4>>2];r=+(m<n?m:n);s=+(p<q?p:q);e=h;g[e>>2]=r;g[e+4>>2]=s;s=+(m>n?m:n);r=+(p>q?p:q);e=h+8|0;g[e>>2]=s;g[e+4>>2]=r;r=n-m;m=q-p;p=r*r+m*m;Nk(j,a,h);h=j+16|0;e=c[j+20>>2]|0;t=j+4|0;u=a+96|0;v=a+40|0;w=k+4|0;x=l+4|0;y=c[h>>2]|0;q=1;a:while(1){if(!(y>>>
0<e>>>0)){z=16;break}A=c[j>>2]|0;B=c[t>>2]|0;C=y;while(1){D=c[C+4>>2]&1048575;E=C;C=C+8|0;c[h>>2]=C;if(D>>>0<A>>>0|D>>>0>B>>>0)if(C>>>0<e>>>0){C=C;continue}else{z=16;break a}F=c[E>>2]|0;if(!((F|0)>-1)){z=16;break a}E=c[u>>2]|0;G=+g[d>>2];H=G-+g[E+(F<<3)>>2];I=+g[o>>2];J=I-+g[E+(F<<3)+4>>2];n=r*H+m*J;s=n*n-p*(H*H+J*J-+g[v>>2]);if(s>=0?(K=+Q(+s),s=(-n-K)/p,!(s>q)):0){if(!(s<0)){L=s;break}s=(K-n)/p;if(!(s<0|s>q)){L=s;break}}if(!(C>>>0<e>>>0)){z=16;break a}}s=r*L;n=m*L;K=H+s;M=J+n;g[k>>2]=K;g[w>>2]=M;
N=+Q(+(K*K+M*M));if(!(N<1.1920928955078125E-7)){O=1/N;g[k>>2]=K*O;g[w>>2]=M*O}B=c[(c[b>>2]|0)+12>>2]|0;g[l>>2]=s+G;g[x>>2]=n+I;n=+ab[B&1](b,a,F,l,k,L);q=q<n?q:n;if(q<=0){z=16;break}else y=C}if((z|0)==16){i=f;return}}function rl(b,c,e){b=b|0;c=c|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;f=i;g=((e+-4+(0-c)|0)>>>2)+1|0;h=b;j=c;k=c;while(1){c=d[h>>0]|d[h+1>>0]<<8|d[h+2>>0]<<16|d[h+3>>0]<<24;l=k+1|0;m=a[l>>0]|0;n=k+2|0;o=a[n>>0]|0;p=k+3|0;q=a[p>>0]|0;a[h>>0]=a[k>>
0]|0;a[h+1>>0]=m;a[h+2>>0]=o;a[h+3>>0]=q;a[k>>0]=c;a[l>>0]=c>>>8;a[n>>0]=c>>>16;a[p>>0]=c>>>24;c=h+4|0;p=k+4|0;r=(c|0)==(j|0);if((p|0)==(e|0))break;h=c;j=r?p:j;k=p}k=b+(g<<2)|0;if(r){i=f;return k|0}else{s=k;t=j;u=j}a:while(1){j=s;r=u;while(1){g=d[j>>0]|d[j+1>>0]<<8|d[j+2>>0]<<16|d[j+3>>0]<<24;b=r+1|0;h=a[b>>0]|0;p=r+2|0;c=a[p>>0]|0;n=r+3|0;l=a[n>>0]|0;a[j>>0]=a[r>>0]|0;a[j+1>>0]=h;a[j+2>>0]=c;a[j+3>>0]=l;a[r>>0]=g;a[b>>0]=g>>>8;a[p>>0]=g>>>16;a[n>>0]=g>>>24;j=j+4|0;v=r+4|0;w=(j|0)==(t|0);if((v|0)!=
(e|0))break;if(w)break a;else r=t}s=j;t=w?v:t;u=v}i=f;return k|0}function sl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0;e=i;f=a;a=b;a:while(1){b=a;g=a+-4|0;h=f;b:while(1){j=h;k=b-j|0;l=k>>2;switch(l|0){case 2:m=4;break a;break;case 3:m=6;break a;break;case 5:m=8;break a;break;case 4:m=7;break a;break;case 1:case 0:m=51;break a;break;default:}if((k|
0)<124){m=10;break a}n=(l|0)/2|0;o=h+(n<<2)|0;if((k|0)>3996){k=(l|0)/4|0;p=vl(h,h+(k<<2)|0,o,h+(k+n<<2)|0,g,d)|0}else p=tl(h,o,g,c[d>>2]|0)|0;n=c[h>>2]|0;k=c[d>>2]|0;l=c[k+(n<<2)>>2]|0;q=c[k+(c[o>>2]<<2)>>2]|0;r=+(l|0)<=0;s=+(q|0)<=0;do if(r^s?r:(l|0)>(q|0)){t=g;u=p}else{v=g;while(1){v=v+-4|0;if((h|0)==(v|0))break;w=c[v>>2]|0;x=c[k+(w<<2)>>2]|0;y=+(x|0)<=0;if(y^s?y:(x|0)>(q|0)){m=34;break}}if((m|0)==34){m=0;c[h>>2]=w;c[v>>2]=n;t=v;u=p+1|0;break}x=h+4|0;y=c[g>>2]|0;z=c[k+(y<<2)>>2]|0;if(r^+(z|0)<=
0?r:(l|0)>(z|0))A=x;else{if((x|0)==(g|0)){m=51;break a}else B=x;while(1){C=c[B>>2]|0;x=c[k+(C<<2)>>2]|0;D=B+4|0;if(r^+(x|0)<=0?r:(l|0)>(x|0))break;if((D|0)==(g|0)){m=51;break a}else B=D}c[B>>2]=y;c[g>>2]=C;A=D}if((A|0)==(g|0)){m=51;break a}else{E=A;F=g}while(1){v=c[k+(c[h>>2]<<2)>>2]|0;x=+(v|0)<=0;z=E;while(1){G=c[z>>2]|0;H=c[k+(G<<2)>>2]|0;I=z+4|0;if(x^+(H|0)<=0?x:(v|0)>(H|0)){J=F;break}else z=I}do{J=J+-4|0;K=c[J>>2]|0;H=c[k+(K<<2)>>2]|0}while(x^+(H|0)<=0?x:(v|0)>(H|0));if(!(z>>>0<J>>>0)){h=z;continue b}c[z>>
2]=K;c[J>>2]=G;E=I;F=J}}while(0);l=h+4|0;c:do if(l>>>0<t>>>0){r=l;n=t;q=o;s=u;while(1){y=c[k+(c[q>>2]<<2)>>2]|0;v=+(y|0)<=0;x=r;while(1){L=c[x>>2]|0;H=c[k+(L<<2)>>2]|0;M=+(H|0)<=0;N=x+4|0;if(M^v?M:(H|0)>(y|0))x=N;else{O=n;break}}do{O=O+-4|0;P=c[O>>2]|0;z=c[k+(P<<2)>>2]|0;H=+(z|0)<=0}while(!(H^v?H:(z|0)>(y|0)));if(x>>>0>O>>>0){Q=x;R=q;S=s;break c}c[x>>2]=P;c[O>>2]=L;r=N;n=O;q=(q|0)==(x|0)?O:q;s=s+1|0}}else{Q=l;R=o;S=u}while(0);if((Q|0)!=(R|0)?(o=c[R>>2]|0,l=c[Q>>2]|0,s=c[k+(o<<2)>>2]|0,q=c[k+(l<<2)>>
2]|0,n=+(s|0)<=0,n^+(q|0)<=0?n:(s|0)>(q|0)):0){c[Q>>2]=o;c[R>>2]=l;T=S+1|0}else T=S;if((T|0)==0){U=wl(h,Q,d)|0;l=Q+4|0;if(wl(l,a,d)|0){m=46;break}if(U){h=l;continue}}l=Q;if((l-j|0)>=(b-l|0)){m=50;break}sl(h,Q,d);h=Q+4|0}if((m|0)==46){m=0;if(U){m=51;break}else{f=h;a=Q;continue}}else if((m|0)==50){m=0;sl(Q+4|0,a,d);f=h;a=Q;continue}}if((m|0)==4){Q=c[g>>2]|0;f=c[h>>2]|0;U=c[d>>2]|0;T=c[U+(Q<<2)>>2]|0;S=c[U+(f<<2)>>2]|0;U=+(T|0)<=0;if(!(U^+(S|0)<=0?U:(T|0)>(S|0))){i=e;return}c[h>>2]=Q;c[g>>2]=f;i=e;return}else if((m|
0)==6){tl(h,h+4|0,g,c[d>>2]|0)|0;i=e;return}else if((m|0)==7){ul(h,h+4|0,h+8|0,g,d)|0;i=e;return}else if((m|0)==8){vl(h,h+4|0,h+8|0,h+12|0,g,d)|0;i=e;return}else if((m|0)==10){g=h+8|0;tl(h,h+4|0,g,c[d>>2]|0)|0;f=h+12|0;if((f|0)==(a|0)){i=e;return}Q=c[d>>2]|0;d=f;f=g;while(1){g=c[d>>2]|0;S=c[f>>2]|0;T=Q+(g<<2)|0;U=c[T>>2]|0;R=c[Q+(S<<2)>>2]|0;u=+(U|0)<=0;if(u^+(R|0)<=0?u:(U|0)>(R|0)){R=S;S=d;U=f;while(1){c[S>>2]=R;if((U|0)==(h|0)){V=h;break}u=U+-4|0;R=c[u>>2]|0;O=c[T>>2]|0;N=c[Q+(R<<2)>>2]|0;L=+(O|
0)<=0;if(!(L^+(N|0)<=0?L:(O|0)>(N|0))){V=U;break}else{N=U;U=u;S=N}}c[V>>2]=g}S=d+4|0;if((S|0)==(a|0))break;else{U=d;d=S;f=U}}i=e;return}else if((m|0)==51){i=e;return}}function tl(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;f=i;g=c[b>>2]|0;h=c[a>>2]|0;j=c[e+(g<<2)>>2]|0;k=e+(h<<2)|0;l=c[k>>2]|0;m=+(j|0)<=0;n=c[d>>2]|0;o=c[e+(n<<2)>>2]|0;p=+(o|0)<=0;q=p^m?p:(o|0)>(j|0);if(!(m^+(l|0)<=0?m:(j|0)>(l|0))){if(!q){r=0;i=f;return r|0}c[b>>2]=n;c[d>>2]=g;l=c[b>>2]|0;
j=c[a>>2]|0;m=c[e+(l<<2)>>2]|0;o=c[e+(j<<2)>>2]|0;p=+(m|0)<=0;if(!(p^+(o|0)<=0?p:(m|0)>(o|0))){r=1;i=f;return r|0}c[a>>2]=l;c[b>>2]=j;r=2;i=f;return r|0}if(q){c[a>>2]=n;c[d>>2]=h;r=1;i=f;return r|0}c[a>>2]=g;c[b>>2]=h;g=c[d>>2]|0;a=c[e+(g<<2)>>2]|0;e=c[k>>2]|0;k=+(a|0)<=0;if(!(k^+(e|0)<=0?k:(a|0)>(e|0))){r=1;i=f;return r|0}c[b>>2]=g;c[d>>2]=h;r=2;i=f;return r|0}function ul(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;g=i;h=tl(a,b,d,c[f>>2]|0)|0;j=c[e>>2]|0;k=c[d>>2]|
0;l=c[f>>2]|0;f=c[l+(j<<2)>>2]|0;m=c[l+(k<<2)>>2]|0;n=+(f|0)<=0;if(!(n^+(m|0)<=0?n:(f|0)>(m|0))){o=h;i=g;return o|0}c[d>>2]=j;c[e>>2]=k;k=c[d>>2]|0;e=c[b>>2]|0;j=c[l+(k<<2)>>2]|0;m=c[l+(e<<2)>>2]|0;f=+(j|0)<=0;if(!(f^+(m|0)<=0?f:(j|0)>(m|0))){o=h+1|0;i=g;return o|0}c[b>>2]=k;c[d>>2]=e;e=c[b>>2]|0;d=c[a>>2]|0;k=c[l+(e<<2)>>2]|0;m=c[l+(d<<2)>>2]|0;l=+(k|0)<=0;if(!(l^+(m|0)<=0?l:(k|0)>(m|0))){o=h+2|0;i=g;return o|0}c[a>>2]=e;c[b>>2]=d;o=h+3|0;i=g;return o|0}function vl(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;
e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;h=i;j=ul(a,b,d,e,g)|0;k=c[f>>2]|0;l=c[e>>2]|0;m=c[g>>2]|0;g=c[m+(k<<2)>>2]|0;n=c[m+(l<<2)>>2]|0;o=+(g|0)<=0;if(!(o^+(n|0)<=0?o:(g|0)>(n|0))){p=j;i=h;return p|0}c[e>>2]=k;c[f>>2]=l;l=c[e>>2]|0;f=c[d>>2]|0;k=c[m+(l<<2)>>2]|0;n=c[m+(f<<2)>>2]|0;g=+(k|0)<=0;if(!(g^+(n|0)<=0?g:(k|0)>(n|0))){p=j+1|0;i=h;return p|0}c[d>>2]=l;c[e>>2]=f;f=c[d>>2]|0;e=c[b>>2]|0;l=c[m+(f<<2)>>2]|0;n=c[m+(e<<2)>>2]|0;k=+(l|0)<=0;if(!(k^+(n|0)<=0?k:(l|0)>(n|0))){p=j+2|0;i=
h;return p|0}c[b>>2]=f;c[d>>2]=e;e=c[b>>2]|0;d=c[a>>2]|0;f=c[m+(e<<2)>>2]|0;n=c[m+(d<<2)>>2]|0;m=+(f|0)<=0;if(!(m^+(n|0)<=0?m:(f|0)>(n|0))){p=j+3|0;i=h;return p|0}c[a>>2]=e;c[b>>2]=d;p=j+4|0;i=h;return p|0}function wl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;e=i;switch(b-a>>2|0){case 3:tl(a,a+4|0,b+-4|0,c[d>>2]|0)|0;f=1;i=e;return f|0;case 2:g=b+-4|0;h=c[g>>2]|0;j=c[a>>2]|0;k=c[d>>2]|0;l=c[k+(h<<2)>>2]|0;m=c[k+(j<<2)>>2]|0;k=+(l|0)<=0;if(!(k^
+(m|0)<=0?k:(l|0)>(m|0))){f=1;i=e;return f|0}c[a>>2]=h;c[g>>2]=j;f=1;i=e;return f|0;case 4:ul(a,a+4|0,a+8|0,b+-4|0,d)|0;f=1;i=e;return f|0;case 1:case 0:f=1;i=e;return f|0;case 5:vl(a,a+4|0,a+8|0,a+12|0,b+-4|0,d)|0;f=1;i=e;return f|0;default:j=a+8|0;tl(a,a+4|0,j,c[d>>2]|0)|0;g=a+12|0;if((g|0)==(b|0)){f=1;i=e;return f|0}h=c[d>>2]|0;d=0;m=g;g=j;while(1){j=c[m>>2]|0;l=c[g>>2]|0;k=h+(j<<2)|0;n=c[k>>2]|0;o=c[h+(l<<2)>>2]|0;p=+(n|0)<=0;if(p^+(o|0)<=0?p:(n|0)>(o|0)){o=l;l=m;n=g;while(1){c[l>>2]=o;if((n|
0)==(a|0)){q=a;break}p=n+-4|0;o=c[p>>2]|0;r=c[k>>2]|0;s=c[h+(o<<2)>>2]|0;t=+(r|0)<=0;if(!(t^+(s|0)<=0?t:(r|0)>(s|0))){q=n;break}else{s=n;n=p;l=s}}c[q>>2]=j;l=d+1|0;if((l|0)==8)break;else u=l}else u=d;l=m+4|0;if((l|0)==(b|0)){f=1;v=15;break}else{n=m;d=u;m=l;g=n}}if((v|0)==15){i=e;return f|0}f=(m+4|0)==(b|0);i=e;return f|0}return 0}function xl(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;d=i;i=i+32|0;e=d+16|0;f=d+8|0;h=d;j=a+4|0;k=a+8|0;if((c[b>>2]|0)==(c[j>>2]|0)){l=c[k>>2]|
0;c[a+8>>2]=l+1;if((l|0)>3){l=c[a+12>>2]|0;c[l>>2]=(c[l>>2]|0)+1;m=1;i=d;return m|0}}else{c[k>>2]=0;c[j>>2]=c[b>>2];c[a+8>>2]=1}j=b+16|0;n=+g[j>>2];k=c[a>>2]|0;o=+g[k+32>>2]*(1-+g[b+12>>2]);l=c[b>>2]|0;p=c[k+96>>2]|0;q=+g[j+4>>2]*o+ +g[p+(l<<3)+4>>2];g[e>>2]=+g[p+(l<<3)>>2]+n*o;g[e+4>>2]=q;l=b+8|0;b=c[l>>2]|0;p=c[b+12>>2]|0;if(hb[c[(c[p>>2]|0)+16>>2]&15](p,(c[b+8>>2]|0)+12|0,e)|0){m=0;i=d;return m|0}b=c[(c[l>>2]|0)+12>>2]|0;p=bb[c[(c[b>>2]|0)+12>>2]&7](b)|0;a:do if((p|0)>0){b=0;while(1){j=c[l>>2]|
0;k=c[j+12>>2]|0;mb[c[(c[k>>2]|0)+20>>2]&7](k,(c[j+8>>2]|0)+12|0,e,f,h,b);b=b+1|0;if(+g[f>>2]<.004999999888241291){m=0;break}if((b|0)>=(p|0))break a}i=d;return m|0}while(0);p=c[a+12>>2]|0;c[p>>2]=(c[p>>2]|0)+1;m=1;i=d;return m|0}function yl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0;e=i;i=i+32|0;f=e;g=a;a=b;a:while(1){b=a;h=a+-28|0;j=g;b:while(1){k=j;l=b-k|0;switch((l|0)/28|0|0){case 4:m=
14;break a;break;case 3:m=6;break a;break;case 5:m=15;break a;break;case 1:case 0:m=67;break a;break;case 2:m=4;break a;break;default:}if((l|0)<868){m=21;break a}n=(l|0)/56|0;o=j+(n*28|0)|0;do if((l|0)>27972){p=(l|0)/112|0;q=j+(p*28|0)|0;r=j+((p+n|0)*28|0)|0;p=zl(j,q,o,r,d)|0;if(nb[c[d>>2]&31](h,r)|0){c[f+0>>2]=c[r+0>>2];c[f+4>>2]=c[r+4>>2];c[f+8>>2]=c[r+8>>2];c[f+12>>2]=c[r+12>>2];c[f+16>>2]=c[r+16>>2];c[f+20>>2]=c[r+20>>2];c[f+24>>2]=c[r+24>>2];c[r+0>>2]=c[h+0>>2];c[r+4>>2]=c[h+4>>2];c[r+8>>2]=
c[h+8>>2];c[r+12>>2]=c[h+12>>2];c[r+16>>2]=c[h+16>>2];c[r+20>>2]=c[h+20>>2];c[r+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];s=p+1|0;if(nb[c[d>>2]&31](r,o)|0){c[f+0>>2]=c[o+0>>2];c[f+4>>2]=c[o+4>>2];c[f+8>>2]=c[o+8>>2];c[f+12>>2]=c[o+12>>2];c[f+16>>2]=c[o+16>>2];c[f+20>>2]=c[o+20>>2];c[f+24>>2]=c[o+24>>2];c[o+0>>2]=c[r+0>>2];c[o+4>>2]=c[r+4>>2];c[o+8>>2]=c[r+8>>2];c[o+12>>2]=c[r+
12>>2];c[o+16>>2]=c[r+16>>2];c[o+20>>2]=c[r+20>>2];c[o+24>>2]=c[r+24>>2];c[r+0>>2]=c[f+0>>2];c[r+4>>2]=c[f+4>>2];c[r+8>>2]=c[f+8>>2];c[r+12>>2]=c[f+12>>2];c[r+16>>2]=c[f+16>>2];c[r+20>>2]=c[f+20>>2];c[r+24>>2]=c[f+24>>2];r=p+2|0;if(nb[c[d>>2]&31](o,q)|0){c[f+0>>2]=c[q+0>>2];c[f+4>>2]=c[q+4>>2];c[f+8>>2]=c[q+8>>2];c[f+12>>2]=c[q+12>>2];c[f+16>>2]=c[q+16>>2];c[f+20>>2]=c[q+20>>2];c[f+24>>2]=c[q+24>>2];c[q+0>>2]=c[o+0>>2];c[q+4>>2]=c[o+4>>2];c[q+8>>2]=c[o+8>>2];c[q+12>>2]=c[o+12>>2];c[q+16>>2]=c[o+16>>
2];c[q+20>>2]=c[o+20>>2];c[q+24>>2]=c[o+24>>2];c[o+0>>2]=c[f+0>>2];c[o+4>>2]=c[f+4>>2];c[o+8>>2]=c[f+8>>2];c[o+12>>2]=c[f+12>>2];c[o+16>>2]=c[f+16>>2];c[o+20>>2]=c[f+20>>2];c[o+24>>2]=c[f+24>>2];if(nb[c[d>>2]&31](q,j)|0){c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[q+0>>2];c[j+4>>2]=c[q+4>>2];c[j+8>>2]=c[q+8>>2];c[j+12>>2]=c[q+12>>2];c[j+16>>2]=c[q+16>>2];c[j+20>>2]=c[q+20>>2];c[j+24>>
2]=c[q+24>>2];c[q+0>>2]=c[f+0>>2];c[q+4>>2]=c[f+4>>2];c[q+8>>2]=c[f+8>>2];c[q+12>>2]=c[f+12>>2];c[q+16>>2]=c[f+16>>2];c[q+20>>2]=c[f+20>>2];c[q+24>>2]=c[f+24>>2];t=p+4|0}else t=p+3|0}else t=r}else t=s}else t=p}else{p=nb[c[d>>2]&31](o,j)|0;s=nb[c[d>>2]&31](h,o)|0;if(!p){if(!s){t=0;break}c[f+0>>2]=c[o+0>>2];c[f+4>>2]=c[o+4>>2];c[f+8>>2]=c[o+8>>2];c[f+12>>2]=c[o+12>>2];c[f+16>>2]=c[o+16>>2];c[f+20>>2]=c[o+20>>2];c[f+24>>2]=c[o+24>>2];c[o+0>>2]=c[h+0>>2];c[o+4>>2]=c[h+4>>2];c[o+8>>2]=c[h+8>>2];c[o+12>>
2]=c[h+12>>2];c[o+16>>2]=c[h+16>>2];c[o+20>>2]=c[h+20>>2];c[o+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](o,j)|0)){t=1;break}c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[o+0>>2];c[j+4>>2]=c[o+4>>2];c[j+8>>2]=c[o+8>>2];c[j+12>>2]=c[o+12>>2];c[j+
16>>2]=c[o+16>>2];c[j+20>>2]=c[o+20>>2];c[j+24>>2]=c[o+24>>2];c[o+0>>2]=c[f+0>>2];c[o+4>>2]=c[f+4>>2];c[o+8>>2]=c[f+8>>2];c[o+12>>2]=c[f+12>>2];c[o+16>>2]=c[f+16>>2];c[o+20>>2]=c[f+20>>2];c[o+24>>2]=c[f+24>>2];t=2;break}if(s){c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[h+0>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];c[j+20>>2]=c[h+20>>2];c[j+
24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];t=1;break}c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[o+0>>2];c[j+4>>2]=c[o+4>>2];c[j+8>>2]=c[o+8>>2];c[j+12>>2]=c[o+12>>2];c[j+16>>2]=c[o+16>>2];c[j+20>>2]=c[o+20>>2];c[j+24>>2]=c[o+24>>2];c[o+0>>2]=c[f+0>>2];c[o+4>>2]=
c[f+4>>2];c[o+8>>2]=c[f+8>>2];c[o+12>>2]=c[f+12>>2];c[o+16>>2]=c[f+16>>2];c[o+20>>2]=c[f+20>>2];c[o+24>>2]=c[f+24>>2];if(nb[c[d>>2]&31](h,o)|0){c[f+0>>2]=c[o+0>>2];c[f+4>>2]=c[o+4>>2];c[f+8>>2]=c[o+8>>2];c[f+12>>2]=c[o+12>>2];c[f+16>>2]=c[o+16>>2];c[f+20>>2]=c[o+20>>2];c[f+24>>2]=c[o+24>>2];c[o+0>>2]=c[h+0>>2];c[o+4>>2]=c[h+4>>2];c[o+8>>2]=c[h+8>>2];c[o+12>>2]=c[h+12>>2];c[o+16>>2]=c[h+16>>2];c[o+20>>2]=c[h+20>>2];c[o+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+
12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];t=2}else t=1}while(0);do if(nb[c[d>>2]&31](j,o)|0){u=h;v=t}else{n=h;while(1){n=n+-28|0;if((j|0)==(n|0))break;if(nb[c[d>>2]&31](n,o)|0){m=50;break}}if((m|0)==50){m=0;c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[n+0>>2];c[j+4>>2]=c[n+4>>2];c[j+8>>2]=c[n+8>>2];c[j+12>>2]=c[n+12>>2];c[j+16>>2]=c[n+16>>2];
c[j+20>>2]=c[n+20>>2];c[j+24>>2]=c[n+24>>2];c[n+0>>2]=c[f+0>>2];c[n+4>>2]=c[f+4>>2];c[n+8>>2]=c[f+8>>2];c[n+12>>2]=c[f+12>>2];c[n+16>>2]=c[f+16>>2];c[n+20>>2]=c[f+20>>2];c[n+24>>2]=c[f+24>>2];u=n;v=t+1|0;break}l=j+28|0;if(nb[c[d>>2]&31](j,h)|0)w=l;else{if((l|0)==(h|0)){m=67;break a}else x=l;while(1){y=x+28|0;if(nb[c[d>>2]&31](j,x)|0)break;if((y|0)==(h|0)){m=67;break a}else x=y}c[f+0>>2]=c[x+0>>2];c[f+4>>2]=c[x+4>>2];c[f+8>>2]=c[x+8>>2];c[f+12>>2]=c[x+12>>2];c[f+16>>2]=c[x+16>>2];c[f+20>>2]=c[x+20>>
2];c[f+24>>2]=c[x+24>>2];c[x+0>>2]=c[h+0>>2];c[x+4>>2]=c[h+4>>2];c[x+8>>2]=c[h+8>>2];c[x+12>>2]=c[h+12>>2];c[x+16>>2]=c[h+16>>2];c[x+20>>2]=c[h+20>>2];c[x+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];w=y}if((w|0)==(h|0)){m=67;break a}else{z=w;A=h}while(1){n=z;while(1){B=n+28|0;if(nb[c[d>>2]&31](j,n)|0){C=A;break}else n=B}do C=C+-28|0;while(nb[c[d>>2]&31](j,C)|0);if(!(n>>>0<C>>>
0)){j=n;continue b}c[f+0>>2]=c[n+0>>2];c[f+4>>2]=c[n+4>>2];c[f+8>>2]=c[n+8>>2];c[f+12>>2]=c[n+12>>2];c[f+16>>2]=c[n+16>>2];c[f+20>>2]=c[n+20>>2];c[f+24>>2]=c[n+24>>2];c[n+0>>2]=c[C+0>>2];c[n+4>>2]=c[C+4>>2];c[n+8>>2]=c[C+8>>2];c[n+12>>2]=c[C+12>>2];c[n+16>>2]=c[C+16>>2];c[n+20>>2]=c[C+20>>2];c[n+24>>2]=c[C+24>>2];c[C+0>>2]=c[f+0>>2];c[C+4>>2]=c[f+4>>2];c[C+8>>2]=c[f+8>>2];c[C+12>>2]=c[f+12>>2];c[C+16>>2]=c[f+16>>2];c[C+20>>2]=c[f+20>>2];c[C+24>>2]=c[f+24>>2];z=B;A=C}}while(0);l=j+28|0;c:do if(l>>>
0<u>>>0){s=l;p=u;r=o;q=v;while(1){D=s;while(1){E=D+28|0;if(nb[c[d>>2]&31](D,r)|0)D=E;else{F=p;break}}do F=F+-28|0;while(!(nb[c[d>>2]&31](F,r)|0));if(D>>>0>F>>>0){G=D;H=r;I=q;break c}c[f+0>>2]=c[D+0>>2];c[f+4>>2]=c[D+4>>2];c[f+8>>2]=c[D+8>>2];c[f+12>>2]=c[D+12>>2];c[f+16>>2]=c[D+16>>2];c[f+20>>2]=c[D+20>>2];c[f+24>>2]=c[D+24>>2];c[D+0>>2]=c[F+0>>2];c[D+4>>2]=c[F+4>>2];c[D+8>>2]=c[F+8>>2];c[D+12>>2]=c[F+12>>2];c[D+16>>2]=c[F+16>>2];c[D+20>>2]=c[F+20>>2];c[D+24>>2]=c[F+24>>2];c[F+0>>2]=c[f+0>>2];c[F+
4>>2]=c[f+4>>2];c[F+8>>2]=c[f+8>>2];c[F+12>>2]=c[f+12>>2];c[F+16>>2]=c[f+16>>2];c[F+20>>2]=c[f+20>>2];c[F+24>>2]=c[f+24>>2];s=E;p=F;r=(r|0)==(D|0)?F:r;q=q+1|0}}else{G=l;H=o;I=v}while(0);if((G|0)!=(H|0)?nb[c[d>>2]&31](H,G)|0:0){c[f+0>>2]=c[G+0>>2];c[f+4>>2]=c[G+4>>2];c[f+8>>2]=c[G+8>>2];c[f+12>>2]=c[G+12>>2];c[f+16>>2]=c[G+16>>2];c[f+20>>2]=c[G+20>>2];c[f+24>>2]=c[G+24>>2];c[G+0>>2]=c[H+0>>2];c[G+4>>2]=c[H+4>>2];c[G+8>>2]=c[H+8>>2];c[G+12>>2]=c[H+12>>2];c[G+16>>2]=c[H+16>>2];c[G+20>>2]=c[H+20>>2];
c[G+24>>2]=c[H+24>>2];c[H+0>>2]=c[f+0>>2];c[H+4>>2]=c[f+4>>2];c[H+8>>2]=c[f+8>>2];c[H+12>>2]=c[f+12>>2];c[H+16>>2]=c[f+16>>2];c[H+20>>2]=c[f+20>>2];c[H+24>>2]=c[f+24>>2];J=I+1|0}else J=I;if((J|0)==0){K=Bl(j,G,d)|0;o=G+28|0;if(Bl(o,a,d)|0){m=62;break}if(K){j=o;continue}}o=G;if((o-k|0)>=(b-o|0)){m=66;break}yl(j,G,d);j=G+28|0}if((m|0)==62){m=0;if(K){m=67;break}else{g=j;a=G;continue}}else if((m|0)==66){m=0;yl(G+28|0,a,d);g=j;a=G;continue}}if((m|0)==4){if(!(nb[c[d>>2]&31](h,j)|0)){i=e;return}c[f+0>>2]=
c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[h+0>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];c[j+20>>2]=c[h+20>>2];c[j+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];i=e;return}else if((m|0)==6){G=j+28|0;g=nb[c[d>>2]&31](G,j)|0;K=nb[c[d>>
2]&31](h,G)|0;if(!g){if(!K){i=e;return}c[f+0>>2]=c[G+0>>2];c[f+4>>2]=c[G+4>>2];c[f+8>>2]=c[G+8>>2];c[f+12>>2]=c[G+12>>2];c[f+16>>2]=c[G+16>>2];c[f+20>>2]=c[G+20>>2];c[f+24>>2]=c[G+24>>2];c[G+0>>2]=c[h+0>>2];c[G+4>>2]=c[h+4>>2];c[G+8>>2]=c[h+8>>2];c[G+12>>2]=c[h+12>>2];c[G+16>>2]=c[h+16>>2];c[G+20>>2]=c[h+20>>2];c[G+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](G,
j)|0)){i=e;return}c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[G+0>>2];c[j+4>>2]=c[G+4>>2];c[j+8>>2]=c[G+8>>2];c[j+12>>2]=c[G+12>>2];c[j+16>>2]=c[G+16>>2];c[j+20>>2]=c[G+20>>2];c[j+24>>2]=c[G+24>>2];c[G+0>>2]=c[f+0>>2];c[G+4>>2]=c[f+4>>2];c[G+8>>2]=c[f+8>>2];c[G+12>>2]=c[f+12>>2];c[G+16>>2]=c[f+16>>2];c[G+20>>2]=c[f+20>>2];c[G+24>>2]=c[f+24>>2];i=e;return}if(K){c[f+0>>2]=c[j+0>>2];c[f+
4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[h+0>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];c[j+20>>2]=c[h+20>>2];c[j+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];i=e;return}c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=
c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[G+0>>2];c[j+4>>2]=c[G+4>>2];c[j+8>>2]=c[G+8>>2];c[j+12>>2]=c[G+12>>2];c[j+16>>2]=c[G+16>>2];c[j+20>>2]=c[G+20>>2];c[j+24>>2]=c[G+24>>2];c[G+0>>2]=c[f+0>>2];c[G+4>>2]=c[f+4>>2];c[G+8>>2]=c[f+8>>2];c[G+12>>2]=c[f+12>>2];c[G+16>>2]=c[f+16>>2];c[G+20>>2]=c[f+20>>2];c[G+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](h,G)|0)){i=e;return}c[f+0>>2]=c[G+0>>2];c[f+4>>2]=c[G+4>>2];c[f+8>>2]=c[G+8>>2];c[f+12>>2]=c[G+12>>2];c[f+16>>
2]=c[G+16>>2];c[f+20>>2]=c[G+20>>2];c[f+24>>2]=c[G+24>>2];c[G+0>>2]=c[h+0>>2];c[G+4>>2]=c[h+4>>2];c[G+8>>2]=c[h+8>>2];c[G+12>>2]=c[h+12>>2];c[G+16>>2]=c[h+16>>2];c[G+20>>2]=c[h+20>>2];c[G+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];i=e;return}else if((m|0)==14){zl(j,j+28|0,j+56|0,h,d)|0;i=e;return}else if((m|0)==15){G=j+28|0;K=j+56|0;g=j+84|0;zl(j,G,K,g,d)|0;if(!(nb[c[d>>2]&31](h,
g)|0)){i=e;return}c[f+0>>2]=c[g+0>>2];c[f+4>>2]=c[g+4>>2];c[f+8>>2]=c[g+8>>2];c[f+12>>2]=c[g+12>>2];c[f+16>>2]=c[g+16>>2];c[f+20>>2]=c[g+20>>2];c[f+24>>2]=c[g+24>>2];c[g+0>>2]=c[h+0>>2];c[g+4>>2]=c[h+4>>2];c[g+8>>2]=c[h+8>>2];c[g+12>>2]=c[h+12>>2];c[g+16>>2]=c[h+16>>2];c[g+20>>2]=c[h+20>>2];c[g+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](g,K)|0)){i=e;return}c[f+
0>>2]=c[K+0>>2];c[f+4>>2]=c[K+4>>2];c[f+8>>2]=c[K+8>>2];c[f+12>>2]=c[K+12>>2];c[f+16>>2]=c[K+16>>2];c[f+20>>2]=c[K+20>>2];c[f+24>>2]=c[K+24>>2];c[K+0>>2]=c[g+0>>2];c[K+4>>2]=c[g+4>>2];c[K+8>>2]=c[g+8>>2];c[K+12>>2]=c[g+12>>2];c[K+16>>2]=c[g+16>>2];c[K+20>>2]=c[g+20>>2];c[K+24>>2]=c[g+24>>2];c[g+0>>2]=c[f+0>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[g+16>>2]=c[f+16>>2];c[g+20>>2]=c[f+20>>2];c[g+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](K,G)|0)){i=e;return}c[f+0>>2]=c[G+0>>2];c[f+
4>>2]=c[G+4>>2];c[f+8>>2]=c[G+8>>2];c[f+12>>2]=c[G+12>>2];c[f+16>>2]=c[G+16>>2];c[f+20>>2]=c[G+20>>2];c[f+24>>2]=c[G+24>>2];c[G+0>>2]=c[K+0>>2];c[G+4>>2]=c[K+4>>2];c[G+8>>2]=c[K+8>>2];c[G+12>>2]=c[K+12>>2];c[G+16>>2]=c[K+16>>2];c[G+20>>2]=c[K+20>>2];c[G+24>>2]=c[K+24>>2];c[K+0>>2]=c[f+0>>2];c[K+4>>2]=c[f+4>>2];c[K+8>>2]=c[f+8>>2];c[K+12>>2]=c[f+12>>2];c[K+16>>2]=c[f+16>>2];c[K+20>>2]=c[f+20>>2];c[K+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](G,j)|0)){i=e;return}c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+
8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[G+0>>2];c[j+4>>2]=c[G+4>>2];c[j+8>>2]=c[G+8>>2];c[j+12>>2]=c[G+12>>2];c[j+16>>2]=c[G+16>>2];c[j+20>>2]=c[G+20>>2];c[j+24>>2]=c[G+24>>2];c[G+0>>2]=c[f+0>>2];c[G+4>>2]=c[f+4>>2];c[G+8>>2]=c[f+8>>2];c[G+12>>2]=c[f+12>>2];c[G+16>>2]=c[f+16>>2];c[G+20>>2]=c[f+20>>2];c[G+24>>2]=c[f+24>>2];i=e;return}else if((m|0)==21){Al(j,a,d);i=e;return}else if((m|0)==67){i=e;return}}function zl(a,b,d,e,
f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0;g=i;i=i+32|0;h=g;j=nb[c[f>>2]&31](b,a)|0;k=nb[c[f>>2]&31](d,b)|0;do if(j){if(k){c[h+0>>2]=c[a+0>>2];c[h+4>>2]=c[a+4>>2];c[h+8>>2]=c[a+8>>2];c[h+12>>2]=c[a+12>>2];c[h+16>>2]=c[a+16>>2];c[h+20>>2]=c[a+20>>2];c[h+24>>2]=c[a+24>>2];c[a+0>>2]=c[d+0>>2];c[a+4>>2]=c[d+4>>2];c[a+8>>2]=c[d+8>>2];c[a+12>>2]=c[d+12>>2];c[a+16>>2]=c[d+16>>2];c[a+20>>2]=c[d+20>>2];c[a+24>>2]=c[d+24>>2];c[d+0>>2]=c[h+0>>2];c[d+4>>2]=c[h+4>>2];c[d+8>>2]=c[h+8>>2];c[d+
12>>2]=c[h+12>>2];c[d+16>>2]=c[h+16>>2];c[d+20>>2]=c[h+20>>2];c[d+24>>2]=c[h+24>>2];l=1;break}c[h+0>>2]=c[a+0>>2];c[h+4>>2]=c[a+4>>2];c[h+8>>2]=c[a+8>>2];c[h+12>>2]=c[a+12>>2];c[h+16>>2]=c[a+16>>2];c[h+20>>2]=c[a+20>>2];c[h+24>>2]=c[a+24>>2];c[a+0>>2]=c[b+0>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];c[a+12>>2]=c[b+12>>2];c[a+16>>2]=c[b+16>>2];c[a+20>>2]=c[b+20>>2];c[a+24>>2]=c[b+24>>2];c[b+0>>2]=c[h+0>>2];c[b+4>>2]=c[h+4>>2];c[b+8>>2]=c[h+8>>2];c[b+12>>2]=c[h+12>>2];c[b+16>>2]=c[h+16>>2];c[b+20>>
2]=c[h+20>>2];c[b+24>>2]=c[h+24>>2];if(nb[c[f>>2]&31](d,b)|0){c[h+0>>2]=c[b+0>>2];c[h+4>>2]=c[b+4>>2];c[h+8>>2]=c[b+8>>2];c[h+12>>2]=c[b+12>>2];c[h+16>>2]=c[b+16>>2];c[h+20>>2]=c[b+20>>2];c[h+24>>2]=c[b+24>>2];c[b+0>>2]=c[d+0>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];c[d+0>>2]=c[h+0>>2];c[d+4>>2]=c[h+4>>2];c[d+8>>2]=c[h+8>>2];c[d+12>>2]=c[h+12>>2];c[d+16>>2]=c[h+16>>2];c[d+20>>2]=c[h+20>>2];c[d+24>>2]=c[h+24>>
2];l=2}else l=1}else if(k){c[h+0>>2]=c[b+0>>2];c[h+4>>2]=c[b+4>>2];c[h+8>>2]=c[b+8>>2];c[h+12>>2]=c[b+12>>2];c[h+16>>2]=c[b+16>>2];c[h+20>>2]=c[b+20>>2];c[h+24>>2]=c[b+24>>2];c[b+0>>2]=c[d+0>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];c[d+0>>2]=c[h+0>>2];c[d+4>>2]=c[h+4>>2];c[d+8>>2]=c[h+8>>2];c[d+12>>2]=c[h+12>>2];c[d+16>>2]=c[h+16>>2];c[d+20>>2]=c[h+20>>2];c[d+24>>2]=c[h+24>>2];if(nb[c[f>>2]&31](b,a)|0){c[h+
0>>2]=c[a+0>>2];c[h+4>>2]=c[a+4>>2];c[h+8>>2]=c[a+8>>2];c[h+12>>2]=c[a+12>>2];c[h+16>>2]=c[a+16>>2];c[h+20>>2]=c[a+20>>2];c[h+24>>2]=c[a+24>>2];c[a+0>>2]=c[b+0>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];c[a+12>>2]=c[b+12>>2];c[a+16>>2]=c[b+16>>2];c[a+20>>2]=c[b+20>>2];c[a+24>>2]=c[b+24>>2];c[b+0>>2]=c[h+0>>2];c[b+4>>2]=c[h+4>>2];c[b+8>>2]=c[h+8>>2];c[b+12>>2]=c[h+12>>2];c[b+16>>2]=c[h+16>>2];c[b+20>>2]=c[h+20>>2];c[b+24>>2]=c[h+24>>2];l=2}else l=1}else l=0;while(0);if(!(nb[c[f>>2]&31](e,d)|0)){m=
l;i=g;return m|0}c[h+0>>2]=c[d+0>>2];c[h+4>>2]=c[d+4>>2];c[h+8>>2]=c[d+8>>2];c[h+12>>2]=c[d+12>>2];c[h+16>>2]=c[d+16>>2];c[h+20>>2]=c[d+20>>2];c[h+24>>2]=c[d+24>>2];c[d+0>>2]=c[e+0>>2];c[d+4>>2]=c[e+4>>2];c[d+8>>2]=c[e+8>>2];c[d+12>>2]=c[e+12>>2];c[d+16>>2]=c[e+16>>2];c[d+20>>2]=c[e+20>>2];c[d+24>>2]=c[e+24>>2];c[e+0>>2]=c[h+0>>2];c[e+4>>2]=c[h+4>>2];c[e+8>>2]=c[h+8>>2];c[e+12>>2]=c[h+12>>2];c[e+16>>2]=c[h+16>>2];c[e+20>>2]=c[h+20>>2];c[e+24>>2]=c[h+24>>2];if(!(nb[c[f>>2]&31](d,b)|0)){m=l+1|0;i=g;
return m|0}c[h+0>>2]=c[b+0>>2];c[h+4>>2]=c[b+4>>2];c[h+8>>2]=c[b+8>>2];c[h+12>>2]=c[b+12>>2];c[h+16>>2]=c[b+16>>2];c[h+20>>2]=c[b+20>>2];c[h+24>>2]=c[b+24>>2];c[b+0>>2]=c[d+0>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];c[d+0>>2]=c[h+0>>2];c[d+4>>2]=c[h+4>>2];c[d+8>>2]=c[h+8>>2];c[d+12>>2]=c[h+12>>2];c[d+16>>2]=c[h+16>>2];c[d+20>>2]=c[h+20>>2];c[d+24>>2]=c[h+24>>2];if(!(nb[c[f>>2]&31](b,a)|0)){m=l+2|0;i=g;return m|
0}c[h+0>>2]=c[a+0>>2];c[h+4>>2]=c[a+4>>2];c[h+8>>2]=c[a+8>>2];c[h+12>>2]=c[a+12>>2];c[h+16>>2]=c[a+16>>2];c[h+20>>2]=c[a+20>>2];c[h+24>>2]=c[a+24>>2];c[a+0>>2]=c[b+0>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];c[a+12>>2]=c[b+12>>2];c[a+16>>2]=c[b+16>>2];c[a+20>>2]=c[b+20>>2];c[a+24>>2]=c[b+24>>2];c[b+0>>2]=c[h+0>>2];c[b+4>>2]=c[h+4>>2];c[b+8>>2]=c[h+8>>2];c[b+12>>2]=c[h+12>>2];c[b+16>>2]=c[h+16>>2];c[b+20>>2]=c[h+20>>2];c[b+24>>2]=c[h+24>>2];m=l+3|0;i=g;return m|0}function Al(a,b,d){a=a|0;b=b|0;d=
d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;e=i;i=i+64|0;f=e+28|0;g=e;h=a+56|0;j=a+28|0;k=nb[c[d>>2]&31](j,a)|0;l=nb[c[d>>2]&31](h,j)|0;do if(k){if(l){c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[h+0>>2];c[a+4>>2]=c[h+4>>2];c[a+8>>2]=c[h+8>>2];c[a+12>>2]=c[h+12>>2];c[a+16>>2]=c[h+16>>2];c[a+20>>2]=c[h+20>>2];c[a+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];
c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];break}c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[j+0>>2];c[a+4>>2]=c[j+4>>2];c[a+8>>2]=c[j+8>>2];c[a+12>>2]=c[j+12>>2];c[a+16>>2]=c[j+16>>2];c[a+20>>2]=c[j+20>>2];c[a+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>
2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];if(nb[c[d>>2]&31](h,j)|0){c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[h+0>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];c[j+20>>2]=c[h+20>>2];c[j+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>
2]}}else if(l){c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[h+0>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];c[j+20>>2]=c[h+20>>2];c[j+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];if(nb[c[d>>2]&31](j,a)|0){c[f+0>>2]=c[a+0>>
2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[j+0>>2];c[a+4>>2]=c[j+4>>2];c[a+8>>2]=c[j+8>>2];c[a+12>>2]=c[j+12>>2];c[a+16>>2]=c[j+16>>2];c[a+20>>2]=c[j+20>>2];c[a+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2]}}while(0);f=a+84|0;if((f|0)==(b|0)){i=e;return}j=f;f=h;while(1){if(nb[c[d>>
2]&31](j,f)|0){c[g+0>>2]=c[j+0>>2];c[g+4>>2]=c[j+4>>2];c[g+8>>2]=c[j+8>>2];c[g+12>>2]=c[j+12>>2];c[g+16>>2]=c[j+16>>2];c[g+20>>2]=c[j+20>>2];c[g+24>>2]=c[j+24>>2];h=j;l=f;while(1){c[h+0>>2]=c[l+0>>2];c[h+4>>2]=c[l+4>>2];c[h+8>>2]=c[l+8>>2];c[h+12>>2]=c[l+12>>2];c[h+16>>2]=c[l+16>>2];c[h+20>>2]=c[l+20>>2];c[h+24>>2]=c[l+24>>2];if((l|0)==(a|0))break;k=l+-28|0;if(nb[c[d>>2]&31](g,k)|0){m=l;l=k;h=m}else break}c[l+0>>2]=c[g+0>>2];c[l+4>>2]=c[g+4>>2];c[l+8>>2]=c[g+8>>2];c[l+12>>2]=c[g+12>>2];c[l+16>>2]=
c[g+16>>2];c[l+20>>2]=c[g+20>>2];c[l+24>>2]=c[g+24>>2]}h=j+28|0;if((h|0)==(b|0))break;else{m=j;j=h;f=m}}i=e;return}function Bl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;e=i;i=i+64|0;f=e+28|0;g=e;switch((b-a|0)/28|0|0){case 5:h=a+28|0;j=a+56|0;k=a+84|0;l=b+-28|0;zl(a,h,j,k,d)|0;if(!(nb[c[d>>2]&31](l,k)|0)){m=1;i=e;return m|0}c[f+0>>2]=c[k+0>>2];c[f+4>>2]=c[k+4>>2];c[f+8>>2]=c[k+8>>2];c[f+12>>2]=c[k+12>>2];c[f+16>>2]=c[k+16>>2];c[f+20>>2]=c[k+20>>2];c[f+24>>2]=c[k+
24>>2];c[k+0>>2]=c[l+0>>2];c[k+4>>2]=c[l+4>>2];c[k+8>>2]=c[l+8>>2];c[k+12>>2]=c[l+12>>2];c[k+16>>2]=c[l+16>>2];c[k+20>>2]=c[l+20>>2];c[k+24>>2]=c[l+24>>2];c[l+0>>2]=c[f+0>>2];c[l+4>>2]=c[f+4>>2];c[l+8>>2]=c[f+8>>2];c[l+12>>2]=c[f+12>>2];c[l+16>>2]=c[f+16>>2];c[l+20>>2]=c[f+20>>2];c[l+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](k,j)|0)){m=1;i=e;return m|0}c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+
0>>2]=c[k+0>>2];c[j+4>>2]=c[k+4>>2];c[j+8>>2]=c[k+8>>2];c[j+12>>2]=c[k+12>>2];c[j+16>>2]=c[k+16>>2];c[j+20>>2]=c[k+20>>2];c[j+24>>2]=c[k+24>>2];c[k+0>>2]=c[f+0>>2];c[k+4>>2]=c[f+4>>2];c[k+8>>2]=c[f+8>>2];c[k+12>>2]=c[f+12>>2];c[k+16>>2]=c[f+16>>2];c[k+20>>2]=c[f+20>>2];c[k+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](j,h)|0)){m=1;i=e;return m|0}c[f+0>>2]=c[h+0>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2];c[f+20>>2]=c[h+20>>2];c[f+24>>2]=c[h+24>>2];c[h+0>>2]=c[j+
0>>2];c[h+4>>2]=c[j+4>>2];c[h+8>>2]=c[j+8>>2];c[h+12>>2]=c[j+12>>2];c[h+16>>2]=c[j+16>>2];c[h+20>>2]=c[j+20>>2];c[h+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](h,a)|0)){m=1;i=e;return m|0}c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[h+0>>2];c[a+
4>>2]=c[h+4>>2];c[a+8>>2]=c[h+8>>2];c[a+12>>2]=c[h+12>>2];c[a+16>>2]=c[h+16>>2];c[a+20>>2]=c[h+20>>2];c[a+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];m=1;i=e;return m|0;case 3:h=a+28|0;j=b+-28|0;k=nb[c[d>>2]&31](h,a)|0;l=nb[c[d>>2]&31](j,h)|0;if(!k){if(!l){m=1;i=e;return m|0}c[f+0>>2]=c[h+0>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2];
c[f+20>>2]=c[h+20>>2];c[f+24>>2]=c[h+24>>2];c[h+0>>2]=c[j+0>>2];c[h+4>>2]=c[j+4>>2];c[h+8>>2]=c[j+8>>2];c[h+12>>2]=c[j+12>>2];c[h+16>>2]=c[j+16>>2];c[h+20>>2]=c[j+20>>2];c[h+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](h,a)|0)){m=1;i=e;return m|0}c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=
c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[h+0>>2];c[a+4>>2]=c[h+4>>2];c[a+8>>2]=c[h+8>>2];c[a+12>>2]=c[h+12>>2];c[a+16>>2]=c[h+16>>2];c[a+20>>2]=c[h+20>>2];c[a+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];m=1;i=e;return m|0}if(l){c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];
c[a+0>>2]=c[j+0>>2];c[a+4>>2]=c[j+4>>2];c[a+8>>2]=c[j+8>>2];c[a+12>>2]=c[j+12>>2];c[a+16>>2]=c[j+16>>2];c[a+20>>2]=c[j+20>>2];c[a+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];m=1;i=e;return m|0}c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[h+0>>2];c[a+4>>2]=c[h+4>>2];
c[a+8>>2]=c[h+8>>2];c[a+12>>2]=c[h+12>>2];c[a+16>>2]=c[h+16>>2];c[a+20>>2]=c[h+20>>2];c[a+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](j,h)|0)){m=1;i=e;return m|0}c[f+0>>2]=c[h+0>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2];c[f+20>>2]=c[h+20>>2];c[f+24>>2]=c[h+24>>2];c[h+0>>2]=c[j+0>>2];c[h+4>>2]=c[j+4>>2];c[h+8>>2]=
c[j+8>>2];c[h+12>>2]=c[j+12>>2];c[h+16>>2]=c[j+16>>2];c[h+20>>2]=c[j+20>>2];c[h+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];m=1;i=e;return m|0;case 1:case 0:m=1;i=e;return m|0;case 4:zl(a,a+28|0,a+56|0,b+-28|0,d)|0;m=1;i=e;return m|0;case 2:j=b+-28|0;if(!(nb[c[d>>2]&31](j,a)|0)){m=1;i=e;return m|0}c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];
c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[j+0>>2];c[a+4>>2]=c[j+4>>2];c[a+8>>2]=c[j+8>>2];c[a+12>>2]=c[j+12>>2];c[a+16>>2]=c[j+16>>2];c[a+20>>2]=c[j+20>>2];c[a+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];m=1;i=e;return m|0;default:j=a+56|0;h=a+28|0;l=nb[c[d>>2]&31](h,a)|0;k=nb[c[d>>2]&31](j,h)|0;do if(l){if(k){c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+
4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[j+0>>2];c[a+4>>2]=c[j+4>>2];c[a+8>>2]=c[j+8>>2];c[a+12>>2]=c[j+12>>2];c[a+16>>2]=c[j+16>>2];c[a+20>>2]=c[j+20>>2];c[a+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];break}c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+
16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[h+0>>2];c[a+4>>2]=c[h+4>>2];c[a+8>>2]=c[h+8>>2];c[a+12>>2]=c[h+12>>2];c[a+16>>2]=c[h+16>>2];c[a+20>>2]=c[h+20>>2];c[a+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];if(nb[c[d>>2]&31](j,h)|0){c[f+0>>2]=c[h+0>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2];c[f+20>>2]=c[h+
20>>2];c[f+24>>2]=c[h+24>>2];c[h+0>>2]=c[j+0>>2];c[h+4>>2]=c[j+4>>2];c[h+8>>2]=c[j+8>>2];c[h+12>>2]=c[j+12>>2];c[h+16>>2]=c[j+16>>2];c[h+20>>2]=c[j+20>>2];c[h+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2]}}else if(k){c[f+0>>2]=c[h+0>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2];c[f+20>>2]=c[h+20>>2];c[f+24>>2]=c[h+24>>2];c[h+0>>2]=c[j+0>>
2];c[h+4>>2]=c[j+4>>2];c[h+8>>2]=c[j+8>>2];c[h+12>>2]=c[j+12>>2];c[h+16>>2]=c[j+16>>2];c[h+20>>2]=c[j+20>>2];c[h+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];if(nb[c[d>>2]&31](h,a)|0){c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[h+0>>2];c[a+4>>2]=c[h+4>>2];c[a+8>>2]=
c[h+8>>2];c[a+12>>2]=c[h+12>>2];c[a+16>>2]=c[h+16>>2];c[a+20>>2]=c[h+20>>2];c[a+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2]}}while(0);f=a+84|0;if((f|0)==(b|0)){m=1;i=e;return m|0}h=0;k=f;f=j;while(1){if(nb[c[d>>2]&31](k,f)|0){c[g+0>>2]=c[k+0>>2];c[g+4>>2]=c[k+4>>2];c[g+8>>2]=c[k+8>>2];c[g+12>>2]=c[k+12>>2];c[g+16>>2]=c[k+16>>2];c[g+20>>2]=c[k+20>>2];c[g+24>>2]=c[k+24>>2];j=k;l=
f;while(1){c[j+0>>2]=c[l+0>>2];c[j+4>>2]=c[l+4>>2];c[j+8>>2]=c[l+8>>2];c[j+12>>2]=c[l+12>>2];c[j+16>>2]=c[l+16>>2];c[j+20>>2]=c[l+20>>2];c[j+24>>2]=c[l+24>>2];if((l|0)==(a|0))break;n=l+-28|0;if(nb[c[d>>2]&31](g,n)|0){o=l;l=n;j=o}else break}c[l+0>>2]=c[g+0>>2];c[l+4>>2]=c[g+4>>2];c[l+8>>2]=c[g+8>>2];c[l+12>>2]=c[g+12>>2];c[l+16>>2]=c[g+16>>2];c[l+20>>2]=c[g+20>>2];c[l+24>>2]=c[g+24>>2];j=h+1|0;if((j|0)==8)break;else p=j}else p=h;j=k+28|0;if((j|0)==(b|0)){m=1;q=35;break}else{o=k;h=p;k=j;f=o}}if((q|
0)==35){i=e;return m|0}m=(k+28|0)==(b|0);i=e;return m|0}return 0}function Cl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0;e=i;i=i+16|0;f=e;g=a;a=b;a:while(1){b=a;h=a+-8|0;j=g;b:while(1){k=j;l=b-k|0;m=l>>3;switch(m|0){case 2:n=4;break a;break;case 3:n=6;break a;break;case 4:n=14;break a;break;case 5:n=26;break a;break;case 1:case 0:n=84;break a;break;default:}if((l|
0)<248){n=28;break a}o=(m|0)/2|0;p=j+(o<<3)|0;do if((l|0)<=7992){q=nb[c[d>>2]&31](p,j)|0;r=nb[c[d>>2]&31](h,p)|0;if(!q){if(!r){s=0;break}q=p;t=c[q>>2]|0;u=c[q+4>>2]|0;q=h;v=c[q+4>>2]|0;w=p;c[w>>2]=c[q>>2];c[w+4>>2]=v;v=h;c[v>>2]=t;c[v+4>>2]=u;if(!(nb[c[d>>2]&31](p,j)|0)){s=1;break}u=j;v=c[u>>2]|0;t=c[u+4>>2]|0;u=p;w=c[u+4>>2]|0;q=j;c[q>>2]=c[u>>2];c[q+4>>2]=w;w=p;c[w>>2]=v;c[w+4>>2]=t;s=2;break}t=j;w=c[t>>2]|0;v=c[t+4>>2]|0;if(r){r=h;t=c[r+4>>2]|0;q=j;c[q>>2]=c[r>>2];c[q+4>>2]=t;t=h;c[t>>2]=w;c[t+
4>>2]=v;s=1;break}t=p;q=c[t+4>>2]|0;r=j;c[r>>2]=c[t>>2];c[r+4>>2]=q;q=p;c[q>>2]=w;c[q+4>>2]=v;if(nb[c[d>>2]&31](h,p)|0){v=p;q=c[v>>2]|0;w=c[v+4>>2]|0;v=h;r=c[v+4>>2]|0;t=p;c[t>>2]=c[v>>2];c[t+4>>2]=r;r=h;c[r>>2]=q;c[r+4>>2]=w;s=2}else s=1}else{w=(m|0)/4|0;s=Dl(j,j+(w<<3)|0,p,j+(w+o<<3)|0,h,d)|0}while(0);do if(nb[c[d>>2]&31](j,p)|0){x=h;y=s}else{o=h;while(1){o=o+-8|0;if((j|0)==(o|0))break;if(nb[c[d>>2]&31](o,p)|0){n=67;break}}if((n|0)==67){n=0;m=j;l=c[m>>2]|0;w=c[m+4>>2]|0;m=o;r=c[m+4>>2]|0;q=j;c[q>>
2]=c[m>>2];c[q+4>>2]=r;r=o;c[r>>2]=l;c[r+4>>2]=w;x=o;y=s+1|0;break}w=j+8|0;if(nb[c[d>>2]&31](j,h)|0)z=w;else{if((w|0)==(h|0)){n=84;break a}else A=w;while(1){B=A+8|0;if(nb[c[d>>2]&31](j,A)|0)break;if((B|0)==(h|0)){n=84;break a}else A=B}o=A;w=c[o>>2]|0;r=c[o+4>>2]|0;o=h;l=c[o+4>>2]|0;q=A;c[q>>2]=c[o>>2];c[q+4>>2]=l;l=h;c[l>>2]=w;c[l+4>>2]=r;z=B}if((z|0)==(h|0)){n=84;break a}else{C=z;D=h}while(1){r=C;while(1){E=r+8|0;if(nb[c[d>>2]&31](j,r)|0){F=D;break}else r=E}do F=F+-8|0;while(nb[c[d>>2]&31](j,F)|
0);if(!(r>>>0<F>>>0)){j=r;continue b}l=r;w=c[l>>2]|0;q=c[l+4>>2]|0;l=F;o=c[l+4>>2]|0;m=r;c[m>>2]=c[l>>2];c[m+4>>2]=o;o=F;c[o>>2]=w;c[o+4>>2]=q;C=E;D=F}}while(0);q=j+8|0;c:do if(q>>>0<x>>>0){o=q;w=x;m=p;l=y;while(1){t=o;while(1){G=t+8|0;if(nb[c[d>>2]&31](t,m)|0)t=G;else{H=w;break}}do H=H+-8|0;while(!(nb[c[d>>2]&31](H,m)|0));if(t>>>0>H>>>0){I=t;J=m;K=l;break c}r=t;v=c[r>>2]|0;u=c[r+4>>2]|0;r=H;L=c[r+4>>2]|0;M=t;c[M>>2]=c[r>>2];c[M+4>>2]=L;L=H;c[L>>2]=v;c[L+4>>2]=u;o=G;w=H;m=(m|0)==(t|0)?H:m;l=l+1|0}}else{I=
q;J=p;K=y}while(0);if((I|0)!=(J|0)?nb[c[d>>2]&31](J,I)|0:0){p=I;q=c[p>>2]|0;l=c[p+4>>2]|0;p=J;m=c[p+4>>2]|0;w=I;c[w>>2]=c[p>>2];c[w+4>>2]=m;m=J;c[m>>2]=q;c[m+4>>2]=l;N=K+1|0}else N=K;if((N|0)==0){O=El(j,I,d)|0;l=I+8|0;if(El(l,a,d)|0){n=79;break}if(O){j=l;continue}}l=I;if((l-k|0)>=(b-l|0)){n=83;break}Cl(j,I,d);j=I+8|0}if((n|0)==79){n=0;if(O){n=84;break}else{g=j;a=I;continue}}else if((n|0)==83){n=0;Cl(I+8|0,a,d);g=j;a=I;continue}}if((n|0)==4){if(!(nb[c[d>>2]&31](h,j)|0)){i=e;return}I=j;g=c[I>>2]|0;
O=c[I+4>>2]|0;I=h;N=c[I+4>>2]|0;K=j;c[K>>2]=c[I>>2];c[K+4>>2]=N;N=h;c[N>>2]=g;c[N+4>>2]=O;i=e;return}else if((n|0)==6){O=j+8|0;N=nb[c[d>>2]&31](O,j)|0;g=nb[c[d>>2]&31](h,O)|0;if(!N){if(!g){i=e;return}N=O;K=c[N>>2]|0;I=c[N+4>>2]|0;N=h;J=c[N+4>>2]|0;y=O;c[y>>2]=c[N>>2];c[y+4>>2]=J;J=h;c[J>>2]=K;c[J+4>>2]=I;if(!(nb[c[d>>2]&31](O,j)|0)){i=e;return}I=j;J=c[I>>2]|0;K=c[I+4>>2]|0;I=O;y=c[I+4>>2]|0;N=j;c[N>>2]=c[I>>2];c[N+4>>2]=y;y=O;c[y>>2]=J;c[y+4>>2]=K;i=e;return}K=j;y=c[K>>2]|0;J=c[K+4>>2]|0;if(g){g=
h;K=c[g+4>>2]|0;N=j;c[N>>2]=c[g>>2];c[N+4>>2]=K;K=h;c[K>>2]=y;c[K+4>>2]=J;i=e;return}K=O;N=c[K+4>>2]|0;g=j;c[g>>2]=c[K>>2];c[g+4>>2]=N;N=O;c[N>>2]=y;c[N+4>>2]=J;if(!(nb[c[d>>2]&31](h,O)|0)){i=e;return}J=O;N=c[J>>2]|0;y=c[J+4>>2]|0;J=h;g=c[J+4>>2]|0;K=O;c[K>>2]=c[J>>2];c[K+4>>2]=g;g=h;c[g>>2]=N;c[g+4>>2]=y;i=e;return}else if((n|0)==14){y=j+8|0;g=j+16|0;N=nb[c[d>>2]&31](y,j)|0;K=nb[c[d>>2]&31](g,y)|0;do if(N){J=j;O=c[J>>2]|0;I=c[J+4>>2]|0;if(K){J=g;H=c[J+4>>2]|0;G=j;c[G>>2]=c[J>>2];c[G+4>>2]=H;H=g;
c[H>>2]=O;c[H+4>>2]=I;break}H=y;G=c[H+4>>2]|0;J=j;c[J>>2]=c[H>>2];c[J+4>>2]=G;G=y;c[G>>2]=O;c[G+4>>2]=I;if(nb[c[d>>2]&31](g,y)|0){I=y;G=c[I>>2]|0;O=c[I+4>>2]|0;I=g;J=c[I+4>>2]|0;H=y;c[H>>2]=c[I>>2];c[H+4>>2]=J;J=g;c[J>>2]=G;c[J+4>>2]=O}}else if(K?(O=y,J=c[O>>2]|0,G=c[O+4>>2]|0,O=g,H=c[O+4>>2]|0,I=y,c[I>>2]=c[O>>2],c[I+4>>2]=H,H=g,c[H>>2]=J,c[H+4>>2]=G,nb[c[d>>2]&31](y,j)|0):0){G=j;H=c[G>>2]|0;J=c[G+4>>2]|0;G=y;I=c[G+4>>2]|0;O=j;c[O>>2]=c[G>>2];c[O+4>>2]=I;I=y;c[I>>2]=H;c[I+4>>2]=J}while(0);if(!(nb[c[d>>
2]&31](h,g)|0)){i=e;return}K=g;N=c[K>>2]|0;J=c[K+4>>2]|0;K=h;I=c[K+4>>2]|0;H=g;c[H>>2]=c[K>>2];c[H+4>>2]=I;I=h;c[I>>2]=N;c[I+4>>2]=J;if(!(nb[c[d>>2]&31](g,y)|0)){i=e;return}J=y;I=c[J>>2]|0;N=c[J+4>>2]|0;J=g;H=c[J+4>>2]|0;K=y;c[K>>2]=c[J>>2];c[K+4>>2]=H;H=g;c[H>>2]=I;c[H+4>>2]=N;if(!(nb[c[d>>2]&31](y,j)|0)){i=e;return}N=j;H=c[N>>2]|0;I=c[N+4>>2]|0;N=y;g=c[N+4>>2]|0;K=j;c[K>>2]=c[N>>2];c[K+4>>2]=g;g=y;c[g>>2]=H;c[g+4>>2]=I;i=e;return}else if((n|0)==26){Dl(j,j+8|0,j+16|0,j+24|0,h,d)|0;i=e;return}else if((n|
0)==28){h=j+16|0;I=j+8|0;g=nb[c[d>>2]&31](I,j)|0;H=nb[c[d>>2]&31](h,I)|0;do if(g){y=j;K=c[y>>2]|0;N=c[y+4>>2]|0;if(H){y=h;J=c[y+4>>2]|0;O=j;c[O>>2]=c[y>>2];c[O+4>>2]=J;J=h;c[J>>2]=K;c[J+4>>2]=N;break}J=I;O=c[J+4>>2]|0;y=j;c[y>>2]=c[J>>2];c[y+4>>2]=O;O=I;c[O>>2]=K;c[O+4>>2]=N;if(nb[c[d>>2]&31](h,I)|0){N=I;O=c[N>>2]|0;K=c[N+4>>2]|0;N=h;y=c[N+4>>2]|0;J=I;c[J>>2]=c[N>>2];c[J+4>>2]=y;y=h;c[y>>2]=O;c[y+4>>2]=K}}else if(H?(K=I,y=c[K>>2]|0,O=c[K+4>>2]|0,K=h,J=c[K+4>>2]|0,N=I,c[N>>2]=c[K>>2],c[N+4>>2]=J,J=
h,c[J>>2]=y,c[J+4>>2]=O,nb[c[d>>2]&31](I,j)|0):0){O=j;J=c[O>>2]|0;y=c[O+4>>2]|0;O=I;N=c[O+4>>2]|0;K=j;c[K>>2]=c[O>>2];c[K+4>>2]=N;N=I;c[N>>2]=J;c[N+4>>2]=y}while(0);I=j+24|0;if((I|0)==(a|0)){i=e;return}else{P=I;Q=h}while(1){if(nb[c[d>>2]&31](P,Q)|0){h=P;I=c[h+4>>2]|0;H=f;c[H>>2]=c[h>>2];c[H+4>>2]=I;I=P;H=Q;while(1){h=H;g=c[h+4>>2]|0;y=I;c[y>>2]=c[h>>2];c[y+4>>2]=g;if((H|0)==(j|0))break;g=H+-8|0;if(nb[c[d>>2]&31](f,g)|0){y=H;H=g;I=y}else break}I=f;y=c[I+4>>2]|0;g=H;c[g>>2]=c[I>>2];c[g+4>>2]=y}y=P+
8|0;if((y|0)==(a|0))break;else{g=P;P=y;Q=g}}i=e;return}else if((n|0)==84){i=e;return}}function Dl(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;h=i;j=nb[c[g>>2]&31](b,a)|0;k=nb[c[g>>2]&31](d,b)|0;do if(j){l=a;m=c[l>>2]|0;n=c[l+4>>2]|0;if(k){l=d;o=c[l+4>>2]|0;p=a;c[p>>2]=c[l>>2];c[p+4>>2]=o;o=d;c[o>>2]=m;c[o+4>>2]=n;q=1;break}o=b;p=c[o+4>>2]|0;l=a;c[l>>2]=c[o>>2];c[l+4>>2]=p;p=b;c[p>>2]=m;c[p+4>>2]=n;if(nb[c[g>>2]&31](d,b)|0){n=b;p=c[n>>2]|0;m=c[n+
4>>2]|0;n=d;l=c[n+4>>2]|0;o=b;c[o>>2]=c[n>>2];c[o+4>>2]=l;l=d;c[l>>2]=p;c[l+4>>2]=m;q=2}else q=1}else if(k){m=b;l=c[m>>2]|0;p=c[m+4>>2]|0;m=d;o=c[m+4>>2]|0;n=b;c[n>>2]=c[m>>2];c[n+4>>2]=o;o=d;c[o>>2]=l;c[o+4>>2]=p;if(nb[c[g>>2]&31](b,a)|0){p=a;o=c[p>>2]|0;l=c[p+4>>2]|0;p=b;n=c[p+4>>2]|0;m=a;c[m>>2]=c[p>>2];c[m+4>>2]=n;n=b;c[n>>2]=o;c[n+4>>2]=l;q=2}else q=1}else q=0;while(0);if(nb[c[g>>2]&31](e,d)|0){k=d;j=c[k>>2]|0;l=c[k+4>>2]|0;k=e;n=c[k+4>>2]|0;o=d;c[o>>2]=c[k>>2];c[o+4>>2]=n;n=e;c[n>>2]=j;c[n+
4>>2]=l;l=q+1|0;if(nb[c[g>>2]&31](d,b)|0){n=b;j=c[n>>2]|0;o=c[n+4>>2]|0;n=d;k=c[n+4>>2]|0;m=b;c[m>>2]=c[n>>2];c[m+4>>2]=k;k=d;c[k>>2]=j;c[k+4>>2]=o;if(nb[c[g>>2]&31](b,a)|0){o=a;k=c[o>>2]|0;j=c[o+4>>2]|0;o=b;m=c[o+4>>2]|0;n=a;c[n>>2]=c[o>>2];c[n+4>>2]=m;m=b;c[m>>2]=k;c[m+4>>2]=j;r=q+3|0}else r=q+2|0}else r=l}else r=q;if(!(nb[c[g>>2]&31](f,e)|0)){s=r;i=h;return s|0}q=e;l=c[q>>2]|0;j=c[q+4>>2]|0;q=f;m=c[q+4>>2]|0;k=e;c[k>>2]=c[q>>2];c[k+4>>2]=m;m=f;c[m>>2]=l;c[m+4>>2]=j;if(!(nb[c[g>>2]&31](e,d)|0)){s=
r+1|0;i=h;return s|0}j=d;m=c[j>>2]|0;l=c[j+4>>2]|0;j=e;f=c[j+4>>2]|0;k=d;c[k>>2]=c[j>>2];c[k+4>>2]=f;f=e;c[f>>2]=m;c[f+4>>2]=l;if(!(nb[c[g>>2]&31](d,b)|0)){s=r+2|0;i=h;return s|0}l=b;f=c[l>>2]|0;m=c[l+4>>2]|0;l=d;e=c[l+4>>2]|0;k=b;c[k>>2]=c[l>>2];c[k+4>>2]=e;e=d;c[e>>2]=f;c[e+4>>2]=m;if(!(nb[c[g>>2]&31](b,a)|0)){s=r+3|0;i=h;return s|0}g=a;m=c[g>>2]|0;e=c[g+4>>2]|0;g=b;f=c[g+4>>2]|0;d=a;c[d>>2]=c[g>>2];c[d+4>>2]=f;f=b;c[f>>2]=m;c[f+4>>2]=e;s=r+4|0;i=h;return s|0}function El(a,b,d){a=a|0;b=b|0;d=d|
0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;e=i;i=i+16|0;f=e;switch(b-a>>3|0){case 2:g=b+-8|0;if(!(nb[c[d>>2]&31](g,a)|0)){h=1;i=e;return h|0}j=a;k=c[j>>2]|0;l=c[j+4>>2]|0;j=g;m=c[j+4>>2]|0;n=a;c[n>>2]=c[j>>2];c[n+4>>2]=m;m=g;c[m>>2]=k;c[m+4>>2]=l;h=1;i=e;return h|0;case 5:Dl(a,a+8|0,a+16|0,a+24|0,b+-8|0,d)|0;h=1;i=e;return h|0;case 1:case 0:h=1;i=e;return h|0;case 4:l=a+8|0;m=a+16|0;k=b+-8|0;g=nb[c[d>>2]&31](l,a)|0;n=nb[c[d>>2]&31](m,l)|0;do if(g){j=a;o=c[j>>2]|
0;p=c[j+4>>2]|0;if(n){j=m;q=c[j+4>>2]|0;r=a;c[r>>2]=c[j>>2];c[r+4>>2]=q;q=m;c[q>>2]=o;c[q+4>>2]=p;break}q=l;r=c[q+4>>2]|0;j=a;c[j>>2]=c[q>>2];c[j+4>>2]=r;r=l;c[r>>2]=o;c[r+4>>2]=p;if(nb[c[d>>2]&31](m,l)|0){p=l;r=c[p>>2]|0;o=c[p+4>>2]|0;p=m;j=c[p+4>>2]|0;q=l;c[q>>2]=c[p>>2];c[q+4>>2]=j;j=m;c[j>>2]=r;c[j+4>>2]=o}}else if(n?(o=l,j=c[o>>2]|0,r=c[o+4>>2]|0,o=m,q=c[o+4>>2]|0,p=l,c[p>>2]=c[o>>2],c[p+4>>2]=q,q=m,c[q>>2]=j,c[q+4>>2]=r,nb[c[d>>2]&31](l,a)|0):0){r=a;q=c[r>>2]|0;j=c[r+4>>2]|0;r=l;p=c[r+4>>2]|
0;o=a;c[o>>2]=c[r>>2];c[o+4>>2]=p;p=l;c[p>>2]=q;c[p+4>>2]=j}while(0);if(!(nb[c[d>>2]&31](k,m)|0)){h=1;i=e;return h|0}n=m;g=c[n>>2]|0;j=c[n+4>>2]|0;n=k;p=c[n+4>>2]|0;q=m;c[q>>2]=c[n>>2];c[q+4>>2]=p;p=k;c[p>>2]=g;c[p+4>>2]=j;if(!(nb[c[d>>2]&31](m,l)|0)){h=1;i=e;return h|0}j=l;p=c[j>>2]|0;g=c[j+4>>2]|0;j=m;k=c[j+4>>2]|0;q=l;c[q>>2]=c[j>>2];c[q+4>>2]=k;k=m;c[k>>2]=p;c[k+4>>2]=g;if(!(nb[c[d>>2]&31](l,a)|0)){h=1;i=e;return h|0}g=a;k=c[g>>2]|0;p=c[g+4>>2]|0;g=l;m=c[g+4>>2]|0;q=a;c[q>>2]=c[g>>2];c[q+4>>2]=
m;m=l;c[m>>2]=k;c[m+4>>2]=p;h=1;i=e;return h|0;case 3:p=a+8|0;m=b+-8|0;k=nb[c[d>>2]&31](p,a)|0;l=nb[c[d>>2]&31](m,p)|0;if(!k){if(!l){h=1;i=e;return h|0}k=p;q=c[k>>2]|0;g=c[k+4>>2]|0;k=m;j=c[k+4>>2]|0;n=p;c[n>>2]=c[k>>2];c[n+4>>2]=j;j=m;c[j>>2]=q;c[j+4>>2]=g;if(!(nb[c[d>>2]&31](p,a)|0)){h=1;i=e;return h|0}g=a;j=c[g>>2]|0;q=c[g+4>>2]|0;g=p;n=c[g+4>>2]|0;k=a;c[k>>2]=c[g>>2];c[k+4>>2]=n;n=p;c[n>>2]=j;c[n+4>>2]=q;h=1;i=e;return h|0}q=a;n=c[q>>2]|0;j=c[q+4>>2]|0;if(l){l=m;q=c[l+4>>2]|0;k=a;c[k>>2]=c[l>>
2];c[k+4>>2]=q;q=m;c[q>>2]=n;c[q+4>>2]=j;h=1;i=e;return h|0}q=p;k=c[q+4>>2]|0;l=a;c[l>>2]=c[q>>2];c[l+4>>2]=k;k=p;c[k>>2]=n;c[k+4>>2]=j;if(!(nb[c[d>>2]&31](m,p)|0)){h=1;i=e;return h|0}j=p;k=c[j>>2]|0;n=c[j+4>>2]|0;j=m;l=c[j+4>>2]|0;q=p;c[q>>2]=c[j>>2];c[q+4>>2]=l;l=m;c[l>>2]=k;c[l+4>>2]=n;h=1;i=e;return h|0;default:n=a+16|0;l=a+8|0;k=nb[c[d>>2]&31](l,a)|0;m=nb[c[d>>2]&31](n,l)|0;do if(k){q=a;j=c[q>>2]|0;p=c[q+4>>2]|0;if(m){q=n;g=c[q+4>>2]|0;o=a;c[o>>2]=c[q>>2];c[o+4>>2]=g;g=n;c[g>>2]=j;c[g+4>>2]=
p;break}g=l;o=c[g+4>>2]|0;q=a;c[q>>2]=c[g>>2];c[q+4>>2]=o;o=l;c[o>>2]=j;c[o+4>>2]=p;if(nb[c[d>>2]&31](n,l)|0){p=l;o=c[p>>2]|0;j=c[p+4>>2]|0;p=n;q=c[p+4>>2]|0;g=l;c[g>>2]=c[p>>2];c[g+4>>2]=q;q=n;c[q>>2]=o;c[q+4>>2]=j}}else if(m?(j=l,q=c[j>>2]|0,o=c[j+4>>2]|0,j=n,g=c[j+4>>2]|0,p=l,c[p>>2]=c[j>>2],c[p+4>>2]=g,g=n,c[g>>2]=q,c[g+4>>2]=o,nb[c[d>>2]&31](l,a)|0):0){o=a;g=c[o>>2]|0;q=c[o+4>>2]|0;o=l;p=c[o+4>>2]|0;j=a;c[j>>2]=c[o>>2];c[j+4>>2]=p;p=l;c[p>>2]=g;c[p+4>>2]=q}while(0);l=a+24|0;if((l|0)==(b|0)){h=
1;i=e;return h|0}else{s=0;t=l;u=n}while(1){if(nb[c[d>>2]&31](t,u)|0){n=t;l=c[n+4>>2]|0;m=f;c[m>>2]=c[n>>2];c[m+4>>2]=l;l=t;m=u;while(1){n=m;k=c[n+4>>2]|0;q=l;c[q>>2]=c[n>>2];c[q+4>>2]=k;if((m|0)==(a|0))break;k=m+-8|0;if(nb[c[d>>2]&31](f,k)|0){q=m;m=k;l=q}else break}l=f;q=c[l+4>>2]|0;k=m;c[k>>2]=c[l>>2];c[k+4>>2]=q;q=s+1|0;if((q|0)==8)break;else v=q}else v=s;q=t+8|0;if((q|0)==(b|0)){h=1;w=41;break}else{k=t;s=v;t=q;u=k}}if((w|0)==41){i=e;return h|0}h=(t+8|0)==(b|0);i=e;return h|0}return 0}function Fl(a,
b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0;e=i;i=i+16|0;f=e;g=a;a=b;a:while(1){b=a;h=a+-8|0;j=g;b:while(1){k=j;l=b-k|0;m=l>>3;switch(m|0){case 2:n=4;break a;break;case 4:n=14;break a;break;case 5:n=26;break a;break;case 3:n=6;break a;break;case 1:case 0:n=84;break a;break;default:}if((l|0)<248){n=28;break a}o=(m|0)/2|0;p=j+(o<<3)|0;do if((l|0)<=7992){q=nb[c[d>>2]&
31](p,j)|0;r=nb[c[d>>2]&31](h,p)|0;if(!q){if(!r){s=0;break}q=p;t=c[q>>2]|0;u=c[q+4>>2]|0;q=h;v=c[q+4>>2]|0;w=p;c[w>>2]=c[q>>2];c[w+4>>2]=v;v=h;c[v>>2]=t;c[v+4>>2]=u;if(!(nb[c[d>>2]&31](p,j)|0)){s=1;break}u=j;v=c[u>>2]|0;t=c[u+4>>2]|0;u=p;w=c[u+4>>2]|0;q=j;c[q>>2]=c[u>>2];c[q+4>>2]=w;w=p;c[w>>2]=v;c[w+4>>2]=t;s=2;break}t=j;w=c[t>>2]|0;v=c[t+4>>2]|0;if(r){r=h;t=c[r+4>>2]|0;q=j;c[q>>2]=c[r>>2];c[q+4>>2]=t;t=h;c[t>>2]=w;c[t+4>>2]=v;s=1;break}t=p;q=c[t+4>>2]|0;r=j;c[r>>2]=c[t>>2];c[r+4>>2]=q;q=p;c[q>>
2]=w;c[q+4>>2]=v;if(nb[c[d>>2]&31](h,p)|0){v=p;q=c[v>>2]|0;w=c[v+4>>2]|0;v=h;r=c[v+4>>2]|0;t=p;c[t>>2]=c[v>>2];c[t+4>>2]=r;r=h;c[r>>2]=q;c[r+4>>2]=w;s=2}else s=1}else{w=(m|0)/4|0;s=Gl(j,j+(w<<3)|0,p,j+(w+o<<3)|0,h,d)|0}while(0);do if(nb[c[d>>2]&31](j,p)|0){x=h;y=s}else{o=h;while(1){o=o+-8|0;if((j|0)==(o|0))break;if(nb[c[d>>2]&31](o,p)|0){n=67;break}}if((n|0)==67){n=0;m=j;l=c[m>>2]|0;w=c[m+4>>2]|0;m=o;r=c[m+4>>2]|0;q=j;c[q>>2]=c[m>>2];c[q+4>>2]=r;r=o;c[r>>2]=l;c[r+4>>2]=w;x=o;y=s+1|0;break}w=j+8|0;
if(nb[c[d>>2]&31](j,h)|0)z=w;else{if((w|0)==(h|0)){n=84;break a}else A=w;while(1){B=A+8|0;if(nb[c[d>>2]&31](j,A)|0)break;if((B|0)==(h|0)){n=84;break a}else A=B}o=A;w=c[o>>2]|0;r=c[o+4>>2]|0;o=h;l=c[o+4>>2]|0;q=A;c[q>>2]=c[o>>2];c[q+4>>2]=l;l=h;c[l>>2]=w;c[l+4>>2]=r;z=B}if((z|0)==(h|0)){n=84;break a}else{C=z;D=h}while(1){r=C;while(1){E=r+8|0;if(nb[c[d>>2]&31](j,r)|0){F=D;break}else r=E}do F=F+-8|0;while(nb[c[d>>2]&31](j,F)|0);if(!(r>>>0<F>>>0)){j=r;continue b}l=r;w=c[l>>2]|0;q=c[l+4>>2]|0;l=F;o=c[l+
4>>2]|0;m=r;c[m>>2]=c[l>>2];c[m+4>>2]=o;o=F;c[o>>2]=w;c[o+4>>2]=q;C=E;D=F}}while(0);q=j+8|0;c:do if(q>>>0<x>>>0){o=q;w=x;m=p;l=y;while(1){t=o;while(1){G=t+8|0;if(nb[c[d>>2]&31](t,m)|0)t=G;else{H=w;break}}do H=H+-8|0;while(!(nb[c[d>>2]&31](H,m)|0));if(t>>>0>H>>>0){I=t;J=m;K=l;break c}r=t;v=c[r>>2]|0;u=c[r+4>>2]|0;r=H;L=c[r+4>>2]|0;M=t;c[M>>2]=c[r>>2];c[M+4>>2]=L;L=H;c[L>>2]=v;c[L+4>>2]=u;o=G;w=H;m=(m|0)==(t|0)?H:m;l=l+1|0}}else{I=q;J=p;K=y}while(0);if((I|0)!=(J|0)?nb[c[d>>2]&31](J,I)|0:0){p=I;q=c[p>>
2]|0;l=c[p+4>>2]|0;p=J;m=c[p+4>>2]|0;w=I;c[w>>2]=c[p>>2];c[w+4>>2]=m;m=J;c[m>>2]=q;c[m+4>>2]=l;N=K+1|0}else N=K;if((N|0)==0){O=Hl(j,I,d)|0;l=I+8|0;if(Hl(l,a,d)|0){n=79;break}if(O){j=l;continue}}l=I;if((l-k|0)>=(b-l|0)){n=83;break}Fl(j,I,d);j=I+8|0}if((n|0)==79){n=0;if(O){n=84;break}else{g=j;a=I;continue}}else if((n|0)==83){n=0;Fl(I+8|0,a,d);g=j;a=I;continue}}if((n|0)==4){if(!(nb[c[d>>2]&31](h,j)|0)){i=e;return}I=j;g=c[I>>2]|0;O=c[I+4>>2]|0;I=h;N=c[I+4>>2]|0;K=j;c[K>>2]=c[I>>2];c[K+4>>2]=N;N=h;c[N>>
2]=g;c[N+4>>2]=O;i=e;return}else if((n|0)==6){O=j+8|0;N=nb[c[d>>2]&31](O,j)|0;g=nb[c[d>>2]&31](h,O)|0;if(!N){if(!g){i=e;return}N=O;K=c[N>>2]|0;I=c[N+4>>2]|0;N=h;J=c[N+4>>2]|0;y=O;c[y>>2]=c[N>>2];c[y+4>>2]=J;J=h;c[J>>2]=K;c[J+4>>2]=I;if(!(nb[c[d>>2]&31](O,j)|0)){i=e;return}I=j;J=c[I>>2]|0;K=c[I+4>>2]|0;I=O;y=c[I+4>>2]|0;N=j;c[N>>2]=c[I>>2];c[N+4>>2]=y;y=O;c[y>>2]=J;c[y+4>>2]=K;i=e;return}K=j;y=c[K>>2]|0;J=c[K+4>>2]|0;if(g){g=h;K=c[g+4>>2]|0;N=j;c[N>>2]=c[g>>2];c[N+4>>2]=K;K=h;c[K>>2]=y;c[K+4>>2]=J;
i=e;return}K=O;N=c[K+4>>2]|0;g=j;c[g>>2]=c[K>>2];c[g+4>>2]=N;N=O;c[N>>2]=y;c[N+4>>2]=J;if(!(nb[c[d>>2]&31](h,O)|0)){i=e;return}J=O;N=c[J>>2]|0;y=c[J+4>>2]|0;J=h;g=c[J+4>>2]|0;K=O;c[K>>2]=c[J>>2];c[K+4>>2]=g;g=h;c[g>>2]=N;c[g+4>>2]=y;i=e;return}else if((n|0)==14){y=j+8|0;g=j+16|0;N=nb[c[d>>2]&31](y,j)|0;K=nb[c[d>>2]&31](g,y)|0;do if(N){J=j;O=c[J>>2]|0;I=c[J+4>>2]|0;if(K){J=g;H=c[J+4>>2]|0;G=j;c[G>>2]=c[J>>2];c[G+4>>2]=H;H=g;c[H>>2]=O;c[H+4>>2]=I;break}H=y;G=c[H+4>>2]|0;J=j;c[J>>2]=c[H>>2];c[J+4>>2]=
G;G=y;c[G>>2]=O;c[G+4>>2]=I;if(nb[c[d>>2]&31](g,y)|0){I=y;G=c[I>>2]|0;O=c[I+4>>2]|0;I=g;J=c[I+4>>2]|0;H=y;c[H>>2]=c[I>>2];c[H+4>>2]=J;J=g;c[J>>2]=G;c[J+4>>2]=O}}else if(K?(O=y,J=c[O>>2]|0,G=c[O+4>>2]|0,O=g,H=c[O+4>>2]|0,I=y,c[I>>2]=c[O>>2],c[I+4>>2]=H,H=g,c[H>>2]=J,c[H+4>>2]=G,nb[c[d>>2]&31](y,j)|0):0){G=j;H=c[G>>2]|0;J=c[G+4>>2]|0;G=y;I=c[G+4>>2]|0;O=j;c[O>>2]=c[G>>2];c[O+4>>2]=I;I=y;c[I>>2]=H;c[I+4>>2]=J}while(0);if(!(nb[c[d>>2]&31](h,g)|0)){i=e;return}K=g;N=c[K>>2]|0;J=c[K+4>>2]|0;K=h;I=c[K+4>>
2]|0;H=g;c[H>>2]=c[K>>2];c[H+4>>2]=I;I=h;c[I>>2]=N;c[I+4>>2]=J;if(!(nb[c[d>>2]&31](g,y)|0)){i=e;return}J=y;I=c[J>>2]|0;N=c[J+4>>2]|0;J=g;H=c[J+4>>2]|0;K=y;c[K>>2]=c[J>>2];c[K+4>>2]=H;H=g;c[H>>2]=I;c[H+4>>2]=N;if(!(nb[c[d>>2]&31](y,j)|0)){i=e;return}N=j;H=c[N>>2]|0;I=c[N+4>>2]|0;N=y;g=c[N+4>>2]|0;K=j;c[K>>2]=c[N>>2];c[K+4>>2]=g;g=y;c[g>>2]=H;c[g+4>>2]=I;i=e;return}else if((n|0)==26){Gl(j,j+8|0,j+16|0,j+24|0,h,d)|0;i=e;return}else if((n|0)==28){h=j+16|0;I=j+8|0;g=nb[c[d>>2]&31](I,j)|0;H=nb[c[d>>2]&
31](h,I)|0;do if(g){y=j;K=c[y>>2]|0;N=c[y+4>>2]|0;if(H){y=h;J=c[y+4>>2]|0;O=j;c[O>>2]=c[y>>2];c[O+4>>2]=J;J=h;c[J>>2]=K;c[J+4>>2]=N;break}J=I;O=c[J+4>>2]|0;y=j;c[y>>2]=c[J>>2];c[y+4>>2]=O;O=I;c[O>>2]=K;c[O+4>>2]=N;if(nb[c[d>>2]&31](h,I)|0){N=I;O=c[N>>2]|0;K=c[N+4>>2]|0;N=h;y=c[N+4>>2]|0;J=I;c[J>>2]=c[N>>2];c[J+4>>2]=y;y=h;c[y>>2]=O;c[y+4>>2]=K}}else if(H?(K=I,y=c[K>>2]|0,O=c[K+4>>2]|0,K=h,J=c[K+4>>2]|0,N=I,c[N>>2]=c[K>>2],c[N+4>>2]=J,J=h,c[J>>2]=y,c[J+4>>2]=O,nb[c[d>>2]&31](I,j)|0):0){O=j;J=c[O>>
2]|0;y=c[O+4>>2]|0;O=I;N=c[O+4>>2]|0;K=j;c[K>>2]=c[O>>2];c[K+4>>2]=N;N=I;c[N>>2]=J;c[N+4>>2]=y}while(0);I=j+24|0;if((I|0)==(a|0)){i=e;return}else{P=I;Q=h}while(1){if(nb[c[d>>2]&31](P,Q)|0){h=P;I=c[h+4>>2]|0;H=f;c[H>>2]=c[h>>2];c[H+4>>2]=I;I=P;H=Q;while(1){h=H;g=c[h+4>>2]|0;y=I;c[y>>2]=c[h>>2];c[y+4>>2]=g;if((H|0)==(j|0))break;g=H+-8|0;if(nb[c[d>>2]&31](f,g)|0){y=H;H=g;I=y}else break}I=f;y=c[I+4>>2]|0;g=H;c[g>>2]=c[I>>2];c[g+4>>2]=y}y=P+8|0;if((y|0)==(a|0))break;else{g=P;P=y;Q=g}}i=e;return}else if((n|
0)==84){i=e;return}}function Gl(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;h=i;j=nb[c[g>>2]&31](b,a)|0;k=nb[c[g>>2]&31](d,b)|0;do if(j){l=a;m=c[l>>2]|0;n=c[l+4>>2]|0;if(k){l=d;o=c[l+4>>2]|0;p=a;c[p>>2]=c[l>>2];c[p+4>>2]=o;o=d;c[o>>2]=m;c[o+4>>2]=n;q=1;break}o=b;p=c[o+4>>2]|0;l=a;c[l>>2]=c[o>>2];c[l+4>>2]=p;p=b;c[p>>2]=m;c[p+4>>2]=n;if(nb[c[g>>2]&31](d,b)|0){n=b;p=c[n>>2]|0;m=c[n+4>>2]|0;n=d;l=c[n+4>>2]|0;o=b;c[o>>2]=c[n>>2];c[o+4>>2]=l;l=d;c[l>>
2]=p;c[l+4>>2]=m;q=2}else q=1}else if(k){m=b;l=c[m>>2]|0;p=c[m+4>>2]|0;m=d;o=c[m+4>>2]|0;n=b;c[n>>2]=c[m>>2];c[n+4>>2]=o;o=d;c[o>>2]=l;c[o+4>>2]=p;if(nb[c[g>>2]&31](b,a)|0){p=a;o=c[p>>2]|0;l=c[p+4>>2]|0;p=b;n=c[p+4>>2]|0;m=a;c[m>>2]=c[p>>2];c[m+4>>2]=n;n=b;c[n>>2]=o;c[n+4>>2]=l;q=2}else q=1}else q=0;while(0);if(nb[c[g>>2]&31](e,d)|0){k=d;j=c[k>>2]|0;l=c[k+4>>2]|0;k=e;n=c[k+4>>2]|0;o=d;c[o>>2]=c[k>>2];c[o+4>>2]=n;n=e;c[n>>2]=j;c[n+4>>2]=l;l=q+1|0;if(nb[c[g>>2]&31](d,b)|0){n=b;j=c[n>>2]|0;o=c[n+4>>
2]|0;n=d;k=c[n+4>>2]|0;m=b;c[m>>2]=c[n>>2];c[m+4>>2]=k;k=d;c[k>>2]=j;c[k+4>>2]=o;if(nb[c[g>>2]&31](b,a)|0){o=a;k=c[o>>2]|0;j=c[o+4>>2]|0;o=b;m=c[o+4>>2]|0;n=a;c[n>>2]=c[o>>2];c[n+4>>2]=m;m=b;c[m>>2]=k;c[m+4>>2]=j;r=q+3|0}else r=q+2|0}else r=l}else r=q;if(!(nb[c[g>>2]&31](f,e)|0)){s=r;i=h;return s|0}q=e;l=c[q>>2]|0;j=c[q+4>>2]|0;q=f;m=c[q+4>>2]|0;k=e;c[k>>2]=c[q>>2];c[k+4>>2]=m;m=f;c[m>>2]=l;c[m+4>>2]=j;if(!(nb[c[g>>2]&31](e,d)|0)){s=r+1|0;i=h;return s|0}j=d;m=c[j>>2]|0;l=c[j+4>>2]|0;j=e;f=c[j+4>>
2]|0;k=d;c[k>>2]=c[j>>2];c[k+4>>2]=f;f=e;c[f>>2]=m;c[f+4>>2]=l;if(!(nb[c[g>>2]&31](d,b)|0)){s=r+2|0;i=h;return s|0}l=b;f=c[l>>2]|0;m=c[l+4>>2]|0;l=d;e=c[l+4>>2]|0;k=b;c[k>>2]=c[l>>2];c[k+4>>2]=e;e=d;c[e>>2]=f;c[e+4>>2]=m;if(!(nb[c[g>>2]&31](b,a)|0)){s=r+3|0;i=h;return s|0}g=a;m=c[g>>2]|0;e=c[g+4>>2]|0;g=b;f=c[g+4>>2]|0;d=a;c[d>>2]=c[g>>2];c[d+4>>2]=f;f=b;c[f>>2]=m;c[f+4>>2]=e;s=r+4|0;i=h;return s|0}function Hl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=
0,u=0,v=0,w=0;e=i;i=i+16|0;f=e;switch(b-a>>3|0){case 3:g=a+8|0;h=b+-8|0;j=nb[c[d>>2]&31](g,a)|0;k=nb[c[d>>2]&31](h,g)|0;if(!j){if(!k){l=1;i=e;return l|0}j=g;m=c[j>>2]|0;n=c[j+4>>2]|0;j=h;o=c[j+4>>2]|0;p=g;c[p>>2]=c[j>>2];c[p+4>>2]=o;o=h;c[o>>2]=m;c[o+4>>2]=n;if(!(nb[c[d>>2]&31](g,a)|0)){l=1;i=e;return l|0}n=a;o=c[n>>2]|0;m=c[n+4>>2]|0;n=g;p=c[n+4>>2]|0;j=a;c[j>>2]=c[n>>2];c[j+4>>2]=p;p=g;c[p>>2]=o;c[p+4>>2]=m;l=1;i=e;return l|0}m=a;p=c[m>>2]|0;o=c[m+4>>2]|0;if(k){k=h;m=c[k+4>>2]|0;j=a;c[j>>2]=c[k>>
2];c[j+4>>2]=m;m=h;c[m>>2]=p;c[m+4>>2]=o;l=1;i=e;return l|0}m=g;j=c[m+4>>2]|0;k=a;c[k>>2]=c[m>>2];c[k+4>>2]=j;j=g;c[j>>2]=p;c[j+4>>2]=o;if(!(nb[c[d>>2]&31](h,g)|0)){l=1;i=e;return l|0}o=g;j=c[o>>2]|0;p=c[o+4>>2]|0;o=h;k=c[o+4>>2]|0;m=g;c[m>>2]=c[o>>2];c[m+4>>2]=k;k=h;c[k>>2]=j;c[k+4>>2]=p;l=1;i=e;return l|0;case 4:p=a+8|0;k=a+16|0;j=b+-8|0;h=nb[c[d>>2]&31](p,a)|0;m=nb[c[d>>2]&31](k,p)|0;do if(h){o=a;g=c[o>>2]|0;n=c[o+4>>2]|0;if(m){o=k;q=c[o+4>>2]|0;r=a;c[r>>2]=c[o>>2];c[r+4>>2]=q;q=k;c[q>>2]=g;c[q+
4>>2]=n;break}q=p;r=c[q+4>>2]|0;o=a;c[o>>2]=c[q>>2];c[o+4>>2]=r;r=p;c[r>>2]=g;c[r+4>>2]=n;if(nb[c[d>>2]&31](k,p)|0){n=p;r=c[n>>2]|0;g=c[n+4>>2]|0;n=k;o=c[n+4>>2]|0;q=p;c[q>>2]=c[n>>2];c[q+4>>2]=o;o=k;c[o>>2]=r;c[o+4>>2]=g}}else if(m?(g=p,o=c[g>>2]|0,r=c[g+4>>2]|0,g=k,q=c[g+4>>2]|0,n=p,c[n>>2]=c[g>>2],c[n+4>>2]=q,q=k,c[q>>2]=o,c[q+4>>2]=r,nb[c[d>>2]&31](p,a)|0):0){r=a;q=c[r>>2]|0;o=c[r+4>>2]|0;r=p;n=c[r+4>>2]|0;g=a;c[g>>2]=c[r>>2];c[g+4>>2]=n;n=p;c[n>>2]=q;c[n+4>>2]=o}while(0);if(!(nb[c[d>>2]&31](j,
k)|0)){l=1;i=e;return l|0}m=k;h=c[m>>2]|0;o=c[m+4>>2]|0;m=j;n=c[m+4>>2]|0;q=k;c[q>>2]=c[m>>2];c[q+4>>2]=n;n=j;c[n>>2]=h;c[n+4>>2]=o;if(!(nb[c[d>>2]&31](k,p)|0)){l=1;i=e;return l|0}o=p;n=c[o>>2]|0;h=c[o+4>>2]|0;o=k;j=c[o+4>>2]|0;q=p;c[q>>2]=c[o>>2];c[q+4>>2]=j;j=k;c[j>>2]=n;c[j+4>>2]=h;if(!(nb[c[d>>2]&31](p,a)|0)){l=1;i=e;return l|0}h=a;j=c[h>>2]|0;n=c[h+4>>2]|0;h=p;k=c[h+4>>2]|0;q=a;c[q>>2]=c[h>>2];c[q+4>>2]=k;k=p;c[k>>2]=j;c[k+4>>2]=n;l=1;i=e;return l|0;case 1:case 0:l=1;i=e;return l|0;case 5:Gl(a,
a+8|0,a+16|0,a+24|0,b+-8|0,d)|0;l=1;i=e;return l|0;case 2:n=b+-8|0;if(!(nb[c[d>>2]&31](n,a)|0)){l=1;i=e;return l|0}k=a;j=c[k>>2]|0;p=c[k+4>>2]|0;k=n;q=c[k+4>>2]|0;h=a;c[h>>2]=c[k>>2];c[h+4>>2]=q;q=n;c[q>>2]=j;c[q+4>>2]=p;l=1;i=e;return l|0;default:p=a+16|0;q=a+8|0;j=nb[c[d>>2]&31](q,a)|0;n=nb[c[d>>2]&31](p,q)|0;do if(j){h=a;k=c[h>>2]|0;o=c[h+4>>2]|0;if(n){h=p;m=c[h+4>>2]|0;g=a;c[g>>2]=c[h>>2];c[g+4>>2]=m;m=p;c[m>>2]=k;c[m+4>>2]=o;break}m=q;g=c[m+4>>2]|0;h=a;c[h>>2]=c[m>>2];c[h+4>>2]=g;g=q;c[g>>2]=
k;c[g+4>>2]=o;if(nb[c[d>>2]&31](p,q)|0){o=q;g=c[o>>2]|0;k=c[o+4>>2]|0;o=p;h=c[o+4>>2]|0;m=q;c[m>>2]=c[o>>2];c[m+4>>2]=h;h=p;c[h>>2]=g;c[h+4>>2]=k}}else if(n?(k=q,h=c[k>>2]|0,g=c[k+4>>2]|0,k=p,m=c[k+4>>2]|0,o=q,c[o>>2]=c[k>>2],c[o+4>>2]=m,m=p,c[m>>2]=h,c[m+4>>2]=g,nb[c[d>>2]&31](q,a)|0):0){g=a;m=c[g>>2]|0;h=c[g+4>>2]|0;g=q;o=c[g+4>>2]|0;k=a;c[k>>2]=c[g>>2];c[k+4>>2]=o;o=q;c[o>>2]=m;c[o+4>>2]=h}while(0);q=a+24|0;if((q|0)==(b|0)){l=1;i=e;return l|0}else{s=0;t=q;u=p}while(1){if(nb[c[d>>2]&31](t,u)|0){p=
t;q=c[p+4>>2]|0;n=f;c[n>>2]=c[p>>2];c[n+4>>2]=q;q=t;n=u;while(1){p=n;j=c[p+4>>2]|0;h=q;c[h>>2]=c[p>>2];c[h+4>>2]=j;if((n|0)==(a|0))break;j=n+-8|0;if(nb[c[d>>2]&31](f,j)|0){h=n;n=j;q=h}else break}q=f;h=c[q+4>>2]|0;j=n;c[j>>2]=c[q>>2];c[j+4>>2]=h;h=s+1|0;if((h|0)==8)break;else v=h}else v=s;h=t+8|0;if((h|0)==(b|0)){l=1;w=41;break}else{j=t;s=v;t=h;u=j}}if((w|0)==41){i=e;return l|0}l=(t+8|0)==(b|0);i=e;return l|0}return 0}function Il(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,
p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0;e=i;f=a;a=b;a:while(1){b=a;g=a+-8|0;h=a+-4|0;j=f;b:while(1){k=j;l=b-k|0;m=l>>3;switch(m|0){case 2:n=4;break a;break;case 4:n=14;break a;break;case 3:n=6;break a;break;case 5:n=15;break a;break;case 1:case 0:n=85;break a;break;default:}if((l|0)<248){n=21;break a}o=(m|0)/2|0;p=j+(o<<3)|0;do if((l|0)>7992){q=(m|0)/4|0;r=j+(q<<3)|0;s=q+o|0;t=j+(s<<3)|0;u=Jl(j,r,p,t,0)|0;v=j+(s<<
3)+4|0;if(!((c[h>>2]|0)>>>0<(c[v>>2]|0)>>>0)){w=j+(o<<3)+4|0;x=u;break}s=t;y=c[s>>2]|0;z=c[s+4>>2]|0;s=g;A=c[s+4>>2]|0;B=t;c[B>>2]=c[s>>2];c[B+4>>2]=A;A=g;c[A>>2]=y;c[A+4>>2]=z;z=j+(o<<3)+4|0;if(!((c[v>>2]|0)>>>0<(c[z>>2]|0)>>>0)){w=z;x=u+1|0;break}v=p;A=c[v>>2]|0;y=c[v+4>>2]|0;v=t;B=c[v+4>>2]|0;s=p;c[s>>2]=c[v>>2];c[s+4>>2]=B;B=t;c[B>>2]=A;c[B+4>>2]=y;y=j+(q<<3)+4|0;if(!((c[z>>2]|0)>>>0<(c[y>>2]|0)>>>0)){w=z;x=u+2|0;break}q=r;B=c[q>>2]|0;A=c[q+4>>2]|0;q=p;t=c[q+4>>2]|0;s=r;c[s>>2]=c[q>>2];c[s+4>>
2]=t;t=p;c[t>>2]=B;c[t+4>>2]=A;if((c[y>>2]|0)>>>0<(c[j+4>>2]|0)>>>0){y=j;A=c[y>>2]|0;t=c[y+4>>2]|0;y=r;B=c[y+4>>2]|0;s=j;c[s>>2]=c[y>>2];c[s+4>>2]=B;B=r;c[B>>2]=A;c[B+4>>2]=t;w=z;x=u+4|0;break}else{w=z;x=u+3|0;break}}else{u=j+(o<<3)+4|0;z=c[u>>2]|0;t=j+4|0;B=(c[h>>2]|0)>>>0<z>>>0;if(!(z>>>0<(c[t>>2]|0)>>>0)){if(!B){w=u;x=0;break}z=p;A=c[z>>2]|0;r=c[z+4>>2]|0;z=g;s=c[z+4>>2]|0;y=p;c[y>>2]=c[z>>2];c[y+4>>2]=s;s=g;c[s>>2]=A;c[s+4>>2]=r;if(!((c[u>>2]|0)>>>0<(c[t>>2]|0)>>>0)){w=u;x=1;break}t=j;r=c[t>>
2]|0;s=c[t+4>>2]|0;t=p;A=c[t+4>>2]|0;y=j;c[y>>2]=c[t>>2];c[y+4>>2]=A;A=p;c[A>>2]=r;c[A+4>>2]=s;w=u;x=2;break}s=j;A=c[s>>2]|0;r=c[s+4>>2]|0;if(B){B=g;s=c[B+4>>2]|0;y=j;c[y>>2]=c[B>>2];c[y+4>>2]=s;s=g;c[s>>2]=A;c[s+4>>2]=r;w=u;x=1;break}s=p;y=c[s+4>>2]|0;B=j;c[B>>2]=c[s>>2];c[B+4>>2]=y;y=p;c[y>>2]=A;c[y+4>>2]=r;if((c[h>>2]|0)>>>0<r>>>0){y=g;B=c[y+4>>2]|0;s=p;c[s>>2]=c[y>>2];c[s+4>>2]=B;B=g;c[B>>2]=A;c[B+4>>2]=r;w=u;x=2}else{w=u;x=1}}while(0);o=j+4|0;m=c[o>>2]|0;l=c[w>>2]|0;do if(m>>>0<l>>>0){C=g;D=
x}else{u=g;while(1){r=u;u=u+-8|0;if((j|0)==(u|0))break;if((c[r+-4>>2]|0)>>>0<l>>>0){n=68;break}}if((n|0)==68){n=0;r=j;B=c[r>>2]|0;A=c[r+4>>2]|0;r=u;s=c[r+4>>2]|0;y=j;c[y>>2]=c[r>>2];c[y+4>>2]=s;s=u;c[s>>2]=B;c[s+4>>2]=A;C=u;D=x+1|0;break}A=j+8|0;if(m>>>0<(c[h>>2]|0)>>>0)E=A;else{if((A|0)==(g|0)){n=85;break a}else F=A;while(1){G=F+8|0;if(m>>>0<(c[F+4>>2]|0)>>>0)break;if((G|0)==(g|0)){n=85;break a}else F=G}u=F;A=c[u>>2]|0;s=c[u+4>>2]|0;u=g;B=c[u+4>>2]|0;y=F;c[y>>2]=c[u>>2];c[y+4>>2]=B;B=g;c[B>>2]=A;
c[B+4>>2]=s;E=G}if((E|0)==(g|0)){n=85;break a}else{H=E;I=g}while(1){s=c[o>>2]|0;B=H;while(1){J=B+8|0;if(s>>>0<(c[B+4>>2]|0)>>>0){K=I;break}else B=J}do{A=K;K=K+-8|0}while(s>>>0<(c[A+-4>>2]|0)>>>0);if(!(B>>>0<K>>>0)){j=B;continue b}s=B;A=c[s>>2]|0;y=c[s+4>>2]|0;s=K;u=c[s+4>>2]|0;r=B;c[r>>2]=c[s>>2];c[r+4>>2]=u;u=K;c[u>>2]=A;c[u+4>>2]=y;H=J;I=K}}while(0);o=j+8|0;c:do if(o>>>0<C>>>0){m=o;l=C;y=p;u=D;while(1){A=c[y+4>>2]|0;r=m;while(1){L=r+8|0;if((c[r+4>>2]|0)>>>0<A>>>0)r=L;else{M=l;break}}do{B=M;M=M+
-8|0}while(!((c[B+-4>>2]|0)>>>0<A>>>0));if(r>>>0>M>>>0){N=r;O=y;P=u;break c}A=r;B=c[A>>2]|0;s=c[A+4>>2]|0;A=M;t=c[A+4>>2]|0;z=r;c[z>>2]=c[A>>2];c[z+4>>2]=t;t=M;c[t>>2]=B;c[t+4>>2]=s;m=L;l=M;y=(y|0)==(r|0)?M:y;u=u+1|0}}else{N=o;O=p;P=D}while(0);if((N|0)!=(O|0)?(c[O+4>>2]|0)>>>0<(c[N+4>>2]|0)>>>0:0){p=N;o=c[p>>2]|0;u=c[p+4>>2]|0;p=O;y=c[p+4>>2]|0;l=N;c[l>>2]=c[p>>2];c[l+4>>2]=y;y=O;c[y>>2]=o;c[y+4>>2]=u;Q=P+1|0}else Q=P;if((Q|0)==0){R=Kl(j,N,0)|0;u=N+8|0;if(Kl(u,a,0)|0){n=80;break}if(R){j=u;continue}}u=
N;if((u-k|0)>=(b-u|0)){n=84;break}Il(j,N,d);j=N+8|0}if((n|0)==80){n=0;if(R){n=85;break}else{f=j;a=N;continue}}else if((n|0)==84){n=0;Il(N+8|0,a,d);f=j;a=N;continue}}if((n|0)==4){if(!((c[h>>2]|0)>>>0<(c[j+4>>2]|0)>>>0)){i=e;return}N=j;f=c[N>>2]|0;d=c[N+4>>2]|0;N=g;R=c[N+4>>2]|0;Q=j;c[Q>>2]=c[N>>2];c[Q+4>>2]=R;R=g;c[R>>2]=f;c[R+4>>2]=d;i=e;return}else if((n|0)==6){d=j+8|0;R=j+12|0;f=c[R>>2]|0;Q=j+4|0;N=(c[h>>2]|0)>>>0<f>>>0;if(!(f>>>0<(c[Q>>2]|0)>>>0)){if(!N){i=e;return}f=d;P=c[f>>2]|0;O=c[f+4>>2]|
0;f=g;D=c[f+4>>2]|0;M=d;c[M>>2]=c[f>>2];c[M+4>>2]=D;D=g;c[D>>2]=P;c[D+4>>2]=O;if(!((c[R>>2]|0)>>>0<(c[Q>>2]|0)>>>0)){i=e;return}Q=j;R=c[Q>>2]|0;O=c[Q+4>>2]|0;Q=d;D=c[Q+4>>2]|0;P=j;c[P>>2]=c[Q>>2];c[P+4>>2]=D;D=d;c[D>>2]=R;c[D+4>>2]=O;i=e;return}O=j;D=c[O>>2]|0;R=c[O+4>>2]|0;if(N){N=g;O=c[N+4>>2]|0;P=j;c[P>>2]=c[N>>2];c[P+4>>2]=O;O=g;c[O>>2]=D;c[O+4>>2]=R;i=e;return}O=d;P=c[O+4>>2]|0;N=j;c[N>>2]=c[O>>2];c[N+4>>2]=P;P=d;c[P>>2]=D;c[P+4>>2]=R;if(!((c[h>>2]|0)>>>0<R>>>0)){i=e;return}P=g;N=c[P+4>>2]|0;
O=d;c[O>>2]=c[P>>2];c[O+4>>2]=N;N=g;c[N>>2]=D;c[N+4>>2]=R;i=e;return}else if((n|0)==14){Jl(j,j+8|0,j+16|0,g,0)|0;i=e;return}else if((n|0)==15){R=j+8|0;N=j+16|0;D=j+24|0;Jl(j,R,N,D,0)|0;O=j+28|0;if(!((c[h>>2]|0)>>>0<(c[O>>2]|0)>>>0)){i=e;return}h=D;P=c[h>>2]|0;d=c[h+4>>2]|0;h=g;Q=c[h+4>>2]|0;M=D;c[M>>2]=c[h>>2];c[M+4>>2]=Q;Q=g;c[Q>>2]=P;c[Q+4>>2]=d;if(!((c[O>>2]|0)>>>0<(c[j+20>>2]|0)>>>0)){i=e;return}O=N;d=c[O>>2]|0;Q=c[O+4>>2]|0;O=D;P=c[O>>2]|0;g=c[O+4>>2]|0;O=N;c[O>>2]=P;c[O+4>>2]=g;O=D;c[O>>2]=
d;c[O+4>>2]=Q;if(!(g>>>0<(c[j+12>>2]|0)>>>0)){i=e;return}Q=R;O=c[Q>>2]|0;d=c[Q+4>>2]|0;Q=R;c[Q>>2]=P;c[Q+4>>2]=g;Q=N;c[Q>>2]=O;c[Q+4>>2]=d;if(!(g>>>0<(c[j+4>>2]|0)>>>0)){i=e;return}d=j;Q=c[d>>2]|0;O=c[d+4>>2]|0;d=j;c[d>>2]=P;c[d+4>>2]=g;g=R;c[g>>2]=Q;c[g+4>>2]=O;i=e;return}else if((n|0)==21){O=j+16|0;g=j+8|0;Q=c[j+12>>2]|0;R=c[j+4>>2]|0;d=c[j+20>>2]|0;P=d>>>0<Q>>>0;do if(Q>>>0<R>>>0){N=j;D=c[N>>2]|0;M=c[N+4>>2]|0;if(P){N=O;h=c[N+4>>2]|0;f=j;c[f>>2]=c[N>>2];c[f+4>>2]=h;h=O;c[h>>2]=D;c[h+4>>2]=M;break}h=
g;f=c[h+4>>2]|0;N=j;c[N>>2]=c[h>>2];c[N+4>>2]=f;f=g;c[f>>2]=D;c[f+4>>2]=M;if(d>>>0<M>>>0){f=O;N=c[f+4>>2]|0;h=g;c[h>>2]=c[f>>2];c[h+4>>2]=N;N=O;c[N>>2]=D;c[N+4>>2]=M}}else if(P?(M=g,N=c[M>>2]|0,D=c[M+4>>2]|0,M=O,h=c[M>>2]|0,f=c[M+4>>2]|0,M=g,c[M>>2]=h,c[M+4>>2]=f,M=O,c[M>>2]=N,c[M+4>>2]=D,f>>>0<R>>>0):0){D=j;M=c[D>>2]|0;N=c[D+4>>2]|0;D=j;c[D>>2]=h;c[D+4>>2]=f;f=g;c[f>>2]=M;c[f+4>>2]=N}while(0);g=j+24|0;if((g|0)==(a|0)){i=e;return}else{S=g;T=O}while(1){if((c[S+4>>2]|0)>>>0<(c[T+4>>2]|0)>>>0){O=S;g=
c[O>>2]|0;R=c[O+4>>2]|0;O=S;P=T;while(1){d=P;Q=c[d+4>>2]|0;N=O;c[N>>2]=c[d>>2];c[N+4>>2]=Q;if((P|0)==(j|0))break;if(R>>>0<(c[P+-4>>2]|0)>>>0){Q=P;P=P+-8|0;O=Q}else break}O=P;c[O>>2]=g;c[O+4>>2]=R}O=S+8|0;if((O|0)==(a|0))break;else{Q=S;S=O;T=Q}}i=e;return}else if((n|0)==85){i=e;return}}function Jl(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;f=i;g=b+4|0;h=c[g>>2]|0;j=a+4|0;k=d+4|0;l=c[k>>2]|0;m=l>>>0<h>>>0;do if(h>>>0<(c[j>>2]|0)>>>0){n=a;
o=c[n>>2]|0;p=c[n+4>>2]|0;if(m){n=d;q=c[n+4>>2]|0;r=a;c[r>>2]=c[n>>2];c[r+4>>2]=q;q=d;c[q>>2]=o;c[q+4>>2]=p;s=1;t=p;break}q=b;r=c[q+4>>2]|0;n=a;c[n>>2]=c[q>>2];c[n+4>>2]=r;r=b;c[r>>2]=o;c[r+4>>2]=p;r=c[k>>2]|0;if(r>>>0<p>>>0){n=d;q=c[n+4>>2]|0;u=b;c[u>>2]=c[n>>2];c[u+4>>2]=q;q=d;c[q>>2]=o;c[q+4>>2]=p;s=2;t=p}else{s=1;t=r}}else if(m){r=b;p=c[r>>2]|0;q=c[r+4>>2]|0;r=d;o=c[r+4>>2]|0;u=b;c[u>>2]=c[r>>2];c[u+4>>2]=o;o=d;c[o>>2]=p;c[o+4>>2]=q;if((c[g>>2]|0)>>>0<(c[j>>2]|0)>>>0){o=a;p=c[o>>2]|0;u=c[o+4>>
2]|0;o=b;r=c[o+4>>2]|0;n=a;c[n>>2]=c[o>>2];c[n+4>>2]=r;r=b;c[r>>2]=p;c[r+4>>2]=u;s=2;t=c[k>>2]|0}else{s=1;t=q}}else{s=0;t=l}while(0);if(!((c[e+4>>2]|0)>>>0<t>>>0)){v=s;i=f;return v|0}t=d;l=c[t>>2]|0;m=c[t+4>>2]|0;t=e;h=c[t+4>>2]|0;q=d;c[q>>2]=c[t>>2];c[q+4>>2]=h;h=e;c[h>>2]=l;c[h+4>>2]=m;if(!((c[k>>2]|0)>>>0<(c[g>>2]|0)>>>0)){v=s+1|0;i=f;return v|0}k=b;m=c[k>>2]|0;h=c[k+4>>2]|0;k=d;l=c[k+4>>2]|0;e=b;c[e>>2]=c[k>>2];c[e+4>>2]=l;l=d;c[l>>2]=m;c[l+4>>2]=h;if(!((c[g>>2]|0)>>>0<(c[j>>2]|0)>>>0)){v=s+2|
0;i=f;return v|0}j=a;g=c[j>>2]|0;h=c[j+4>>2]|0;j=b;l=c[j+4>>2]|0;m=a;c[m>>2]=c[j>>2];c[m+4>>2]=l;l=b;c[l>>2]=g;c[l+4>>2]=h;v=s+3|0;i=f;return v|0}function Kl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;d=i;switch(b-a>>3|0){case 5:e=a+8|0;f=a+16|0;g=a+24|0;Jl(a,e,f,g,0)|0;h=a+28|0;if(!((c[b+-4>>2]|0)>>>0<(c[h>>2]|0)>>>0)){j=1;i=d;return j|0}k=b+-8|0;l=g;m=c[l>>2]|0;n=c[l+4>>2]|0;l=k;o=c[l+4>>2]|0;p=g;c[p>>2]=c[l>>2];c[p+4>>2]=o;o=k;c[o>>2]=m;c[o+
4>>2]=n;if(!((c[h>>2]|0)>>>0<(c[a+20>>2]|0)>>>0)){j=1;i=d;return j|0}h=f;n=c[h>>2]|0;o=c[h+4>>2]|0;h=g;m=c[h>>2]|0;k=c[h+4>>2]|0;h=f;c[h>>2]=m;c[h+4>>2]=k;h=g;c[h>>2]=n;c[h+4>>2]=o;if(!(k>>>0<(c[a+12>>2]|0)>>>0)){j=1;i=d;return j|0}o=e;h=c[o>>2]|0;n=c[o+4>>2]|0;o=e;c[o>>2]=m;c[o+4>>2]=k;o=f;c[o>>2]=h;c[o+4>>2]=n;if(!(k>>>0<(c[a+4>>2]|0)>>>0)){j=1;i=d;return j|0}n=a;o=c[n>>2]|0;h=c[n+4>>2]|0;n=a;c[n>>2]=m;c[n+4>>2]=k;k=e;c[k>>2]=o;c[k+4>>2]=h;j=1;i=d;return j|0;case 4:Jl(a,a+8|0,a+16|0,b+-8|0,0)|0;
j=1;i=d;return j|0;case 1:case 0:j=1;i=d;return j|0;case 3:h=a+8|0;k=b+-8|0;o=a+12|0;e=c[o>>2]|0;n=a+4|0;m=b+-4|0;f=(c[m>>2]|0)>>>0<e>>>0;if(!(e>>>0<(c[n>>2]|0)>>>0)){if(!f){j=1;i=d;return j|0}e=h;g=c[e>>2]|0;p=c[e+4>>2]|0;e=k;l=c[e+4>>2]|0;q=h;c[q>>2]=c[e>>2];c[q+4>>2]=l;l=k;c[l>>2]=g;c[l+4>>2]=p;if(!((c[o>>2]|0)>>>0<(c[n>>2]|0)>>>0)){j=1;i=d;return j|0}n=a;o=c[n>>2]|0;p=c[n+4>>2]|0;n=h;l=c[n+4>>2]|0;g=a;c[g>>2]=c[n>>2];c[g+4>>2]=l;l=h;c[l>>2]=o;c[l+4>>2]=p;j=1;i=d;return j|0}p=a;l=c[p>>2]|0;o=c[p+
4>>2]|0;if(f){f=k;p=c[f+4>>2]|0;g=a;c[g>>2]=c[f>>2];c[g+4>>2]=p;p=k;c[p>>2]=l;c[p+4>>2]=o;j=1;i=d;return j|0}p=h;g=c[p+4>>2]|0;f=a;c[f>>2]=c[p>>2];c[f+4>>2]=g;g=h;c[g>>2]=l;c[g+4>>2]=o;if(!((c[m>>2]|0)>>>0<o>>>0)){j=1;i=d;return j|0}m=k;g=c[m+4>>2]|0;f=h;c[f>>2]=c[m>>2];c[f+4>>2]=g;g=k;c[g>>2]=l;c[g+4>>2]=o;j=1;i=d;return j|0;case 2:if(!((c[b+-4>>2]|0)>>>0<(c[a+4>>2]|0)>>>0)){j=1;i=d;return j|0}o=b+-8|0;g=a;l=c[g>>2]|0;k=c[g+4>>2]|0;g=o;f=c[g+4>>2]|0;m=a;c[m>>2]=c[g>>2];c[m+4>>2]=f;f=o;c[f>>2]=l;
c[f+4>>2]=k;j=1;i=d;return j|0;default:k=a+16|0;f=a+8|0;l=c[a+12>>2]|0;o=c[a+4>>2]|0;m=c[a+20>>2]|0;g=m>>>0<l>>>0;do if(l>>>0<o>>>0){h=a;p=c[h>>2]|0;n=c[h+4>>2]|0;if(g){h=k;q=c[h+4>>2]|0;e=a;c[e>>2]=c[h>>2];c[e+4>>2]=q;q=k;c[q>>2]=p;c[q+4>>2]=n;break}q=f;e=c[q+4>>2]|0;h=a;c[h>>2]=c[q>>2];c[h+4>>2]=e;e=f;c[e>>2]=p;c[e+4>>2]=n;if(m>>>0<n>>>0){e=k;h=c[e+4>>2]|0;q=f;c[q>>2]=c[e>>2];c[q+4>>2]=h;h=k;c[h>>2]=p;c[h+4>>2]=n}}else if(g?(n=f,h=c[n>>2]|0,p=c[n+4>>2]|0,n=k,q=c[n>>2]|0,e=c[n+4>>2]|0,n=f,c[n>>2]=
q,c[n+4>>2]=e,n=k,c[n>>2]=h,c[n+4>>2]=p,e>>>0<o>>>0):0){p=a;n=c[p>>2]|0;h=c[p+4>>2]|0;p=a;c[p>>2]=q;c[p+4>>2]=e;e=f;c[e>>2]=n;c[e+4>>2]=h}while(0);f=a+24|0;if((f|0)==(b|0)){j=1;i=d;return j|0}else{r=0;s=f;t=k}while(1){if((c[s+4>>2]|0)>>>0<(c[t+4>>2]|0)>>>0){k=s;f=c[k>>2]|0;o=c[k+4>>2]|0;k=s;g=t;while(1){m=g;l=c[m+4>>2]|0;h=k;c[h>>2]=c[m>>2];c[h+4>>2]=l;if((g|0)==(a|0))break;if(o>>>0<(c[g+-4>>2]|0)>>>0){l=g;g=g+-8|0;k=l}else break}k=g;c[k>>2]=f;c[k+4>>2]=o;k=r+1|0;if((k|0)==8)break;else u=k}else u=
r;k=s+8|0;if((k|0)==(b|0)){j=1;v=34;break}else{l=s;r=u;s=k;t=l}}if((v|0)==34){i=d;return j|0}j=(s+8|0)==(b|0);i=d;return j|0}return 0}function Ll(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;h=i;i=i+64|0;j=h;if((e|0)==2){k=b+-60|0;if(!(nb[c[d>>2]&31](k,a)|0)){i=h;return}l=j+0|0;m=a+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));l=a+0|0;m=k+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|
0));l=k+0|0;m=j+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));i=h;return}else if((e|0)==1|(e|0)==0){i=h;return}else{if((e|0)<129){if((a|0)==(b|0)){i=h;return}k=a+60|0;if((k|0)==(b|0)){i=h;return}o=k;do{l=j+0|0;m=o+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));a:do if((o|0)==(a|0))p=a;else{k=o;while(1){q=k;k=k+-60|0;if(!(nb[c[d>>2]&31](j,k)|0)){p=q;break a}l=q+0|0;m=k+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));if((k|0)==(a|0)){p=a;break}}}while(0);
l=p+0|0;m=j+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));o=o+60|0}while((o|0)!=(b|0));i=h;return}o=(e|0)/2|0;j=a+(o*60|0)|0;if((e|0)>(g|0)){Ll(a,j,d,o,f,g);p=e-o|0;Ll(j,b,d,p,f,g);Nl(a,j,b,d,o,p,f,g);i=h;return}Ml(a,j,d,o,f);g=f+(o*60|0)|0;Ml(j,b,d,e-o|0,g);o=f+(e*60|0)|0;b:do if((e+1|0)>>>0<3){r=a;s=g}else{b=a;j=f;p=g;while(1){if((p|0)==(o|0))break;if(nb[c[d>>2]&31](p,j)|0){l=b+0|0;m=p+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));t=p+60|0;u=j}else{l=b+
0|0;m=j+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));t=p;u=j+60|0}k=b+60|0;if((u|0)==(g|0)){r=k;s=t;break b}else{b=k;j=u;p=t}}if((j|0)==(g|0)){i=h;return}else{v=j;w=b}while(1){l=w+0|0;m=v+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));v=v+60|0;if((v|0)==(g|0))break;else w=w+60|0}i=h;return}while(0);if((s|0)==(o|0)){i=h;return}else{x=r;y=s}while(1){l=x+0|0;m=y+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));y=y+60|0;if((y|0)==(o|0))break;
else x=x+60|0}i=h;return}}function Ml(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;g=i;if((e|0)==1){if((f|0)==0){i=g;return}h=f+0|0;j=a+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0));i=g;return}else if((e|0)==2){l=b+-60|0;m=(f|0)==0;if(nb[c[d>>2]&31](l,a)|0){if(!m){h=f+0|0;j=l+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}h=f+60|0;j=a+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|
0)<(k|0));i=g;return}else{if(!m){h=f+0|0;j=a+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}h=f+60|0;j=l+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0));i=g;return}}else if((e|0)==0){i=g;return}else{if((e|0)<9){if((a|0)==(b|0)){i=g;return}if((f|0)==0)n=0;else{h=f+0|0;j=a+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0));n=f}l=a+60|0;if((l|0)==(b|0)){i=g;return}else{o=l;p=n}do{n=p;p=p+60|0;if(nb[c[d>>2]&31](o,n)|0){h=p+0|0;j=n+0|0;k=h+60|0;do{c[h>>
2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0));a:do if((n|0)==(f|0))q=f;else{l=n;while(1){m=l;l=l+-60|0;if(!(nb[c[d>>2]&31](o,l)|0)){q=m;break a}h=m+0|0;j=l+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0));if((l|0)==(f|0)){q=f;break}}}while(0);h=q+0|0;j=o+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}else{h=p+0|0;j=o+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}o=o+60|0}while((o|0)!=(b|0));i=g;return}o=(e|0)/2|0;p=a+(o*60|0)|0;Ll(a,p,d,o,
f,o);q=e-o|0;Ll(p,b,d,q,f+(o*60|0)|0,q);b:do if((e+1|0)>>>0<3){r=p;s=f}else{q=p;o=a;n=f;while(1){if((q|0)==(b|0))break;l=(n|0)==0;if(nb[c[d>>2]&31](q,o)|0){if(!l){h=n+0|0;j=q+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}t=o;u=q+60|0}else{if(!l){h=n+0|0;j=o+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}t=o+60|0;u=q}l=n+60|0;if((t|0)==(p|0)){r=u;s=l;break b}else{q=u;o=t;n=l}}if((o|0)==(p|0)){i=g;return}else{v=o;w=n}while(1){if((w|0)!=0){h=w+0|0;j=v+0|0;k=h+
60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}v=v+60|0;if((v|0)==(p|0))break;else w=w+60|0}i=g;return}while(0);if((r|0)==(b|0)){i=g;return}else{x=r;y=s}while(1){if((y|0)!=0){h=y+0|0;j=x+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}x=x+60|0;if((x|0)==(b|0))break;else y=y+60|0}i=g;return}}function Nl(a,b,d,e,f,g,h,j){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;j=j|0;var k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=
0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0;k=i;i=i+64|0;l=k;if((g|0)==0){i=k;return}m=a;a=b;b=d;d=f;f=g;a:while(1){g=b;n=a;o=d;p=m;q=f;while(1){if((o|0)==0){r=45;break a}else{s=p;t=o}while(1){if(nb[c[e>>2]&31](n,s)|0)break;u=t+-1|0;if((u|0)==0){r=45;break a}else{s=s+60|0;t=u}}if(!((t|0)>(j|0)&(q|0)>(j|0))){r=8;break a}if((t|0)<(q|0)){u=(q|0)/2|0;v=n+(u*60|0)|0;w=s;x=s;y=(n-w|0)/60|0;b:while(1){z=y;while(1){if((z|0)==0)break b;A=(z|0)/2|0;if(nb[c[e>>2]&31](v,x+(A*60|0)|0)|0)z=A;else break}x=
x+((A+1|0)*60|0)|0;y=z+-1-A|0}B=x;C=v;D=(x-w|0)/60|0;E=u}else{if((t|0)==1){r=17;break a}y=(t|0)/2|0;F=s+(y*60|0)|0;G=n;H=n;I=(g-G|0)/60|0;c:while(1){J=I;while(1){if((J|0)==0)break c;K=(J|0)/2|0;if(nb[c[e>>2]&31](H+(K*60|0)|0,F)|0)break;else J=K}H=H+((K+1|0)*60|0)|0;I=J+-1-K|0}B=F;C=H;D=y;E=(H-G|0)/60|0}o=t-D|0;L=q-E|0;d:do if((B|0)!=(n|0))if((n|0)==(C|0))M=B;else{if((B+60|0)==(n|0)){N=l+0|0;O=B+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));J=C-n|0;Bn(B|0,n|0,J|0)|0;I=B+(((J|0)/
60|0)*60|0)|0;N=I+0|0;O=l+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));M=I;break}if((n+60|0)==(C|0)){J=C+-60|0;N=l+0|0;O=J+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));I=J-B|0;u=C+(((I|0)/-60|0)*60|0)|0;Bn(u|0,B|0,I|0)|0;N=B+0|0;O=l+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));M=u;break}J=n;I=(J-B|0)/60|0;w=C;x=(w-J|0)/60|0;if((I|0)==(x|0)){J=B;v=n;while(1){N=l+0|0;O=J+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|
0));N=J+0|0;O=v+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));N=v+0|0;O=l+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));J=J+60|0;if((J|0)==(n|0)){M=n;break d}else v=v+60|0}}else{Q=I;R=x}while(1){v=(Q|0)%(R|0)|0;if((v|0)==0)break;else{J=R;R=v;Q=J}}if((R|0)!=0){J=I+-1|0;v=B+(R*60|0)|0;do{u=v;v=v+-60|0;N=l+0|0;O=v+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));z=v;S=u+(J*60|0)|0;while(1){N=z+0|0;O=S+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;
O=O+4|0}while((N|0)<(P|0));T=(w-S|0)/60|0;if((I|0)<(T|0))U=S+(I*60|0)|0;else U=B+((I-T|0)*60|0)|0;if((U|0)==(v|0))break;else{T=S;S=U;z=T}}N=S+0|0;O=l+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0))}while((v|0)!=(B|0))}M=B+(x*60|0)|0}else M=C;while(0);if((E+D|0)>=(L+o|0))break;Nl(s,B,M,e,D,E,h,j);if((q|0)==(E|0)){r=45;break a}else{n=C;p=M;q=L}}Nl(M,C,b,e,o,L,h,j);if((E|0)==0){r=45;break}else{m=s;a=B;b=M;d=D;f=E}}if((r|0)==8){Ol(s,n,b,e,t,q,h);i=k;return}else if((r|0)==17){N=l+0|
0;O=s+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));N=s+0|0;O=n+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));N=n+0|0;O=l+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));i=k;return}else if((r|0)==45){i=k;return}}function Ol(a,b,d,e,f,g,h){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0;j=i;k=a;l=b;if((f|0)<=(g|0)){a:do if((a|0)!=(b|0)){g=(((b+-60+(0-
k)|0)>>>0)/60|0)+1|0;f=a;m=h;while(1){if((m|0)!=0){n=m+0|0;o=f+0|0;p=n+60|0;do{c[n>>2]=c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0))}f=f+60|0;if((f|0)==(b|0))break;else m=m+60|0}m=h+(g*60|0)|0;if((m|0)!=(h|0)){f=a;q=b;r=h;while(1){if((q|0)==(d|0))break;if(nb[c[e>>2]&31](q,r)|0){n=f+0|0;o=q+0|0;p=n+60|0;do{c[n>>2]=c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0));s=r;t=q+60|0}else{n=f+0|0;o=r+0|0;p=n+60|0;do{c[n>>2]=c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0));s=r+60|0;t=q}u=f+60|0;if((s|0)==(m|0)){v=u;w=t;break a}else{f=
u;q=t;r=s}}Bn(f|0,r|0,m-r|0)|0;i=j;return}else{v=a;w=b}}else{v=a;w=b}while(0);Bn(v|0,w|0,d-w|0)|0;i=j;return}if((b|0)==(d|0))x=h;else{w=(((d+-60+(0-l)|0)>>>0)/60|0)+1|0;l=b;v=h;while(1){if((v|0)!=0){n=v+0|0;o=l+0|0;p=n+60|0;do{c[n>>2]=c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0))}l=l+60|0;if((l|0)==(d|0))break;else v=v+60|0}x=h+(w*60|0)|0}w=x;b:do if((b|0)==(a|0)){y=w;z=d}else{v=w;l=b;r=x;m=d;while(1){if((v|0)==(h|0))break;f=r+-60|0;s=l+-60|0;t=m+-60|0;if(nb[c[e>>2]&31](f,s)|0){n=t+0|0;o=s+0|0;p=n+60|
0;do{c[n>>2]=c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0));A=s;B=r}else{n=t+0|0;o=f+0|0;p=n+60|0;do{c[n>>2]=c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0));A=l;B=f}s=B;if((A|0)==(a|0)){y=s;z=t;break b}else{v=s;l=A;r=B;m=t}}if((l|0)==(a|0)){i=j;return}else{C=m;D=l}do{C=C+-60|0;D=D+-60|0;n=C+0|0;o=D+0|0;p=n+60|0;do{c[n>>2]=c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0))}while((D|0)!=(a|0));i=j;return}while(0);a=y;if((a|0)==(h|0)){i=j;return}else{E=z;F=a}do{E=E+-60|0;F=F+-60|0;n=E+0|0;o=F+0|0;p=n+60|0;do{c[n>>2]=
c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0))}while((F|0)!=(h|0));i=j;return}function Pl(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;h=i;i=i+32|0;j=h;if((e|0)==2){k=b+-20|0;if(!(nb[c[d>>2]&31](k,a)|0)){i=h;return}c[j+0>>2]=c[a+0>>2];c[j+4>>2]=c[a+4>>2];c[j+8>>2]=c[a+8>>2];c[j+12>>2]=c[a+12>>2];c[j+16>>2]=c[a+16>>2];c[a+0>>2]=c[k+0>>2];c[a+4>>2]=c[k+4>>2];c[a+8>>2]=c[k+8>>2];c[a+12>>2]=c[k+12>>2];c[a+16>>2]=c[k+16>>2];c[k+0>>2]=c[j+0>>2];
c[k+4>>2]=c[j+4>>2];c[k+8>>2]=c[j+8>>2];c[k+12>>2]=c[j+12>>2];c[k+16>>2]=c[j+16>>2];i=h;return}else if((e|0)==1|(e|0)==0){i=h;return}else{if((e|0)<129){if((a|0)==(b|0)){i=h;return}k=a+20|0;if((k|0)==(b|0)){i=h;return}else l=k;do{c[j+0>>2]=c[l+0>>2];c[j+4>>2]=c[l+4>>2];c[j+8>>2]=c[l+8>>2];c[j+12>>2]=c[l+12>>2];c[j+16>>2]=c[l+16>>2];a:do if((l|0)==(a|0))m=a;else{k=l;while(1){n=k;k=k+-20|0;if(!(nb[c[d>>2]&31](j,k)|0)){m=n;break a}c[n+0>>2]=c[k+0>>2];c[n+4>>2]=c[k+4>>2];c[n+8>>2]=c[k+8>>2];c[n+12>>2]=
c[k+12>>2];c[n+16>>2]=c[k+16>>2];if((k|0)==(a|0)){m=a;break}}}while(0);c[m+0>>2]=c[j+0>>2];c[m+4>>2]=c[j+4>>2];c[m+8>>2]=c[j+8>>2];c[m+12>>2]=c[j+12>>2];c[m+16>>2]=c[j+16>>2];l=l+20|0}while((l|0)!=(b|0));i=h;return}l=(e|0)/2|0;j=a+(l*20|0)|0;if((e|0)>(g|0)){Pl(a,j,d,l,f,g);m=e-l|0;Pl(j,b,d,m,f,g);Rl(a,j,b,d,l,m,f,g);i=h;return}Ql(a,j,d,l,f);g=f+(l*20|0)|0;Ql(j,b,d,e-l|0,g);l=f+(e*20|0)|0;b:do if((e+1|0)>>>0<3){o=a;p=g}else{b=a;j=f;m=g;while(1){if((m|0)==(l|0))break;if(nb[c[d>>2]&31](m,j)|0){c[b+0>>
2]=c[m+0>>2];c[b+4>>2]=c[m+4>>2];c[b+8>>2]=c[m+8>>2];c[b+12>>2]=c[m+12>>2];c[b+16>>2]=c[m+16>>2];q=m+20|0;r=j}else{c[b+0>>2]=c[j+0>>2];c[b+4>>2]=c[j+4>>2];c[b+8>>2]=c[j+8>>2];c[b+12>>2]=c[j+12>>2];c[b+16>>2]=c[j+16>>2];q=m;r=j+20|0}k=b+20|0;if((r|0)==(g|0)){o=k;p=q;break b}else{b=k;j=r;m=q}}if((j|0)==(g|0)){i=h;return}else{s=j;t=b}while(1){c[t+0>>2]=c[s+0>>2];c[t+4>>2]=c[s+4>>2];c[t+8>>2]=c[s+8>>2];c[t+12>>2]=c[s+12>>2];c[t+16>>2]=c[s+16>>2];s=s+20|0;if((s|0)==(g|0))break;else t=t+20|0}i=h;return}while(0);
if((p|0)==(l|0)){i=h;return}else{u=o;v=p}while(1){c[u+0>>2]=c[v+0>>2];c[u+4>>2]=c[v+4>>2];c[u+8>>2]=c[v+8>>2];c[u+12>>2]=c[v+12>>2];c[u+16>>2]=c[v+16>>2];v=v+20|0;if((v|0)==(l|0))break;else u=u+20|0}i=h;return}}function Ql(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;g=i;if((e|0)==1){if((f|0)==0){i=g;return}c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];i=g;return}else if((e|0)==
0){i=g;return}else if((e|0)==2){h=b+-20|0;j=(f|0)==0;if(nb[c[d>>2]&31](h,a)|0){if(!j){c[f+0>>2]=c[h+0>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2]}k=f+20|0;c[k+0>>2]=c[a+0>>2];c[k+4>>2]=c[a+4>>2];c[k+8>>2]=c[a+8>>2];c[k+12>>2]=c[a+12>>2];c[k+16>>2]=c[a+16>>2];i=g;return}else{if(!j){c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2]}j=f+20|0;c[j+0>>2]=c[h+0>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+
12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];i=g;return}}else{if((e|0)<9){if((a|0)==(b|0)){i=g;return}if((f|0)==0)l=0;else{c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];l=f}h=a+20|0;if((h|0)==(b|0)){i=g;return}else{m=h;n=l}do{l=n;n=n+20|0;if(nb[c[d>>2]&31](m,l)|0){c[n+0>>2]=c[l+0>>2];c[n+4>>2]=c[l+4>>2];c[n+8>>2]=c[l+8>>2];c[n+12>>2]=c[l+12>>2];c[n+16>>2]=c[l+16>>2];a:do if((l|0)==(f|0))o=f;else{h=l;while(1){j=h;h=h+-20|0;if(!(nb[c[d>>2]&31](m,
h)|0)){o=j;break a}c[j+0>>2]=c[h+0>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];if((h|0)==(f|0)){o=f;break}}}while(0);c[o+0>>2]=c[m+0>>2];c[o+4>>2]=c[m+4>>2];c[o+8>>2]=c[m+8>>2];c[o+12>>2]=c[m+12>>2];c[o+16>>2]=c[m+16>>2]}else{c[n+0>>2]=c[m+0>>2];c[n+4>>2]=c[m+4>>2];c[n+8>>2]=c[m+8>>2];c[n+12>>2]=c[m+12>>2];c[n+16>>2]=c[m+16>>2]}m=m+20|0}while((m|0)!=(b|0));i=g;return}m=(e|0)/2|0;n=a+(m*20|0)|0;Pl(a,n,d,m,f,m);o=e-m|0;Pl(n,b,d,o,f+(m*20|0)|0,o);b:do if((e+
1|0)>>>0<3){p=n;q=f}else{o=n;m=a;l=f;while(1){if((o|0)==(b|0))break;h=(l|0)==0;if(nb[c[d>>2]&31](o,m)|0){if(!h){c[l+0>>2]=c[o+0>>2];c[l+4>>2]=c[o+4>>2];c[l+8>>2]=c[o+8>>2];c[l+12>>2]=c[o+12>>2];c[l+16>>2]=c[o+16>>2]}r=m;s=o+20|0}else{if(!h){c[l+0>>2]=c[m+0>>2];c[l+4>>2]=c[m+4>>2];c[l+8>>2]=c[m+8>>2];c[l+12>>2]=c[m+12>>2];c[l+16>>2]=c[m+16>>2]}r=m+20|0;s=o}h=l+20|0;if((r|0)==(n|0)){p=s;q=h;break b}else{o=s;m=r;l=h}}if((m|0)==(n|0)){i=g;return}else{t=m;u=l}while(1){if((u|0)!=0){c[u+0>>2]=c[t+0>>2];
c[u+4>>2]=c[t+4>>2];c[u+8>>2]=c[t+8>>2];c[u+12>>2]=c[t+12>>2];c[u+16>>2]=c[t+16>>2]}t=t+20|0;if((t|0)==(n|0))break;else u=u+20|0}i=g;return}while(0);if((p|0)==(b|0)){i=g;return}else{v=p;w=q}while(1){if((w|0)!=0){c[w+0>>2]=c[v+0>>2];c[w+4>>2]=c[v+4>>2];c[w+8>>2]=c[v+8>>2];c[w+12>>2]=c[v+12>>2];c[w+16>>2]=c[v+16>>2]}v=v+20|0;if((v|0)==(b|0))break;else w=w+20|0}i=g;return}}function Rl(a,b,d,e,f,g,h,j){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;j=j|0;var k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,
w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0;k=i;i=i+48|0;l=k+20|0;m=k;if((g|0)==0){i=k;return}n=a;a=b;b=d;d=f;f=g;a:while(1){g=b;o=a;p=d;q=n;r=f;while(1){if((p|0)==0){s=45;break a}else{t=q;u=p}while(1){if(nb[c[e>>2]&31](o,t)|0)break;v=u+-1|0;if((v|0)==0){s=45;break a}else{t=t+20|0;u=v}}if(!((u|0)>(j|0)&(r|0)>(j|0))){s=8;break a}if((u|0)<(r|0)){v=(r|0)/2|0;w=o+(v*20|0)|0;x=t;y=t;z=(o-x|0)/20|0;b:while(1){A=z;while(1){if((A|0)==0)break b;B=(A|0)/2|0;if(nb[c[e>>
2]&31](w,y+(B*20|0)|0)|0)A=B;else break}y=y+((B+1|0)*20|0)|0;z=A+-1-B|0}C=y;D=w;E=(y-x|0)/20|0;F=v}else{if((u|0)==1){s=17;break a}z=(u|0)/2|0;G=t+(z*20|0)|0;H=o;I=o;J=(g-H|0)/20|0;c:while(1){K=J;while(1){if((K|0)==0)break c;L=(K|0)/2|0;if(nb[c[e>>2]&31](I+(L*20|0)|0,G)|0)break;else K=L}I=I+((L+1|0)*20|0)|0;J=K+-1-L|0}C=G;D=I;E=z;F=(I-H|0)/20|0}p=u-E|0;M=r-F|0;d:do if((C|0)!=(o|0))if((o|0)==(D|0))N=C;else{if((C+20|0)==(o|0)){c[l+0>>2]=c[C+0>>2];c[l+4>>2]=c[C+4>>2];c[l+8>>2]=c[C+8>>2];c[l+12>>2]=c[C+
12>>2];c[l+16>>2]=c[C+16>>2];J=D-o|0;Bn(C|0,o|0,J|0)|0;v=C+(((J|0)/20|0)*20|0)|0;c[v+0>>2]=c[l+0>>2];c[v+4>>2]=c[l+4>>2];c[v+8>>2]=c[l+8>>2];c[v+12>>2]=c[l+12>>2];c[v+16>>2]=c[l+16>>2];N=v;break}if((o+20|0)==(D|0)){v=D+-20|0;c[l+0>>2]=c[v+0>>2];c[l+4>>2]=c[v+4>>2];c[l+8>>2]=c[v+8>>2];c[l+12>>2]=c[v+12>>2];c[l+16>>2]=c[v+16>>2];J=v-C|0;v=D+(((J|0)/-20|0)*20|0)|0;Bn(v|0,C|0,J|0)|0;c[C+0>>2]=c[l+0>>2];c[C+4>>2]=c[l+4>>2];c[C+8>>2]=c[l+8>>2];c[C+12>>2]=c[l+12>>2];c[C+16>>2]=c[l+16>>2];N=v;break}v=o;J=
(v-C|0)/20|0;x=D;y=(x-v|0)/20|0;if((J|0)==(y|0)){v=C;w=o;while(1){c[l+0>>2]=c[v+0>>2];c[l+4>>2]=c[v+4>>2];c[l+8>>2]=c[v+8>>2];c[l+12>>2]=c[v+12>>2];c[l+16>>2]=c[v+16>>2];c[v+0>>2]=c[w+0>>2];c[v+4>>2]=c[w+4>>2];c[v+8>>2]=c[w+8>>2];c[v+12>>2]=c[w+12>>2];c[v+16>>2]=c[w+16>>2];c[w+0>>2]=c[l+0>>2];c[w+4>>2]=c[l+4>>2];c[w+8>>2]=c[l+8>>2];c[w+12>>2]=c[l+12>>2];c[w+16>>2]=c[l+16>>2];v=v+20|0;if((v|0)==(o|0)){N=o;break d}else w=w+20|0}}else{O=J;P=y}while(1){w=(O|0)%(P|0)|0;if((w|0)==0)break;else{v=P;P=w;O=
v}}if((P|0)!=0){v=J+-1|0;w=C+(P*20|0)|0;do{K=w;w=w+-20|0;c[m+0>>2]=c[w+0>>2];c[m+4>>2]=c[w+4>>2];c[m+8>>2]=c[w+8>>2];c[m+12>>2]=c[w+12>>2];c[m+16>>2]=c[w+16>>2];A=w;Q=K+(v*20|0)|0;while(1){c[A+0>>2]=c[Q+0>>2];c[A+4>>2]=c[Q+4>>2];c[A+8>>2]=c[Q+8>>2];c[A+12>>2]=c[Q+12>>2];c[A+16>>2]=c[Q+16>>2];K=(x-Q|0)/20|0;if((J|0)<(K|0))R=Q+(J*20|0)|0;else R=C+((J-K|0)*20|0)|0;if((R|0)==(w|0))break;else{K=Q;Q=R;A=K}}c[Q+0>>2]=c[m+0>>2];c[Q+4>>2]=c[m+4>>2];c[Q+8>>2]=c[m+8>>2];c[Q+12>>2]=c[m+12>>2];c[Q+16>>2]=c[m+
16>>2]}while((w|0)!=(C|0))}N=C+(y*20|0)|0}else N=D;while(0);if((F+E|0)>=(M+p|0))break;Rl(t,C,N,e,E,F,h,j);if((r|0)==(F|0)){s=45;break a}else{o=D;q=N;r=M}}Rl(N,D,b,e,p,M,h,j);if((F|0)==0){s=45;break}else{n=t;a=C;b=N;d=E;f=F}}if((s|0)==8){Sl(t,o,b,e,u,r,h);i=k;return}else if((s|0)==17){c[l+0>>2]=c[t+0>>2];c[l+4>>2]=c[t+4>>2];c[l+8>>2]=c[t+8>>2];c[l+12>>2]=c[t+12>>2];c[l+16>>2]=c[t+16>>2];c[t+0>>2]=c[o+0>>2];c[t+4>>2]=c[o+4>>2];c[t+8>>2]=c[o+8>>2];c[t+12>>2]=c[o+12>>2];c[t+16>>2]=c[o+16>>2];c[o+0>>2]=
c[l+0>>2];c[o+4>>2]=c[l+4>>2];c[o+8>>2]=c[l+8>>2];c[o+12>>2]=c[l+12>>2];c[o+16>>2]=c[l+16>>2];i=k;return}else if((s|0)==45){i=k;return}}function Sl(a,b,d,e,f,g,h){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;j=i;k=a;l=b;if((f|0)<=(g|0)){a:do if((a|0)!=(b|0)){g=(((b+-20+(0-k)|0)>>>0)/20|0)+1|0;f=a;m=h;while(1){if((m|0)!=0){c[m+0>>2]=c[f+0>>2];c[m+4>>2]=c[f+4>>2];c[m+8>>2]=c[f+8>>2];c[m+12>>2]=c[f+12>>2];c[m+16>>2]=c[f+
16>>2]}f=f+20|0;if((f|0)==(b|0))break;else m=m+20|0}m=h+(g*20|0)|0;if((m|0)!=(h|0)){f=a;n=b;o=h;while(1){if((n|0)==(d|0))break;if(nb[c[e>>2]&31](n,o)|0){c[f+0>>2]=c[n+0>>2];c[f+4>>2]=c[n+4>>2];c[f+8>>2]=c[n+8>>2];c[f+12>>2]=c[n+12>>2];c[f+16>>2]=c[n+16>>2];p=o;q=n+20|0}else{c[f+0>>2]=c[o+0>>2];c[f+4>>2]=c[o+4>>2];c[f+8>>2]=c[o+8>>2];c[f+12>>2]=c[o+12>>2];c[f+16>>2]=c[o+16>>2];p=o+20|0;q=n}r=f+20|0;if((p|0)==(m|0)){s=r;t=q;break a}else{f=r;n=q;o=p}}Bn(f|0,o|0,m-o|0)|0;i=j;return}else{s=a;t=b}}else{s=
a;t=b}while(0);Bn(s|0,t|0,d-t|0)|0;i=j;return}if((b|0)==(d|0))u=h;else{t=(((d+-20+(0-l)|0)>>>0)/20|0)+1|0;l=b;s=h;while(1){if((s|0)!=0){c[s+0>>2]=c[l+0>>2];c[s+4>>2]=c[l+4>>2];c[s+8>>2]=c[l+8>>2];c[s+12>>2]=c[l+12>>2];c[s+16>>2]=c[l+16>>2]}l=l+20|0;if((l|0)==(d|0))break;else s=s+20|0}u=h+(t*20|0)|0}t=u;b:do if((b|0)==(a|0)){v=t;w=d}else{s=t;l=b;p=u;q=d;while(1){if((s|0)==(h|0))break;k=p+-20|0;n=l+-20|0;g=q+-20|0;if(nb[c[e>>2]&31](k,n)|0){c[g+0>>2]=c[n+0>>2];c[g+4>>2]=c[n+4>>2];c[g+8>>2]=c[n+8>>2];
c[g+12>>2]=c[n+12>>2];c[g+16>>2]=c[n+16>>2];x=n;y=p}else{c[g+0>>2]=c[k+0>>2];c[g+4>>2]=c[k+4>>2];c[g+8>>2]=c[k+8>>2];c[g+12>>2]=c[k+12>>2];c[g+16>>2]=c[k+16>>2];x=l;y=k}k=y;if((x|0)==(a|0)){v=k;w=g;break b}else{s=k;l=x;p=y;q=g}}if((l|0)==(a|0)){i=j;return}else{z=q;A=l}do{z=z+-20|0;A=A+-20|0;c[z+0>>2]=c[A+0>>2];c[z+4>>2]=c[A+4>>2];c[z+8>>2]=c[A+8>>2];c[z+12>>2]=c[A+12>>2];c[z+16>>2]=c[A+16>>2]}while((A|0)!=(a|0));i=j;return}while(0);a=v;if((a|0)==(h|0)){i=j;return}else{B=w;C=a}do{B=B+-20|0;C=C+-20|
0;c[B+0>>2]=c[C+0>>2];c[B+4>>2]=c[C+4>>2];c[B+8>>2]=c[C+8>>2];c[B+12>>2]=c[C+12>>2];c[B+16>>2]=c[C+16>>2]}while((C|0)!=(h|0));i=j;return}function Tl(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0;b=i;d=a+4|0;e=c[d>>2]|0;if((e|0)!=(a|0)){f=e;do{e=Sm(f)|0;g=c[e>>2]|0;if((g|0)!=0){h=0;j=e+32|0;while(1){k=j+4|0;c[(c[j>>2]|0)+4>>2]=c[k>>2];c[c[k>>2]>>2]=c[j>>2];c[k>>2]=j;c[j>>2]=j;h=h+1|0;if((h|0)==(g|0))break;else j=j+12|0}}Um(a,e);f=c[d>>2]|0}while((f|0)!=(a|0))}f=a+12|0;j=a+20|0;g=a+24|0;c[(c[j>>2]|0)+
4>>2]=c[g>>2];c[c[g>>2]>>2]=c[j>>2];c[g>>2]=j;c[j>>2]=j;j=a+16|0;c[(c[f>>2]|0)+4>>2]=c[j>>2];c[c[j>>2]>>2]=c[f>>2];c[j>>2]=f;c[f>>2]=f;Vm(a);c[(c[a>>2]|0)+4>>2]=c[d>>2];c[c[d>>2]>>2]=c[a>>2];c[d>>2]=a;c[a>>2]=a;i=b;return}function Ul(a){a=a|0;return}function Vl(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Wl(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;e=i;i=i+48|0;f=e+24|0;g=e;if((a[d+38>>0]|0)!=0){i=e;return 1}h=c[d+12>>2]|0;j=bb[c[(c[h>>2]|0)+12>>2]&
7](h)|0;if((j|0)<=0){i=e;return 1}h=d+24|0;k=b+4|0;l=g+16|0;m=g+20|0;n=g+4|0;o=0;do{p=(c[h>>2]|0)+(o*28|0)|0;c[f+0>>2]=c[p+0>>2];c[f+4>>2]=c[p+4>>2];c[f+8>>2]=c[p+8>>2];c[f+12>>2]=c[p+12>>2];Nk(g,c[k>>2]|0,f);p=c[l>>2]|0;q=c[m>>2]|0;a:do if(p>>>0<q>>>0){r=c[g>>2]|0;s=c[n>>2]|0;t=p;while(1){u=c[t+4>>2]&1048575;v=t;t=t+8|0;c[l>>2]=t;if(u>>>0<r>>>0|u>>>0>s>>>0)if(t>>>0<q>>>0){t=t;continue}else break;u=c[v>>2]|0;if(!((u|0)>-1))break a;pb[c[(c[b>>2]|0)+20>>2]&31](b,d,o,u);if(!(t>>>0<q>>>0))break}}while(0);
o=o+1|0}while((o|0)!=(j|0));i=e;return 1}function Xl(a,b){a=a|0;b=b|0;return 0}function Yl(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0;h=i;i=i+48|0;j=h+24|0;l=h;m=c[d+8>>2]|0;n=b+4|0;o=c[n>>2]|0;p=(c[o+96>>2]|0)+(f<<3)|0;q=c[p>>2]|0;r=c[p+4>>2]|0;s=(c[k>>2]=q,+g[k>>2]);t=(c[k>>2]=r,+g[k>>2]);p=(c[o+104>>2]|0)+(f<<3)|0;u=+g[p>>2];v=+g[p+4>>2];if((c[o+24>>2]|0)==0){w=s-+g[m+28>>2];x=t-+g[m+32>>2];
y=+g[m+40>>2];z=+g[m+36>>2];A=w*y+x*z;B=y*x-w*z;o=c[d+12>>2]|0;if((c[o+4>>2]|0)==0){w=+g[m+44>>2];x=A-w;C=+g[m+48>>2];D=B-C;E=x*y-D*z;F=y*D+x*z;z=+g[m+24>>2];x=+g[m+20>>2];G=z;H=w+(z*E+x*F);I=x;J=C+(z*F-E*x)}else{G=+g[m+24>>2];H=A;I=+g[m+20>>2];J=B}B=+(+g[m+12>>2]+(H*G-J*I));A=+(J*G+H*I+ +g[m+16>>2]);p=l;g[p>>2]=B;g[p+4>>2]=A;K=o}else{o=l;c[o>>2]=q;c[o+4>>2]=r;K=c[d+12>>2]|0}d=l+8|0;A=+g[b+8>>2];B=+(s+u*A);I=+(t+v*A);r=d;g[r>>2]=B;g[r+4>>2]=I;g[l+16>>2]=1;if(!(ob[c[(c[K>>2]|0)+24>>2]&15](K,j,l,m+
12|0,e)|0)){i=h;return}e=j;I=+g[e>>2];B=+g[j+8>>2];A=1-B;j=b+12|0;H=+g[j>>2];G=H*(I*.004999999888241291+(+g[l>>2]*A+B*+g[d>>2])-s);s=H*(+g[e+4>>2]*.004999999888241291+(A*+g[l+4>>2]+B*+g[l+12>>2])-t);t=+G;B=+s;l=(c[(c[n>>2]|0)+104>>2]|0)+(f<<3)|0;g[l>>2]=t;g[l+4>>2]=B;l=c[n>>2]|0;B=+g[l+32>>2]*.75;t=+g[j>>2]*B*+g[l+320>>2]*B;B=(u-G)*t;G=(v-s)*t;if(!(B!=0|G!=0)){i=h;return}if((c[(c[l+88>>2]|0)+(f<<2)>>2]&4|0)!=0){i=h;return}j=l+21|0;n=l+112|0;if((a[j>>0]|0)==0){xn(c[n>>2]|0,0,c[l+44>>2]<<3|0)|0;a[j>>
0]=1}j=c[n>>2]|0;n=j+(f<<3)|0;g[n>>2]=B+ +g[n>>2];n=j+(f<<3)+4|0;g[n>>2]=G+ +g[n>>2];i=h;return}function Zl(a){a=a|0;return}function _l(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function $l(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;f=i;i=i+32|0;h=f;j=f+16|0;k=f+8|0;l=a+4|0;m=(c[(c[l>>2]|0)+96>>2]|0)+(e<<3)|0;n=c[m+4>>2]|0;o=h;c[o>>2]=c[m>>2];c[o+4>>2]=n;n=c[b+12>>2]|0;o=b+8|0;mb[c[(c[n>>2]|0)+20>>2]&7](n,(c[o>>2]|0)+12|
0,h,j,k,d);d=c[l>>2]|0;if(!(+g[j>>2]<+g[d+32>>2])){i=f;return}n=c[a+8>>2]|0;if(((n|0)!=0?(c[(c[d+88>>2]|0)+(e<<2)>>2]&65536|0)!=0:0)?!(lb[c[(c[n>>2]|0)+12>>2]&7](n,b,d,e)|0):0){i=f;return}d=c[o>>2]|0;o=d+60|0;p=+g[o>>2];q=+g[d+132>>2];r=+g[d+44>>2];s=+g[d+48>>2];t=q*(r*r+s*s);s=+g[d+140>>2]+t-t;if(q>0)u=1/q;else u=0;if(s>0)v=1/s;else v=0;n=c[l>>2]|0;if((c[(c[n+88>>2]|0)+(e<<2)>>2]&4|0)==0){s=+g[n+36>>2]*1.3333333730697632;w=s*+g[n+28>>2]*s}else w=0;a=k+4|0;s=(+g[h>>2]-p)*+g[a>>2]-(+g[h+4>>2]-+g[o+
4>>2])*+g[k>>2];p=u+w+s*v*s;o=n+232|0;h=n+236|0;m=c[h>>2]|0;x=n+240|0;y=c[x>>2]|0;if((m|0)>=(y|0)?(z=(y|0)==0?256:y<<1,(y|0)<(z|0)):0){y=n+244|0;n=Em(c[y>>2]|0,z*28|0)|0;A=c[o>>2]|0;if((A|0)!=0){An(n|0,A|0,(c[h>>2]|0)*28|0)|0;Fm(c[y>>2]|0,c[o>>2]|0,(c[x>>2]|0)*28|0)}c[x>>2]=z;c[o>>2]=n;B=c[h>>2]|0}else B=m;c[h>>2]=B+1;h=c[o>>2]|0;c[h+(B*28|0)>>2]=e;c[h+(B*28|0)+4>>2]=d;c[h+(B*28|0)+8>>2]=b;g[h+(B*28|0)+12>>2]=1-+g[j>>2]*+g[(c[l>>2]|0)+36>>2];s=+-+g[k>>2];v=+-+g[a>>2];a=h+(B*28|0)+16|0;g[a>>2]=s;g[a+
4>>2]=v;if(p>0)C=1/p;else C=0;g[h+(B*28|0)+24>>2]=C;Tk(c[l>>2]|0,e);i=f;return}function am(a){a=a|0;return}function bm(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function sj(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;b=i;d=c[a+102960>>2]|0;if((d|0)!=0){e=d;do{d=e;e=c[e+112>>2]|0;f=c[d+116>>2]|0;while(1){if((f|0)==0)break;d=c[f+4>>2]|0;c[f+28>>2]=0;nj(f,a);f=d}}while((e|0)!=0)}e=a+102968|0;f=c[e>>2]|0;if((f|0)==0){g=a+102880|0;Ne(g);h=a+76|0;Xm(h);Dm(a);i=b;return}d=a+102876|0;j=f;while(1){if((c[d>>
2]&2|0)==0){f=j+404|0;k=c[f>>2]|0;l=j+408|0;if((k|0)!=0)c[k+408>>2]=c[l>>2];k=c[l>>2]|0;if((k|0)!=0)c[k+404>>2]=c[f>>2];if((c[e>>2]|0)==(j|0))c[e>>2]=c[l>>2];sk(j);Fm(a,j,416);m=c[e>>2]|0}else m=j;if((m|0)==0)break;else j=m}g=a+102880|0;Ne(g);h=a+76|0;Xm(h);Dm(a);i=b;return}function tj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;if((c[a+102876>>2]&2|0)!=0){i=d;return}e=b+404|0;f=c[e>>2]|0;g=b+408|0;if((f|0)!=0)c[f+408>>2]=c[g>>2];f=c[g>>2]|0;if((f|0)!=0)c[f+404>>2]=c[e>>2];e=a+102968|0;if((c[e>>2]|0)==
(b|0))c[e>>2]=c[g>>2];sk(b);Fm(a,b,416);i=d;return}function uj(a,b){a=a|0;b=b|0;c[a+102952>>2]=b;return}function vj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;if((c[a+102876>>2]&2|0)!=0){e=0;i=d;return e|0}f=Em(a,168)|0;if((f|0)==0)g=0;else{Hj(f,b,a);g=f}c[g+108>>2]=0;f=a+102960|0;c[g+112>>2]=c[f>>2];b=c[f>>2]|0;if((b|0)!=0)c[b+108>>2]=g;c[f>>2]=g;f=a+102972|0;c[f>>2]=(c[f>>2]|0)+1;e=g;i=d;return e|0}function wj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;d=i;if((c[a+102876>>2]&2|0)!=0){i=
d;return}e=b+124|0;f=c[e>>2]|0;if((f|0)!=0){g=a+102992|0;h=f;do{f=h;h=c[h+12>>2]|0;j=c[g>>2]|0;if((j|0)==0)k=f+4|0;else{l=f+4|0;gb[c[(c[j>>2]|0)+8>>2]&63](j,c[l>>2]|0);k=l}xj(a,c[k>>2]|0);c[e>>2]=h}while((h|0)!=0)}c[e>>2]=0;e=b+128|0;h=c[e>>2]|0;if((h|0)!=0){k=a+102880|0;g=h;do{h=g;g=c[g+12>>2]|0;Tj(k,c[h+4>>2]|0)}while((g|0)!=0)}c[e>>2]=0;e=b+116|0;g=c[e>>2]|0;if((g|0)==0)m=b+120|0;else{k=a+102992|0;h=a+102880|0;l=b+120|0;j=g;do{g=j;j=c[j+4>>2]|0;f=c[k>>2]|0;if((f|0)!=0)gb[c[(c[f>>2]|0)+12>>2]&63](f,
g);pj(g,h);nj(g,a);Fm(a,g,44);c[e>>2]=j;c[l>>2]=(c[l>>2]|0)+-1}while((j|0)!=0);m=l}c[e>>2]=0;c[m>>2]=0;m=b+108|0;e=c[m>>2]|0;l=b+112|0;if((e|0)!=0)c[e+112>>2]=c[l>>2];e=c[l>>2]|0;if((e|0)!=0)c[e+108>>2]=c[m>>2];m=a+102960|0;if((c[m>>2]|0)==(b|0))c[m>>2]=c[l>>2];l=a+102972|0;c[l>>2]=(c[l>>2]|0)+-1;Ij(b);Fm(a,b,168);i=d;return}function xj(d,f){d=d|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;h=i;if((c[d+102876>>2]&2|0)!=0){i=h;return}j=a[f+61>>0]|0;k=f+8|0;l=c[k>>2]|0;m=f+12|0;if((l|0)!=0)c[l+12>>2]=
c[m>>2];l=c[m>>2]|0;if((l|0)!=0)c[l+8>>2]=c[k>>2];k=d+102964|0;if((c[k>>2]|0)==(f|0))c[k>>2]=c[m>>2];m=c[f+48>>2]|0;k=c[f+52>>2]|0;l=m+4|0;n=e[l>>1]|0;if((n&2|0)==0){b[l>>1]=n|2;g[m+160>>2]=0}n=k+4|0;l=e[n>>1]|0;if((l&2|0)==0){b[n>>1]=l|2;g[k+160>>2]=0}l=f+24|0;n=c[l>>2]|0;o=f+28|0;if((n|0)!=0)c[n+12>>2]=c[o>>2];n=c[o>>2]|0;if((n|0)!=0)c[n+8>>2]=c[l>>2];n=m+124|0;if((f+16|0)==(c[n>>2]|0))c[n>>2]=c[o>>2];c[l>>2]=0;c[o>>2]=0;o=f+40|0;l=c[o>>2]|0;n=f+44|0;if((l|0)!=0)c[l+12>>2]=c[n>>2];l=c[n>>2]|0;if((l|
0)!=0)c[l+8>>2]=c[o>>2];l=k+124|0;if((f+32|0)==(c[l>>2]|0))c[l>>2]=c[n>>2];c[o>>2]=0;c[n>>2]=0;uh(f,d);f=d+102976|0;c[f>>2]=(c[f>>2]|0)+-1;if(!(j<<24>>24==0)){i=h;return}j=c[k+128>>2]|0;if((j|0)==0){i=h;return}else p=j;do{if((c[p>>2]|0)==(m|0)){j=(c[p+4>>2]|0)+4|0;c[j>>2]=c[j>>2]|8}p=c[p+12>>2]|0}while((p|0)!=0);i=h;return}function yj(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;e=i;if((c[b+102876>>2]&2|0)!=0){f=0;i=e;return f|0}g=th(d,b)|0;c[g+8>>2]=0;h=b+102964|0;c[g+12>>2]=
c[h>>2];j=c[h>>2]|0;if((j|0)!=0)c[j+8>>2]=g;c[h>>2]=g;h=b+102976|0;c[h>>2]=(c[h>>2]|0)+1;h=g+16|0;c[g+20>>2]=g;b=g+52|0;c[h>>2]=c[b>>2];c[g+24>>2]=0;j=g+48|0;k=c[j>>2]|0;l=k+124|0;c[g+28>>2]=c[l>>2];m=c[l>>2]|0;if((m|0)==0)n=k;else{c[m+8>>2]=h;n=c[j>>2]|0}c[n+124>>2]=h;h=g+32|0;c[g+36>>2]=g;c[h>>2]=c[j>>2];c[g+40>>2]=0;j=c[b>>2]|0;n=j+124|0;c[g+44>>2]=c[n>>2];m=c[n>>2]|0;if((m|0)==0)o=j;else{c[m+8>>2]=h;o=c[b>>2]|0}c[o+124>>2]=h;h=c[d+8>>2]|0;if((a[d+16>>0]|0)!=0){f=g;i=e;return f|0}o=c[(c[d+12>>
2]|0)+128>>2]|0;if((o|0)==0){f=g;i=e;return f|0}else p=o;do{if((c[p>>2]|0)==(h|0)){o=(c[p+4>>2]|0)+4|0;c[o>>2]=c[o>>2]|8}p=c[p+12>>2]|0}while((p|0)!=0);f=g;i=e;return f|0}function zj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;if((c[a+102876>>2]&2|0)!=0){e=0;i=d;return e|0}f=Em(a,416)|0;if((f|0)==0)g=0;else{rk(f,b,a);g=f}c[g+404>>2]=0;f=a+102968|0;c[g+408>>2]=c[f>>2];a=c[f>>2]|0;if((a|0)!=0)c[a+404>>2]=g;c[f>>2]=g;e=g;i=d;return e|0}function Aj(d,f){d=d|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=
0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0;h=i;i=i+96|0;j=h+40|0;k=h+8|0;l=h;m=d+102960|0;n=c[m>>2]|0;if((n|0)!=0){o=n;do{n=o+28|0;p=o+12|0;c[n+0>>2]=c[p+0>>2];c[n+4>>2]=c[p+4>>2];c[n+8>>2]=c[p+8>>2];c[n+12>>2]=c[p+12>>2];o=c[o+112>>2]|0}while((o|0)!=0)}o=d+103020|0;g[o>>2]=0;p=d+103024|0;g[p>>2]=0;n=d+103028|0;g[n>>2]=0;q=d+102972|0;r=d+102880|0;s=d+76|0;mf(j,c[q>>2]|0,c[d+102944>>2]|0,c[d+102976>>2]|0,s,c[d+
102952>>2]|0);t=c[m>>2]|0;if((t|0)!=0){u=t;do{t=u+4|0;b[t>>1]=b[t>>1]&65534;u=c[u+112>>2]|0}while((u|0)!=0)}u=c[d+102940>>2]|0;if((u|0)!=0){t=u;do{u=t+4|0;c[u>>2]=c[u>>2]&-2;t=c[t+12>>2]|0}while((t|0)!=0)}t=c[d+102964>>2]|0;if((t|0)!=0){u=t;do{a[u+60>>0]=0;u=c[u+12>>2]|0}while((u|0)!=0)}u=Ym(s,c[q>>2]<<2)|0;q=c[m>>2]|0;if((q|0)!=0){t=j+28|0;v=j+36|0;w=j+32|0;x=j+8|0;y=j+16|0;z=j+12|0;A=d+102980|0;B=d+102988|0;C=k+12|0;D=k+16|0;E=k+20|0;F=q;do{q=F+4|0;G=b[q>>1]|0;if((G&35)==34?(c[F>>2]|0)!=0:0){c[t>>
2]=0;c[v>>2]=0;c[w>>2]=0;c[u>>2]=F;b[q>>1]=G&65535|1;G=0;q=1;while(1){H=q+-1|0;I=c[u+(H<<2)>>2]|0;c[I+8>>2]=G;J=c[t>>2]|0;c[(c[x>>2]|0)+(J<<2)>>2]=I;c[t>>2]=J+1;J=I+4|0;K=e[J>>1]|0;if((K&2|0)==0){b[J>>1]=K|2;g[I+160>>2]=0}if((c[I>>2]|0)!=0){K=c[I+128>>2]|0;if((K|0)==0)L=H;else{J=K;K=H;while(1){M=c[J+4>>2]|0;N=M+4|0;do if((c[N>>2]&7|0)==6?(a[(c[M+48>>2]|0)+38>>0]|0)==0:0){if((a[(c[M+52>>2]|0)+38>>0]|0)!=0){O=K;break}P=c[v>>2]|0;c[v>>2]=P+1;c[(c[z>>2]|0)+(P<<2)>>2]=M;c[N>>2]=c[N>>2]|1;P=c[J>>2]|0;Q=
P+4|0;R=b[Q>>1]|0;if(!((R&1)==0)){O=K;break}c[u+(K<<2)>>2]=P;b[Q>>1]=R&65535|1;O=K+1|0}else O=K;while(0);J=c[J+12>>2]|0;if((J|0)==0){L=O;break}else K=O}}K=c[I+124>>2]|0;if((K|0)==0)S=L;else{J=K;K=L;while(1){N=J+4|0;M=c[N>>2]|0;do if((a[M+60>>0]|0)==0?(R=c[J>>2]|0,Q=R+4|0,P=b[Q>>1]|0,!((P&32)==0)):0){T=c[w>>2]|0;c[w>>2]=T+1;c[(c[y>>2]|0)+(T<<2)>>2]=M;a[(c[N>>2]|0)+60>>0]=1;if(!((P&1)==0)){U=K;break}c[u+(K<<2)>>2]=R;b[Q>>1]=P&65535|1;U=K+1|0}else U=K;while(0);J=c[J+12>>2]|0;if((J|0)==0){S=U;break}else K=
U}}}else S=H;if((S|0)<=0)break;G=c[t>>2]|0;q=S}of(j,k,f,A,(a[B>>0]|0)!=0);g[o>>2]=+g[C>>2]+ +g[o>>2];g[p>>2]=+g[D>>2]+ +g[p>>2];g[n>>2]=+g[E>>2]+ +g[n>>2];q=c[t>>2]|0;if((q|0)>0){G=c[x>>2]|0;K=0;do{J=c[G+(K<<2)>>2]|0;if((c[J>>2]|0)==0){I=J+4|0;b[I>>1]=b[I>>1]&65534}K=K+1|0}while((K|0)<(q|0))}}F=c[F+112>>2]|0}while((F|0)!=0)}_m(s,u);Km(l);u=c[m>>2]|0;if((u|0)==0){Vj(r);V=+Mm(l);W=d+103032|0;g[W>>2]=V;nf(j);i=h;return}else X=u;do{if(!((b[X+4>>1]&1)==0)?(c[X>>2]|0)!=0:0)Lj(X);X=c[X+112>>2]|0}while((X|
0)!=0);Vj(r);V=+Mm(l);W=d+103032|0;g[W>>2]=V;nf(j);i=h;return}function Bj(d,f){d=d|0;f=f|0;var h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,
Va=0,Wa=0,Xa=0,Ya=0,Za=0;h=i;i=i+336|0;j=h+284|0;l=h+152|0;m=h+144|0;n=h+108|0;o=h+72|0;p=h+64|0;q=h+28|0;r=h;s=d+102880|0;t=d+102952|0;mf(j,64,32,0,d+76|0,c[t>>2]|0);u=d+103007|0;if((a[u>>0]|0)!=0){v=c[d+102960>>2]|0;if((v|0)!=0){w=v;do{v=w+4|0;b[v>>1]=b[v>>1]&65534;g[w+76>>2]=0;w=c[w+112>>2]|0}while((w|0)!=0)}w=d+102940|0;v=c[w>>2]|0;if((v|0)==0)x=w;else{y=v;do{v=y+4|0;c[v>>2]=c[v>>2]&-34;c[y+128>>2]=0;g[y+132>>2]=1;y=c[y+12>>2]|0}while((y|0)!=0);x=w}}else x=d+102940|0;w=j+28|0;y=j+36|0;v=j+32|
0;z=j+8|0;A=j+12|0;B=p+4|0;C=j+40|0;D=j+44|0;E=r+4|0;F=r+8|0;G=r+16|0;H=f+12|0;I=r+12|0;J=f+20|0;K=r+20|0;L=r+24|0;M=d+103006|0;d=l+16|0;N=l+20|0;O=l+24|0;P=l+44|0;Q=l+48|0;R=l+52|0;U=l+28|0;V=l+56|0;W=l+92|0;X=l+128|0;Y=m+4|0;while(1){Z=c[x>>2]|0;if((Z|0)==0){_=28;break}else{$=Z;aa=1;ba=0}while(1){Z=$+4|0;ca=c[Z>>2]|0;do if((ca&4|0)!=0?(c[$+128>>2]|0)<=8:0){if((ca&32|0)==0){da=c[$+48>>2]|0;ea=c[$+52>>2]|0;if((a[da+38>>0]|0)!=0){fa=aa;ga=ba;break}if((a[ea+38>>0]|0)!=0){fa=aa;ga=ba;break}ha=c[da+8>>
2]|0;ia=c[ea+8>>2]|0;ja=c[ha>>2]|0;ka=c[ia>>2]|0;la=b[ha+4>>1]|0;ma=b[ia+4>>1]|0;if(!((la&2)!=0&(ja|0)!=0|(ma&2)!=0&(ka|0)!=0)){fa=aa;ga=ba;break}if(!((la&8)!=0|(ja|0)!=2|((ma&8)!=0|(ka|0)!=2))){fa=aa;ga=ba;break}ka=ha+44|0;ma=ha+76|0;na=+g[ma>>2];ja=ia+44|0;la=ia+76|0;oa=+g[la>>2];if(!(na<oa))if(oa<na){pa=(na-oa)/(1-oa);qa=ia+52|0;ra=+g[qa>>2];sa=ia+56|0;ta=+g[sa>>2];ua=pa*(+g[ia+64>>2]-ta);g[qa>>2]=ra+pa*(+g[ia+60>>2]-ra);g[sa>>2]=ta+ua;sa=ia+68|0;ua=+g[sa>>2];g[sa>>2]=ua+pa*(+g[ia+72>>2]-ua);g[la>>
2]=na;va=na}else va=na;else{ua=(oa-na)/(1-na);la=ha+52|0;na=+g[la>>2];ia=ha+56|0;pa=+g[ia>>2];ta=ua*(+g[ha+64>>2]-pa);g[la>>2]=na+ua*(+g[ha+60>>2]-na);g[ia>>2]=pa+ta;ia=ha+68|0;ta=+g[ia>>2];g[ia>>2]=ta+ua*(+g[ha+72>>2]-ta);g[ma>>2]=oa;va=oa}ma=c[$+56>>2]|0;ha=c[$+60>>2]|0;c[d>>2]=0;c[N>>2]=0;g[O>>2]=0;c[P>>2]=0;c[Q>>2]=0;g[R>>2]=0;be(l,c[da+12>>2]|0,ma);be(U,c[ea+12>>2]|0,ha);wa=V+0|0;xa=ka+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+4|0}while((wa|0)<(ya|0));wa=W+0|0;xa=ja+0|0;ya=wa+36|0;
do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+4|0}while((wa|0)<(ya|0));g[X>>2]=1;Zd(m,l);if((c[m>>2]|0)==3){oa=va+(1-va)*+g[Y>>2];za=oa<1?oa:1}else za=1;g[$+132>>2]=za;c[Z>>2]=c[Z>>2]|32;Aa=za}else Aa=+g[$+132>>2];if(Aa<aa){fa=Aa;ga=$}else{fa=aa;ga=ba}}else{fa=aa;ga=ba}while(0);$=c[$+12>>2]|0;if(($|0)==0)break;else{aa=fa;ba=ga}}if((ga|0)==0|fa>.9999988079071045){_=28;break}Z=c[(c[ga+48>>2]|0)+8>>2]|0;ca=c[(c[ga+52>>2]|0)+8>>2]|0;ja=Z+44|0;wa=n+0|0;xa=ja+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+
4|0}while((wa|0)<(ya|0));ka=ca+44|0;wa=o+0|0;xa=ka+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+4|0}while((wa|0)<(ya|0));ha=Z+76|0;oa=+g[ha>>2];ta=(fa-oa)/(1-oa);ea=Z+60|0;ma=Z+52|0;oa=+g[ma>>2];da=Z+64|0;ia=Z+56|0;ua=+g[ia>>2];pa=ta*(+g[da>>2]-ua);g[ma>>2]=oa+ta*(+g[ea>>2]-oa);g[ia>>2]=ua+pa;ia=Z+72|0;ma=Z+68|0;pa=+g[ma>>2];ua=pa+ta*(+g[ia>>2]-pa);g[ma>>2]=ua;g[ha>>2]=fa;ha=Z+52|0;ma=c[ha>>2]|0;la=c[ha+4>>2]|0;ha=Z+60|0;c[ha>>2]=ma;c[ha+4>>2]=la;g[ia>>2]=ua;pa=+T(+ua);ha=Z+20|0;g[ha>>2]=pa;
ta=+S(+ua);sa=Z+24|0;g[sa>>2]=ta;qa=Z+12|0;Ba=Z+44|0;ua=+g[Ba>>2];Ca=Z+48|0;oa=+g[Ca>>2];na=(c[k>>2]=ma,+g[k>>2])-(ta*ua-pa*oa);ra=(c[k>>2]=la,+g[k>>2])-(pa*ua+ta*oa);oa=+na;na=+ra;la=qa;g[la>>2]=oa;g[la+4>>2]=na;la=ca+76|0;na=+g[la>>2];oa=(fa-na)/(1-na);ma=ca+60|0;Da=ca+52|0;na=+g[Da>>2];Ea=ca+64|0;Fa=ca+56|0;ra=+g[Fa>>2];ta=oa*(+g[Ea>>2]-ra);g[Da>>2]=na+oa*(+g[ma>>2]-na);g[Fa>>2]=ra+ta;Fa=ca+72|0;Da=ca+68|0;ta=+g[Da>>2];ra=ta+oa*(+g[Fa>>2]-ta);g[Da>>2]=ra;g[la>>2]=fa;la=ca+52|0;Da=c[la>>2]|0;Ga=
c[la+4>>2]|0;la=ca+60|0;c[la>>2]=Da;c[la+4>>2]=Ga;g[Fa>>2]=ra;ta=+T(+ra);la=ca+20|0;g[la>>2]=ta;oa=+S(+ra);Ha=ca+24|0;g[Ha>>2]=oa;Ia=ca+12|0;Ja=ca+44|0;ra=+g[Ja>>2];Ka=ca+48|0;na=+g[Ka>>2];ua=(c[k>>2]=Da,+g[k>>2])-(oa*ra-ta*na);pa=(c[k>>2]=Ga,+g[k>>2])-(ta*ra+oa*na);na=+ua;ua=+pa;Ga=Ia;g[Ga>>2]=na;g[Ga+4>>2]=ua;xi(ga,c[t>>2]|0);Ga=ga+4|0;Da=c[Ga>>2]|0;c[Ga>>2]=Da&-33;La=ga+128|0;c[La>>2]=(c[La>>2]|0)+1;if((Da&6|0)!=6){c[Ga>>2]=Da&-37;wa=ja+0|0;xa=n+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=
xa+4|0}while((wa|0)<(ya|0));wa=ka+0|0;xa=o+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+4|0}while((wa|0)<(ya|0));ua=+g[ia>>2];na=+T(+ua);g[ha>>2]=na;pa=+S(+ua);g[sa>>2]=pa;ua=+g[Ba>>2];oa=+g[Ca>>2];ra=+(+g[ea>>2]-(pa*ua-na*oa));ta=+(+g[da>>2]-(na*ua+pa*oa));ka=qa;g[ka>>2]=ra;g[ka+4>>2]=ta;ta=+g[Fa>>2];ra=+T(+ta);g[la>>2]=ra;oa=+S(+ta);g[Ha>>2]=oa;ta=+g[Ja>>2];pa=+g[Ka>>2];ua=+(+g[ma>>2]-(oa*ta-ra*pa));na=+(+g[Ea>>2]-(ra*ta+oa*pa));ka=Ia;g[ka>>2]=ua;g[ka+4>>2]=na;continue}ka=Z+4|0;ja=b[ka>>
1]|0;Da=ja&65535;if((Da&2|0)==0){La=(Da|2)&65535;b[ka>>1]=La;g[Z+160>>2]=0;Ma=La}else Ma=ja;ja=ca+4|0;La=e[ja>>1]|0;if((La&2|0)==0){b[ja>>1]=La|2;g[ca+160>>2]=0;Na=b[ka>>1]|0}else Na=Ma;c[w>>2]=0;c[y>>2]=0;c[v>>2]=0;La=Z+8|0;c[La>>2]=0;Da=c[w>>2]|0;c[(c[z>>2]|0)+(Da<<2)>>2]=Z;Oa=Da+1|0;c[w>>2]=Oa;Da=ca+8|0;c[Da>>2]=Oa;Oa=c[w>>2]|0;c[(c[z>>2]|0)+(Oa<<2)>>2]=ca;c[w>>2]=Oa+1;Oa=c[y>>2]|0;c[y>>2]=Oa+1;c[(c[A>>2]|0)+(Oa<<2)>>2]=ga;b[ka>>1]=Na&65535|1;b[ja>>1]=e[ja>>1]|1;c[Ga>>2]=c[Ga>>2]|1;c[p>>2]=Z;c[B>>
2]=ca;ja=Z;ka=1;while(1){a:do if((c[ja>>2]|0)==2?(Oa=c[ja+128>>2]|0,(Oa|0)!=0):0){Pa=ja+4|0;Qa=Oa;do{if((c[w>>2]|0)==(c[C>>2]|0))break a;if((c[y>>2]|0)==(c[D>>2]|0))break a;Oa=c[Qa+4>>2]|0;Ra=Oa+4|0;do if((c[Ra>>2]&1|0)==0){Sa=c[Qa>>2]|0;if(((c[Sa>>2]|0)==2?(b[Pa>>1]&8)==0:0)?(b[Sa+4>>1]&8)==0:0)break;if((a[(c[Oa+48>>2]|0)+38>>0]|0)==0?(a[(c[Oa+52>>2]|0)+38>>0]|0)==0:0){Ta=Sa+44|0;wa=q+0|0;xa=Ta+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+4|0}while((wa|0)<(ya|0));Ua=Sa+4|0;if((b[Ua>>1]&1)==
0){Va=Sa+76|0;na=+g[Va>>2];ua=(fa-na)/(1-na);Wa=Sa+52|0;na=+g[Wa>>2];Xa=Sa+56|0;pa=+g[Xa>>2];oa=ua*(+g[Sa+64>>2]-pa);g[Wa>>2]=na+ua*(+g[Sa+60>>2]-na);g[Xa>>2]=pa+oa;Xa=Sa+72|0;Wa=Sa+68|0;oa=+g[Wa>>2];pa=oa+ua*(+g[Xa>>2]-oa);g[Wa>>2]=pa;g[Va>>2]=fa;Va=Sa+52|0;Wa=c[Va>>2]|0;Ya=c[Va+4>>2]|0;Va=Sa+60|0;c[Va>>2]=Wa;c[Va+4>>2]=Ya;g[Xa>>2]=pa;oa=+T(+pa);g[Sa+20>>2]=oa;ua=+S(+pa);g[Sa+24>>2]=ua;pa=+g[Sa+44>>2];na=+g[Sa+48>>2];ta=(c[k>>2]=Wa,+g[k>>2])-(ua*pa-oa*na);ra=(c[k>>2]=Ya,+g[k>>2])-(oa*pa+ua*na);na=
+ta;ta=+ra;Ya=Sa+12|0;g[Ya>>2]=na;g[Ya+4>>2]=ta}xi(Oa,c[t>>2]|0);Ya=c[Ra>>2]|0;if((Ya&4|0)==0){wa=Ta+0|0;xa=q+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+4|0}while((wa|0)<(ya|0));ta=+g[Sa+72>>2];na=+T(+ta);g[Sa+20>>2]=na;ra=+S(+ta);g[Sa+24>>2]=ra;ta=+g[Sa+44>>2];ua=+g[Sa+48>>2];pa=+(+g[Sa+60>>2]-(ra*ta-na*ua));oa=+(+g[Sa+64>>2]-(na*ta+ra*ua));Wa=Sa+12|0;g[Wa>>2]=pa;g[Wa+4>>2]=oa;break}if((Ya&2|0)==0){wa=Ta+0|0;xa=q+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+4|0}while((wa|0)<(ya|0));
oa=+g[Sa+72>>2];pa=+T(+oa);g[Sa+20>>2]=pa;ua=+S(+oa);g[Sa+24>>2]=ua;oa=+g[Sa+44>>2];ra=+g[Sa+48>>2];ta=+(+g[Sa+60>>2]-(ua*oa-pa*ra));na=+(+g[Sa+64>>2]-(pa*oa+ua*ra));Ta=Sa+12|0;g[Ta>>2]=ta;g[Ta+4>>2]=na;break}c[Ra>>2]=Ya|1;Ta=c[y>>2]|0;c[y>>2]=Ta+1;c[(c[A>>2]|0)+(Ta<<2)>>2]=Oa;Ta=e[Ua>>1]|0;if((Ta&1|0)!=0)break;b[Ua>>1]=Ta|1;do if((c[Sa>>2]|0)!=0){if((Ta&2|0)!=0)break;b[Ua>>1]=Ta|3;g[Sa+160>>2]=0}while(0);c[Sa+8>>2]=c[w>>2];Ta=c[w>>2]|0;c[(c[z>>2]|0)+(Ta<<2)>>2]=Sa;c[w>>2]=Ta+1}}while(0);Qa=c[Qa+
12>>2]|0}while((Qa|0)!=0)}while(0);if((ka|0)>=2)break;ja=c[p+(ka<<2)>>2]|0;ka=ka+1|0}na=(1-fa)*+g[f>>2];g[r>>2]=na;g[E>>2]=1/na;g[F>>2]=1;c[G>>2]=20;c[I>>2]=c[H>>2];c[K>>2]=c[J>>2];a[L>>0]=0;pf(j,r,c[La>>2]|0,c[Da>>2]|0);ka=c[w>>2]|0;if((ka|0)>0){ja=ka;ka=0;while(1){Z=c[(c[z>>2]|0)+(ka<<2)>>2]|0;ca=Z+4|0;b[ca>>1]=b[ca>>1]&65534;if((c[Z>>2]|0)==2){Lj(Z);ca=c[Z+128>>2]|0;if((ca|0)!=0){Z=ca;do{ca=(c[Z+4>>2]|0)+4|0;c[ca>>2]=c[ca>>2]&-34;Z=c[Z+12>>2]|0}while((Z|0)!=0)}Za=c[w>>2]|0}else Za=ja;ka=ka+1|0;
if((ka|0)>=(Za|0))break;else ja=Za}}Vj(s);if((a[M>>0]|0)!=0){_=68;break}}if((_|0)==28){a[u>>0]=1;nf(j);i=h;return}else if((_|0)==68){a[u>>0]=0;nf(j);i=h;return}}function Cj(b,d,e,f,h){b=b|0;d=+d;e=e|0;f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;j=i;i=i+64|0;k=j+24|0;l=j+32|0;m=j+16|0;n=j+8|0;o=j;Km(k);p=b+102876|0;q=c[p>>2]|0;if((q&1|0)==0)r=q;else{Vj(b+102880|0);q=c[p>>2]&-2;c[p>>2]=q;r=q}c[p>>2]=r|2;g[l>>2]=d;c[l+12>>2]=e;c[l+16>>2]=f;c[l+20>>2]=h;if(d>0)g[l+4>>2]=
1/d;else g[l+4>>2]=0;h=b+103E3|0;g[l+8>>2]=+g[h>>2]*d;a[l+24>>0]=a[b+103004>>0]|0;Km(m);Uj(b+102880|0);g[b+103012>>2]=+Mm(m);if((a[b+103007>>0]|0)!=0?+g[l>>2]>0:0){Km(n);m=c[b+102968>>2]|0;if((m|0)!=0){f=m;do{bl(f,l);f=c[f+408>>2]|0}while((f|0)!=0)}Aj(b,l);g[b+103016>>2]=+Mm(n)}if((a[b+103005>>0]|0)!=0){d=+g[l>>2];if(d>0){Km(o);Bj(b,l);g[b+103036>>2]=+Mm(o);s=14}else t=d}else s=14;if((s|0)==14)t=+g[l>>2];if(t>0)g[h>>2]=+g[l+4>>2];l=c[p>>2]|0;if((l&4|0)==0){u=l&-3;c[p>>2]=u;v=+Mm(k);w=b+103008|0;g[w>>
2]=v;i=j;return}h=c[b+102960>>2]|0;if((h|0)==0){u=l&-3;c[p>>2]=u;v=+Mm(k);w=b+103008|0;g[w>>2]=v;i=j;return}else x=h;do{g[x+92>>2]=0;g[x+96>>2]=0;g[x+100>>2]=0;x=c[x+112>>2]|0}while((x|0)!=0);u=l&-3;c[p>>2]=u;v=+Mm(k);w=b+103008|0;g[w>>2]=v;i=j;return}function Dj(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=i;i=i+16|0;f=e;g=a+102880|0;c[f>>2]=g;c[f+4>>2]=b;Gj(g,f,d);f=c[a+102968>>2]|0;if((f|0)==0){i=e;return}a=f;do{if(nb[c[(c[b>>2]|0)+16>>2]&31](b,a)|0)pl(a,b,d);a=c[a+408>>2]|0}while((a|0)!=0);i=e;
return}function Ej(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0;f=i;i=i+32|0;h=f+24|0;j=f;k=a+102880|0;c[h>>2]=k;c[h+4>>2]=b;g[j+16>>2]=1;l=d;m=c[l+4>>2]|0;n=j;c[n>>2]=c[l>>2];c[n+4>>2]=m;m=e;n=c[m+4>>2]|0;l=j+8|0;c[l>>2]=c[m>>2];c[l+4>>2]=n;Fj(k,h,j);j=c[a+102968>>2]|0;if((j|0)==0){i=f;return}a=j;do{if(nb[c[(c[b>>2]|0)+16>>2]&31](b,a)|0)ql(a,b,d,e);a=c[a+408>>2]|0}while((a|0)!=0);i=f;return}function Fj(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=
0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0;e=i;i=i+1088|0;f=e+1064|0;h=e+1056|0;j=e+20|0;k=e;l=d;m=+g[l>>2];n=+g[l+4>>2];l=d+8|0;o=l;p=+g[o>>2];q=p-m;p=+g[o+4>>2]-n;r=+Q(+(q*q+p*p));if(r<1.1920928955078125E-7){s=p;t=q}else{u=1/r;s=p*u;t=q*u}u=-s;r=s<-0?u:s;if(t>0)v=t;else v=-t;s=+g[d+16>>2];w=m+q*s;x=n+p*s;o=j+4|0;c[j>>2]=o;y=j+1028|
0;c[y>>2]=0;z=j+1032|0;c[z>>2]=256;A=c[j>>2]|0;c[A+(c[y>>2]<<2)>>2]=c[a>>2];B=c[y>>2]|0;C=B+1|0;c[y>>2]=C;a:do if((B|0)>-1){D=a+4|0;E=k+8|0;F=k+16|0;G=f+8|0;H=k+4|0;I=k+8|0;J=k+12|0;K=h+4|0;L=b+4|0;M=C;N=n<x?n:x;O=m<w?m:w;P=n>x?n:x;R=m>w?m:w;S=A;T=s;while(1){U=M;V=S;while(1){W=U+-1|0;c[y>>2]=W;X=c[V+(W<<2)>>2]|0;if((X|0)==-1){Y=W;Z=V}else{_=c[D>>2]|0;$=+g[_+(X*36|0)+8>>2];aa=+g[_+(X*36|0)+12>>2];ba=+g[_+(X*36|0)>>2];ca=+g[_+(X*36|0)+4>>2];if(O-$>0|N-aa>0|ba-R>0|ca-P>0){da=N;ea=O;fa=P;ga=R;ha=T;break}ia=
(m-($+ba)*.5)*u+t*(n-(aa+ca)*.5);if(ia>0)ja=ia;else ja=-ia;if(ja-(r*($-ba)*.5+v*(aa-ca)*.5)>0){da=N;ea=O;fa=P;ga=R;ha=T;break}ka=_+(X*36|0)+24|0;if((c[ka>>2]|0)==-1){la=17;break}if((W|0)==(c[z>>2]|0)?(c[z>>2]=W<<1,ma=Pm(W<<3)|0,c[j>>2]=ma,An(ma|0,V|0,c[y>>2]<<2|0)|0,(V|0)!=(o|0)):0)Qm(V);ma=c[j>>2]|0;c[ma+(c[y>>2]<<2)>>2]=c[ka>>2];ka=(c[y>>2]|0)+1|0;c[y>>2]=ka;W=_+(X*36|0)+28|0;if((ka|0)==(c[z>>2]|0)?(c[z>>2]=ka<<1,_=Pm(ka<<3)|0,c[j>>2]=_,An(_|0,ma|0,c[y>>2]<<2|0)|0,(ma|0)!=(o|0)):0)Qm(ma);ma=c[j>>
2]|0;c[ma+(c[y>>2]<<2)>>2]=c[W>>2];W=(c[y>>2]|0)+1|0;c[y>>2]=W;Y=W;Z=ma}if((Y|0)>0){U=Y;V=Z}else break a}if((la|0)==17){la=0;c[k+0>>2]=0;c[k+4>>2]=0;c[k+8>>2]=0;c[k+12>>2]=0;V=d;U=c[V+4>>2]|0;ma=k;c[ma>>2]=c[V>>2];c[ma+4>>2]=U;U=l;ma=c[U+4>>2]|0;V=E;c[V>>2]=c[U>>2];c[V+4>>2]=ma;g[F>>2]=T;ma=c[(c[(c[b>>2]|0)+4>>2]|0)+(X*36|0)+16>>2]|0;V=c[ma+16>>2]|0;U=c[V+12>>2]|0;if(ob[c[(c[U>>2]|0)+24>>2]&15](U,f,k,(c[V+8>>2]|0)+12|0,c[ma+20>>2]|0)|0){ca=+g[G>>2];aa=1-ca;ba=aa*+g[H>>2]+ca*+g[J>>2];g[h>>2]=+g[k>>
2]*aa+ca*+g[I>>2];g[K>>2]=ba;ma=c[L>>2]|0;na=+fb[c[(c[ma>>2]|0)+8>>2]&1](ma,V,h,f,ca)}else na=+g[F>>2];if(na==0)break a;if(na>0){ca=m+q*na;ba=n+p*na;da=n<ba?n:ba;ea=m<ca?m:ca;fa=n>ba?n:ba;ga=m>ca?m:ca;ha=na}else{da=N;ea=O;fa=P;ga=R;ha=T}}V=c[y>>2]|0;if((V|0)<=0)break a;M=V;N=da;O=ea;P=fa;R=ga;S=c[j>>2]|0;T=ha}}while(0);y=c[j>>2]|0;if((y|0)==(o|0)){i=e;return}Qm(y);c[j>>2]=0;i=e;return}function Gj(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,
y=0,z=0,A=0,B=0;e=i;i=i+1040|0;f=e;h=f+4|0;c[f>>2]=h;j=f+1028|0;c[j>>2]=0;k=f+1032|0;c[k>>2]=256;l=c[f>>2]|0;c[l+(c[j>>2]<<2)>>2]=c[a>>2];m=c[j>>2]|0;n=m+1|0;c[j>>2]=n;a:do if((m|0)>-1){o=a+4|0;p=d+4|0;q=d+8|0;r=d+12|0;s=b+4|0;t=n;u=l;while(1){v=t+-1|0;c[j>>2]=v;w=c[u+(v<<2)>>2]|0;do if(!((w|0)==-1)?(x=c[o>>2]|0,!((+g[d>>2]-+g[x+(w*36|0)+8>>2]>0?1:+g[p>>2]-+g[x+(w*36|0)+12>>2]>0)|+g[x+(w*36|0)>>2]-+g[q>>2]>0|+g[x+(w*36|0)+4>>2]-+g[r>>2]>0)):0){y=x+(w*36|0)+24|0;if((c[y>>2]|0)==-1){z=c[s>>2]|0;if(!(nb[c[(c[z>>
2]|0)+8>>2]&31](z,c[(c[(c[(c[b>>2]|0)+4>>2]|0)+(w*36|0)+16>>2]|0)+16>>2]|0)|0))break a;A=c[j>>2]|0;break}if((v|0)==(c[k>>2]|0)?(c[k>>2]=v<<1,z=Pm(v<<3)|0,c[f>>2]=z,An(z|0,u|0,c[j>>2]<<2|0)|0,(u|0)!=(h|0)):0)Qm(u);z=c[f>>2]|0;c[z+(c[j>>2]<<2)>>2]=c[y>>2];y=(c[j>>2]|0)+1|0;c[j>>2]=y;B=x+(w*36|0)+28|0;if((y|0)==(c[k>>2]|0)?(c[k>>2]=y<<1,x=Pm(y<<3)|0,c[f>>2]=x,An(x|0,z|0,c[j>>2]<<2|0)|0,(z|0)!=(h|0)):0)Qm(z);c[(c[f>>2]|0)+(c[j>>2]<<2)>>2]=c[B>>2];B=(c[j>>2]|0)+1|0;c[j>>2]=B;A=B}else A=v;while(0);if((A|
0)<=0)break a;t=A;u=c[f>>2]|0}}while(0);A=c[f>>2]|0;if((A|0)==(h|0)){i=e;return}Qm(A);c[f>>2]=0;i=e;return}function Hj(d,e,f){d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;h=i;j=d+12|0;k=d+28|0;l=d+80|0;m=d+4|0;n=(a[e+39>>0]|0)==0?0:8;b[m>>1]=n;if((a[e+38>>0]|0)==0)o=n;else{p=(n&65535|16)&65535;b[m>>1]=p;o=p}if((a[e+36>>0]|0)==0)q=o;else{p=(o&65535|4)&65535;b[m>>1]=p;q=p}if((a[e+37>>0]|0)==0)r=q;else{p=(q&65535|2)&65535;b[m>>1]=p;r=p}if((a[e+40>>0]|
0)!=0)b[m>>1]=r&65535|32;c[d+104>>2]=f;f=e+4|0;r=c[f>>2]|0;m=c[f+4>>2]|0;f=j;c[f>>2]=r;c[f+4>>2]=m;f=e+12|0;s=+g[f>>2];g[d+20>>2]=+T(+s);g[d+24>>2]=+S(+s);c[k+0>>2]=c[j+0>>2];c[k+4>>2]=c[j+4>>2];c[k+8>>2]=c[j+8>>2];c[k+12>>2]=c[j+12>>2];g[d+44>>2]=0;g[d+48>>2]=0;j=d+52|0;c[j>>2]=r;c[j+4>>2]=m;j=d+60|0;c[j>>2]=r;c[j+4>>2]=m;g[d+68>>2]=+g[f>>2];g[d+72>>2]=+g[f>>2];g[d+76>>2]=0;c[d+124>>2]=0;c[d+128>>2]=0;c[d+108>>2]=0;c[d+112>>2]=0;f=e+16|0;m=c[f+4>>2]|0;j=l;c[j>>2]=c[f>>2];c[j+4>>2]=m;g[d+88>>2]=+g[e+
24>>2];g[d+148>>2]=+g[e+28>>2];g[d+152>>2]=+g[e+32>>2];g[d+156>>2]=+g[e+48>>2];g[d+92>>2]=0;g[d+96>>2]=0;g[d+100>>2]=0;g[d+160>>2]=0;m=c[e>>2]|0;c[d>>2]=m;j=d+132|0;if((m|0)==2){g[j>>2]=1;g[d+136>>2]=1;t=d+140|0;g[t>>2]=0;u=d+144|0;g[u>>2]=0;v=e+44|0;w=c[v>>2]|0;x=d+164|0;c[x>>2]=w;y=d+116|0;c[y>>2]=0;z=d+120|0;c[z>>2]=0;i=h;return}else{g[j>>2]=0;g[d+136>>2]=0;t=d+140|0;g[t>>2]=0;u=d+144|0;g[u>>2]=0;v=e+44|0;w=c[v>>2]|0;x=d+164|0;c[x>>2]=w;y=d+116|0;c[y>>2]=0;z=d+120|0;c[z>>2]=0;i=h;return}}function Ij(a){a=
a|0;return}function Jj(a,d){a=a|0;d=d|0;var f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;f=i;i=i+16|0;h=f;j=a+104|0;if((c[(c[j>>2]|0)+102876>>2]&2|0)!=0){i=f;return}if((c[a>>2]|0)==(d|0)){i=f;return}c[a>>2]=d;Kj(a);if((c[a>>2]|0)==0?(g[a+80>>2]=0,g[a+84>>2]=0,g[a+88>>2]=0,l=+g[a+72>>2],g[a+68>>2]=l,d=a+60|0,m=c[d>>2]|0,n=c[d+4>>2]|0,d=a+52|0,c[d>>2]=m,c[d+4>>2]=n,o=+T(+l),g[h+8>>2]=o,p=+S(+l),g[h+12>>2]=p,l=+g[a+44>>2],q=+g[a+48>>2],r=(c[k>>2]=m,+g[k>>2])-(p*l-o*q),s=(c[k>>2]=n,+g[k>>2])-(o*
l+p*q),q=+r,r=+s,n=h,g[n>>2]=q,g[n+4>>2]=r,n=(c[j>>2]|0)+102880|0,m=c[a+116>>2]|0,(m|0)!=0):0){d=a+12|0;t=m;do{qj(t,n,h,d);t=c[t+4>>2]|0}while((t|0)!=0)}t=a+4|0;d=e[t>>1]|0;if((d&2|0)==0){b[t>>1]=d|2;g[a+160>>2]=0}g[a+92>>2]=0;g[a+96>>2]=0;g[a+100>>2]=0;d=a+128|0;t=c[d>>2]|0;if((t|0)!=0){h=t;do{t=h;h=c[h+12>>2]|0;Tj((c[j>>2]|0)+102880|0,c[t+4>>2]|0)}while((h|0)!=0)}c[d>>2]=0;d=(c[j>>2]|0)+102880|0;j=c[a+116>>2]|0;if((j|0)==0){i=f;return}else u=j;do{j=c[u+28>>2]|0;if((j|0)>0){a=u+24|0;h=0;do{Re(d,
c[(c[a>>2]|0)+(h*28|0)+24>>2]|0);h=h+1|0}while((h|0)!=(j|0))}u=c[u+4>>2]|0}while((u|0)!=0);i=f;return}function Kj(a){a=a|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0;d=i;i=i+16|0;e=d;f=a+132|0;h=a+136|0;j=a+140|0;k=a+144|0;l=a+44|0;g[l>>2]=0;g[a+48>>2]=0;c[f+0>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;if((c[a>>2]|0)>>>0<2){m=a+12|0;n=c[m>>2]|0;o=c[m+4>>2]|0;m=a+52|0;c[m>>2]=n;c[m+4>>2]=o;m=a+60|0;
c[m>>2]=n;c[m+4>>2]=o;g[a+68>>2]=+g[a+72>>2];i=d;return}o=8784;p=+g[o>>2];q=+g[o+4>>2];o=c[a+116>>2]|0;if((o|0)!=0){m=e+4|0;n=e+8|0;r=e+12|0;s=0;t=0;u=p;v=q;w=o;while(1){x=+g[w>>2];if(x==0){y=s;z=t;A=u;B=v}else{o=c[w+12>>2]|0;kb[c[(c[o>>2]|0)+32>>2]&31](o,e,x);x=+g[e>>2];C=x+ +g[f>>2];g[f>>2]=C;D=u+x*+g[m>>2];E=v+x*+g[n>>2];x=+g[r>>2]+ +g[j>>2];g[j>>2]=x;y=x;z=C;A=D;B=E}w=c[w+4>>2]|0;if((w|0)==0)break;else{s=y;t=z;u=A;v=B}}if(z>0){v=1/z;g[h>>2]=v;F=y;G=A*v;H=B*v;I=z}else{J=B;K=A;L=y;M=10}}else{J=
q;K=p;L=0;M=10}if((M|0)==10){g[f>>2]=1;g[h>>2]=1;F=L;G=K;H=J;I=1}if(F>0?(b[a+4>>1]&16)==0:0){J=F-(H*H+G*G)*I;g[j>>2]=J;N=1/J}else{g[j>>2]=0;N=0}g[k>>2]=N;k=a+60|0;j=k;N=+g[j>>2];J=+g[j+4>>2];I=+G;F=+H;j=l;g[j>>2]=I;g[j+4>>2]=F;F=+g[a+24>>2];I=+g[a+20>>2];K=+g[a+12>>2]+(F*G-I*H);L=G*I+F*H+ +g[a+16>>2];H=+K;F=+L;j=k;g[j>>2]=H;g[j+4>>2]=F;j=a+52|0;g[j>>2]=H;g[j+4>>2]=F;F=+g[a+88>>2];j=a+80|0;g[j>>2]=+g[j>>2]-F*(L-J);j=a+84|0;g[j>>2]=F*(K-N)+ +g[j>>2];i=d;return}function Lj(a){a=a|0;var b=0,d=0,e=0,f=
0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;b=i;i=i+16|0;d=b;e=+g[a+68>>2];f=+T(+e);g[d+8>>2]=f;h=+S(+e);g[d+12>>2]=h;e=+g[a+44>>2];j=+g[a+48>>2];k=+(+g[a+52>>2]-(h*e-f*j));l=+(+g[a+56>>2]-(e*f+h*j));m=d;g[m>>2]=k;g[m+4>>2]=l;m=(c[a+104>>2]|0)+102880|0;n=c[a+116>>2]|0;if((n|0)==0){i=b;return}o=a+12|0;a=n;do{qj(a,m,d,o);a=c[a+4>>2]|0}while((a|0)!=0);i=b;return}function Mj(a,d){a=a|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0;e=i;f=a+104|0;h=c[f>>2]|0;if((c[h+102876>>2]&2|0)!=0){j=0;i=e;return j|0}k=Em(h,44)|0;if((k|0)==
0)l=0;else{lj(k);l=k}mj(l,h,a,d);if(!((b[a+4>>1]&32)==0))oj(l,(c[f>>2]|0)+102880|0,a+12|0);d=a+116|0;c[l+4>>2]=c[d>>2];c[d>>2]=l;d=a+120|0;c[d>>2]=(c[d>>2]|0)+1;c[l+8>>2]=a;if(+g[l>>2]>0)Kj(a);a=(c[f>>2]|0)+102876|0;c[a>>2]=c[a>>2]|1;j=l;i=e;return j|0}function Nj(a,d){a=a|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0;e=i;f=a+104|0;if((c[(c[f>>2]|0)+102876>>2]&2|0)!=0){i=e;return}g=a+116|0;h=c[g>>2]|0;a:do if((h|0)!=0){j=h;k=g;while(1){l=j+4|0;if((j|0)==(d|0))break;j=c[l>>2]|0;if((j|0)==0)break a;else k=
l}c[k>>2]=c[d+4>>2]}while(0);g=c[a+128>>2]|0;if((g|0)!=0){h=g;do{g=c[h+4>>2]|0;h=c[h+12>>2]|0;if((c[g+48>>2]|0)==(d|0)?1:(c[g+52>>2]|0)==(d|0))Tj((c[f>>2]|0)+102880|0,g)}while((h|0)!=0)}h=c[f>>2]|0;if(!((b[a+4>>1]&32)==0))pj(d,h+102880|0);nj(d,h);c[d+8>>2]=0;c[d+4>>2]=0;Fm(h,d,44);d=a+120|0;c[d>>2]=(c[d>>2]|0)+-1;Kj(a);i=e;return}function Oj(a,d){a=a|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;e=i;if((c[(c[a+104>>2]|0)+102876>>2]&2|0)!=0){i=e;return}if((c[a>>2]|0)!=2){i=e;return}f=
a+136|0;g[f>>2]=0;h=a+140|0;g[h>>2]=0;j=a+144|0;g[j>>2]=0;l=+g[d>>2];m=!(l<=0)?l:1;g[a+132>>2]=m;g[f>>2]=1/m;l=+g[d+12>>2];if(l>0?(b[a+4>>1]&16)==0:0){n=+g[d+4>>2];o=+g[d+8>>2];p=l-m*(n*n+o*o);g[h>>2]=p;g[j>>2]=1/p}j=a+60|0;h=j;p=+g[h>>2];o=+g[h+4>>2];h=d+4|0;d=c[h>>2]|0;f=c[h+4>>2]|0;h=a+44|0;c[h>>2]=d;c[h+4>>2]=f;n=+g[a+24>>2];m=(c[k>>2]=d,+g[k>>2]);l=+g[a+20>>2];q=(c[k>>2]=f,+g[k>>2]);r=+g[a+12>>2]+(n*m-l*q);s=m*l+n*q+ +g[a+16>>2];q=+r;n=+s;f=j;g[f>>2]=q;g[f+4>>2]=n;f=a+52|0;g[f>>2]=q;g[f+4>>2]=
n;n=+g[a+88>>2];f=a+80|0;g[f>>2]=+g[f>>2]-n*(s-o);f=a+84|0;g[f>>2]=n*(r-p)+ +g[f>>2];i=e;return}function Pj(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0;e=i;if((c[b>>2]|0)!=2?(c[d>>2]|0)!=2:0)f=0;else g=3;a:do if((g|0)==3){h=c[b+124>>2]|0;if((h|0)==0)f=1;else{j=h;while(1){if((c[j>>2]|0)==(d|0)?(a[(c[j+4>>2]|0)+61>>0]|0)==0:0){f=0;break a}j=c[j+12>>2]|0;if((j|0)==0){f=1;break}}}}while(0);i=e;return f|0}function Qj(a,b,d){a=a|0;b=b|0;d=+d;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;e=i;f=c[a+104>>
2]|0;if((c[f+102876>>2]&2|0)!=0){i=e;return}h=a+12|0;j=+T(+d);g[a+20>>2]=j;l=+S(+d);g[a+24>>2]=l;m=b;b=c[m>>2]|0;n=c[m+4>>2]|0;m=h;c[m>>2]=b;c[m+4>>2]=n;m=a+28|0;c[m+0>>2]=c[h+0>>2];c[m+4>>2]=c[h+4>>2];c[m+8>>2]=c[h+8>>2];c[m+12>>2]=c[h+12>>2];o=+g[a+44>>2];p=+g[a+48>>2];q=(c[k>>2]=b,+g[k>>2])+(l*o-j*p);r=o*j+l*p+(c[k>>2]=n,+g[k>>2]);p=+q;q=+r;n=a+60|0;g[n>>2]=p;g[n+4>>2]=q;g[a+72>>2]=d;n=a+52|0;g[n>>2]=p;g[n+4>>2]=q;g[a+68>>2]=d;n=f+102880|0;f=c[a+116>>2]|0;if((f|0)==0){i=e;return}else s=f;do{qj(s,
n,h,h);s=c[s+4>>2]|0}while((s|0)!=0);i=e;return}function Rj(a){a=a|0;return}function Sj(a){a=a|0;var b=0;b=i;Me(a);c[a+60>>2]=0;c[a+64>>2]=0;c[a+68>>2]=6800;c[a+72>>2]=6808;c[a+76>>2]=0;i=b;return}function Tj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;d=i;e=c[(c[b+48>>2]|0)+8>>2]|0;f=c[(c[b+52>>2]|0)+8>>2]|0;g=c[a+72>>2]|0;if((g|0)!=0?(c[b+4>>2]&2|0)!=0:0)gb[c[(c[g>>2]|0)+12>>2]&63](g,b);g=b+8|0;h=c[g>>2]|0;j=b+12|0;if((h|0)!=0)c[h+12>>2]=c[j>>2];h=c[j>>2]|0;if((h|0)!=0)c[h+
8>>2]=c[g>>2];g=a+60|0;if((c[g>>2]|0)==(b|0))c[g>>2]=c[j>>2];j=b+24|0;g=c[j>>2]|0;h=b+28|0;if((g|0)!=0)c[g+12>>2]=c[h>>2];g=c[h>>2]|0;if((g|0)!=0)c[g+8>>2]=c[j>>2];j=e+128|0;if((b+16|0)==(c[j>>2]|0))c[j>>2]=c[h>>2];h=b+40|0;j=c[h>>2]|0;e=b+44|0;if((j|0)!=0)c[j+12>>2]=c[e>>2];j=c[e>>2]|0;if((j|0)!=0)c[j+8>>2]=c[h>>2];h=f+128|0;if((b+32|0)!=(c[h>>2]|0)){k=a+76|0;l=c[k>>2]|0;vi(b,l);m=a+64|0;n=c[m>>2]|0;o=n+-1|0;c[m>>2]=o;i=d;return}c[h>>2]=c[e>>2];k=a+76|0;l=c[k>>2]|0;vi(b,l);m=a+64|0;n=c[m>>2]|0;o=
n+-1|0;c[m>>2]=o;i=d;return}function Uj(a){a=a|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;d=i;e=c[a+60>>2]|0;if((e|0)==0){i=d;return}f=a+4|0;h=a+72|0;j=a+68|0;k=e;while(1){e=c[k+48>>2]|0;l=c[k+52>>2]|0;m=c[k+56>>2]|0;n=c[k+60>>2]|0;o=c[e+8>>2]|0;p=c[l+8>>2]|0;q=k+4|0;do if((c[q>>2]&8|0)==0)r=11;else{if(!(Pj(p,o)|0)){s=c[k+12>>2]|0;Tj(a,k);t=s;break}s=c[j>>2]|0;if((s|0)!=0?!(hb[c[(c[s>>2]|0)+8>>2]&15](s,e,l)|0):0){s=c[k+12>>2]|0;Tj(a,k);t=s;break}c[q>>2]=c[q>>2]&
-9;r=11}while(0);do if((r|0)==11){r=0;if((b[o+4>>1]&2)==0)u=0;else u=(c[o>>2]|0)!=0;if((b[p+4>>1]&2)==0)v=0;else v=(c[p>>2]|0)!=0;if(!(u|v)){t=c[k+12>>2]|0;break}q=c[(c[e+24>>2]|0)+(m*28|0)+24>>2]|0;s=c[(c[l+24>>2]|0)+(n*28|0)+24>>2]|0;w=c[f>>2]|0;if((+g[w+(s*36|0)>>2]-+g[w+(q*36|0)+8>>2]>0?1:+g[w+(s*36|0)+4>>2]-+g[w+(q*36|0)+12>>2]>0)|+g[w+(q*36|0)>>2]-+g[w+(s*36|0)+8>>2]>0|+g[w+(q*36|0)+4>>2]-+g[w+(s*36|0)+12>>2]>0){s=c[k+12>>2]|0;Tj(a,k);t=s;break}else{xi(k,c[h>>2]|0);t=c[k+12>>2]|0;break}}while(0);
if((t|0)==0)break;else k=t}i=d;return}function Vj(a){a=a|0;var b=0;b=i;Wj(a,a);i=b;return}function Wj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;d=i;i=i+16|0;e=d;f=a+52|0;c[f>>2]=0;g=a+40|0;h=c[g>>2]|0;if((h|0)>0){j=a+32|0;k=a+56|0;l=a+4|0;m=h;h=0;while(1){n=c[(c[j>>2]|0)+(h<<2)>>2]|0;c[k>>2]=n;if((n|0)==-1)o=m;else{Yj(a,a,(c[l>>2]|0)+(n*36|0)|0);o=c[g>>2]|0}h=h+1|0;if((h|0)>=(o|0))break;else m=o}p=c[f>>2]|0}else p=0;c[g>>2]=0;g=a+44|0;o=c[g>>2]|0;c[e>>2]=26;_j(o,o+(p<<3)|
0,e);if((c[f>>2]|0)<=0){i=d;return}e=a+4|0;a=0;a:while(1){p=c[g>>2]|0;o=p+(a<<3)|0;m=c[e>>2]|0;h=p+(a<<3)+4|0;Xj(b,c[m+((c[o>>2]|0)*36|0)+16>>2]|0,c[m+((c[h>>2]|0)*36|0)+16>>2]|0);m=c[f>>2]|0;p=a;while(1){l=p+1|0;if((l|0)>=(m|0))break a;k=c[g>>2]|0;if((c[k+(l<<3)>>2]|0)!=(c[o>>2]|0)){a=l;continue a}if((c[k+(l<<3)+4>>2]|0)==(c[h>>2]|0))p=l;else{a=l;continue a}}}i=d;return}function Xj(d,f,h){d=d|0;f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;j=i;k=c[f+16>>2]|0;l=c[h+16>>2]|0;
m=c[f+20>>2]|0;f=c[h+20>>2]|0;h=c[k+8>>2]|0;n=c[l+8>>2]|0;if((h|0)==(n|0)){i=j;return}o=c[n+128>>2]|0;a:do if((o|0)!=0){p=o;while(1){if((c[p>>2]|0)==(h|0)){q=c[p+4>>2]|0;r=c[q+48>>2]|0;s=c[q+52>>2]|0;t=c[q+56>>2]|0;u=c[q+60>>2]|0;if((r|0)==(k|0)&(s|0)==(l|0)&(t|0)==(m|0)&(u|0)==(f|0)){v=24;break}if((r|0)==(l|0)&(s|0)==(k|0)&(t|0)==(f|0)&(u|0)==(m|0)){v=24;break}}p=c[p+12>>2]|0;if((p|0)==0)break a}if((v|0)==24){i=j;return}}while(0);if(!(Pj(n,h)|0)){i=j;return}h=c[d+68>>2]|0;if((h|0)!=0?!(hb[c[(c[h>>
2]|0)+8>>2]&15](h,k,l)|0):0){i=j;return}h=ui(k,m,l,f,c[d+76>>2]|0)|0;if((h|0)==0){i=j;return}f=c[h+48>>2]|0;l=c[h+52>>2]|0;m=c[f+8>>2]|0;k=c[l+8>>2]|0;c[h+8>>2]=0;n=d+60|0;c[h+12>>2]=c[n>>2];v=c[n>>2]|0;if((v|0)!=0)c[v+8>>2]=h;c[n>>2]=h;n=h+16|0;c[h+20>>2]=h;c[n>>2]=k;c[h+24>>2]=0;v=m+128|0;c[h+28>>2]=c[v>>2];o=c[v>>2]|0;if((o|0)!=0)c[o+8>>2]=n;c[v>>2]=n;n=h+32|0;c[h+36>>2]=h;c[n>>2]=m;c[h+40>>2]=0;v=k+128|0;c[h+44>>2]=c[v>>2];h=c[v>>2]|0;if((h|0)!=0)c[h+8>>2]=n;c[v>>2]=n;if((a[f+38>>0]|0)==0?(a[l+
38>>0]|0)==0:0){l=m+4|0;f=e[l>>1]|0;if((f&2|0)==0){b[l>>1]=f|2;g[m+160>>2]=0}m=k+4|0;f=e[m>>1]|0;if((f&2|0)==0){b[m>>1]=f|2;g[k+160>>2]=0}}k=d+64|0;c[k>>2]=(c[k>>2]|0)+1;i=j;return}function Yj(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;e=i;i=i+1040|0;f=e;h=f+4|0;c[f>>2]=h;j=f+1028|0;c[j>>2]=0;k=f+1032|0;c[k>>2]=256;l=c[f>>2]|0;c[l+(c[j>>2]<<2)>>2]=c[a>>2];m=c[j>>2]|0;n=m+1|0;c[j>>2]=n;a:do if((m|0)>-1){o=a+4|0;p=d+4|0;q=d+8|0;r=
d+12|0;s=n;t=l;while(1){u=s+-1|0;c[j>>2]=u;v=c[t+(u<<2)>>2]|0;do if(!((v|0)==-1)?(w=c[o>>2]|0,!((+g[d>>2]-+g[w+(v*36|0)+8>>2]>0?1:+g[p>>2]-+g[w+(v*36|0)+12>>2]>0)|+g[w+(v*36|0)>>2]-+g[q>>2]>0|+g[w+(v*36|0)+4>>2]-+g[r>>2]>0)):0){x=w+(v*36|0)+24|0;if((c[x>>2]|0)==-1){if(!(Se(b,v)|0))break a;y=c[j>>2]|0;break}if((u|0)==(c[k>>2]|0)?(c[k>>2]=u<<1,z=Pm(u<<3)|0,c[f>>2]=z,An(z|0,t|0,c[j>>2]<<2|0)|0,(t|0)!=(h|0)):0)Qm(t);z=c[f>>2]|0;c[z+(c[j>>2]<<2)>>2]=c[x>>2];x=(c[j>>2]|0)+1|0;c[j>>2]=x;A=w+(v*36|0)+28|
0;if((x|0)==(c[k>>2]|0)?(c[k>>2]=x<<1,w=Pm(x<<3)|0,c[f>>2]=w,An(w|0,z|0,c[j>>2]<<2|0)|0,(z|0)!=(h|0)):0)Qm(z);c[(c[f>>2]|0)+(c[j>>2]<<2)>>2]=c[A>>2];A=(c[j>>2]|0)+1|0;c[j>>2]=A;y=A}else y=u;while(0);if((y|0)<=0)break a;s=y;t=c[f>>2]|0}}while(0);y=c[f>>2]|0;if((y|0)==(h|0)){i=e;return}Qm(y);c[f>>2]=0;i=e;return}function Zj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;e=c[a>>2]|0;f=c[b>>2]|0;if((e|0)>=(f|0))if((e|0)==(f|0))g=(c[a+4>>2]|0)<(c[b+4>>2]|0);else g=0;else g=1;i=d;return g|0}function _j(a,b,d){a=
a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0;e=i;f=a;a=b;a:while(1){b=a;g=a+-8|0;h=f;b:while(1){j=h;k=b-j|0;l=k>>3;switch(l|0){case 5:m=15;break a;break;case 2:m=4;break a;break;case 4:m=14;break a;break;case 1:case 0:m=67;break a;break;case 3:m=6;break a;break;default:}if((k|0)<248){m=21;break a}n=(l|0)/2|0;o=h+(n<<3)|0;do if((k|0)>7992){p=(l|0)/4|0;q=h+(p<<3)|0;r=h+(p+n<<3)|0;p=
$j(h,q,o,r,d)|0;if(nb[c[d>>2]&31](g,r)|0){s=r;t=c[s>>2]|0;u=c[s+4>>2]|0;s=g;v=c[s+4>>2]|0;w=r;c[w>>2]=c[s>>2];c[w+4>>2]=v;v=g;c[v>>2]=t;c[v+4>>2]=u;u=p+1|0;if(nb[c[d>>2]&31](r,o)|0){v=o;t=c[v>>2]|0;w=c[v+4>>2]|0;v=r;s=c[v+4>>2]|0;x=o;c[x>>2]=c[v>>2];c[x+4>>2]=s;s=r;c[s>>2]=t;c[s+4>>2]=w;w=p+2|0;if(nb[c[d>>2]&31](o,q)|0){s=q;t=c[s>>2]|0;r=c[s+4>>2]|0;s=o;x=c[s+4>>2]|0;v=q;c[v>>2]=c[s>>2];c[v+4>>2]=x;x=o;c[x>>2]=t;c[x+4>>2]=r;if(nb[c[d>>2]&31](q,h)|0){r=h;x=c[r>>2]|0;t=c[r+4>>2]|0;r=q;v=c[r+4>>2]|0;
s=h;c[s>>2]=c[r>>2];c[s+4>>2]=v;v=q;c[v>>2]=x;c[v+4>>2]=t;y=p+4|0}else y=p+3|0}else y=w}else y=u}else y=p}else{p=nb[c[d>>2]&31](o,h)|0;u=nb[c[d>>2]&31](g,o)|0;if(!p){if(!u){y=0;break}p=o;w=c[p>>2]|0;t=c[p+4>>2]|0;p=g;v=c[p+4>>2]|0;x=o;c[x>>2]=c[p>>2];c[x+4>>2]=v;v=g;c[v>>2]=w;c[v+4>>2]=t;if(!(nb[c[d>>2]&31](o,h)|0)){y=1;break}t=h;v=c[t>>2]|0;w=c[t+4>>2]|0;t=o;x=c[t+4>>2]|0;p=h;c[p>>2]=c[t>>2];c[p+4>>2]=x;x=o;c[x>>2]=v;c[x+4>>2]=w;y=2;break}w=h;x=c[w>>2]|0;v=c[w+4>>2]|0;if(u){u=g;w=c[u+4>>2]|0;p=h;
c[p>>2]=c[u>>2];c[p+4>>2]=w;w=g;c[w>>2]=x;c[w+4>>2]=v;y=1;break}w=o;p=c[w+4>>2]|0;u=h;c[u>>2]=c[w>>2];c[u+4>>2]=p;p=o;c[p>>2]=x;c[p+4>>2]=v;if(nb[c[d>>2]&31](g,o)|0){v=o;p=c[v>>2]|0;x=c[v+4>>2]|0;v=g;u=c[v+4>>2]|0;w=o;c[w>>2]=c[v>>2];c[w+4>>2]=u;u=g;c[u>>2]=p;c[u+4>>2]=x;y=2}else y=1}while(0);do if(nb[c[d>>2]&31](h,o)|0){z=g;A=y}else{n=g;while(1){n=n+-8|0;if((h|0)==(n|0))break;if(nb[c[d>>2]&31](n,o)|0){m=50;break}}if((m|0)==50){m=0;l=h;k=c[l>>2]|0;x=c[l+4>>2]|0;l=n;u=c[l+4>>2]|0;p=h;c[p>>2]=c[l>>
2];c[p+4>>2]=u;u=n;c[u>>2]=k;c[u+4>>2]=x;z=n;A=y+1|0;break}x=h+8|0;if(nb[c[d>>2]&31](h,g)|0)B=x;else{if((x|0)==(g|0)){m=67;break a}else C=x;while(1){D=C+8|0;if(nb[c[d>>2]&31](h,C)|0)break;if((D|0)==(g|0)){m=67;break a}else C=D}n=C;x=c[n>>2]|0;u=c[n+4>>2]|0;n=g;k=c[n+4>>2]|0;p=C;c[p>>2]=c[n>>2];c[p+4>>2]=k;k=g;c[k>>2]=x;c[k+4>>2]=u;B=D}if((B|0)==(g|0)){m=67;break a}else{E=B;F=g}while(1){u=E;while(1){G=u+8|0;if(nb[c[d>>2]&31](h,u)|0){H=F;break}else u=G}do H=H+-8|0;while(nb[c[d>>2]&31](h,H)|0);if(!(u>>>
0<H>>>0)){h=u;continue b}k=u;x=c[k>>2]|0;p=c[k+4>>2]|0;k=H;n=c[k+4>>2]|0;l=u;c[l>>2]=c[k>>2];c[l+4>>2]=n;n=H;c[n>>2]=x;c[n+4>>2]=p;E=G;F=H}}while(0);p=h+8|0;c:do if(p>>>0<z>>>0){n=p;x=z;l=o;k=A;while(1){w=n;while(1){I=w+8|0;if(nb[c[d>>2]&31](w,l)|0)w=I;else{J=x;break}}do J=J+-8|0;while(!(nb[c[d>>2]&31](J,l)|0));if(w>>>0>J>>>0){K=w;L=l;M=k;break c}u=w;v=c[u>>2]|0;t=c[u+4>>2]|0;u=J;q=c[u+4>>2]|0;s=w;c[s>>2]=c[u>>2];c[s+4>>2]=q;q=J;c[q>>2]=v;c[q+4>>2]=t;n=I;x=J;l=(l|0)==(w|0)?J:l;k=k+1|0}}else{K=p;L=
o;M=A}while(0);if((K|0)!=(L|0)?nb[c[d>>2]&31](L,K)|0:0){o=K;p=c[o>>2]|0;k=c[o+4>>2]|0;o=L;l=c[o+4>>2]|0;x=K;c[x>>2]=c[o>>2];c[x+4>>2]=l;l=L;c[l>>2]=p;c[l+4>>2]=k;N=M+1|0}else N=M;if((N|0)==0){O=bk(h,K,d)|0;k=K+8|0;if(bk(k,a,d)|0){m=62;break}if(O){h=k;continue}}k=K;if((k-j|0)>=(b-k|0)){m=66;break}_j(h,K,d);h=K+8|0}if((m|0)==62){m=0;if(O){m=67;break}else{f=h;a=K;continue}}else if((m|0)==66){m=0;_j(K+8|0,a,d);f=h;a=K;continue}}if((m|0)==4){if(!(nb[c[d>>2]&31](g,h)|0)){i=e;return}K=h;f=c[K>>2]|0;O=c[K+
4>>2]|0;K=g;N=c[K+4>>2]|0;M=h;c[M>>2]=c[K>>2];c[M+4>>2]=N;N=g;c[N>>2]=f;c[N+4>>2]=O;i=e;return}else if((m|0)==6){O=h+8|0;N=nb[c[d>>2]&31](O,h)|0;f=nb[c[d>>2]&31](g,O)|0;if(!N){if(!f){i=e;return}N=O;M=c[N>>2]|0;K=c[N+4>>2]|0;N=g;L=c[N+4>>2]|0;A=O;c[A>>2]=c[N>>2];c[A+4>>2]=L;L=g;c[L>>2]=M;c[L+4>>2]=K;if(!(nb[c[d>>2]&31](O,h)|0)){i=e;return}K=h;L=c[K>>2]|0;M=c[K+4>>2]|0;K=O;A=c[K+4>>2]|0;N=h;c[N>>2]=c[K>>2];c[N+4>>2]=A;A=O;c[A>>2]=L;c[A+4>>2]=M;i=e;return}M=h;A=c[M>>2]|0;L=c[M+4>>2]|0;if(f){f=g;M=c[f+
4>>2]|0;N=h;c[N>>2]=c[f>>2];c[N+4>>2]=M;M=g;c[M>>2]=A;c[M+4>>2]=L;i=e;return}M=O;N=c[M+4>>2]|0;f=h;c[f>>2]=c[M>>2];c[f+4>>2]=N;N=O;c[N>>2]=A;c[N+4>>2]=L;if(!(nb[c[d>>2]&31](g,O)|0)){i=e;return}L=O;N=c[L>>2]|0;A=c[L+4>>2]|0;L=g;f=c[L+4>>2]|0;M=O;c[M>>2]=c[L>>2];c[M+4>>2]=f;f=g;c[f>>2]=N;c[f+4>>2]=A;i=e;return}else if((m|0)==14){$j(h,h+8|0,h+16|0,g,d)|0;i=e;return}else if((m|0)==15){A=h+8|0;f=h+16|0;N=h+24|0;$j(h,A,f,N,d)|0;if(!(nb[c[d>>2]&31](g,N)|0)){i=e;return}M=N;L=c[M>>2]|0;O=c[M+4>>2]|0;M=g;K=
c[M+4>>2]|0;J=N;c[J>>2]=c[M>>2];c[J+4>>2]=K;K=g;c[K>>2]=L;c[K+4>>2]=O;if(!(nb[c[d>>2]&31](N,f)|0)){i=e;return}O=f;K=c[O>>2]|0;L=c[O+4>>2]|0;O=N;g=c[O+4>>2]|0;J=f;c[J>>2]=c[O>>2];c[J+4>>2]=g;g=N;c[g>>2]=K;c[g+4>>2]=L;if(!(nb[c[d>>2]&31](f,A)|0)){i=e;return}L=A;g=c[L>>2]|0;K=c[L+4>>2]|0;L=f;N=c[L+4>>2]|0;J=A;c[J>>2]=c[L>>2];c[J+4>>2]=N;N=f;c[N>>2]=g;c[N+4>>2]=K;if(!(nb[c[d>>2]&31](A,h)|0)){i=e;return}K=h;N=c[K>>2]|0;g=c[K+4>>2]|0;K=A;f=c[K+4>>2]|0;J=h;c[J>>2]=c[K>>2];c[J+4>>2]=f;f=A;c[f>>2]=N;c[f+4>>
2]=g;i=e;return}else if((m|0)==21){ak(h,a,d);i=e;return}else if((m|0)==67){i=e;return}}function $j(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;g=i;h=nb[c[f>>2]&31](b,a)|0;j=nb[c[f>>2]&31](d,b)|0;do if(h){k=a;l=c[k>>2]|0;m=c[k+4>>2]|0;if(j){k=d;n=c[k+4>>2]|0;o=a;c[o>>2]=c[k>>2];c[o+4>>2]=n;n=d;c[n>>2]=l;c[n+4>>2]=m;p=1;break}n=b;o=c[n+4>>2]|0;k=a;c[k>>2]=c[n>>2];c[k+4>>2]=o;o=b;c[o>>2]=l;c[o+4>>2]=m;if(nb[c[f>>2]&31](d,b)|0){m=b;o=c[m>>2]|0;l=c[m+4>>2]|0;m=
d;k=c[m+4>>2]|0;n=b;c[n>>2]=c[m>>2];c[n+4>>2]=k;k=d;c[k>>2]=o;c[k+4>>2]=l;p=2}else p=1}else if(j){l=b;k=c[l>>2]|0;o=c[l+4>>2]|0;l=d;n=c[l+4>>2]|0;m=b;c[m>>2]=c[l>>2];c[m+4>>2]=n;n=d;c[n>>2]=k;c[n+4>>2]=o;if(nb[c[f>>2]&31](b,a)|0){o=a;n=c[o>>2]|0;k=c[o+4>>2]|0;o=b;m=c[o+4>>2]|0;l=a;c[l>>2]=c[o>>2];c[l+4>>2]=m;m=b;c[m>>2]=n;c[m+4>>2]=k;p=2}else p=1}else p=0;while(0);if(!(nb[c[f>>2]&31](e,d)|0)){q=p;i=g;return q|0}j=d;h=c[j>>2]|0;k=c[j+4>>2]|0;j=e;m=c[j+4>>2]|0;n=d;c[n>>2]=c[j>>2];c[n+4>>2]=m;m=e;c[m>>
2]=h;c[m+4>>2]=k;if(!(nb[c[f>>2]&31](d,b)|0)){q=p+1|0;i=g;return q|0}k=b;m=c[k>>2]|0;h=c[k+4>>2]|0;k=d;e=c[k+4>>2]|0;n=b;c[n>>2]=c[k>>2];c[n+4>>2]=e;e=d;c[e>>2]=m;c[e+4>>2]=h;if(!(nb[c[f>>2]&31](b,a)|0)){q=p+2|0;i=g;return q|0}f=a;h=c[f>>2]|0;e=c[f+4>>2]|0;f=b;m=c[f+4>>2]|0;d=a;c[d>>2]=c[f>>2];c[d+4>>2]=m;m=b;c[m>>2]=h;c[m+4>>2]=e;q=p+3|0;i=g;return q|0}function ak(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;e=i;i=i+16|0;f=e;g=a+16|0;h=a+8|0;j=nb[c[d>>2]&31](h,
a)|0;k=nb[c[d>>2]&31](g,h)|0;do if(j){l=a;m=c[l>>2]|0;n=c[l+4>>2]|0;if(k){l=g;o=c[l+4>>2]|0;p=a;c[p>>2]=c[l>>2];c[p+4>>2]=o;o=g;c[o>>2]=m;c[o+4>>2]=n;break}o=h;p=c[o+4>>2]|0;l=a;c[l>>2]=c[o>>2];c[l+4>>2]=p;p=h;c[p>>2]=m;c[p+4>>2]=n;if(nb[c[d>>2]&31](g,h)|0){n=h;p=c[n>>2]|0;m=c[n+4>>2]|0;n=g;l=c[n+4>>2]|0;o=h;c[o>>2]=c[n>>2];c[o+4>>2]=l;l=g;c[l>>2]=p;c[l+4>>2]=m}}else if(k?(m=h,l=c[m>>2]|0,p=c[m+4>>2]|0,m=g,o=c[m+4>>2]|0,n=h,c[n>>2]=c[m>>2],c[n+4>>2]=o,o=g,c[o>>2]=l,c[o+4>>2]=p,nb[c[d>>2]&31](h,a)|
0):0){p=a;o=c[p>>2]|0;l=c[p+4>>2]|0;p=h;n=c[p+4>>2]|0;m=a;c[m>>2]=c[p>>2];c[m+4>>2]=n;n=h;c[n>>2]=o;c[n+4>>2]=l}while(0);h=a+24|0;if((h|0)==(b|0)){i=e;return}else{q=h;r=g}while(1){if(nb[c[d>>2]&31](q,r)|0){g=q;h=c[g+4>>2]|0;k=f;c[k>>2]=c[g>>2];c[k+4>>2]=h;h=q;k=r;while(1){g=k;j=c[g+4>>2]|0;l=h;c[l>>2]=c[g>>2];c[l+4>>2]=j;if((k|0)==(a|0))break;j=k+-8|0;if(nb[c[d>>2]&31](f,j)|0){l=k;k=j;h=l}else break}h=f;l=c[h+4>>2]|0;j=k;c[j>>2]=c[h>>2];c[j+4>>2]=l}l=q+8|0;if((l|0)==(b|0))break;else{j=q;q=l;r=j}}i=
e;return}function bk(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;e=i;i=i+16|0;f=e;switch(b-a>>3|0){case 2:g=b+-8|0;if(!(nb[c[d>>2]&31](g,a)|0)){h=1;i=e;return h|0}j=a;k=c[j>>2]|0;l=c[j+4>>2]|0;j=g;m=c[j+4>>2]|0;n=a;c[n>>2]=c[j>>2];c[n+4>>2]=m;m=g;c[m>>2]=k;c[m+4>>2]=l;h=1;i=e;return h|0;case 4:$j(a,a+8|0,a+16|0,b+-8|0,d)|0;h=1;i=e;return h|0;case 5:l=a+8|0;m=a+16|0;k=a+24|0;g=b+-8|0;$j(a,l,m,k,d)|0;if(!(nb[c[d>>2]&31](g,k)|0)){h=1;i=e;return h|
0}n=k;j=c[n>>2]|0;o=c[n+4>>2]|0;n=g;p=c[n+4>>2]|0;q=k;c[q>>2]=c[n>>2];c[q+4>>2]=p;p=g;c[p>>2]=j;c[p+4>>2]=o;if(!(nb[c[d>>2]&31](k,m)|0)){h=1;i=e;return h|0}o=m;p=c[o>>2]|0;j=c[o+4>>2]|0;o=k;g=c[o+4>>2]|0;q=m;c[q>>2]=c[o>>2];c[q+4>>2]=g;g=k;c[g>>2]=p;c[g+4>>2]=j;if(!(nb[c[d>>2]&31](m,l)|0)){h=1;i=e;return h|0}j=l;g=c[j>>2]|0;p=c[j+4>>2]|0;j=m;k=c[j+4>>2]|0;q=l;c[q>>2]=c[j>>2];c[q+4>>2]=k;k=m;c[k>>2]=g;c[k+4>>2]=p;if(!(nb[c[d>>2]&31](l,a)|0)){h=1;i=e;return h|0}p=a;k=c[p>>2]|0;g=c[p+4>>2]|0;p=l;m=c[p+
4>>2]|0;q=a;c[q>>2]=c[p>>2];c[q+4>>2]=m;m=l;c[m>>2]=k;c[m+4>>2]=g;h=1;i=e;return h|0;case 3:g=a+8|0;m=b+-8|0;k=nb[c[d>>2]&31](g,a)|0;l=nb[c[d>>2]&31](m,g)|0;if(!k){if(!l){h=1;i=e;return h|0}k=g;q=c[k>>2]|0;p=c[k+4>>2]|0;k=m;j=c[k+4>>2]|0;o=g;c[o>>2]=c[k>>2];c[o+4>>2]=j;j=m;c[j>>2]=q;c[j+4>>2]=p;if(!(nb[c[d>>2]&31](g,a)|0)){h=1;i=e;return h|0}p=a;j=c[p>>2]|0;q=c[p+4>>2]|0;p=g;o=c[p+4>>2]|0;k=a;c[k>>2]=c[p>>2];c[k+4>>2]=o;o=g;c[o>>2]=j;c[o+4>>2]=q;h=1;i=e;return h|0}q=a;o=c[q>>2]|0;j=c[q+4>>2]|0;if(l){l=
m;q=c[l+4>>2]|0;k=a;c[k>>2]=c[l>>2];c[k+4>>2]=q;q=m;c[q>>2]=o;c[q+4>>2]=j;h=1;i=e;return h|0}q=g;k=c[q+4>>2]|0;l=a;c[l>>2]=c[q>>2];c[l+4>>2]=k;k=g;c[k>>2]=o;c[k+4>>2]=j;if(!(nb[c[d>>2]&31](m,g)|0)){h=1;i=e;return h|0}j=g;k=c[j>>2]|0;o=c[j+4>>2]|0;j=m;l=c[j+4>>2]|0;q=g;c[q>>2]=c[j>>2];c[q+4>>2]=l;l=m;c[l>>2]=k;c[l+4>>2]=o;h=1;i=e;return h|0;case 1:case 0:h=1;i=e;return h|0;default:o=a+16|0;l=a+8|0;k=nb[c[d>>2]&31](l,a)|0;m=nb[c[d>>2]&31](o,l)|0;do if(k){q=a;j=c[q>>2]|0;g=c[q+4>>2]|0;if(m){q=o;p=c[q+
4>>2]|0;n=a;c[n>>2]=c[q>>2];c[n+4>>2]=p;p=o;c[p>>2]=j;c[p+4>>2]=g;break}p=l;n=c[p+4>>2]|0;q=a;c[q>>2]=c[p>>2];c[q+4>>2]=n;n=l;c[n>>2]=j;c[n+4>>2]=g;if(nb[c[d>>2]&31](o,l)|0){g=l;n=c[g>>2]|0;j=c[g+4>>2]|0;g=o;q=c[g+4>>2]|0;p=l;c[p>>2]=c[g>>2];c[p+4>>2]=q;q=o;c[q>>2]=n;c[q+4>>2]=j}}else if(m?(j=l,q=c[j>>2]|0,n=c[j+4>>2]|0,j=o,p=c[j+4>>2]|0,g=l,c[g>>2]=c[j>>2],c[g+4>>2]=p,p=o,c[p>>2]=q,c[p+4>>2]=n,nb[c[d>>2]&31](l,a)|0):0){n=a;p=c[n>>2]|0;q=c[n+4>>2]|0;n=l;g=c[n+4>>2]|0;j=a;c[j>>2]=c[n>>2];c[j+4>>2]=
g;g=l;c[g>>2]=p;c[g+4>>2]=q}while(0);l=a+24|0;if((l|0)==(b|0)){h=1;i=e;return h|0}else{r=0;s=l;t=o}while(1){if(nb[c[d>>2]&31](s,t)|0){o=s;l=c[o+4>>2]|0;m=f;c[m>>2]=c[o>>2];c[m+4>>2]=l;l=s;m=t;while(1){o=m;k=c[o+4>>2]|0;q=l;c[q>>2]=c[o>>2];c[q+4>>2]=k;if((m|0)==(a|0))break;k=m+-8|0;if(nb[c[d>>2]&31](f,k)|0){q=m;m=k;l=q}else break}l=f;q=c[l+4>>2]|0;k=m;c[k>>2]=c[l>>2];c[k+4>>2]=q;q=r+1|0;if((q|0)==8)break;else u=q}else u=r;q=s+8|0;if((q|0)==(b|0)){h=1;v=34;break}else{k=s;r=u;s=q;t=k}}if((v|0)==34){i=
e;return h|0}h=(s+8|0)==(b|0);i=e;return h|0}return 0}function ck(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function dk(a,b){a=a|0;b=b|0;return}function ek(a,b){a=a|0;b=b|0;return}function fk(a,b,c){a=a|0;b=b|0;c=c|0;return}function gk(a,b,c){a=a|0;b=b|0;c=c|0;return}function hk(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;e=i;c[a>>2]=b;c[a+4>>2]=Ym(b,d<<4)|0;c[a+8>>2]=d;d=a+12|0;c[d+0>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;i=e;return}function ik(a){a=a|0;var b=0,d=0;b=i;d=c[a+24>>2]|0;if((d|0)!=0)_m(c[a>>2]|
0,d);_m(c[a>>2]|0,c[a+4>>2]|0);i=b;return}function jk(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;g=b+12|0;h=c[g>>2]|0;c[g>>2]=h+1;g=c[b+4>>2]|0;b=d;d=c[b+4>>2]|0;i=g+(h<<4)|0;c[i>>2]=c[b>>2];c[i+4>>2]=d;c[g+(h<<4)+8>>2]=e;a[g+(h<<4)+12>>0]=f&1;return}function kk(b,d,e){b=b|0;d=+d;e=+e;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,ba=0,ca=0,da=0,ea=
0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0,ob=0,pb=0,qb=0,rb=0,sb=0,tb=0,ub=0,vb=0,wb=0,xb=0,yb=0,zb=0,Ab=0,Bb=0,Cb=0,Db=0,Eb=0,Fb=0,Gb=0,Hb=0,Ib=0,Jb=0,Kb=0,Lb=0,Mb=0,Nb=0,Ob=0,Pb=0,Qb=0,Rb=0,Sb=0,Tb=0,Ub=0,Vb=0,Wb=0,Xb=0,Yb=0,
Zb=0,_b=0,$b=0,ac=0,bc=0,cc=0,dc=0,ec=0,fc=0,gc=0,hc=0,ic=0,jc=0;f=i;h=1/d;j=b+12|0;k=c[j>>2]|0;if((k|0)>0){l=c[b+4>>2]|0;d=3.4028234663852886E38;m=3.4028234663852886E38;n=-3.4028234663852886E38;o=-3.4028234663852886E38;p=0;while(1){if((a[l+(p<<4)+12>>0]|0)==0){q=m;r=d;s=o;t=n}else{u=+g[l+(p<<4)>>2];v=+g[l+(p<<4)+4>>2];q=m<v?m:v;r=d<u?d:u;s=o>v?o:v;t=n>u?n:u}p=p+1|0;if((p|0)>=(k|0)){w=q;x=r;y=s;z=t;break}else{d=r;m=q;n=t;o=s}}}else{w=3.4028234663852886E38;x=3.4028234663852886E38;y=-3.4028234663852886E38;
z=-3.4028234663852886E38}s=x-e;x=w-e;k=~~(h*(z+e-s))+1|0;p=b+16|0;c[p>>2]=k;l=~~(h*(y+e-x))+1|0;A=b+20|0;c[A>>2]=l;B=Ym(c[b>>2]|0,aa(l<<2,k)|0)|0;k=b+24|0;c[k>>2]=B;l=c[p>>2]|0;C=c[A>>2]|0;D=aa(C,l)|0;a:do if((D|0)>0){E=B;F=0;while(1){c[E+(F<<2)>>2]=0;G=F+1|0;if((G|0)>=(D|0))break a;E=c[k>>2]|0;F=G}}while(0);D=c[b>>2]|0;B=aa(l<<2,C)|0;C=Ym(D,B<<4)|0;if((c[j>>2]|0)>0){l=b+4|0;b=0;F=B;E=C;G=0;while(1){H=c[l>>2]|0;I=H+(G<<4)|0;J=H+(G<<4)+4|0;e=h*(+g[I>>2]-s);y=+e;z=+(h*(+g[J>>2]-x));H=I;g[H>>2]=y;g[H+
4>>2]=z;H=~~e;K=~~+g[J>>2];if(((K|H|0)>-1?(J=c[p>>2]|0,(H|0)<(J|0)):0)?(K|0)<(c[A>>2]|0):0){L=(aa(J,K)|0)+H|0;if((b|0)<(F|0)){M=F;N=E}else{if((b|0)>0){J=0;do J=J+1|0;while((J|0)!=(b|0))}J=(F|0)>0?F<<1:1;M=J;N=Zm(D,E,J<<4)|0}c[N+(b<<4)>>2]=H;c[N+(b<<4)+4>>2]=K;c[N+(b<<4)+8>>2]=L;c[N+(b<<4)+12>>2]=I;O=M;P=b+1|0;Q=N}else{O=F;P=b;Q=E}G=G+1|0;if((G|0)>=(c[j>>2]|0)){R=O;S=P;T=0;U=Q;break}else{b=P;F=O;E=Q}}}else{R=B;S=0;T=0;U=C}b:while(1){C=T;do{if((C|0)==(S|0))break b;V=c[U+(C<<4)>>2]|0;W=c[U+(C<<4)+4>>
2]|0;X=c[U+(C<<4)+8>>2]|0;Y=c[U+(C<<4)+12>>2]|0;C=C+1|0;Z=(c[k>>2]|0)+(X<<2)|0}while((c[Z>>2]|0)!=0);c[Z>>2]=Y;if((V|0)>0){I=V+-1|0;L=X+-1|0;if((S|0)>=(R|0)){if((C|0)<(S|0)){K=C;do{H=U+(K-C<<4)|0;B=U+(K<<4)|0;c[H+0>>2]=c[B+0>>2];c[H+4>>2]=c[B+4>>2];c[H+8>>2]=c[B+8>>2];c[H+12>>2]=c[B+12>>2];K=K+1|0}while((K|0)!=(S|0))}K=S-C|0;if((K|0)<(R|0)){_=U;$=K;ba=R;ca=0}else{B=(R|0)>0?R<<1:1;_=Zm(D,U,B<<4)|0;$=K;ba=B;ca=0}}else{_=U;$=S;ba=R;ca=C}c[_+($<<4)>>2]=I;c[_+($<<4)+4>>2]=W;c[_+($<<4)+8>>2]=L;c[_+($<<
4)+12>>2]=Y;da=$+1|0;ea=ba;fa=ca;ga=_}else{da=S;ea=R;fa=C;ga=U}if((W|0)>0){B=W+-1|0;K=X-(c[p>>2]|0)|0;if((da|0)>=(ea|0)){if((fa|0)<(da|0)){H=fa;do{Q=ga+(H-fa<<4)|0;E=ga+(H<<4)|0;c[Q+0>>2]=c[E+0>>2];c[Q+4>>2]=c[E+4>>2];c[Q+8>>2]=c[E+8>>2];c[Q+12>>2]=c[E+12>>2];H=H+1|0}while((H|0)!=(da|0))}H=da-fa|0;if((H|0)<(ea|0)){ha=ga;ia=H;ja=ea;ka=0}else{C=(ea|0)>0?ea<<1:1;ha=Zm(D,ga,C<<4)|0;ia=H;ja=C;ka=0}}else{ha=ga;ia=da;ja=ea;ka=fa}c[ha+(ia<<4)>>2]=V;c[ha+(ia<<4)+4>>2]=B;c[ha+(ia<<4)+8>>2]=K;c[ha+(ia<<4)+12>>
2]=Y;la=ia+1|0;ma=ja;na=ka;oa=ha}else{la=da;ma=ea;na=fa;oa=ga}if((V|0)<((c[p>>2]|0)+-1|0)){C=V+1|0;H=X+1|0;if((la|0)>=(ma|0)){if((na|0)<(la|0)){L=na;do{I=oa+(L-na<<4)|0;E=oa+(L<<4)|0;c[I+0>>2]=c[E+0>>2];c[I+4>>2]=c[E+4>>2];c[I+8>>2]=c[E+8>>2];c[I+12>>2]=c[E+12>>2];L=L+1|0}while((L|0)!=(la|0))}L=la-na|0;if((L|0)<(ma|0)){pa=oa;qa=L;ra=ma;sa=0}else{K=(ma|0)>0?ma<<1:1;pa=Zm(D,oa,K<<4)|0;qa=L;ra=K;sa=0}}else{pa=oa;qa=la;ra=ma;sa=na}c[pa+(qa<<4)>>2]=C;c[pa+(qa<<4)+4>>2]=W;c[pa+(qa<<4)+8>>2]=H;c[pa+(qa<<
4)+12>>2]=Y;ta=qa+1|0;ua=ra;va=sa;wa=pa}else{ta=la;ua=ma;va=na;wa=oa}if((W|0)>=((c[A>>2]|0)+-1|0)){R=ua;S=ta;T=va;U=wa;continue}K=W+1|0;L=(c[p>>2]|0)+X|0;if((ta|0)>=(ua|0)){if((va|0)<(ta|0)){B=va;do{E=wa+(B-va<<4)|0;I=wa+(B<<4)|0;c[E+0>>2]=c[I+0>>2];c[E+4>>2]=c[I+4>>2];c[E+8>>2]=c[I+8>>2];c[E+12>>2]=c[I+12>>2];B=B+1|0}while((B|0)!=(ta|0))}B=ta-va|0;if((B|0)<(ua|0)){xa=wa;ya=B;za=ua;Aa=0}else{H=(ua|0)>0?ua<<1:1;xa=Zm(D,wa,H<<4)|0;ya=B;za=H;Aa=0}}else{xa=wa;ya=ta;za=ua;Aa=va}c[xa+(ya<<4)>>2]=V;c[xa+
(ya<<4)+4>>2]=K;c[xa+(ya<<4)+8>>2]=L;c[xa+(ya<<4)+12>>2]=Y;R=za;S=ya+1|0;T=Aa;U=xa}xa=c[A>>2]|0;if((xa|0)>0){Aa=c[p>>2]|0;T=xa;ya=U;za=S;Y=S;V=R;va=0;while(1){if((Aa+-1|0)>0){ua=Aa;ta=Y;wa=V;X=za;W=ya;oa=0;while(1){na=(aa(ua,va)|0)+oa|0;ma=c[k>>2]|0;la=c[ma+(na<<2)>>2]|0;pa=na+1|0;sa=c[ma+(pa<<2)>>2]|0;if((la|0)==(sa|0)){Ba=oa+1|0;Ca=ua;Da=wa;Ea=ta;Fa=X;Ga=W}else{if((ta|0)>=(wa|0)){if((X|0)<(ta|0)){ma=X;do{ra=W+(ma-X<<4)|0;qa=W+(ma<<4)|0;c[ra+0>>2]=c[qa+0>>2];c[ra+4>>2]=c[qa+4>>2];c[ra+8>>2]=c[qa+
8>>2];c[ra+12>>2]=c[qa+12>>2];ma=ma+1|0}while((ma|0)!=(ta|0))}ma=ta-X|0;if((ma|0)<(wa|0)){Ha=W;Ia=ma;Ja=wa;Ka=0}else{qa=(wa|0)>0?wa<<1:1;Ha=Zm(D,W,qa<<4)|0;Ia=ma;Ja=qa;Ka=0}}else{Ha=W;Ia=ta;Ja=wa;Ka=X}c[Ha+(Ia<<4)>>2]=oa;c[Ha+(Ia<<4)+4>>2]=va;c[Ha+(Ia<<4)+8>>2]=na;c[Ha+(Ia<<4)+12>>2]=sa;qa=Ia+1|0;ma=oa+1|0;if((qa|0)>=(Ja|0)){if((Ka|0)<(qa|0)){ra=Ka;do{ga=Ha+(ra-Ka<<4)|0;fa=Ha+(ra<<4)|0;c[ga+0>>2]=c[fa+0>>2];c[ga+4>>2]=c[fa+4>>2];c[ga+8>>2]=c[fa+8>>2];c[ga+12>>2]=c[fa+12>>2];ra=ra+1|0}while((ra|0)!=
(qa|0))}ra=qa-Ka|0;if((ra|0)<(Ja|0)){La=Ha;Ma=ra;Na=Ja;Oa=0}else{sa=(Ja|0)>0?Ja<<1:1;La=Zm(D,Ha,sa<<4)|0;Ma=ra;Na=sa;Oa=0}}else{La=Ha;Ma=qa;Na=Ja;Oa=Ka}c[La+(Ma<<4)>>2]=ma;c[La+(Ma<<4)+4>>2]=va;c[La+(Ma<<4)+8>>2]=pa;c[La+(Ma<<4)+12>>2]=la;Ba=ma;Ca=c[p>>2]|0;Da=Na;Ea=Ma+1|0;Fa=Oa;Ga=La}if((Ba|0)<(Ca+-1|0)){ua=Ca;ta=Ea;wa=Da;X=Fa;W=Ga;oa=Ba}else break}Pa=Da;Qa=Ea;Ra=Fa;Sa=Ga;Ta=c[A>>2]|0;Ua=Ca}else{Pa=V;Qa=Y;Ra=za;Sa=ya;Ta=T;Ua=Aa}va=va+1|0;if((va|0)>=(Ta|0)){Va=Pa;Wa=Qa;Xa=Ra;Ya=Sa;Za=Ta;break}else{Aa=
Ua;T=Ta;ya=Sa;za=Ra;Y=Qa;V=Pa}}}else{Va=R;Wa=S;Xa=S;Ya=U;Za=xa}if((Za+-1|0)>0){xa=c[p>>2]|0;U=Za;Za=Ya;S=Xa;R=Wa;Pa=Va;V=0;while(1){Qa=V;V=V+1|0;if((xa|0)>0){Y=xa;Ra=R;za=Pa;Sa=S;ya=Za;Ta=0;while(1){T=(aa(Y,Qa)|0)+Ta|0;Ua=c[k>>2]|0;Aa=c[Ua+(T<<2)>>2]|0;va=c[Ua+(T+Y<<2)>>2]|0;if((Aa|0)==(va|0)){_a=Y;$a=za;ab=Ra;bb=Sa;cb=ya}else{if((Ra|0)>=(za|0)){if((Sa|0)<(Ra|0)){Ua=Sa;do{Ca=ya+(Ua-Sa<<4)|0;Ga=ya+(Ua<<4)|0;c[Ca+0>>2]=c[Ga+0>>2];c[Ca+4>>2]=c[Ga+4>>2];c[Ca+8>>2]=c[Ga+8>>2];c[Ca+12>>2]=c[Ga+12>>2];Ua=
Ua+1|0}while((Ua|0)!=(Ra|0))}Ua=Ra-Sa|0;if((Ua|0)<(za|0)){db=ya;eb=Ua;fb=za;gb=0}else{ma=(za|0)>0?za<<1:1;db=Zm(D,ya,ma<<4)|0;eb=Ua;fb=ma;gb=0}}else{db=ya;eb=Ra;fb=za;gb=Sa}c[db+(eb<<4)>>2]=Ta;c[db+(eb<<4)+4>>2]=Qa;c[db+(eb<<4)+8>>2]=T;c[db+(eb<<4)+12>>2]=va;ma=eb+1|0;Ua=(c[p>>2]|0)+T|0;if((ma|0)>=(fb|0)){if((gb|0)<(ma|0)){la=gb;do{pa=db+(la-gb<<4)|0;qa=db+(la<<4)|0;c[pa+0>>2]=c[qa+0>>2];c[pa+4>>2]=c[qa+4>>2];c[pa+8>>2]=c[qa+8>>2];c[pa+12>>2]=c[qa+12>>2];la=la+1|0}while((la|0)!=(ma|0))}la=ma-gb|0;
if((la|0)<(fb|0)){hb=db;ib=la;jb=fb;kb=0}else{T=(fb|0)>0?fb<<1:1;hb=Zm(D,db,T<<4)|0;ib=la;jb=T;kb=0}}else{hb=db;ib=ma;jb=fb;kb=gb}c[hb+(ib<<4)>>2]=Ta;c[hb+(ib<<4)+4>>2]=V;c[hb+(ib<<4)+8>>2]=Ua;c[hb+(ib<<4)+12>>2]=Aa;_a=c[p>>2]|0;$a=jb;ab=ib+1|0;bb=kb;cb=hb}Ta=Ta+1|0;if((Ta|0)>=(_a|0))break;else{Y=_a;Ra=ab;za=$a;Sa=bb;ya=cb}}lb=$a;mb=ab;nb=bb;ob=cb;pb=c[A>>2]|0;qb=_a}else{lb=Pa;mb=R;nb=S;ob=Za;pb=U;qb=xa}if((V|0)>=(pb+-1|0)){rb=lb;sb=mb;tb=nb;ub=ob;break}else{xa=qb;U=pb;Za=ob;S=nb;R=mb;Pa=lb}}}else{rb=
Va;sb=Wa;tb=Xa;ub=Ya}if((tb|0)==(sb|0)){vb=ub;_m(D,vb);i=f;return}else{wb=rb;xb=sb;yb=tb;zb=ub}c:while(1){ub=c[k>>2]|0;tb=yb;while(1){Ab=c[zb+(tb<<4)>>2]|0;Bb=c[zb+(tb<<4)+4>>2]|0;Cb=c[zb+(tb<<4)+8>>2]|0;Db=c[zb+(tb<<4)+12>>2]|0;tb=tb+1|0;Eb=ub+(Cb<<2)|0;sb=c[Eb>>2]|0;if((sb|0)!=(Db|0)?(x=+(Ab|0),h=+g[sb>>2]-x,s=+(Bb|0),e=+g[sb+4>>2]-s,z=+g[Db>>2]-x,x=+g[Db+4>>2]-s,h*h+e*e>z*z+x*x):0)break;if((tb|0)==(xb|0)){vb=zb;Fb=122;break c}}c[Eb>>2]=Db;if((Ab|0)>0){ub=Ab+-1|0;sb=Cb+-1|0;if((xb|0)>=(wb|0)){if((tb|
0)<(xb|0)){rb=tb;do{Ya=zb+(rb-tb<<4)|0;Xa=zb+(rb<<4)|0;c[Ya+0>>2]=c[Xa+0>>2];c[Ya+4>>2]=c[Xa+4>>2];c[Ya+8>>2]=c[Xa+8>>2];c[Ya+12>>2]=c[Xa+12>>2];rb=rb+1|0}while((rb|0)!=(xb|0))}rb=xb-tb|0;if((rb|0)<(wb|0)){Gb=zb;Hb=rb;Ib=wb;Jb=0}else{Xa=(wb|0)>0?wb<<1:1;Gb=Zm(D,zb,Xa<<4)|0;Hb=rb;Ib=Xa;Jb=0}}else{Gb=zb;Hb=xb;Ib=wb;Jb=tb}c[Gb+(Hb<<4)>>2]=ub;c[Gb+(Hb<<4)+4>>2]=Bb;c[Gb+(Hb<<4)+8>>2]=sb;c[Gb+(Hb<<4)+12>>2]=Db;Kb=Hb+1|0;Lb=Ib;Mb=Jb;Nb=Gb}else{Kb=xb;Lb=wb;Mb=tb;Nb=zb}if((Bb|0)>0){Xa=Bb+-1|0;rb=Cb-(c[p>>
2]|0)|0;if((Kb|0)>=(Lb|0)){if((Mb|0)<(Kb|0)){Ya=Mb;do{Wa=Nb+(Ya-Mb<<4)|0;Va=Nb+(Ya<<4)|0;c[Wa+0>>2]=c[Va+0>>2];c[Wa+4>>2]=c[Va+4>>2];c[Wa+8>>2]=c[Va+8>>2];c[Wa+12>>2]=c[Va+12>>2];Ya=Ya+1|0}while((Ya|0)!=(Kb|0))}Ya=Kb-Mb|0;if((Ya|0)<(Lb|0)){Ob=Nb;Pb=Ya;Qb=Lb;Rb=0}else{tb=(Lb|0)>0?Lb<<1:1;Ob=Zm(D,Nb,tb<<4)|0;Pb=Ya;Qb=tb;Rb=0}}else{Ob=Nb;Pb=Kb;Qb=Lb;Rb=Mb}c[Ob+(Pb<<4)>>2]=Ab;c[Ob+(Pb<<4)+4>>2]=Xa;c[Ob+(Pb<<4)+8>>2]=rb;c[Ob+(Pb<<4)+12>>2]=Db;Sb=Pb+1|0;Tb=Qb;Ub=Rb;Vb=Ob}else{Sb=Kb;Tb=Lb;Ub=Mb;Vb=Nb}if((Ab|
0)<((c[p>>2]|0)+-1|0)){tb=Ab+1|0;Ya=Cb+1|0;if((Sb|0)>=(Tb|0)){if((Ub|0)<(Sb|0)){sb=Ub;do{ub=Vb+(sb-Ub<<4)|0;Va=Vb+(sb<<4)|0;c[ub+0>>2]=c[Va+0>>2];c[ub+4>>2]=c[Va+4>>2];c[ub+8>>2]=c[Va+8>>2];c[ub+12>>2]=c[Va+12>>2];sb=sb+1|0}while((sb|0)!=(Sb|0))}sb=Sb-Ub|0;if((sb|0)<(Tb|0)){Wb=Vb;Xb=sb;Yb=Tb;Zb=0}else{rb=(Tb|0)>0?Tb<<1:1;Wb=Zm(D,Vb,rb<<4)|0;Xb=sb;Yb=rb;Zb=0}}else{Wb=Vb;Xb=Sb;Yb=Tb;Zb=Ub}c[Wb+(Xb<<4)>>2]=tb;c[Wb+(Xb<<4)+4>>2]=Bb;c[Wb+(Xb<<4)+8>>2]=Ya;c[Wb+(Xb<<4)+12>>2]=Db;_b=Xb+1|0;$b=Yb;ac=Zb;bc=
Wb}else{_b=Sb;$b=Tb;ac=Ub;bc=Vb}if((Bb|0)<((c[A>>2]|0)+-1|0)){rb=Bb+1|0;sb=(c[p>>2]|0)+Cb|0;if((_b|0)>=($b|0)){if((ac|0)<(_b|0)){Xa=ac;do{Va=bc+(Xa-ac<<4)|0;ub=bc+(Xa<<4)|0;c[Va+0>>2]=c[ub+0>>2];c[Va+4>>2]=c[ub+4>>2];c[Va+8>>2]=c[ub+8>>2];c[Va+12>>2]=c[ub+12>>2];Xa=Xa+1|0}while((Xa|0)!=(_b|0))}Xa=_b-ac|0;if((Xa|0)<($b|0)){cc=bc;dc=Xa;ec=$b;fc=0}else{Ya=($b|0)>0?$b<<1:1;cc=Zm(D,bc,Ya<<4)|0;dc=Xa;ec=Ya;fc=0}}else{cc=bc;dc=_b;ec=$b;fc=ac}c[cc+(dc<<4)>>2]=Ab;c[cc+(dc<<4)+4>>2]=rb;c[cc+(dc<<4)+8>>2]=sb;
c[cc+(dc<<4)+12>>2]=Db;gc=ec;hc=dc+1|0;ic=fc;jc=cc}else{gc=$b;hc=_b;ic=ac;jc=bc}if((ic|0)==(hc|0)){vb=jc;Fb=122;break}else{wb=gc;xb=hc;yb=ic;zb=jc}}if((Fb|0)==122){_m(D,vb);i=f;return}}function lk(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;e=i;f=b+20|0;g=c[f>>2]|0;if((g+-1|0)<=0){i=e;return}h=b+16|0;j=b+24|0;b=c[h>>2]|0;k=g;g=0;while(1){if((b+-1|0)>0){l=b;m=0;do{n=(aa(l,g)|0)+m|0;o=c[j>>2]|0;p=c[o+(n<<2)>>2]|0;q=n+1|0;r=c[o+(q<<2)>>2]|0;s=c[o+(n+l<<2)>>2]|
0;n=c[o+(q+l<<2)>>2]|0;do if((r|0)!=(s|0)){do if(!((p|0)==(r|0)|(p|0)==(s|0))){if(((a[p+12>>0]|0)==0?(a[r+12>>0]|0)==0:0)?(a[s+12>>0]|0)==0:0)break;pb[c[(c[d>>2]|0)+8>>2]&31](d,c[p+8>>2]|0,c[r+8>>2]|0,c[s+8>>2]|0)}while(0);if(!((n|0)==(r|0)|(n|0)==(s|0))){if(((a[r+12>>0]|0)==0?(a[n+12>>0]|0)==0:0)?(a[s+12>>0]|0)==0:0)break;pb[c[(c[d>>2]|0)+8>>2]&31](d,c[r+8>>2]|0,c[n+8>>2]|0,c[s+8>>2]|0)}}while(0);m=m+1|0;l=c[h>>2]|0}while((m|0)<(l+-1|0));t=c[f>>2]|0;u=l}else{t=k;u=b}g=g+1|0;if((g|0)>=(t+-1|0))break;
else{b=u;k=t}}i=e;return}function mk(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0;b=i;d=a+40|0;e=a+48|0;f=a+16|0;c[a+0>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;c[a+12>>2]=0;g[f>>2]=1;c[a+20>>2]=0;c[a+24>>2]=0;c[a+28>>2]=-1;g[a+32>>2]=0;g[a+36>>2]=0;f=8784;h=c[f+4>>2]|0;j=d;c[j>>2]=c[f>>2];c[j+4>>2]=h;h=8784;j=c[h+4>>2]|0;f=e;c[f>>2]=c[h>>2];c[f+4>>2]=j;j=a+56|0;f=a+72|0;c[j+0>>2]=0;c[j+4>>2]=0;c[j+8>>2]=0;c[j+12>>2]=0;g[f>>2]=1;c[a+76>>2]=0;i=b;return}function nk(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,
o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0;b=i;d=a+28|0;e=c[a>>2]|0;f=c[e+4>>2]|0;if((c[d>>2]|0)==(f|0)){i=b;return}h=+g[e+32>>2]*.75;j=h*+g[e+320>>2]*h;k=a+32|0;g[k>>2]=0;l=a+40|0;m=a+44|0;n=a+48|0;o=a+52|0;p=a+4|0;c[l+0>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;q=c[p>>2]|0;p=c[a+8>>2]|0;r=(q|0)<(p|0);if(r){s=c[e+96>>2]|0;t=c[e+104>>2]|0;h=0;u=0;v=0;w=0;x=0;y=q;do{h=j+h;g[k>>2]=h;z=j*+g[s+(y<<3)+4>>2];u=j*+g[s+(y<<3)>>2]+u;g[l>>2]=u;v=z+v;g[m>>2]=v;z=j*+g[t+(y<<
3)+4>>2];w=j*+g[t+(y<<3)>>2]+w;g[n>>2]=w;x=z+x;g[o>>2]=x;y=y+1|0}while((y|0)<(p|0));if(h>0){z=1/h;A=z*u;g[l>>2]=A;B=z*v;g[m>>2]=B;z=1/h;h=z*w;g[n>>2]=h;C=z*x;g[o>>2]=C;D=A;E=B;F=h;G=C}else{D=u;E=v;F=w;G=x}o=a+36|0;g[o>>2]=0;n=a+56|0;g[n>>2]=0;if(r){r=c[e+96>>2]|0;m=c[e+104>>2]|0;x=0;w=0;e=q;do{v=+g[r+(e<<3)>>2]-D;u=+g[r+(e<<3)+4>>2]-E;C=+g[m+(e<<3)>>2]-F;h=+g[m+(e<<3)+4>>2]-G;x=j*(v*v+u*u)+x;g[o>>2]=x;w=w+j*(v*h-u*C);g[n>>2]=w;e=e+1|0}while((e|0)<(p|0));if(x>0)g[n>>2]=1/x*w}}else{g[a+36>>2]=0;g[a+
56>>2]=0}c[d>>2]=f;i=b;return}function ok(a,b){a=a|0;b=b|0;var d=0;d=i;nl(c[a>>2]|0,c[a+4>>2]|0,c[a+8>>2]|0,b);i=d;return}function pk(a,b){a=a|0;b=b|0;var d=0;d=i;ol(c[a>>2]|0,c[a+4>>2]|0,c[a+8>>2]|0,b);i=d;return}function qk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;e=c[a>>2]|0;if((c[(c[e+400>>2]|0)+102876>>2]&2|0)!=0){i=d;return}f=c[a+4>>2]|0;g=a+8|0;if((f|0)<(c[g>>2]|0)){h=e;j=f}else{i=d;return}while(1){Bk(h,j,b);f=j+1|0;if((f|0)>=(c[g>>2]|0))break;h=c[a>>2]|0;j=f}i=d;return}function rk(b,
d,e){b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;f=i;h=b+52|0;c[b+56>>2]=h;c[h>>2]=h;c[b+60>>2]=256;h=b+64|0;c[b+68>>2]=h;c[h>>2]=h;h=b+72|0;c[b+76>>2]=h;c[h>>2]=h;h=b+80|0;c[b+136>>2]=0;c[b+140>>2]=0;c[b+148>>2]=0;c[b+152>>2]=0;j=b+160|0;k=b+196|0;c[h+0>>2]=0;c[h+4>>2]=0;c[h+8>>2]=0;c[h+12>>2]=0;c[h+16>>2]=0;c[h+20>>2]=0;c[h+24>>2]=0;c[h+28>>2]=0;h=j+0|0;j=h+36|0;do{c[h>>2]=0;h=h+4|0}while((h|0)<(j|0));c[k>>2]=e;c[b+200>>2]=0;c[b+204>>2]=0;c[b+208>>2]=0;c[b+212>>2]=e;c[b+216>>
2]=0;c[b+220>>2]=0;c[b+224>>2]=0;c[b+228>>2]=e;c[b+232>>2]=0;c[b+236>>2]=0;c[b+240>>2]=0;c[b+244>>2]=e;c[b+248>>2]=0;c[b+252>>2]=0;c[b+256>>2]=0;c[b+260>>2]=e;c[b+264>>2]=0;c[b+268>>2]=0;c[b+272>>2]=0;c[b+276>>2]=e;k=b+280|0;l=b+316|0;a[l>>0]=0;m=b+320|0;c[k+0>>2]=0;c[k+4>>2]=0;c[k+8>>2]=0;c[k+12>>2]=0;g[m>>2]=1;n=b+324|0;g[n>>2]=1;g[b+328>>2]=1;o=b+332|0;c[o>>2]=0;g[b+336>>2]=.05000000074505806;g[b+340>>2]=1;g[b+344>>2]=.25;g[b+348>>2]=.25;g[b+352>>2]=.25;g[b+356>>2]=.20000000298023224;g[b+360>>
2]=.20000000298023224;g[b+364>>2]=1;g[b+368>>2]=.5;g[b+372>>2]=.5;g[b+376>>2]=.20000000298023224;g[b+380>>2]=.20000000298023224;c[b+384>>2]=8;g[b+388>>2]=.5;p=b+392|0;a[p>>0]=1;g[b+396>>2]=.01666666753590107;a[b>>0]=0;c[b+4>>2]=0;c[b+8>>2]=0;a[b+12>>0]=0;c[b+16>>2]=0;a[b+20>>0]=0;a[b+21>>0]=0;c[b+24>>2]=0;a[l>>0]=a[d>>0]|0;q=+g[d+4>>2];g[m>>2]=q;g[b+28>>2]=1/q;g[n>>2]=+g[d+8>>2];q=+g[d+12>>2]*2;g[b+32>>2]=q;g[b+40>>2]=q*q;g[b+36>>2]=1/q;c[o>>2]=c[d+16>>2];c[b+44>>2]=0;o=b+48|0;c[o>>2]=0;n=b+112|0;
c[b+144>>2]=0;c[b+308>>2]=0;c[b+312>>2]=0;c[n+0>>2]=0;c[n+4>>2]=0;c[n+8>>2]=0;c[n+12>>2]=0;c[n+16>>2]=0;c[n+20>>2]=0;h=l+0|0;l=d+0|0;j=h+84|0;do{c[h>>2]=c[l>>2];h=h+4|0;l=l+4|0}while((h|0)<(j|0));l=b+400|0;c[l>>2]=e;c[b+156>>2]=0;e=b+296|0;c[e>>2]=0;c[e+4>>2]=0;a[b+304>>0]=0;e=a[p>>0]|0;if(e<<24>>24==0){a[p>>0]=e;i=f;return}h=c[k>>2]|0;if((h|0)==0){vk(b,256);b=Em(c[l>>2]|0,c[o>>2]<<2)|0;xn(b|0,0,c[o>>2]<<2|0)|0;r=b}else r=h;c[k>>2]=r;a[p>>0]=e;i=f;return}function sk(a){a=a|0;var b=0,d=0,e=0,f=0,g=
0;b=i;d=a+312|0;while(1){e=c[d>>2]|0;if((e|0)==0)break;tk(a,e)}if((c[a+84>>2]|0)==0?(d=a+80|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+92>>2]|0)==0?(d=a+88|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+164>>2]|0)==0?(d=a+160|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+172>>2]|0)==0?(d=a+168|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+180>>2]|0)==0?(d=a+176|0,e=
c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+100>>2]|0)==0?(d=a+96|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<3);c[d>>2]=0}if((c[a+108>>2]|0)==0?(d=a+104|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<3);c[d>>2]=0}if((c[a+140>>2]|0)==0?(d=a+136|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+152>>2]|0)==0?(d=a+148|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+284>>2]|0)==0?(d=a+
280|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+292>>2]|0)==0?(d=a+288|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}d=a+112|0;e=a+48|0;f=c[d>>2]|0;if((f|0)!=0){Fm(c[a+400>>2]|0,f,c[e>>2]<<3);c[d>>2]=0}d=a+116|0;f=c[d>>2]|0;if((f|0)!=0){Fm(c[a+400>>2]|0,f,c[e>>2]<<2);c[d>>2]=0}d=a+120|0;f=c[d>>2]|0;if((f|0)!=0){Fm(c[a+400>>2]|0,f,c[e>>2]<<2);c[d>>2]=0}d=a+124|0;f=c[d>>2]|0;if((f|0)!=0){Fm(c[a+400>>2]|0,f,c[e>>2]<<2);c[d>>2]=0}d=a+128|0;f=
c[d>>2]|0;if((f|0)!=0){Fm(c[a+400>>2]|0,f,c[e>>2]<<3);c[d>>2]=0}d=a+132|0;f=c[d>>2]|0;if((f|0)!=0){Fm(c[a+400>>2]|0,f,c[e>>2]<<2);c[d>>2]=0}d=a+144|0;f=c[d>>2]|0;if((f|0)!=0){Fm(c[a+400>>2]|0,f,c[e>>2]<<2);c[d>>2]=0}d=a+264|0;e=c[d>>2]|0;if((e|0)!=0){f=a+272|0;Fm(c[a+276>>2]|0,e,(c[f>>2]|0)*60|0);c[d>>2]=0;c[f>>2]=0;c[a+268>>2]=0}f=a+248|0;d=c[f>>2]|0;if((d|0)!=0){e=a+256|0;Fm(c[a+260>>2]|0,d,(c[e>>2]|0)*20|0);c[f>>2]=0;c[e>>2]=0;c[a+252>>2]=0}e=a+232|0;f=c[e>>2]|0;if((f|0)!=0){d=a+240|0;Fm(c[a+244>>
2]|0,f,(c[d>>2]|0)*28|0);c[e>>2]=0;c[d>>2]=0;c[a+236>>2]=0}d=a+216|0;e=c[d>>2]|0;if((e|0)!=0){f=a+224|0;Fm(c[a+228>>2]|0,e,(c[f>>2]|0)*24|0);c[d>>2]=0;c[f>>2]=0;c[a+220>>2]=0}f=a+200|0;d=c[f>>2]|0;if((d|0)!=0){e=a+208|0;Fm(c[a+212>>2]|0,d,c[e>>2]<<3);c[f>>2]=0;c[e>>2]=0;c[a+204>>2]=0}e=a+184|0;f=c[e>>2]|0;if((f|0)==0){g=a+52|0;Tl(g);i=b;return}d=a+192|0;Fm(c[a+196>>2]|0,f,c[d>>2]<<2);c[e>>2]=0;c[d>>2]=0;c[a+188>>2]=0;g=a+52|0;Tl(g);i=b;return}function tk(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=
0,l=0,m=0,n=0,o=0;e=i;f=b+400|0;g=c[(c[f>>2]|0)+102992>>2]|0;if((g|0)!=0)gb[c[(c[g>>2]|0)+16>>2]&63](g,d);g=d+12|0;h=c[g>>2]|0;j=h<<4;k=j&16;if((((j|-17)^16)&h|0)!=0)a[b+20>>0]=1;h=b+16|0;j=c[h>>2]|0;if((k&~j|0)!=0)c[h>>2]=j|k;c[g>>2]=k;k=c[d+4>>2]|0;g=c[d+8>>2]|0;if((k|0)<(g|0)){j=b+144|0;h=k;do{c[(c[j>>2]|0)+(h<<2)>>2]=0;h=h+1|0}while((h|0)<(g|0))}g=d+20|0;h=c[g>>2]|0;j=d+24|0;if((h|0)!=0)c[h+24>>2]=c[j>>2];h=c[j>>2]|0;if((h|0)!=0)c[h+20>>2]=c[g>>2];g=b+312|0;if((c[g>>2]|0)!=(d|0)){l=b+308|0;m=
c[l>>2]|0;n=m+-1|0;c[l>>2]=n;o=c[f>>2]|0;Fm(o,d,80);i=e;return}c[g>>2]=c[j>>2];l=b+308|0;m=c[l>>2]|0;n=m+-1|0;c[l>>2]=n;o=c[f>>2]|0;Fm(o,d,80);i=e;return}function uk(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;b=i;d=a+136|0;e=c[d>>2]|0;if((e|0)!=0){f=e;c[d>>2]=f;i=b;return f|0}e=a+48|0;g=c[e>>2]|0;if((g|0)==0){vk(a,256);h=c[e>>2]|0}else h=g;g=Em(c[a+400>>2]|0,h<<2)|0;xn(g|0,0,c[e>>2]<<2|0)|0;f=g;c[d>>2]=f;i=b;return f|0}function vk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,
r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0;d=i;e=c[a+332>>2]|0;if((e|0)==0)f=b;else f=(e|0)<(b|0)?e:b;b=a+92|0;e=c[b>>2]|0;if((e|0)==0)g=f;else g=(f|0)>(e|0)?e:f;f=a+100|0;e=c[f>>2]|0;if((e|0)==0)h=g;else h=(g|0)>(e|0)?e:g;g=a+108|0;e=c[g>>2]|0;if((e|0)==0)j=h;else j=(h|0)>(e|0)?e:h;h=a+140|0;e=c[h>>2]|0;if((e|0)==0)k=j;else k=(j|0)>(e|0)?e:j;j=a+152|0;e=c[j>>2]|0;if((e|0)==0)l=k;else l=(k|0)>(e|0)?e:k;k=a+48|0;e=c[k>>2]|0;if((e|0)>=(l|0)){i=d;return}m=a+80|0;n=c[m>>2]|0;o=(n|
0)==0;if((c[a+84>>2]|0)==0&(o^1)){p=a+400|0;q=Em(c[p>>2]|0,l<<2)|0;if(o)r=q;else{o=e<<2;An(q|0,n|0,o|0)|0;Fm(c[p>>2]|0,n,o);r=q}}else r=n;c[m>>2]=r;r=c[k>>2]|0;c[a+60>>2]=l-r;m=a+88|0;n=c[m>>2]|0;if((c[b>>2]|0)==0){b=a+400|0;q=Em(c[b>>2]|0,l<<2)|0;if((n|0)==0)s=q;else{o=r<<2;An(q|0,n|0,o|0)|0;Fm(c[b>>2]|0,n,o);s=q}}else s=n;c[m>>2]=s;s=(c[a+156>>2]|0)>0;m=c[k>>2]|0;n=a+160|0;q=c[n>>2]|0;o=(q|0)==0;if((c[a+164>>2]|0)==0&(o&s^1)){b=a+400|0;r=Em(c[b>>2]|0,l<<2)|0;if(o)t=r;else{o=m<<2;An(r|0,q|0,o|0)|
0;Fm(c[b>>2]|0,q,o);t=r}}else t=q;c[n>>2]=t;t=c[k>>2]|0;n=a+168|0;q=c[n>>2]|0;r=(q|0)==0;if((c[a+172>>2]|0)==0&(r&s^1)){o=a+400|0;b=Em(c[o>>2]|0,l<<2)|0;if(r)u=b;else{r=t<<2;An(b|0,q|0,r|0)|0;Fm(c[o>>2]|0,q,r);u=b}}else u=q;c[n>>2]=u;u=c[k>>2]|0;n=a+176|0;q=c[n>>2]|0;b=(q|0)==0;if((c[a+180>>2]|0)==0&(b&s^1)){s=a+400|0;r=Em(c[s>>2]|0,l<<2)|0;if(b)v=r;else{b=u<<2;An(r|0,q|0,b|0)|0;Fm(c[s>>2]|0,q,b);v=r}}else v=q;c[n>>2]=v;v=c[k>>2]|0;n=a+96|0;q=c[n>>2]|0;if((c[f>>2]|0)==0){f=a+400|0;r=Em(c[f>>2]|0,
l<<3)|0;if((q|0)==0)w=r;else{b=v<<3;An(r|0,q|0,b|0)|0;Fm(c[f>>2]|0,q,b);w=r}}else w=q;c[n>>2]=w;w=c[k>>2]|0;n=a+104|0;q=c[n>>2]|0;if((c[g>>2]|0)==0){g=a+400|0;r=l<<3;b=Em(c[g>>2]|0,r)|0;if((q|0)==0){x=b;y=r;z=g}else{f=w<<3;An(b|0,q|0,f|0)|0;Fm(c[g>>2]|0,q,f);x=b;y=r;z=g}}else{x=q;y=l<<3;z=a+400|0}c[n>>2]=x;x=a+112|0;n=c[x>>2]|0;q=c[k>>2]|0;g=Em(c[z>>2]|0,y)|0;if((n|0)!=0){r=q<<3;An(g|0,n|0,r|0)|0;Fm(c[z>>2]|0,n,r)}c[x>>2]=g;g=a+116|0;x=c[g>>2]|0;r=c[k>>2]|0;n=l<<2;q=Em(c[z>>2]|0,n)|0;if((x|0)!=0){b=
r<<2;An(q|0,x|0,b|0)|0;Fm(c[z>>2]|0,x,b)}c[g>>2]=q;q=a+120|0;g=c[q>>2]|0;if((g|0)==0)A=0;else{b=c[k>>2]|0;x=Em(c[z>>2]|0,n)|0;r=b<<2;An(x|0,g|0,r|0)|0;Fm(c[z>>2]|0,g,r);A=x}c[q>>2]=A;A=a+124|0;q=c[A>>2]|0;x=c[k>>2]|0;r=Em(c[z>>2]|0,n)|0;if((q|0)!=0){g=x<<2;An(r|0,q|0,g|0)|0;Fm(c[z>>2]|0,q,g)}c[A>>2]=r;r=a+128|0;A=c[r>>2]|0;if((A|0)==0)B=0;else{g=c[k>>2]|0;q=Em(c[z>>2]|0,y)|0;y=g<<3;An(q|0,A|0,y|0)|0;Fm(c[z>>2]|0,A,y);B=q}c[r>>2]=B;B=a+132|0;r=c[B>>2]|0;if((r|0)==0)C=0;else{q=c[k>>2]|0;y=Em(c[z>>2]|
0,n)|0;A=q<<2;An(y|0,r|0,A|0)|0;Fm(c[z>>2]|0,r,A);C=y}c[B>>2]=C;C=c[k>>2]|0;B=a+136|0;y=c[B>>2]|0;A=(y|0)==0;do if((c[h>>2]|0)==0&(A^1)){r=Em(c[z>>2]|0,n)|0;if(A){D=r;break}q=C<<2;An(r|0,y|0,q|0)|0;Fm(c[z>>2]|0,y,q);D=r}else D=y;while(0);c[B>>2]=D;D=a+144|0;B=c[D>>2]|0;y=c[k>>2]|0;C=Em(c[z>>2]|0,n)|0;if((B|0)!=0){A=y<<2;An(C|0,B|0,A|0)|0;Fm(c[z>>2]|0,B,A)}c[D>>2]=C;C=c[k>>2]|0;D=a+148|0;A=c[D>>2]|0;B=(A|0)==0;do if((c[j>>2]|0)==0&(B^1)){y=Em(c[z>>2]|0,n)|0;if(B){E=y;break}h=C<<2;An(y|0,A|0,h|0)|0;
Fm(c[z>>2]|0,A,h);E=y}else E=A;while(0);c[D>>2]=E;E=c[k>>2]|0;D=a+280|0;A=c[D>>2]|0;C=(A|0)==0;do if((c[a+284>>2]|0)==0&(C^1)){B=Em(c[z>>2]|0,n)|0;if(C){F=B;break}j=E<<2;An(B|0,A|0,j|0)|0;Fm(c[z>>2]|0,A,j);F=B}else F=A;while(0);c[D>>2]=F;F=c[k>>2]|0;D=a+288|0;A=c[D>>2]|0;E=(A|0)==0;do if((c[a+292>>2]|0)==0&(E^1)){C=Em(c[z>>2]|0,n)|0;if(E){G=C;break}B=F<<2;An(C|0,A|0,B|0)|0;Fm(c[z>>2]|0,A,B);G=C}else G=A;while(0);c[D>>2]=G;c[k>>2]=l;i=d;return}function wk(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=
0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;e=i;f=b+400|0;if((c[(c[f>>2]|0)+102876>>2]&2|0)!=0){h=0;i=e;return h|0}j=b+44|0;k=c[j>>2]|0;l=b+48|0;m=c[l>>2]|0;if((k|0)<(m|0)){n=k;o=m}else{vk(b,(k|0)==0?256:k<<1);n=c[j>>2]|0;o=c[l>>2]|0}do if((n|0)>=(o|0))if((a[b+392>>0]|0)==0){h=-1;i=e;return h|0}else{k=c[b+288>>2]|0;m=c[k+(n+-1<<2)>>2]|0;p=+(c[(c[b+280>>2]|0)+(m<<2)>>2]|0)>0?m:c[k>>2]|0;k=b+88|0;Ak(b,p,c[(c[k>>2]|0)+(p<<2)>>2]|2);xk(b);q=k;r=c[j>>2]|0;break}else{q=b+88|0;r=n}while(0);
n=r+1|0;c[j>>2]=n;c[(c[q>>2]|0)+(r<<2)>>2]=0;q=c[b+160>>2]|0;if((q|0)!=0)c[q+(r<<2)>>2]=0;q=c[b+168>>2]|0;if((q|0)!=0)c[q+(r<<2)>>2]=0;q=c[b+176>>2]|0;if((q|0)!=0)c[q+(r<<2)>>2]=0;q=d+4|0;j=c[q+4>>2]|0;o=(c[b+96>>2]|0)+(r<<3)|0;c[o>>2]=c[q>>2];c[o+4>>2]=j;j=d+12|0;o=c[j+4>>2]|0;q=(c[b+104>>2]|0)+(r<<3)|0;c[q>>2]=c[j>>2];c[q+4>>2]=o;g[(c[b+116>>2]|0)+(r<<2)>>2]=0;o=8784;q=c[o+4>>2]|0;j=(c[b+112>>2]|0)+(r<<3)|0;c[j>>2]=c[o>>2];c[j+4>>2]=q;q=c[b+120>>2]|0;if((q|0)!=0)g[q+(r<<2)>>2]=0;q=c[b+132>>2]|0;
if((q|0)!=0)g[q+(r<<2)>>2]=0;q=b+136|0;j=c[q>>2]|0;o=d+20|0;do if((j|0)==0){if((((a[o>>0]|0)==0?(a[d+21>>0]|0)==0:0)?(a[d+22>>0]|0)==0:0)?(a[d+23>>0]|0)==0:0)break;k=c[l>>2]|0;if((k|0)==0){vk(b,256);s=c[l>>2]|0}else s=k;k=Em(c[f>>2]|0,s<<2)|0;xn(k|0,0,c[l>>2]<<2|0)|0;t=k;u=26}else{t=j;u=26}while(0);if((u|0)==26){c[q>>2]=t;q=a[d+21>>0]|0;j=a[d+22>>0]|0;s=a[d+23>>0]|0;a[t+(r<<2)>>0]=a[o>>0]|0;a[t+(r<<2)+1>>0]=q;a[t+(r<<2)+2>>0]=j;a[t+(r<<2)+3>>0]=s}s=b+148|0;t=c[s>>2]|0;j=d+28|0;if((t|0)==0){if((c[j>>
2]|0)!=0){q=c[l>>2]|0;if((q|0)==0){vk(b,256);v=c[l>>2]|0}else v=q;q=Em(c[f>>2]|0,v<<2)|0;xn(q|0,0,c[l>>2]<<2|0)|0;w=q;u=32}}else{w=t;u=32}if((u|0)==32){c[s>>2]=w;c[w+(r<<2)>>2]=c[j>>2]}j=c[b+80>>2]|0;if((j|0)!=0)c[j+(r<<2)>>2]=0;j=b+200|0;w=b+204|0;s=c[w>>2]|0;u=b+208|0;t=c[u>>2]|0;if((s|0)>=(t|0)?(q=(t|0)==0?256:t<<1,(t|0)<(q|0)):0){t=b+212|0;l=Em(c[t>>2]|0,q<<3)|0;v=c[j>>2]|0;if((v|0)!=0){An(l|0,v|0,c[w>>2]<<3|0)|0;Fm(c[t>>2]|0,c[j>>2]|0,c[u>>2]<<3)}c[u>>2]=q;c[j>>2]=l;x=c[w>>2]|0}else x=s;c[w>>
2]=x+1;w=c[j>>2]|0;y=+g[d+24>>2];j=y>0;if((c[b+280>>2]|0)!=0|j){if(j)z=y;else{j=c[b+300>>2]|0;z=+g[b+396>>2]*+(((j|0)<0?0-j|0:0)-j|0)}yk(b,r,z);c[(c[b+288>>2]|0)+(r<<2)>>2]=r}c[w+(x<<3)>>2]=r;x=c[d+32>>2]|0;c[(c[b+144>>2]|0)+(r<<2)>>2]=x;do if((x|0)!=0){w=x+4|0;j=c[w>>2]|0;s=x+8|0;l=c[s>>2]|0;if((j|0)<(l|0)){zk(b,j,l,r);c[s>>2]=n;break}else{c[w>>2]=r;c[s>>2]=n;break}}while(0);Ak(b,r,c[d>>2]|0);h=r;i=e;return h|0}function xk(b){b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,
u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0;d=i;e=b+400|0;f=b+44|0;h=Ym((c[e>>2]|0)+76|0,c[f>>2]<<2)|0;if((c[f>>2]|0)>0){j=b+88|0;k=b+80|0;l=b+160|0;m=b+168|0;n=b+176|0;o=b+96|0;p=b+104|0;q=b+144|0;r=b+21|0;s=b+120|0;t=b+132|0;u=b+136|0;v=b+148|0;w=b+280|0;x=b+112|0;y=b+64|0;z=0;A=0;B=0;while(1){C=
c[j>>2]|0;D=c[C+(A<<2)>>2]|0;if((D&2|0)==0){c[h+(A<<2)>>2]=B;if((A|0)!=(B|0)){E=c[k>>2]|0;if((E|0)==0)F=C;else{C=c[E+(A<<2)>>2]|0;if((C|0)!=0)c[C+8>>2]=B;c[E+(B<<2)>>2]=C;F=c[j>>2]|0}c[F+(B<<2)>>2]=c[F+(A<<2)>>2];C=c[l>>2]|0;if((C|0)!=0)c[C+(B<<2)>>2]=c[C+(A<<2)>>2];C=c[m>>2]|0;if((C|0)!=0)c[C+(B<<2)>>2]=c[C+(A<<2)>>2];C=c[n>>2]|0;if((C|0)!=0)c[C+(B<<2)>>2]=c[C+(A<<2)>>2];C=c[o>>2]|0;E=C+(A<<3)|0;G=c[E+4>>2]|0;H=C+(B<<3)|0;c[H>>2]=c[E>>2];c[H+4>>2]=G;G=c[p>>2]|0;H=G+(A<<3)|0;E=c[H+4>>2]|0;C=G+(B<<
3)|0;c[C>>2]=c[H>>2];c[C+4>>2]=E;E=c[q>>2]|0;c[E+(B<<2)>>2]=c[E+(A<<2)>>2];if((a[r>>0]|0)!=0){E=c[x>>2]|0;C=E+(A<<3)|0;H=c[C+4>>2]|0;G=E+(B<<3)|0;c[G>>2]=c[C>>2];c[G+4>>2]=H}H=c[s>>2]|0;if((H|0)!=0)g[H+(B<<2)>>2]=+g[H+(A<<2)>>2];H=c[t>>2]|0;if((H|0)!=0)g[H+(B<<2)>>2]=+g[H+(A<<2)>>2];H=c[u>>2]|0;if((H|0)!=0){G=a[H+(A<<2)+1>>0]|0;C=a[H+(A<<2)+2>>0]|0;E=a[H+(A<<2)+3>>0]|0;a[H+(B<<2)>>0]=a[H+(A<<2)>>0]|0;a[H+(B<<2)+1>>0]=G;a[H+(B<<2)+2>>0]=C;a[H+(B<<2)+3>>0]=E}E=c[v>>2]|0;if((E|0)!=0)c[E+(B<<2)>>2]=c[E+
(A<<2)>>2];E=c[w>>2]|0;if((E|0)!=0)c[E+(B<<2)>>2]=c[E+(A<<2)>>2]}I=D|z;J=B+1|0}else{E=c[(c[e>>2]|0)+102992>>2]|0;if(!((D&512|0)==0|(E|0)==0))ib[c[(c[E>>2]|0)+20>>2]&7](E,b,A);E=c[k>>2]|0;if((E|0)!=0?(D=E+(A<<2)|0,E=c[D>>2]|0,(E|0)!=0):0){c[E+8>>2]=-1;c[D>>2]=0;Bm(y,E)}c[h+(A<<2)>>2]=-1;I=z;J=B}A=A+1|0;if((A|0)>=(c[f>>2]|0)){K=I;L=J;break}else{z=I;B=J}}}else{K=0;L=0}J=b+204|0;B=c[J>>2]|0;I=b+200|0;z=c[I>>2]|0;if((B|0)>0){A=0;do{y=z+(A<<3)|0;c[y>>2]=c[h+(c[y>>2]<<2)>>2];A=A+1|0;y=c[J>>2]|0}while((A|
0)<(y|0));M=y}else M=B;B=z+(M<<3)|0;a:do if((M|0)==0){N=z;O=40}else{A=z;while(1){if((c[A>>2]|0)<0){N=A;O=40;break a}A=A+8|0;if((A|0)==(B|0)){P=B;Q=z;break}}}while(0);if((O|0)==40)if((N|0)==(B|0)){P=B;Q=z}else{z=N;M=N;b:while(1){N=M;do{N=N+8|0;if((N|0)==(B|0))break b}while((c[N>>2]|0)<0);A=N;y=c[A+4>>2]|0;k=z;c[k>>2]=c[A>>2];c[k+4>>2]=y;z=z+8|0;M=N}P=z;Q=c[I>>2]|0}c[J>>2]=P-Q>>3;Q=b+220|0;P=c[Q>>2]|0;J=b+216|0;I=c[J>>2]|0;if((P|0)>0){z=0;do{M=I+(z*24|0)|0;B=I+(z*24|0)+4|0;y=c[h+(c[B>>2]<<2)>>2]|0;
c[M>>2]=c[h+(c[M>>2]<<2)>>2];c[B>>2]=y;z=z+1|0;y=c[Q>>2]|0}while((z|0)<(y|0));R=y}else R=P;P=I+(R*24|0)|0;c:do if((R|0)==0){S=I;O=52}else{z=I;while(1){if((c[z>>2]|0)<0){S=z;O=52;break c}if((c[z+4>>2]|0)<0){S=z;O=52;break c}z=z+24|0;if((z|0)==(P|0)){T=P;U=I;break}}}while(0);if((O|0)==52)if((S|0)==(P|0)){T=P;U=I}else{I=S+24|0;d:do if((I|0)==(P|0))V=S;else{R=S;z=I;N=S;while(1){y=z;B=N;while(1){if((c[y>>2]|0)>=0?(c[B+28>>2]|0)>=0:0)break;M=y+24|0;if((M|0)==(P|0)){V=R;break d}else{k=y;y=M;B=k}}c[R+0>>
2]=c[y+0>>2];c[R+4>>2]=c[y+4>>2];c[R+8>>2]=c[y+8>>2];c[R+12>>2]=c[y+12>>2];c[R+16>>2]=c[y+16>>2];c[R+20>>2]=c[y+20>>2];B=R+24|0;z=y+24|0;if((z|0)==(P|0)){V=B;break}else{R=B;N=y}}}while(0);T=V;U=c[J>>2]|0}c[Q>>2]=(T-U|0)/24|0;U=b+236|0;T=c[U>>2]|0;Q=b+232|0;J=c[Q>>2]|0;if((T|0)>0){V=0;do{P=J+(V*28|0)|0;c[P>>2]=c[h+(c[P>>2]<<2)>>2];V=V+1|0;P=c[U>>2]|0}while((V|0)<(P|0));W=P}else W=T;T=J+(W*28|0)|0;e:do if((W|0)==0){X=J;O=65}else{V=J;while(1){if((c[V>>2]|0)<0){X=V;O=65;break e}V=V+28|0;if((V|0)==(T|
0)){Y=T;Z=J;break}}}while(0);if((O|0)==65)if((X|0)==(T|0)){Y=T;Z=J}else{J=X;W=X;f:while(1){X=W;do{X=X+28|0;if((X|0)==(T|0))break f}while((c[X>>2]|0)<0);c[J+0>>2]=c[X+0>>2];c[J+4>>2]=c[X+4>>2];c[J+8>>2]=c[X+8>>2];c[J+12>>2]=c[X+12>>2];c[J+16>>2]=c[X+16>>2];c[J+20>>2]=c[X+20>>2];c[J+24>>2]=c[X+24>>2];J=J+28|0;W=X}Y=J;Z=c[Q>>2]|0}c[U>>2]=(Y-Z|0)/28|0;Z=b+252|0;Y=c[Z>>2]|0;U=b+248|0;Q=c[U>>2]|0;if((Y|0)>0){J=0;do{W=Q+(J*20|0)|0;c[W>>2]=c[h+(c[W>>2]<<2)>>2];W=Q+(J*20|0)+4|0;c[W>>2]=c[h+(c[W>>2]<<2)>>2];
J=J+1|0;W=c[Z>>2]|0}while((J|0)<(W|0));_=W}else _=Y;Y=Q+(_*20|0)|0;g:do if((_|0)==0){$=Q;O=77}else{J=Q;while(1){if((c[J>>2]|0)<0){$=J;O=77;break g}if((c[J+4>>2]|0)<0){$=J;O=77;break g}J=J+20|0;if((J|0)==(Y|0)){aa=Y;ba=Q;break}}}while(0);if((O|0)==77)if(($|0)==(Y|0)){aa=Y;ba=Q}else{Q=$+20|0;h:do if((Q|0)==(Y|0))ca=$;else{_=$;J=Q;X=$;while(1){W=J;T=X;while(1){if((c[W>>2]|0)>=0?(c[T+24>>2]|0)>=0:0)break;V=W+20|0;if((V|0)==(Y|0)){ca=_;break h}else{P=W;W=V;T=P}}c[_+0>>2]=c[W+0>>2];c[_+4>>2]=c[W+4>>2];
c[_+8>>2]=c[W+8>>2];c[_+12>>2]=c[W+12>>2];c[_+16>>2]=c[W+16>>2];T=_+20|0;J=W+20|0;if((J|0)==(Y|0)){ca=T;break}else{_=T;X=W}}}while(0);aa=ca;ba=c[U>>2]|0}c[Z>>2]=(aa-ba|0)/20|0;ba=b+268|0;aa=c[ba>>2]|0;Z=b+264|0;U=c[Z>>2]|0;if((aa|0)>0){ca=0;do{Y=U+(ca*60|0)|0;c[Y>>2]=c[h+(c[Y>>2]<<2)>>2];Y=U+(ca*60|0)+4|0;c[Y>>2]=c[h+(c[Y>>2]<<2)>>2];Y=U+(ca*60|0)+8|0;c[Y>>2]=c[h+(c[Y>>2]<<2)>>2];ca=ca+1|0;Y=c[ba>>2]|0}while((ca|0)<(Y|0));da=Y}else da=aa;aa=U+(da*60|0)|0;i:do if((da|0)==0){ea=U;O=92}else{ca=U;while(1){if((c[ca>>
2]|0)<0){ea=ca;O=92;break i}if((c[ca+4>>2]|0)<0){ea=ca;O=92;break i}if((c[ca+8>>2]|0)<0){ea=ca;O=92;break i}ca=ca+60|0;if((ca|0)==(aa|0)){fa=aa;ga=U;break}}}while(0);if((O|0)==92)if((ea|0)==(aa|0)){fa=aa;ga=U}else{U=ea+60|0;j:do if((U|0)==(aa|0))ha=ea;else{O=ea;da=U;ca=ea;while(1){Y=da;$=ca;while(1){if(((c[Y>>2]|0)>=0?(c[$+64>>2]|0)>=0:0)?(c[$+68>>2]|0)>=0:0)break;Q=Y+60|0;if((Q|0)==(aa|0)){ha=O;break j}else{X=Y;Y=Q;$=X}}$=O+0|0;W=Y+0|0;X=$+60|0;do{c[$>>2]=c[W>>2];$=$+4|0;W=W+4|0}while(($|0)<(X|0));
W=O+60|0;da=Y+60|0;if((da|0)==(aa|0)){ha=W;break}else{O=W;ca=Y}}}while(0);fa=ha;ga=c[Z>>2]|0}c[ba>>2]=(fa-ga|0)/60|0;ga=c[b+288>>2]|0;if((ga|0)!=0?(fa=c[f>>2]|0,(fa|0)>0):0){ba=fa;fa=0;Z=0;while(1){ha=c[h+(c[ga+(fa<<2)>>2]<<2)>>2]|0;if((ha|0)==-1){ia=ba;ja=Z}else{c[ga+(Z<<2)>>2]=ha;ia=c[f>>2]|0;ja=Z+1|0}fa=fa+1|0;if((fa|0)>=(ia|0))break;else{ba=ia;Z=ja}}}ja=b+312|0;Z=c[ja>>2]|0;if((Z|0)!=0){ia=b+16|0;ba=b+132|0;fa=b+48|0;ga=b+20|0;ha=Z;do{Z=ha+4|0;aa=c[Z>>2]|0;ea=ha+8|0;U=c[ea>>2]|0;if((aa|0)<(U|
0)){ca=L;O=aa;aa=0;da=0;while(1){W=c[h+(O<<2)>>2]|0;if((W|0)>-1){$=W+1|0;ka=(ca|0)<(W|0)?ca:W;la=(aa|0)>($|0)?aa:$;ma=da}else{ka=ca;la=aa;ma=1}O=O+1|0;if((O|0)>=(U|0)){na=ka;oa=la;pa=ma;break}else{ca=ka;aa=la;da=ma}}}else{na=L;oa=0;pa=0}if((na|0)<(oa|0)){c[Z>>2]=na;c[ea>>2]=oa;if(pa?(da=ha+12|0,aa=c[da>>2]|0,(aa&1|0)!=0):0){ca=aa|16;aa=c[ia>>2]|0;if((ca&~aa|0)!=0){U=c[ba>>2]|0;if((U|0)==0){O=c[fa>>2]|0;if((O|0)==0){vk(b,256);qa=c[fa>>2]|0}else qa=O;O=Em(c[e>>2]|0,qa<<2)|0;xn(O|0,0,c[fa>>2]<<2|0)|
0;ra=O;sa=c[ia>>2]|0}else{ra=U;sa=aa}c[ba>>2]=ra;c[ia>>2]=sa|ca}c[da>>2]=ca}}else{c[Z>>2]=0;c[ea>>2]=0;ca=ha+12|0;da=c[ca>>2]|0;if((da&4|0)==0){aa=da|8;if(((da&-9^-9)&da|0)!=0)a[ga>>0]=1;U=c[ia>>2]|0;if((aa&~U|0)!=0){if((da&1|0)==0)ta=U;else{da=c[ba>>2]|0;if((da|0)==0){O=c[fa>>2]|0;if((O|0)==0){vk(b,256);ua=c[fa>>2]|0}else ua=O;O=Em(c[e>>2]|0,ua<<2)|0;xn(O|0,0,c[fa>>2]<<2|0)|0;va=O;wa=c[ia>>2]|0}else{va=da;wa=U}c[ba>>2]=va;ta=wa}c[ia>>2]=ta|aa}c[ca>>2]=aa}}ha=c[ha+24>>2]|0}while((ha|0)!=0)}c[f>>2]=
L;_m((c[e>>2]|0)+76|0,h);c[b+8>>2]=K;a[b+12>>0]=0;K=c[ja>>2]|0;if((K|0)==0){i=d;return}else xa=K;do{K=xa;xa=c[xa+24>>2]|0;if((c[K+12>>2]&8|0)!=0)tk(b,K)}while((xa|0)!=0);i=d;return}function yk(b,d,e){b=b|0;d=d|0;e=+e;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;f=i;h=b+288|0;j=c[h>>2]|0;k=(j|0)==0;l=b+280|0;m=c[l>>2]|0;if((m|0)==0){n=b+48|0;o=c[n>>2]|0;if((o|0)==0){vk(b,256);p=c[n>>2]|0}else p=o;o=Em(c[b+400>>2]|0,p<<2)|0;xn(o|0,0,c[n>>2]<<2|0)|0;q=o;r=c[h>>2]|0}else{q=m;r=j}c[l>>2]=
q;if((r|0)==0){q=b+48|0;j=c[q>>2]|0;if((j|0)==0){vk(b,256);s=c[q>>2]|0}else s=j;j=Em(c[b+400>>2]|0,s<<2)|0;xn(j|0,0,c[q>>2]<<2|0)|0;t=j}else t=r;c[h>>2]=t;if(k?(k=c[b+44>>2]|0,(k|0)>0):0){h=0;do{c[t+(h<<2)>>2]=h;h=h+1|0}while((h|0)!=(k|0))}k=~~(e/+g[b+396>>2]);if((k|0)>0)u=(c[b+300>>2]|0)+k|0;else u=k;k=(c[l>>2]|0)+(d<<2)|0;if((u|0)==(c[k>>2]|0)){i=f;return}c[k>>2]=u;a[b+304>>0]=1;i=f;return}function zk(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=
0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0;h=i;if((d|0)==(e|0)|(e|0)==(f|0)){i=h;return}j=c[b+88>>2]|0;k=j+(d<<2)|0;l=j+(e<<2)|0;m=j+(f<<2)|0;a:do if((d+1|0)!=(e|0)){if((e+1|0)==(f|0)){n=j+(f+-1<<2)|0;o=c[n>>2]|0;p=n-k|0;Bn(j+(f-(p>>2)<<2)|0,k|0,p|0)|0;c[k>>2]=o;break}o=l;p=o-k>>2;n=m;q=n-o>>2;if((p|0)==(q|
0)){o=k;r=l;while(1){s=c[o>>2]|0;c[o>>2]=c[r>>2];c[r>>2]=s;o=o+4|0;if((o|0)==(l|0))break a;else r=r+4|0}}else{t=p;u=q}while(1){r=(t|0)%(u|0)|0;if((r|0)==0)break;else{o=u;u=r;t=o}}if((u|0)!=0){q=p+-1|0;o=p+d|0;r=j+(u+d<<2)|0;do{s=r;r=r+-4|0;v=c[r>>2]|0;w=r;x=s+(q<<2)|0;while(1){c[w>>2]=c[x>>2];s=n-x>>2;if((p|0)<(s|0))y=x+(p<<2)|0;else y=j+(o-s<<2)|0;if((y|0)==(r|0))break;else{s=x;x=y;w=s}}c[x>>2]=v}while((r|0)!=(k|0))}}else{r=c[k>>2]|0;o=m-l|0;Bn(k|0,l|0,o|0)|0;c[j+((o>>2)+d<<2)>>2]=r}while(0);j=c[b+
160>>2]|0;b:do if((j|0)!=0){l=j+(d<<2)|0;k=j+(e<<2)|0;m=j+(f<<2)|0;if((d+1|0)==(e|0)){y=c[l>>2]|0;u=m-k|0;Bn(l|0,k|0,u|0)|0;c[j+((u>>2)+d<<2)>>2]=y;break}if((e+1|0)==(f|0)){y=j+(f+-1<<2)|0;u=c[y>>2]|0;t=y-l|0;Bn(j+(f-(t>>2)<<2)|0,l|0,t|0)|0;c[l>>2]=u;break}u=k;t=u-l>>2;y=m;m=y-u>>2;if((t|0)==(m|0)){u=l;r=k;while(1){o=c[u>>2]|0;c[u>>2]=c[r>>2];c[r>>2]=o;u=u+4|0;if((u|0)==(k|0))break b;else r=r+4|0}}else{z=t;A=m}while(1){r=(z|0)%(A|0)|0;if((r|0)==0)break;else{k=A;A=r;z=k}}if((A|0)!=0){m=t+-1|0;k=t+
d|0;r=j+(A+d<<2)|0;do{u=r;r=r+-4|0;o=c[r>>2]|0;p=r;n=u+(m<<2)|0;while(1){c[p>>2]=c[n>>2];u=y-n>>2;if((t|0)<(u|0))B=n+(t<<2)|0;else B=j+(k-u<<2)|0;if((B|0)==(r|0))break;else{u=n;n=B;p=u}}c[n>>2]=o}while((r|0)!=(l|0))}}while(0);B=c[b+168>>2]|0;c:do if((B|0)!=0){j=B+(d<<2)|0;A=B+(e<<2)|0;z=B+(f<<2)|0;if((d+1|0)==(e|0)){l=c[j>>2]|0;r=z-A|0;Bn(j|0,A|0,r|0)|0;c[B+((r>>2)+d<<2)>>2]=l;break}if((e+1|0)==(f|0)){l=B+(f+-1<<2)|0;r=c[l>>2]|0;k=l-j|0;Bn(B+(f-(k>>2)<<2)|0,j|0,k|0)|0;c[j>>2]=r;break}r=A;k=r-j>>2;
l=z;z=l-r>>2;if((k|0)==(z|0)){r=j;t=A;while(1){y=c[r>>2]|0;c[r>>2]=c[t>>2];c[t>>2]=y;r=r+4|0;if((r|0)==(A|0))break c;else t=t+4|0}}else{C=k;D=z}while(1){t=(C|0)%(D|0)|0;if((t|0)==0)break;else{A=D;D=t;C=A}}if((D|0)!=0){z=k+-1|0;A=k+d|0;t=B+(D+d<<2)|0;do{r=t;t=t+-4|0;y=c[t>>2]|0;m=t;p=r+(z<<2)|0;while(1){c[m>>2]=c[p>>2];r=l-p>>2;if((k|0)<(r|0))E=p+(k<<2)|0;else E=B+(A-r<<2)|0;if((E|0)==(t|0))break;else{r=p;p=E;m=r}}c[p>>2]=y}while((t|0)!=(j|0))}}while(0);E=c[b+176>>2]|0;d:do if((E|0)!=0){B=E+(d<<2)|
0;D=E+(e<<2)|0;C=E+(f<<2)|0;if((d+1|0)==(e|0)){j=c[B>>2]|0;t=C-D|0;Bn(B|0,D|0,t|0)|0;c[E+((t>>2)+d<<2)>>2]=j;break}if((e+1|0)==(f|0)){j=E+(f+-1<<2)|0;t=c[j>>2]|0;A=j-B|0;Bn(E+(f-(A>>2)<<2)|0,B|0,A|0)|0;c[B>>2]=t;break}t=D;A=t-B>>2;j=C;C=j-t>>2;if((A|0)==(C|0)){t=B;k=D;while(1){l=c[t>>2]|0;c[t>>2]=c[k>>2];c[k>>2]=l;t=t+4|0;if((t|0)==(D|0))break d;else k=k+4|0}}else{F=A;G=C}while(1){k=(F|0)%(G|0)|0;if((k|0)==0)break;else{D=G;G=k;F=D}}if((G|0)!=0){C=A+-1|0;D=A+d|0;k=E+(G+d<<2)|0;do{t=k;k=k+-4|0;l=c[k>>
2]|0;z=k;m=t+(C<<2)|0;while(1){c[z>>2]=c[m>>2];t=j-m>>2;if((A|0)<(t|0))H=m+(A<<2)|0;else H=E+(D-t<<2)|0;if((H|0)==(k|0))break;else{t=m;m=H;z=t}}c[m>>2]=l}while((k|0)!=(B|0))}}while(0);H=c[b+96>>2]|0;E=H+(d<<3)|0;G=H+(e<<3)|0;F=H+(f<<3)|0;e:do if((d+1|0)!=(e|0)){if((e+1|0)==(f|0)){B=H+(f+-1<<3)|0;k=B;D=c[k>>2]|0;A=c[k+4>>2]|0;k=B-E|0;Bn(H+(f-(k>>3)<<3)|0,E|0,k|0)|0;k=E;c[k>>2]=D;c[k+4>>2]=A;break}A=G;k=A-E>>3;D=F;B=D-A>>3;if((k|0)==(B|0)){A=E;j=G;while(1){C=A;z=c[C>>2]|0;y=c[C+4>>2]|0;C=j;p=c[C+4>>
2]|0;t=A;c[t>>2]=c[C>>2];c[t+4>>2]=p;p=j;c[p>>2]=z;c[p+4>>2]=y;A=A+8|0;if((A|0)==(G|0))break e;else j=j+8|0}}else{I=k;J=B}while(1){j=(I|0)%(J|0)|0;if((j|0)==0)break;else{A=J;J=j;I=A}}if((J|0)!=0){B=k+-1|0;A=k+d|0;j=H+(J+d<<3)|0;do{y=j;j=j+-8|0;p=j;z=c[p>>2]|0;t=c[p+4>>2]|0;p=j;C=y+(B<<3)|0;while(1){y=C;o=c[y+4>>2]|0;n=p;c[n>>2]=c[y>>2];c[n+4>>2]=o;o=D-C>>3;if((k|0)<(o|0))K=C+(k<<3)|0;else K=H+(A-o<<3)|0;if((K|0)==(j|0))break;else{o=C;C=K;p=o}}p=C;c[p>>2]=z;c[p+4>>2]=t}while((j|0)!=(E|0))}}else{j=
E;A=c[j>>2]|0;k=c[j+4>>2]|0;j=F-G|0;Bn(E|0,G|0,j|0)|0;D=H+((j>>3)+d<<3)|0;c[D>>2]=A;c[D+4>>2]=k}while(0);H=c[b+104>>2]|0;G=H+(d<<3)|0;E=H+(e<<3)|0;F=H+(f<<3)|0;f:do if((d+1|0)!=(e|0)){if((e+1|0)==(f|0)){K=H+(f+-1<<3)|0;J=K;I=c[J>>2]|0;k=c[J+4>>2]|0;J=K-G|0;Bn(H+(f-(J>>3)<<3)|0,G|0,J|0)|0;J=G;c[J>>2]=I;c[J+4>>2]=k;break}k=E;J=k-G>>3;I=F;K=I-k>>3;if((J|0)==(K|0)){k=G;D=E;while(1){A=k;j=c[A>>2]|0;B=c[A+4>>2]|0;A=D;p=c[A+4>>2]|0;l=k;c[l>>2]=c[A>>2];c[l+4>>2]=p;p=D;c[p>>2]=j;c[p+4>>2]=B;k=k+8|0;if((k|
0)==(E|0))break f;else D=D+8|0}}else{L=J;M=K}while(1){D=(L|0)%(M|0)|0;if((D|0)==0)break;else{k=M;M=D;L=k}}if((M|0)!=0){K=J+-1|0;k=J+d|0;D=H+(M+d<<3)|0;do{B=D;D=D+-8|0;p=D;j=c[p>>2]|0;l=c[p+4>>2]|0;p=D;A=B+(K<<3)|0;while(1){B=A;m=c[B+4>>2]|0;o=p;c[o>>2]=c[B>>2];c[o+4>>2]=m;m=I-A>>3;if((J|0)<(m|0))N=A+(J<<3)|0;else N=H+(k-m<<3)|0;if((N|0)==(D|0))break;else{m=A;A=N;p=m}}p=A;c[p>>2]=j;c[p+4>>2]=l}while((D|0)!=(G|0))}}else{D=G;k=c[D>>2]|0;J=c[D+4>>2]|0;D=F-E|0;Bn(G|0,E|0,D|0)|0;I=H+((D>>3)+d<<3)|0;c[I>>
2]=k;c[I+4>>2]=J}while(0);H=c[b+144>>2]|0;E=H+(d<<2)|0;G=H+(e<<2)|0;F=H+(f<<2)|0;g:do if((d+1|0)!=(e|0)){if((e+1|0)==(f|0)){N=H+(f+-1<<2)|0;M=c[N>>2]|0;L=N-E|0;Bn(H+(f-(L>>2)<<2)|0,E|0,L|0)|0;c[E>>2]=M;break}M=G;L=M-E>>2;N=F;J=N-M>>2;if((L|0)==(J|0)){M=E;I=G;while(1){k=c[M>>2]|0;c[M>>2]=c[I>>2];c[I>>2]=k;M=M+4|0;if((M|0)==(G|0))break g;else I=I+4|0}}else{O=L;P=J}while(1){I=(O|0)%(P|0)|0;if((I|0)==0)break;else{M=P;P=I;O=M}}if((P|0)!=0){J=L+-1|0;M=L+d|0;I=H+(P+d<<2)|0;do{k=I;I=I+-4|0;D=c[I>>2]|0;K=
I;p=k+(J<<2)|0;while(1){c[K>>2]=c[p>>2];k=N-p>>2;if((L|0)<(k|0))Q=p+(L<<2)|0;else Q=H+(M-k<<2)|0;if((Q|0)==(I|0))break;else{k=p;p=Q;K=k}}c[p>>2]=D}while((I|0)!=(E|0))}}else{I=c[E>>2]|0;M=F-G|0;Bn(E|0,G|0,M|0)|0;c[H+((M>>2)+d<<2)>>2]=I}while(0);h:do if((a[b+21>>0]|0)!=0){H=c[b+112>>2]|0;G=H+(d<<3)|0;E=H+(e<<3)|0;F=H+(f<<3)|0;if((d+1|0)==(e|0)){Q=G;P=c[Q>>2]|0;O=c[Q+4>>2]|0;Q=F-E|0;Bn(G|0,E|0,Q|0)|0;I=H+((Q>>3)+d<<3)|0;c[I>>2]=P;c[I+4>>2]=O;break}if((e+1|0)==(f|0)){O=H+(f+-1<<3)|0;I=O;P=c[I>>2]|0;Q=
c[I+4>>2]|0;I=O-G|0;Bn(H+(f-(I>>3)<<3)|0,G|0,I|0)|0;I=G;c[I>>2]=P;c[I+4>>2]=Q;break}Q=E;I=Q-G>>3;P=F;F=P-Q>>3;if((I|0)==(F|0)){Q=G;O=E;while(1){M=Q;L=c[M>>2]|0;N=c[M+4>>2]|0;M=O;J=c[M+4>>2]|0;K=Q;c[K>>2]=c[M>>2];c[K+4>>2]=J;J=O;c[J>>2]=L;c[J+4>>2]=N;Q=Q+8|0;if((Q|0)==(E|0))break h;else O=O+8|0}}else{R=I;S=F}while(1){O=(R|0)%(S|0)|0;if((O|0)==0)break;else{E=S;S=O;R=E}}if((S|0)!=0){F=I+-1|0;E=I+d|0;O=H+(S+d<<3)|0;do{Q=O;O=O+-8|0;N=O;J=c[N>>2]|0;L=c[N+4>>2]|0;N=O;K=Q+(F<<3)|0;while(1){Q=K;M=c[Q+4>>2]|
0;l=N;c[l>>2]=c[Q>>2];c[l+4>>2]=M;M=P-K>>3;if((I|0)<(M|0))T=K+(I<<3)|0;else T=H+(E-M<<3)|0;if((T|0)==(O|0))break;else{M=K;K=T;N=M}}N=K;c[N>>2]=J;c[N+4>>2]=L}while((O|0)!=(G|0))}}while(0);T=c[b+120>>2]|0;i:do if((T|0)!=0){S=T+(d<<2)|0;R=T+(e<<2)|0;G=T+(f<<2)|0;if((d+1|0)==(e|0)){U=+g[S>>2];O=G-R|0;Bn(S|0,R|0,O|0)|0;g[T+((O>>2)+d<<2)>>2]=U;break}if((e+1|0)==(f|0)){O=T+(f+-1<<2)|0;U=+g[O>>2];E=O-S|0;Bn(T+(f-(E>>2)<<2)|0,S|0,E|0)|0;g[S>>2]=U;break}E=R;O=E-S>>2;H=G;G=H-E>>2;if((O|0)==(G|0)){E=S;I=R;while(1){U=
+g[E>>2];g[E>>2]=+g[I>>2];g[I>>2]=U;E=E+4|0;if((E|0)==(R|0))break i;else I=I+4|0}}else{V=O;W=G}while(1){I=(V|0)%(W|0)|0;if((I|0)==0)break;else{R=W;W=I;V=R}}if((W|0)!=0){G=O+-1|0;R=O+d|0;I=T+(W+d<<2)|0;do{E=I;I=I+-4|0;U=+g[I>>2];P=I;F=E+(G<<2)|0;while(1){g[P>>2]=+g[F>>2];E=H-F>>2;if((O|0)<(E|0))X=F+(O<<2)|0;else X=T+(R-E<<2)|0;if((X|0)==(I|0))break;else{E=F;F=X;P=E}}g[F>>2]=U}while((I|0)!=(S|0))}}while(0);X=c[b+132>>2]|0;j:do if((X|0)!=0){T=X+(d<<2)|0;W=X+(e<<2)|0;V=X+(f<<2)|0;if((d+1|0)==(e|0)){Y=
+g[T>>2];S=V-W|0;Bn(T|0,W|0,S|0)|0;g[X+((S>>2)+d<<2)>>2]=Y;break}if((e+1|0)==(f|0)){S=X+(f+-1<<2)|0;Y=+g[S>>2];I=S-T|0;Bn(X+(f-(I>>2)<<2)|0,T|0,I|0)|0;g[T>>2]=Y;break}I=W;S=I-T>>2;R=V;V=R-I>>2;if((S|0)==(V|0)){I=T;O=W;while(1){Y=+g[I>>2];g[I>>2]=+g[O>>2];g[O>>2]=Y;I=I+4|0;if((I|0)==(W|0))break j;else O=O+4|0}}else{Z=S;_=V}while(1){O=(Z|0)%(_|0)|0;if((O|0)==0)break;else{W=_;_=O;Z=W}}if((_|0)!=0){V=S+-1|0;W=S+d|0;O=X+(_+d<<2)|0;do{I=O;O=O+-4|0;Y=+g[O>>2];H=O;G=I+(V<<2)|0;while(1){g[H>>2]=+g[G>>2];I=
R-G>>2;if((S|0)<(I|0))$=G+(S<<2)|0;else $=X+(W-I<<2)|0;if(($|0)==(O|0))break;else{I=G;G=$;H=I}}g[G>>2]=Y}while((O|0)!=(T|0))}}while(0);$=c[b+136>>2]|0;if(($|0)!=0)rl($+(d<<2)|0,$+(e<<2)|0,$+(f<<2)|0)|0;$=c[b+148>>2]|0;k:do if(($|0)!=0){X=$+(d<<2)|0;_=$+(e<<2)|0;Z=$+(f<<2)|0;if((d+1|0)==(e|0)){T=c[X>>2]|0;O=Z-_|0;Bn(X|0,_|0,O|0)|0;c[$+((O>>2)+d<<2)>>2]=T;break}if((e+1|0)==(f|0)){T=$+(f+-1<<2)|0;O=c[T>>2]|0;W=T-X|0;Bn($+(f-(W>>2)<<2)|0,X|0,W|0)|0;c[X>>2]=O;break}O=_;W=O-X>>2;T=Z;Z=T-O>>2;if((W|0)==
(Z|0)){O=X;S=_;while(1){R=c[O>>2]|0;c[O>>2]=c[S>>2];c[S>>2]=R;O=O+4|0;if((O|0)==(_|0))break k;else S=S+4|0}}else{aa=W;ba=Z}while(1){S=(aa|0)%(ba|0)|0;if((S|0)==0)break;else{_=ba;ba=S;aa=_}}if((ba|0)!=0){Z=W+-1|0;_=W+d|0;S=$+(ba+d<<2)|0;do{O=S;S=S+-4|0;R=c[S>>2]|0;V=S;H=O+(Z<<2)|0;while(1){c[V>>2]=c[H>>2];O=T-H>>2;if((W|0)<(O|0))ca=H+(W<<2)|0;else ca=$+(_-O<<2)|0;if((ca|0)==(S|0))break;else{O=H;H=ca;V=O}}c[H>>2]=R}while((S|0)!=(X|0))}}while(0);ca=b+80|0;$=c[ca>>2]|0;if(($|0)!=0){ba=$+(d<<2)|0;aa=$+
(e<<2)|0;X=$+(f<<2)|0;l:do if((d+1|0)!=(e|0)){if((e+1|0)==(f|0)){S=$+(f+-1<<2)|0;_=c[S>>2]|0;W=S-ba|0;Bn($+(f-(W>>2)<<2)|0,ba|0,W|0)|0;c[ba>>2]=_;break}_=aa;W=_-ba>>2;S=X;T=S-_>>2;if((W|0)==(T|0)){_=ba;Z=aa;while(1){V=c[_>>2]|0;c[_>>2]=c[Z>>2];c[Z>>2]=V;_=_+4|0;if((_|0)==(aa|0))break l;else Z=Z+4|0}}else{da=W;ea=T}while(1){Z=(da|0)%(ea|0)|0;if((Z|0)==0)break;else{_=ea;ea=Z;da=_}}if((ea|0)!=0){T=W+-1|0;_=W+d|0;Z=$+(ea+d<<2)|0;do{V=Z;Z=Z+-4|0;G=c[Z>>2]|0;O=Z;F=V+(T<<2)|0;while(1){c[O>>2]=c[F>>2];V=
S-F>>2;if((W|0)<(V|0))fa=F+(W<<2)|0;else fa=$+(_-V<<2)|0;if((fa|0)==(Z|0))break;else{V=F;F=fa;O=V}}c[F>>2]=G}while((Z|0)!=(ba|0))}}else{Z=c[ba>>2]|0;_=X-aa|0;Bn(ba|0,aa|0,_|0)|0;c[$+((_>>2)+d<<2)>>2]=Z}while(0);if((d|0)<(f|0)){$=c[ca>>2]|0;ca=f-e|0;aa=d-e|0;ba=d;do{X=c[$+(ba<<2)>>2]|0;if((X|0)!=0){fa=X+8|0;X=c[fa>>2]|0;do if((X|0)>=(d|0))if((X|0)<(e|0)){ga=ca+X|0;break}else{ga=X+((X|0)<(f|0)?aa:0)|0;break}else ga=X;while(0);c[fa>>2]=ga}ba=ba+1|0}while((ba|0)!=(f|0))}}ba=c[b+280>>2]|0;if((ba|0)!=0){ga=
ba+(d<<2)|0;aa=ba+(e<<2)|0;ca=ba+(f<<2)|0;m:do if((d+1|0)==(e|0)){$=c[ga>>2]|0;X=ca-aa|0;Bn(ga|0,aa|0,X|0)|0;c[ba+((X>>2)+d<<2)>>2]=$}else{if((e+1|0)==(f|0)){$=ba+(f+-1<<2)|0;X=c[$>>2]|0;ea=$-ga|0;Bn(ba+(f-(ea>>2)<<2)|0,ga|0,ea|0)|0;c[ga>>2]=X;break}X=aa;ea=X-ga>>2;$=ca;da=$-X>>2;if((ea|0)==(da|0)){X=ga;Z=aa;while(1){_=c[X>>2]|0;c[X>>2]=c[Z>>2];c[Z>>2]=_;X=X+4|0;if((X|0)==(aa|0))break m;else Z=Z+4|0}}else{ha=ea;ia=da}while(1){Z=(ha|0)%(ia|0)|0;if((Z|0)==0)break;else{X=ia;ia=Z;ha=X}}if((ia|0)==0)break;
da=ea+-1|0;X=ea+d|0;Z=ba+(ia+d<<2)|0;do{fa=Z;Z=Z+-4|0;_=c[Z>>2]|0;W=Z;S=fa+(da<<2)|0;while(1){c[W>>2]=c[S>>2];fa=$-S>>2;if((ea|0)<(fa|0))ja=S+(ea<<2)|0;else ja=ba+(X-fa<<2)|0;if((ja|0)==(Z|0))break;else{fa=S;S=ja;W=fa}}c[S>>2]=_}while((Z|0)!=(ga|0))}while(0);ga=c[b+44>>2]|0;ja=c[b+288>>2]|0;if((ga|0)>0){ba=f-e|0;ia=d-e|0;ha=0;do{aa=ja+(ha<<2)|0;ca=c[aa>>2]|0;do if((ca|0)>=(d|0))if((ca|0)<(e|0)){ka=ba+ca|0;break}else{ka=ca+((ca|0)<(f|0)?ia:0)|0;break}else ka=ca;while(0);c[aa>>2]=ka;ha=ha+1|0}while((ha|
0)!=(ga|0))}}ga=b+204|0;if((c[ga>>2]|0)>0){ha=c[b+200>>2]|0;ka=f-e|0;ia=d-e|0;ba=0;do{ja=ha+(ba<<3)|0;ca=c[ja>>2]|0;do if((ca|0)>=(d|0))if((ca|0)<(e|0)){la=ka+ca|0;break}else{la=ca+((ca|0)<(f|0)?ia:0)|0;break}else la=ca;while(0);c[ja>>2]=la;ba=ba+1|0}while((ba|0)<(c[ga>>2]|0))}ga=b+220|0;if((c[ga>>2]|0)>0){ba=c[b+216>>2]|0;la=f-e|0;ia=d-e|0;ka=0;do{ha=ba+(ka*24|0)|0;ca=c[ha>>2]|0;do if((ca|0)>=(d|0))if((ca|0)<(e|0)){ma=la+ca|0;break}else{ma=ca+((ca|0)<(f|0)?ia:0)|0;break}else ma=ca;while(0);ca=ba+
(ka*24|0)+4|0;ja=c[ca>>2]|0;do if((ja|0)>=(d|0))if((ja|0)<(e|0)){na=la+ja|0;break}else{na=ja+((ja|0)<(f|0)?ia:0)|0;break}else na=ja;while(0);c[ha>>2]=ma;c[ca>>2]=na;ka=ka+1|0}while((ka|0)<(c[ga>>2]|0))}ga=b+236|0;if((c[ga>>2]|0)>0){ka=c[b+232>>2]|0;na=f-e|0;ma=d-e|0;ia=0;do{la=ka+(ia*28|0)|0;ba=c[la>>2]|0;do if((ba|0)>=(d|0))if((ba|0)<(e|0)){oa=na+ba|0;break}else{oa=ba+((ba|0)<(f|0)?ma:0)|0;break}else oa=ba;while(0);c[la>>2]=oa;ia=ia+1|0}while((ia|0)<(c[ga>>2]|0))}ga=b+252|0;if((c[ga>>2]|0)>0){ia=
c[b+248>>2]|0;oa=f-e|0;ma=d-e|0;na=0;do{ka=ia+(na*20|0)|0;ba=c[ka>>2]|0;do if((ba|0)>=(d|0))if((ba|0)<(e|0)){pa=oa+ba|0;break}else{pa=ba+((ba|0)<(f|0)?ma:0)|0;break}else pa=ba;while(0);c[ka>>2]=pa;ba=ia+(na*20|0)+4|0;la=c[ba>>2]|0;do if((la|0)>=(d|0))if((la|0)<(e|0)){qa=oa+la|0;break}else{qa=la+((la|0)<(f|0)?ma:0)|0;break}else qa=la;while(0);c[ba>>2]=qa;na=na+1|0}while((na|0)<(c[ga>>2]|0))}ga=b+268|0;if((c[ga>>2]|0)>0){na=c[b+264>>2]|0;qa=f-e|0;ma=d-e|0;oa=0;do{ia=na+(oa*60|0)|0;pa=c[ia>>2]|0;do if((pa|
0)>=(d|0))if((pa|0)<(e|0)){ra=qa+pa|0;break}else{ra=pa+((pa|0)<(f|0)?ma:0)|0;break}else ra=pa;while(0);c[ia>>2]=ra;pa=na+(oa*60|0)+4|0;ba=c[pa>>2]|0;do if((ba|0)>=(d|0))if((ba|0)<(e|0)){sa=qa+ba|0;break}else{sa=ba+((ba|0)<(f|0)?ma:0)|0;break}else sa=ba;while(0);c[pa>>2]=sa;ba=na+(oa*60|0)+8|0;ia=c[ba>>2]|0;do if((ia|0)>=(d|0))if((ia|0)<(e|0)){ta=qa+ia|0;break}else{ta=ia+((ia|0)<(f|0)?ma:0)|0;break}else ta=ia;while(0);c[ba>>2]=ta;oa=oa+1|0}while((oa|0)<(c[ga>>2]|0))}ga=c[b+312>>2]|0;if((ga|0)==0){i=
h;return}b=d-e|0;oa=f-e|0;ta=ga;do{ga=ta+4|0;ma=c[ga>>2]|0;do if((ma|0)>=(d|0))if((ma|0)<(e|0)){ua=oa+ma|0;break}else{ua=ma+((ma|0)<(f|0)?b:0)|0;break}else ua=ma;while(0);c[ga>>2]=ua;ma=ta+8|0;ba=c[ma>>2]|0;qa=ba+-1|0;do if((ba|0)>(d|0))if((ba|0)>(e|0)){va=qa+((ba|0)>(f|0)?0:b)|0;break}else{va=oa+qa|0;break}else va=qa;while(0);c[ma>>2]=va+1;ta=c[ta+24>>2]|0}while((ta|0)!=0);i=h;return}function Ak(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;f=i;g=(c[b+88>>2]|0)+(d<<2)|0;if((c[g>>
2]&~e|0)!=0)a[b+12>>0]=1;d=b+8|0;if((~c[d>>2]&e|0)==0){c[g>>2]=e;i=f;return}if((e&128|0)!=0){h=b+128|0;j=c[h>>2]|0;if((j|0)==0){k=b+48|0;l=c[k>>2]|0;if((l|0)==0){vk(b,256);m=c[k>>2]|0}else m=l;l=Em(c[b+400>>2]|0,m<<3)|0;xn(l|0,0,c[k>>2]<<3|0)|0;n=l}else n=j;c[h>>2]=n}if((e&256|0)!=0){n=b+136|0;h=c[n>>2]|0;if((h|0)==0){j=b+48|0;l=c[j>>2]|0;if((l|0)==0){vk(b,256);o=c[j>>2]|0}else o=l;l=Em(c[b+400>>2]|0,o<<2)|0;xn(l|0,0,c[j>>2]<<2|0)|0;p=l}else p=h;c[n>>2]=p}c[d>>2]=c[d>>2]|e;c[g>>2]=e;i=f;return}function Bk(a,
b,d){a=a|0;b=b|0;d=d|0;var e=0;e=i;Ak(a,b,c[(c[a+88>>2]|0)+(b<<2)>>2]|(d?514:2));i=e;return}function Ck(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0;g=i;i=i+64|0;h=g+16|0;j=g;k=b+400|0;if((c[(c[k>>2]|0)+102876>>2]&2|0)!=0){l=0;i=g;return l|0}c[h>>2]=7912;m=h+12|0;c[h+4>>2]=b;c[h+8>>2]=d;c[m+0>>2]=c[e+0>>2];c[m+4>>2]=c[e+4>>2];c[m+8>>2]=c[e+8>>2];c[m+12>>2]=c[e+12>>2];a[h+28>>0]=f&1;f=h+32|0;c[f>>2]=0;pb[c[(c[d>>2]|0)+28>>2]&31](d,j,e,0);Dj(c[k>>2]|0,h,j);l=c[f>>2]|0;i=g;return l|0}
function Dk(d,e,f,h){d=d|0;e=e|0;f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0;j=i;i=i+96|0;k=j+48|0;l=j;m=+g[f+52>>2];if(m==0)n=+g[d+32>>2]*.75;else n=m;o=bb[c[(c[e>>2]|0)+12>>2]&7](e)|0;if((o|0)<=0){i=j;return}p=l+4|0;q=l+8|0;r=l+28|0;s=e+4|0;t=l+12|0;u=e+12|0;v=l+20|0;w=l+12|0;x=l+
24|0;y=l+16|0;z=k+4|0;A=k+12|0;B=k+20|0;C=k+21|0;D=k+22|0;E=k+23|0;F=k+24|0;G=k+28|0;H=k+32|0;I=h+12|0;J=h+8|0;K=h+4|0;L=f+28|0;M=f+8|0;N=f+12|0;O=f+20|0;P=f+24|0;R=f+32|0;S=f+33|0;T=f+34|0;U=f+35|0;V=f+64|0;W=f+68|0;X=0;m=0;while(1){c[l>>2]=488;c[p>>2]=1;g[q>>2]=.009999999776482582;c[r+0>>2]=0;c[r+4>>2]=0;c[r+8>>2]=0;c[r+12>>2]=0;b[r+16>>1]=0;if((c[s>>2]|0)==1){Y=s;Z=c[Y+4>>2]|0;_=p;c[_>>2]=c[Y>>2];c[_+4>>2]=Z;c[t+0>>2]=c[u+0>>2];c[t+4>>2]=c[u+4>>2];c[t+8>>2]=c[u+8>>2];c[t+12>>2]=c[u+12>>2];c[t+
16>>2]=c[u+16>>2];c[t+20>>2]=c[u+20>>2];c[t+24>>2]=c[u+24>>2];c[t+28>>2]=c[u+28>>2];b[t+32>>1]=b[u+32>>1]|0}else Ge(e,l,X);$=+g[w>>2];aa=+g[v>>2]-$;ba=+g[y>>2];ca=+g[x>>2]-ba;da=+Q(+(aa*aa+ca*ca));a:do if(m<da){ea=$;fa=ba;ga=m;while(1){ha=ga/da;ia=ea+aa*ha;ja=ca*ha+fa;c[H>>2]=0;c[k>>2]=c[f>>2];ha=+g[I>>2];ka=+g[J>>2];la=+g[h>>2]+(ia*ha-ja*ka);ma=ja*ha+ia*ka+ +g[K>>2];ka=+la;ia=+ma;Z=z;g[Z>>2]=ka;g[Z+4>>2]=ia;ia=+g[L>>2];ka=+(+g[O>>2]-ia*(ma-+g[N>>2]));ma=+(ia*(la-+g[M>>2])+ +g[P>>2]);Z=A;g[Z>>2]=
ka;g[Z+4>>2]=ma;Z=a[S>>0]|0;_=a[T>>0]|0;Y=a[U>>0]|0;a[B>>0]=a[R>>0]|0;a[C>>0]=Z;a[D>>0]=_;a[E>>0]=Y;g[F>>2]=+g[V>>2];c[G>>2]=c[W>>2];wk(d,k)|0;ma=n+ga;if(!(ma<da)){na=ma;break a}ea=+g[w>>2];fa=+g[y>>2];ga=ma}}else na=m;while(0);Y=X+1|0;if((Y|0)==(o|0))break;X=Y;m=na-da}i=j;return}function Ek(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,
_=0,$=0,aa=0,ba=0,ca=0;h=i;i=i+80|0;j=h+40|0;k=h+24|0;l=h+8|0;m=h;n=+g[e+52>>2];if(n==0)o=+g[b+32>>2]*.75;else o=n;g[k>>2]=0;g[k+4>>2]=0;g[k+8>>2]=0;g[k+12>>2]=1;pb[c[(c[d>>2]|0)+28>>2]&31](d,l,k,0);n=o*+O(+(+g[l+4>>2]/o));p=l+12|0;q=+g[p>>2];if(!(n<q)){i=h;return}r=l+8|0;s=m+4|0;t=j+4|0;u=j+12|0;v=j+20|0;w=j+21|0;x=j+22|0;y=j+23|0;z=j+24|0;A=j+28|0;B=j+32|0;C=f+12|0;D=f+8|0;E=f+4|0;F=e+28|0;G=e+8|0;H=e+12|0;I=e+20|0;J=e+24|0;K=e+32|0;L=e+33|0;M=e+34|0;N=e+35|0;P=e+64|0;Q=e+68|0;R=q;q=+g[r>>2];S=
n;while(1){n=o*+O(+(+g[l>>2]/o));if(n<q){T=n;do{g[m>>2]=T;g[s>>2]=S;if(hb[c[(c[d>>2]|0)+16>>2]&15](d,k,m)|0){c[B>>2]=0;c[j>>2]=c[e>>2];n=+g[C>>2];U=+g[m>>2];V=+g[D>>2];W=+g[s>>2];X=+g[f>>2]+(n*U-V*W);Y=U*V+n*W+ +g[E>>2];W=+X;n=+Y;Z=t;g[Z>>2]=W;g[Z+4>>2]=n;n=+g[F>>2];W=+(+g[I>>2]-n*(Y-+g[H>>2]));Y=+(n*(X-+g[G>>2])+ +g[J>>2]);Z=u;g[Z>>2]=W;g[Z+4>>2]=Y;Z=a[L>>0]|0;_=a[M>>0]|0;$=a[N>>0]|0;a[v>>0]=a[K>>0]|0;a[w>>0]=Z;a[x>>0]=_;a[y>>0]=$;g[z>>2]=+g[P>>2];c[A>>2]=c[Q>>2];wk(b,j)|0}T=o+T;aa=+g[r>>2]}while(T<
aa);ba=+g[p>>2];ca=aa}else{ba=R;ca=q}S=o+S;if(!(S<ba))break;else{R=ba;q=ca}}i=h;return}function Fk(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0;e=i;i=i+64|0;f=e+20|0;h=e;j=e+16|0;k=b+400|0;if((c[(c[k>>2]|0)+102876>>2]&2|0)!=0){l=0;i=e;return l|0}m=+g[d+16>>2];n=d+8|0;o=c[n+4>>2]|0;p=h;c[p>>2]=c[n>>2];c[p+4>>2]=o;o=h+8|0;g[o>>2]=+T(+m);
p=h+12|0;g[p>>2]=+S(+m);n=b+44|0;q=c[n>>2]|0;r=c[d+40>>2]|0;do if((r|0)!=0){s=c[r+4>>2]|0;if((s|0)==3|(s|0)==1){Dk(b,r,d,h);break}else if((s|0)==0|(s|0)==2){Ek(b,r,d,h);break}else break}while(0);r=c[d+44>>2]|0;if((r|0)!=0){s=c[d+48>>2]|0;c[f>>2]=7720;c[f+12>>2]=r;c[f+16>>2]=s;Ek(b,f,d,h)}s=d+56|0;if((c[s>>2]|0)>0){r=d+60|0;t=f+4|0;u=f+12|0;v=f+20|0;w=f+21|0;x=f+22|0;y=f+23|0;z=f+24|0;A=f+28|0;B=f+32|0;m=+g[p>>2];C=+g[o>>2];D=+g[h>>2];E=+g[h+4>>2];o=d+28|0;p=d+8|0;F=d+12|0;G=d+20|0;H=d+24|0;I=d+32|
0;J=d+33|0;K=d+34|0;L=d+35|0;M=d+64|0;N=d+68|0;O=0;do{P=(c[r>>2]|0)+(O<<3)|0;Q=+g[P>>2];R=+g[P+4>>2];c[B>>2]=0;c[f>>2]=c[d>>2];U=D+(Q*m-R*C);V=m*R+Q*C+E;Q=+U;R=+V;P=t;g[P>>2]=Q;g[P+4>>2]=R;R=+g[o>>2];Q=+(+g[G>>2]-R*(V-+g[F>>2]));V=+(R*(U-+g[p>>2])+ +g[H>>2]);P=u;g[P>>2]=Q;g[P+4>>2]=V;P=a[J>>0]|0;W=a[K>>0]|0;X=a[L>>0]|0;a[v>>0]=a[I>>0]|0;a[w>>0]=P;a[x>>0]=W;a[y>>0]=X;g[z>>2]=+g[M>>2];c[A>>2]=c[N>>2];wk(b,f)|0;O=O+1|0}while((O|0)<(c[s>>2]|0))}s=c[n>>2]|0;n=Em(c[k>>2]|0,80)|0;if((n|0)==0)Y=0;else{mk(n);
Y=n}c[Y>>2]=b;c[Y+4>>2]=q;c[Y+8>>2]=s;g[Y+16>>2]=+g[d+36>>2];c[Y+76>>2]=c[d+68>>2];n=Y+60|0;c[n+0>>2]=c[h+0>>2];c[n+4>>2]=c[h+4>>2];c[n+8>>2]=c[h+8>>2];c[n+12>>2]=c[h+12>>2];c[Y+20>>2]=0;h=b+312|0;c[Y+24>>2]=c[h>>2];n=c[h>>2]|0;if((n|0)!=0)c[n+20>>2]=Y;c[h>>2]=Y;h=b+308|0;c[h>>2]=(c[h>>2]|0)+1;if((q|0)<(s|0)){h=b+144|0;n=q;do{c[(c[h>>2]|0)+(n<<2)>>2]=Y;n=n+1|0}while((n|0)!=(s|0))}n=c[d+4>>2]|0;h=Y+12|0;O=c[h>>2]|0;f=(O^n)<<4&16|n;if((O&~f|0)!=0)a[b+20>>0]=1;O=b+16|0;N=c[O>>2]|0;if((f&~N|0)!=0){if((n&
1|0)==0)Z=N;else{n=b+132|0;A=c[n>>2]|0;if((A|0)==0){M=b+48|0;z=c[M>>2]|0;if((z|0)==0){vk(b,256);_=c[M>>2]|0}else _=z;z=Em(c[k>>2]|0,_<<2)|0;xn(z|0,0,c[M>>2]<<2|0)|0;$=z;aa=c[O>>2]|0}else{$=A;aa=N}c[n>>2]=$;Z=aa}c[O>>2]=Z|f}c[h>>2]=f;c[j>>2]=7544;Gk(b,1);Hk(b,q,s,j);j=d+72|0;d=c[j>>2]|0;if((d|0)==0){l=Y;i=e;return l|0}Ik(b,d,Y);l=c[j>>2]|0;i=e;return l|0}function Gk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;d=i;i=i+32|0;e=d;f=d+8|0;h=a+204|0;j=c[h>>2]|0;k=
c[a+200>>2]|0;l=k+(j<<3)|0;if((j|0)>0){m=c[a+96>>2]|0;n=+g[a+36>>2];o=k;do{p=c[o>>2]|0;c[o+4>>2]=(~~(n*+g[m+(p<<3)+4>>2]+2048)>>>0<<20)+(~~(n*+g[m+(p<<3)>>2]*256+524288)>>>0);o=o+8|0}while(o>>>0<l>>>0);q=c[h>>2]|0}else q=j;Il(k,k+(q<<3)|0,e);e=c[a+400>>2]|0;c[f>>2]=0;c[f+4>>2]=0;q=f+8|0;c[q>>2]=0;k=f+12|0;c[k>>2]=e+76;if((c[a+8>>2]&32768|0)!=0?(c[e+102952>>2]|0)!=0:0)Rk(f,c[a+216>>2]|0,c[a+220>>2]|0,c[a+88>>2]|0);e=a+216|0;Ok(a,e);Qk(a,e);Sk(a,f);if(b){b=c[e>>2]|0;j=a+220|0;a=c[j>>2]|0;h=b+(a*24|
0)|0;a:do if((a|0)==0){r=b;s=12}else{l=b;while(1){if((c[l+20>>2]&2|0)!=0){r=l;s=12;break a}l=l+24|0;if((l|0)==(h|0)){t=h;u=b;break}}}while(0);if((s|0)==12)if((r|0)==(h|0)){t=h;u=b}else{b=r;s=r;b:while(1){r=s;do{a=r;r=r+24|0;if((r|0)==(h|0))break b}while((c[a+44>>2]&2|0)!=0);c[b+0>>2]=c[r+0>>2];c[b+4>>2]=c[r+4>>2];c[b+8>>2]=c[r+8>>2];c[b+12>>2]=c[r+12>>2];c[b+16>>2]=c[r+16>>2];c[b+20>>2]=c[r+20>>2];b=b+24|0;s=r}t=b;u=c[e>>2]|0}c[j>>2]=(t-u|0)/24|0}u=c[f>>2]|0;if((u|0)==0){i=d;return}_m(c[k>>2]|0,u);
c[f>>2]=0;c[q>>2]=0;i=d;return}function Hk(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0;f=i;i=i+48|0;h=f+40|0;j=f+12|0;k=f;l=(b|0)<(d|0);if(!l){i=f;return}m=c[a+88>>2]|0;n=b;o=0;do{o=c[m+(n<<2)>>2]|o;n=n+1|0}while((n|0)!=(d|0));if((o&1032|0)!=0){n=a+220|0;if((c[n>>2]|0)>0){m=a+216|0;p=a+88|0;q=a+144|0;r=a+252|0;s=a+256|0;t=a+248|0;
u=a+96|0;v=a+260|0;w=0;do{x=c[m>>2]|0;y=c[x+(w*24|0)>>2]|0;z=c[x+(w*24|0)+4>>2]|0;A=c[p>>2]|0;B=c[A+(y<<2)>>2]|0;C=c[A+(z<<2)>>2]|0;A=c[q>>2]|0;D=c[A+(y<<2)>>2]|0;E=c[A+(z<<2)>>2]|0;do if((z|0)<(d|0)&(((y|0)>=(d|0)|(y|0)<(b|0)|(z|0)<(b|0))^1)?(A=C|B,!((A&2|0)!=0|(A&1032|0)==0)):0){if(!(nb[c[(c[e>>2]|0)+8>>2]&31](e,y)|0)?!(nb[c[(c[e>>2]|0)+8>>2]&31](e,z)|0):0)break;if((B&28|0)==0){if((D|0)==0)break;if((c[D+12>>2]&2|0)==0)break}if((C&28|0)==0){if((E|0)==0)break;if((c[E+12>>2]&2|0)==0)break}if(hb[c[(c[e>>
2]|0)+12>>2]&15](e,y,z)|0){A=c[r>>2]|0;F=c[s>>2]|0;if((A|0)>=(F|0)?(G=(F|0)==0?256:F<<1,(F|0)<(G|0)):0){F=Em(c[v>>2]|0,G*20|0)|0;H=c[t>>2]|0;if((H|0)!=0){An(F|0,H|0,(c[r>>2]|0)*20|0)|0;Fm(c[v>>2]|0,c[t>>2]|0,(c[s>>2]|0)*20|0)}c[s>>2]=G;c[t>>2]=F;I=c[r>>2]|0}else I=A;c[r>>2]=I+1;A=c[t>>2]|0;c[A+(I*20|0)>>2]=y;c[A+(I*20|0)+4>>2]=z;c[A+(I*20|0)+8>>2]=c[x+(w*24|0)+20>>2];if((D|0)==0)J=1;else J=+g[D+16>>2];if((E|0)==0)K=1;else K=+g[E+16>>2];g[A+(I*20|0)+12>>2]=J<K?J:K;F=c[u>>2]|0;L=+g[F+(y<<3)>>2]-+g[F+
(z<<3)>>2];M=+g[F+(y<<3)+4>>2]-+g[F+(z<<3)+4>>2];g[A+(I*20|0)+16>>2]=+Q(+(L*L+M*M))}}while(0);w=w+1|0}while((w|0)<(c[n>>2]|0));N=r}else N=a+252|0;r=a+248|0;n=c[r>>2]|0;w=c[N>>2]|0;I=n+(w*20|0)|0;c[h>>2]=27;u=w*20|0;w=(u|0)/20|0;a:do if((u|0)>2560){t=w;while(1){s=rn(t*20|0,9632)|0;if((s|0)!=0){O=s;P=t;break a}if((t|0)>1)t=(t|0)/2|0;else{O=s;P=0;break}}}else{O=0;P=0}while(0);Pl(n,I,h,w,O,P);if((O|0)!=0)sn(O);O=c[r>>2]|0;P=c[N>>2]|0;w=O+(P*20|0)|0;b:do if((P|0)==0){R=O;S=40}else if((P|0)==1){T=w;U=O}else{I=
O;n=O+20|0;u=c[O>>2]|0;while(1){t=u;u=c[n>>2]|0;if((t|0)==(u|0)?(c[I+4>>2]|0)==(c[I+24>>2]|0):0){R=I;S=40;break b}t=n+20|0;if((t|0)==(w|0)){T=w;U=O;break}else{s=n;n=t;I=s}}}while(0);if((S|0)==40)if((R|0)==(w|0)){T=w;U=O}else{O=R;P=R+20|0;c:while(1){R=O+4|0;I=P;do{n=I;I=I+20|0;if((I|0)==(w|0))break c;if((c[O>>2]|0)!=(c[I>>2]|0))break}while((c[R>>2]|0)==(c[n+24>>2]|0));R=O+20|0;c[R+0>>2]=c[I+0>>2];c[R+4>>2]=c[I+4>>2];c[R+8>>2]=c[I+8>>2];c[R+12>>2]=c[I+12>>2];c[R+16>>2]=c[I+16>>2];O=R;P=I}T=O+20|0;U=
c[r>>2]|0}c[N>>2]=(T-U|0)/20|0}if((o&16|0)==0){i=f;return}hk(j,(c[a+400>>2]|0)+76|0,d-b|0);if(l){l=a+88|0;o=a+144|0;U=a+96|0;T=b;do{b=c[(c[l>>2]|0)+(T<<2)>>2]|0;do if((b&2|0)==0){N=c[(c[o>>2]|0)+(T<<2)>>2]|0;if((b&28|0)==0){if((N|0)==0)break;if((c[N+12>>2]&2|0)==0)break}N=c[U>>2]|0;jk(j,N+(T<<3)|0,T,nb[c[(c[e>>2]|0)+8>>2]&31](e,T)|0)}while(0);T=T+1|0}while((T|0)<(d|0))}K=+g[a+32>>2]*.75;kk(j,K*.5,K*2);c[k>>2]=7176;c[k+4>>2]=a;c[k+8>>2]=e;lk(j,k);k=a+264|0;e=c[k>>2]|0;d=a+268|0;a=c[d>>2]|0;T=e+(a*
60|0)|0;c[h>>2]=28;U=a*60|0;a=(U|0)/60|0;d:do if((U|0)>7680){o=a;while(1){l=rn(o*60|0,9632)|0;if((l|0)!=0){V=l;W=o;break d}if((o|0)>1)o=(o|0)/2|0;else{V=l;W=0;break}}}else{V=0;W=0}while(0);Ll(e,T,h,a,V,W);if((V|0)!=0)sn(V);V=c[k>>2]|0;W=c[d>>2]|0;a=V+(W*60|0)|0;e:do if((W|0)==0){X=V;S=69}else if((W|0)==1){Y=a;Z=V}else{h=V;T=V+60|0;e=c[V>>2]|0;while(1){U=e;e=c[T>>2]|0;if(((U|0)==(e|0)?(c[h+4>>2]|0)==(c[h+64>>2]|0):0)?(c[h+8>>2]|0)==(c[h+68>>2]|0):0){X=h;S=69;break e}U=T+60|0;if((U|0)==(a|0)){Y=a;Z=
V;break}else{o=T;T=U;h=o}}}while(0);if((S|0)==69)if((X|0)==(a|0)){Y=a;Z=V}else{V=X;S=X+60|0;f:while(1){X=V+4|0;W=V+8|0;h=S;do{T=h;h=h+60|0;if((h|0)==(a|0))break f;if((c[V>>2]|0)!=(c[h>>2]|0))break;if((c[X>>2]|0)!=(c[T+64>>2]|0))break}while((c[W>>2]|0)==(c[T+68>>2]|0));W=V+60|0;X=W+0|0;T=h+0|0;e=X+60|0;do{c[X>>2]=c[T>>2];X=X+4|0;T=T+4|0}while((X|0)<(e|0));V=W;S=h}Y=V+60|0;Z=c[k>>2]|0}c[d>>2]=(Y-Z|0)/60|0;ik(j);i=f;return}function Ik(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,
p=0,q=0,r=0,s=0,t=0,u=0,v=0;f=i;i=i+16|0;g=f;h=b+400|0;if((c[(c[h>>2]|0)+102876>>2]&2|0)!=0){i=f;return}j=e+4|0;k=e+8|0;zk(b,c[j>>2]|0,c[k>>2]|0,c[b+44>>2]|0);l=d+4|0;m=d+8|0;zk(b,c[l>>2]|0,c[m>>2]|0,c[j>>2]|0);n=c[j>>2]|0;c[g>>2]=7576;c[g+4>>2]=n;Gk(b,1);Hk(b,c[l>>2]|0,c[k>>2]|0,g);g=c[j>>2]|0;l=c[k>>2]|0;if((g|0)<(l|0)){n=b+144|0;o=g;do{c[(c[n>>2]|0)+(o<<2)>>2]=d;o=o+1|0}while((o|0)<(l|0))}l=d+12|0;d=c[l>>2]|0;o=c[e+12>>2]|d;n=(o^d)<<4&16|o;if((d&~n|0)!=0)a[b+20>>0]=1;d=b+16|0;g=c[d>>2]|0;if((n&
~g|0)!=0){if((o&1|0)==0)p=g;else{o=b+132|0;q=c[o>>2]|0;if((q|0)==0){r=b+48|0;s=c[r>>2]|0;if((s|0)==0){vk(b,256);t=c[r>>2]|0}else t=s;s=Em(c[h>>2]|0,t<<2)|0;xn(s|0,0,c[r>>2]<<2|0)|0;u=s;v=c[d>>2]|0}else{u=q;v=g}c[o>>2]=u;p=v}c[d>>2]=p|n}c[l>>2]=n;c[m>>2]=c[k>>2];c[j>>2]=c[k>>2];tk(b,e);i=f;return}function Jk(a){a=a|0;return}function Kk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;e=c[a>>2]|0;f=c[b>>2]|0;if((e|0)==(f|0)){g=(c[a+4>>2]|0)<(c[b+4>>2]|0);i=d;return g|0}else{g=(e-f|0)<0;i=d;return g|0}return 0}
function Lk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;e=c[a>>2]|0;f=c[b>>2]|0;if((e|0)!=(f|0)){g=(e-f|0)<0;i=d;return g|0}f=c[a+4>>2]|0;e=c[b+4>>2]|0;if((f|0)==(e|0)){g=(c[a+8>>2]|0)<(c[b+8>>2]|0);i=d;return g|0}else{g=(f-e|0)<0;i=d;return g|0}return 0}function Mk(b){b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0;d=i;e=b+400|0;f=b+220|0;h=Ym((c[e>>2]|0)+76|0,(c[f>>2]|0)*24|0)|0;j=c[f>>2]|
0;if((j|0)>0){k=b+216|0;l=b+144|0;m=j;j=0;n=0;while(1){o=c[k>>2]|0;p=o+(n*24|0)|0;q=c[l>>2]|0;r=c[q+(c[p>>2]<<2)>>2]|0;if(((r|0)!=0?(r|0)==(c[q+(c[o+(n*24|0)+4>>2]<<2)>>2]|0):0)?(c[r+12>>2]&16|0)!=0:0){r=j+1|0;o=h+(j*24|0)|0;c[o+0>>2]=c[p+0>>2];c[o+4>>2]=c[p+4>>2];c[o+8>>2]=c[p+8>>2];c[o+12>>2]=c[p+12>>2];c[o+16>>2]=c[p+16>>2];c[o+20>>2]=c[p+20>>2];s=c[f>>2]|0;t=r}else{s=m;t=j}n=n+1|0;if((n|0)>=(s|0)){u=t;break}else{m=s;j=t}}}else u=0;t=Ym((c[e>>2]|0)+76|0,c[b+308>>2]<<2)|0;j=c[b+312>>2]|0;if((j|
0)==0)v=0;else{s=b+16|0;m=b+124|0;n=b+132|0;f=b+48|0;l=b+20|0;k=j;j=0;while(1){r=k+12|0;p=c[r>>2]|0;if((p&16|0)!=0){o=j+1|0;c[t+(j<<2)>>2]=k;q=p&-17;if((((p|16)^-17)&p|0)!=0)a[l>>0]=1;w=c[s>>2]|0;if((q&~w|0)!=0){if((p&1|0)==0)x=w;else{p=c[n>>2]|0;if((p|0)==0){y=c[f>>2]|0;if((y|0)==0){vk(b,256);z=c[f>>2]|0}else z=y;y=Em(c[e>>2]|0,z<<2)|0;xn(y|0,0,c[f>>2]<<2|0)|0;A=y;B=c[s>>2]|0}else{A=p;B=w}c[n>>2]=A;x=B}c[s>>2]=x|q}c[r>>2]=q;q=c[k+4>>2]|0;r=c[k+8>>2]|0;if((q|0)<(r|0)){w=q+1|0;xn((c[m>>2]|0)+(q<<2)|
0,0,((r|0)>(w|0)?r:w)-q<<2|0)|0;C=o}else C=o}else C=j;k=c[k+24>>2]|0;if((k|0)==0){v=C;break}else j=C}}C=(u|0)>0;if(C){j=c[b+124>>2]|0;k=0;do{m=c[h+(k*24|0)+4>>2]|0;D=+g[h+(k*24|0)+8>>2];x=j+(c[h+(k*24|0)>>2]<<2)|0;g[x>>2]=D+ +g[x>>2];x=j+(m<<2)|0;g[x>>2]=D+ +g[x>>2];k=k+1|0}while((k|0)!=(u|0))}k=(v|0)>0;if(k){j=b+124|0;x=b+132|0;m=0;do{s=c[t+(m<<2)>>2]|0;B=c[s+4>>2]|0;A=c[s+8>>2]|0;if((B|0)<(A|0)){s=c[j>>2]|0;n=c[x>>2]|0;f=B;do{g[n+(f<<2)>>2]=+g[s+(f<<2)>>2]<.800000011920929?0:3.4028234663852886E38;
f=f+1|0}while((f|0)<(A|0))}m=m+1|0}while((m|0)!=(v|0))}m=~~+Q(+ +(c[b+44>>2]|0));if((m|0)>0?(x=b+132|0,C):0){C=0;do{j=c[x>>2]|0;A=0;f=0;while(1){D=1-+g[h+(A*24|0)+8>>2];s=j+(c[h+(A*24|0)>>2]<<2)|0;n=j+(c[h+(A*24|0)+4>>2]<<2)|0;E=+g[n>>2];F=D+E;G=+g[s>>2];H=D+G;if(G>F){g[s>>2]=F;I=+g[n>>2];J=1}else{I=E;J=f}if(I>H){g[n>>2]=H;K=1}else K=J;A=A+1|0;if((A|0)==(u|0))break;else f=K}C=C+1|0}while(K&(C|0)<(m|0))}if(!k){L=c[e>>2]|0;M=L+76|0;_m(M,t);N=c[e>>2]|0;O=N+76|0;_m(O,h);i=d;return}k=b+132|0;m=b+32|0;
b=0;do{C=c[t+(b<<2)>>2]|0;K=c[C+4>>2]|0;u=c[C+8>>2]|0;if((K|0)<(u|0)){C=c[k>>2]|0;J=K;do{K=C+(J<<2)|0;I=+g[K>>2];if(I<3.4028234663852886E38)P=I*+g[m>>2];else P=0;g[K>>2]=P;J=J+1|0}while((J|0)<(u|0))}b=b+1|0}while((b|0)!=(v|0));L=c[e>>2]|0;M=L+76|0;_m(M,t);N=c[e>>2]|0;O=N+76|0;_m(O,h);i=d;return}function Nk(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;e=i;f=+g[b+36>>2];h=(~~(f*+g[d+4>>2]+-1+2048)>>>0<<20)+(~~((f*+g[d>>2]+-1)*256+524288)>>>0)|0;j=~~(f*+g[d+12>>2]+1+2048)>>>0;k=~~((f*
+g[d+8>>2]+1)*256+524288)>>>0;d=c[b+200>>2]|0;l=c[b+204>>2]|0;b=d+(l<<3)|0;m=d;d=l<<3>>3;a:while(1){l=d;while(1){if((l|0)==0)break a;n=(l|0)/2|0;if((c[m+(n<<3)+4>>2]|0)>>>0<h>>>0)break;else l=n}m=m+(n+1<<3)|0;d=l+-1-n|0}n=(j<<20)+k|0;k=m;j=b-m>>3;b:while(1){b=j;while(1){if((b|0)==0)break b;o=(b|0)/2|0;if((c[k+(o<<3)+4>>2]|0)>>>0>n>>>0)b=o;else break}k=k+(o+1<<3)|0;j=b+-1-o|0}c[a>>2]=h&1048575;c[a+4>>2]=n&1048575;c[a+8>>2]=h&-1048576;c[a+12>>2]=n&-1048576;c[a+16>>2]=m;c[a+20>>2]=k;i=e;return}function Ok(a,
b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;d=i;e=c[a+200>>2]|0;f=c[a+204>>2]|0;g=e+(f<<3)|0;c[b+4>>2]=0;if((f|0)>0){h=e;j=e}else{i=d;return}while(1){e=h+4|0;f=(c[e>>2]|0)+256|0;k=h;h=h+8|0;l=h>>>0<g>>>0;a:do if(l){m=h;do{if(f>>>0<(c[m+4>>2]|0)>>>0)break a;Pk(a,c[k>>2]|0,c[m>>2]|0,b);m=m+8|0}while(m>>>0<g>>>0)}while(0);f=c[e>>2]|0;m=f+1048320|0;b:do if(j>>>0<g>>>0){n=j;while(1){o=n+8|0;if(!(m>>>0>(c[n+4>>2]|0)>>>0)){p=n;break b}if(o>>>0<g>>>0)n=o;else{p=o;break}}}else p=j;while(0);
m=f+1048832|0;c:do if(p>>>0<g>>>0){e=p;do{if(m>>>0<(c[e+4>>2]|0)>>>0)break c;Pk(a,c[k>>2]|0,c[e>>2]|0,b);e=e+8|0}while(e>>>0<g>>>0)}while(0);if(!l)break;else j=p}i=d;return}function Pk(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;f=i;h=c[a+96>>2]|0;j=+g[h+(d<<3)>>2]-+g[h+(b<<3)>>2];l=+g[h+(d<<3)+4>>2]-+g[h+(b<<3)+4>>2];m=j*j+l*l;if(!(m<+g[a+40>>2])){i=f;return}n=(c[k>>2]=1597463007-((g[k>>2]=m,c[k>>2]|0)>>1),+g[k>>2]);o=n*(1.5-n*m*.5*n);h=e+4|0;p=c[h>>
2]|0;q=e+8|0;r=c[q>>2]|0;if((p|0)>=(r|0)?(s=(r|0)==0?256:r<<1,(r|0)<(s|0)):0){r=e+12|0;t=Em(c[r>>2]|0,s*24|0)|0;u=c[e>>2]|0;if((u|0)!=0){An(t|0,u|0,(c[h>>2]|0)*24|0)|0;Fm(c[r>>2]|0,c[e>>2]|0,(c[q>>2]|0)*24|0)}c[q>>2]=s;c[e>>2]=t;v=c[h>>2]|0}else v=p;c[h>>2]=v+1;h=c[e>>2]|0;c[h+(v*24|0)>>2]=b;c[h+(v*24|0)+4>>2]=d;e=c[a+88>>2]|0;c[h+(v*24|0)+20>>2]=c[e+(d<<2)>>2]|c[e+(b<<2)>>2];g[h+(v*24|0)+8>>2]=1-m*o*+g[a+36>>2];m=+(j*o);j=+(l*o);a=h+(v*24|0)+12|0;g[a>>2]=m;g[a+4>>2]=j;i=f;return}function Qk(a,b){a=
a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;d=i;if((c[a+8>>2]&131072|0)==0){i=d;return}e=c[(c[a+400>>2]|0)+102948>>2]|0;if((e|0)==0){i=d;return}f=c[b>>2]|0;g=b+4|0;h=c[g>>2]|0;j=f+(h*24|0)|0;a:do if((h|0)==0){k=f;l=8}else{m=f;while(1){if((c[m+20>>2]&131072|0)!=0?!(lb[c[(c[e>>2]|0)+16>>2]&7](e,a,c[m>>2]|0,c[m+4>>2]|0)|0):0){k=m;l=8;break a}m=m+24|0;if((m|0)==(j|0)){n=j;break}}}while(0);b:do if((l|0)==8)if((k|0)==(j|0))n=j;else{f=k;h=k;while(1){m=h;do{o=m;m=m+24|0;if((m|0)==(j|0)){n=f;
break b}if((c[o+44>>2]&131072|0)==0)break}while(!(lb[c[(c[e>>2]|0)+16>>2]&7](e,a,c[m>>2]|0,c[o+28>>2]|0)|0));c[f+0>>2]=c[m+0>>2];c[f+4>>2]=c[m+4>>2];c[f+8>>2]=c[m+8>>2];c[f+12>>2]=c[m+12>>2];c[f+16>>2]=c[m+16>>2];c[f+20>>2]=c[m+20>>2];f=f+24|0;h=m}}while(0);c[g>>2]=(n-(c[b>>2]|0)|0)/24|0;i=d;return}function Rk(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;f=i;i=i+16|0;g=f;h=c[a>>2]|0;if((h|0)!=0){_m(c[a+12>>2]|0,h);c[a>>2]=0;c[a+8>>2]=0}if((d|0)==0)j=c[a+8>>2]|0;else{h=
Ym(c[a+12>>2]|0,d*9|0)|0;c[a>>2]=h;k=h+(d<<3)|0;c[a+4>>2]=k;xn(k|0,1,d|0)|0;c[a+8>>2]=d;j=d}if((j|0)==0){i=f;return}j=c[a>>2]|0;if((d|0)>0){k=0;h=0;while(1){l=c[b+(k*24|0)>>2]|0;if((!((l|0)==-1)?(m=b+(k*24|0)+4|0,n=c[m>>2]|0,!((n|0)==-1)):0)?((c[e+(n<<2)>>2]|c[e+(l<<2)>>2])&32768|0)!=0:0){c[j+(k<<3)>>2]=l;c[j+(k<<3)+4>>2]=c[m>>2];o=h+1|0}else o=h;k=k+1|0;if((k|0)==(d|0)){p=o;break}else h=o}}else p=0;c[a+8>>2]=p;c[g>>2]=29;Cl(j,j+(p<<3)|0,g);i=f;return}function Sk(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,
h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0;e=i;if((c[b+8>>2]&32768|0)==0){i=e;return}f=c[(c[b+400>>2]|0)+102952>>2]|0;if((f|0)==0){i=e;return}g=c[b+220>>2]|0;h=c[b+216>>2]|0;j=h+(g*24|0)|0;k=d+8|0;if((g|0)>0){g=d+4|0;l=h;while(1){h=c[l>>2]|0;m=c[l+4>>2]|0;n=c[k>>2]|0;do if((n|0)==0)o=24;else{p=c[d>>2]|0;q=p;r=p+(n<<3)-q>>3;s=(r|0)==0;a:do if(s)t=p;else{u=p;v=r;while(1){w=v;while(1){x=(w|0)/2|0;if((c[u+(x<<3)>>2]|0)<(h|0)?(c[u+(x<<3)+4>>2]|0)<(m|
0):0)break;if((w+1|0)>>>0<3){t=u;break a}else w=x}y=u+(x+1<<3)|0;z=w+-1|0;if((z|0)==(x|0)){t=y;break}else{u=y;v=z-x|0}}}while(0);if((t|0)!=0?(v=(t-q|0)>>>3,u=c[g>>2]|0,(a[u+v>>0]|0)!=0):0){A=u;B=v}else{b:do if(s)C=p;else{v=p;u=r;while(1){z=u;while(1){D=(z|0)/2|0;if((c[v+(D<<3)>>2]|0)<(m|0)?(c[v+(D<<3)+4>>2]|0)<(h|0):0)break;if((z+1|0)>>>0<3){C=v;break b}else z=D}w=v+(D+1<<3)|0;y=z+-1|0;if((y|0)==(D|0)){C=w;break}else{v=w;u=y-D|0}}}while(0);if((C|0)==0){o=24;break}r=(C-q|0)>>>3;p=c[g>>2]|0;if((a[p+
r>>0]|0)==0){o=24;break}else{A=p;B=r}}a[A+B>>0]=0}while(0);if((o|0)==24){o=0;ib[c[(c[f>>2]|0)+24>>2]&7](f,b,l)}l=l+24|0;if(!(l>>>0<j>>>0)){E=d;F=g;break}}}else{E=d;F=d+4|0}d=c[k>>2]|0;k=c[E>>2]|0;E=c[F>>2]|0;if((d|0)<=0){i=e;return}F=0;do{if((a[E+F>>0]|0)!=0)pb[c[(c[f>>2]|0)+28>>2]&31](f,b,c[k+(F<<3)>>2]|0,c[k+(F<<3)+4>>2]|0);F=F+1|0}while((F|0)!=(d|0));i=e;return}function Tk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;d=i;e=a+156|0;if((c[e>>2]|0)<1){i=d;return}f=(c[a+176>>2]|
0)+(b<<2)|0;g=(c[a+160>>2]|0)+(b<<2)|0;h=(c[a+168>>2]|0)+(b<<2)|0;j=(c[h>>2]|0)+1|0;c[h>>2]=j;if((j|0)==2?(j=c[f>>2]|0,c[f>>2]=j+1,(j|0)>=(c[e>>2]|0)):0){e=a+184|0;j=a+188|0;f=c[j>>2]|0;h=a+192|0;k=c[h>>2]|0;if((f|0)>=(k|0)?(l=(k|0)==0?256:k<<1,(k|0)<(l|0)):0){k=a+196|0;m=Em(c[k>>2]|0,l<<2)|0;n=c[e>>2]|0;if((n|0)!=0){An(m|0,n|0,c[j>>2]<<2|0)|0;Fm(c[k>>2]|0,c[e>>2]|0,c[h>>2]<<2)}c[h>>2]=l;c[e>>2]=m;o=c[j>>2]|0}else o=f;c[j>>2]=o+1;c[(c[e>>2]|0)+(o<<2)>>2]=b}c[g>>2]=c[a+4>>2];i=d;return}function Uk(a,
b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;f=i;i=i+16|0;g=f;h=c[a>>2]|0;if((h|0)!=0){_m(c[a+12>>2]|0,h);c[a>>2]=0;c[a+8>>2]=0}if((d|0)==0)j=c[a+8>>2]|0;else{h=Ym(c[a+12>>2]|0,d*9|0)|0;c[a>>2]=h;k=h+(d<<3)|0;c[a+4>>2]=k;xn(k|0,1,d|0)|0;c[a+8>>2]=d;j=d}if((j|0)==0){i=f;return}j=c[a>>2]|0;if((d|0)>0){k=0;h=0;while(1){l=c[b+(k*28|0)>>2]|0;if(!((l|0)==-1)?(c[e+(l<<2)>>2]&16384|0)!=0:0){c[j+(k<<3)>>2]=c[b+(k*28|0)+8>>2];c[j+(k<<3)+4>>2]=l;m=h+1|0}else m=h;k=k+1|0;if((k|0)==(d|0)){n=
m;break}else h=m}}else n=0;c[a+8>>2]=n;c[g>>2]=30;Fl(j,j+(n<<3)|0,g);i=f;return}function Vk(a,b){a=a|0;b=b|0;var d=0,e=0;d=i;if(!((c[a>>2]|0)>>>0<(c[b>>2]|0)>>>0)){e=0;i=d;return e|0}e=(c[a+4>>2]|0)<(c[b+4>>2]|0);i=d;return e|0}function Wk(a,b){a=a|0;b=b|0;var d=0,e=0;d=i;if((c[a>>2]|0)>=(c[b>>2]|0)){e=0;i=d;return e|0}e=(c[a+4>>2]|0)<(c[b+4>>2]|0);i=d;return e|0}function Xk(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0;e=i;if((c[b+
8>>2]&16384|0)==0){i=e;return}f=c[(c[b+400>>2]|0)+102952>>2]|0;if((f|0)==0){i=e;return}g=b+232|0;h=b+236|0;if((c[h>>2]|0)==0){j=d;k=d+8|0;l=d+4|0}else{m=d+8|0;n=d+4|0;o=c[g>>2]|0;while(1){p=c[o+8>>2]|0;q=c[o>>2]|0;r=c[m>>2]|0;if((r|0)!=0){s=c[d>>2]|0;t=s;u=s+(r<<3)-t>>3;a:do if((u|0)==0)v=s;else{r=s;w=u;while(1){x=w;while(1){y=(x|0)/2|0;if((c[r+(y<<3)>>2]|0)>>>0<p>>>0?(c[r+(y<<3)+4>>2]|0)<(q|0):0)break;if((x+1|0)>>>0<3){v=r;break a}else x=y}z=r+(y+1<<3)|0;A=x+-1|0;if((A|0)==(y|0)){v=z;break}else{r=
z;w=A-y|0}}}while(0);if((v|0)!=0?(q=(c[n>>2]|0)+((v-t|0)>>>3)|0,(a[q>>0]|0)!=0):0)a[q>>0]=0;else B=16}else B=16;if((B|0)==16){B=0;ib[c[(c[f>>2]|0)+16>>2]&7](f,b,o)}o=o+28|0;if((o|0)==((c[g>>2]|0)+((c[h>>2]|0)*28|0)|0)){j=d;k=m;l=n;break}}}n=c[j>>2]|0;j=c[l>>2]|0;l=c[k>>2]|0;if((l|0)<=0){i=e;return}k=0;do{if((a[j+k>>0]|0)!=0)pb[c[(c[f>>2]|0)+20>>2]&31](f,c[n+(k<<3)>>2]|0,b,c[n+(k<<3)+4>>2]|0);k=k+1|0}while((k|0)!=(l|0));i=e;return}function Yk(b){b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=
0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0;d=i;i=i+48|0;e=d+32|0;f=d+16|0;h=d;j=b+400|0;k=c[j>>2]|0;c[e>>2]=0;c[e+4>>2]=0;l=e+8|0;c[l>>2]=0;m=e+12|0;c[m>>2]=k+76;n=b+8|0;if((c[n>>2]&16384|0)!=0?(c[k+102952>>2]|0)!=0:0)Uk(e,c[b+232>>2]|0,c[b+236>>2]|0,c[b+88>>2]|0);if((c[b+156>>2]|0)>0?(k=c[b+44>>2]|0,(k|0)>0):0){o=c[b+168>>2]|0;p=b+4|0;q=c[b+160>>2]|0;r=b+176|0;s=0;do{c[o+(s<<2)>>2]=0;if((c[p>>2]|0)>((c[q+(s<<2)>>2]|0)+1|0))c[(c[r>>2]|0)+(s<<2)>>2]=0;s=s+1|0}while((s|
0)!=(k|0))}c[b+236>>2]=0;c[b+188>>2]=0;if((c[n>>2]&65536|0)==0)t=0;else t=c[(c[j>>2]|0)+102948>>2]|0;c[f+4>>2]=b;c[f>>2]=7056;c[f+8>>2]=t;t=c[b+44>>2]|0;g[h>>2]=3.4028234663852886E38;n=h+4|0;g[n>>2]=3.4028234663852886E38;k=h+8|0;g[k>>2]=-3.4028234663852886E38;s=h+12|0;g[s>>2]=-3.4028234663852886E38;if((t|0)>0){r=c[b+96>>2]|0;u=3.4028234663852886E38;v=3.4028234663852886E38;w=-3.4028234663852886E38;x=-3.4028234663852886E38;q=0;while(1){p=r+(q<<3)|0;y=+g[p>>2];z=+g[p+4>>2];A=u<y?u:y;B=v<z?v:z;C=+A;D=
+B;p=h;g[p>>2]=C;g[p+4>>2]=D;D=w>y?w:y;y=x>z?x:z;z=+D;C=+y;p=k;g[p>>2]=z;g[p+4>>2]=C;q=q+1|0;if((q|0)==(t|0)){E=y;F=A;G=B;H=D;break}else{u=A;v=B;w=D;x=y}}}else{E=-3.4028234663852886E38;F=3.4028234663852886E38;G=3.4028234663852886E38;H=-3.4028234663852886E38}x=+g[b+32>>2];g[h>>2]=F-x;g[n>>2]=G-x;g[k>>2]=H+x;g[s>>2]=E+x;Dj(c[j>>2]|0,f,h);if((a[b+316>>0]|0)!=0)Zk(b);Xk(b,e);b=c[e>>2]|0;if((b|0)==0){i=d;return}_m(c[m>>2]|0,b);c[e>>2]=0;c[l>>2]=0;i=d;return}function Zk(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,
h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;b=i;i=i+32|0;d=b+20|0;e=b;f=b+16|0;g=a+232|0;h=c[g>>2]|0;j=a+236|0;k=h+((c[j>>2]|0)*28|0)|0;c[d>>2]=31;yl(h,k,d);c[f>>2]=0;d=c[g>>2]|0;g=c[j>>2]|0;k=d+(g*28|0)|0;c[e>>2]=a;c[e+4>>2]=-1;c[e+8>>2]=0;c[e+12>>2]=f;a:do if((g|0)==0)l=d;else{a=d;do{if(xl(e,a)|0){l=a;break a}a=a+28|0}while((a|0)!=(k|0));m=c[j>>2]|0;n=c[f>>2]|0;o=m-n|0;c[j>>2]=o;i=b;return}while(0);if((l|0)==(k|0)){m=c[j>>2]|0;n=c[f>>2]|0;o=m-n|0;c[j>>2]=o;i=b;return}else{p=l;q=l}b:while(1){l=q;do{l=l+
28|0;if((l|0)==(k|0))break b}while(xl(e,l)|0);c[p+0>>2]=c[l+0>>2];c[p+4>>2]=c[l+4>>2];c[p+8>>2]=c[l+8>>2];c[p+12>>2]=c[l+12>>2];c[p+16>>2]=c[l+16>>2];c[p+20>>2]=c[l+20>>2];c[p+24>>2]=c[l+24>>2];p=p+28|0;q=l}m=c[j>>2]|0;n=c[f>>2]|0;o=m-n|0;c[j>>2]=o;i=b;return}function _k(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0;d=i;e=c[a>>2]|0;f=c[b>>2]|0;if((e|0)==(f|0)){h=+g[a+12>>2]>+g[b+12>>2];i=d;return h|0}else{h=(e|0)<(f|0);i=d;return h|0}return 0}function Jf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0;d=i;vh(a,b);c[a>>
2]=1056;e=b+20|0;f=c[e+4>>2]|0;h=a+68|0;c[h>>2]=c[e>>2];c[h+4>>2]=f;g[a+76>>2]=+g[b+28>>2];g[a+80>>2]=0;g[a+84>>2]=0;g[a+88>>2]=0;g[a+92>>2]=+g[b+32>>2];g[a+96>>2]=+g[b+36>>2];g[a+100>>2]=+g[b+40>>2];i=d;return}function Kf(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=
0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+104|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+108|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+128|0;c[o>>2]=p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+136|0;c[o>>2]=r;c[o+4>>2]=s;o=b+156|0;g[o>>2]=+g[f+136>>2];t=b+160|0;g[t>>2]=+g[l+136>>2];u=b+164|0;g[u>>2]=+g[f+144>>2];f=b+168|0;g[f>>2]=+g[l+144>>2];l=c[d+28>>2]|0;v=l+(h*12|0)|0;w=+g[v>>2];x=+g[v+4>>2];y=+g[l+(h*
12|0)+8>>2];v=d+32|0;z=c[v>>2]|0;A=z+(h*12|0)|0;B=+g[A>>2];C=+g[A+4>>2];D=+g[z+(h*12|0)+8>>2];h=l+(m*12|0)|0;E=+g[h>>2];F=+g[h+4>>2];G=+g[l+(m*12|0)+8>>2];l=z+(m*12|0)|0;H=+g[l>>2];I=+g[l+4>>2];J=+g[z+(m*12|0)+8>>2];K=+T(+y);L=+S(+y);M=+T(+G);N=+S(+G);O=-(c[k>>2]=p,+g[k>>2]);P=-(c[k>>2]=q,+g[k>>2]);Q=L*O-K*P;R=K*O+L*P;P=+Q;O=+R;q=b+112|0;g[q>>2]=P;g[q+4>>2]=O;O=-(c[k>>2]=r,+g[k>>2]);P=-(c[k>>2]=s,+g[k>>2]);U=N*O-M*P;V=M*O+N*P;P=+U;N=+V;s=b+120|0;g[s>>2]=P;g[s+4>>2]=N;N=+g[o>>2];P=+g[t>>2];O=+g[u>>
2];M=+g[f>>2];W=N+P;X=W+R*O*R+V*M*V;Y=O*Q;Z=M*U;_=-(R*Y)-V*Z;$=W+Q*Y+U*Z;Z=X*$-_*_;if(Z!=0)aa=1/Z;else aa=Z;Z=-(_*aa);g[b+172>>2]=$*aa;g[b+176>>2]=Z;g[b+180>>2]=Z;g[b+184>>2]=X*aa;aa=O+M;if(aa>0)ba=1/aa;else ba=aa;g[b+188>>2]=ba;ba=+g[b+68>>2];aa=+g[b+72>>2];X=+(E+U-w-Q-(L*ba-K*aa));w=+(F+V-x-R-(K*ba+L*aa));f=b+144|0;g[f>>2]=X;g[f+4>>2]=w;g[b+152>>2]=G-y-+g[b+76>>2];f=b+80|0;if((a[d+24>>0]|0)==0){g[f>>2]=0;g[b+84>>2]=0;g[b+88>>2]=0;ca=B;da=C;ea=H;fa=I;ga=D;ha=J;ia=c[j>>2]|0;ja=c[v>>2]|0;ka=ja+(ia*
12|0)|0;la=+ca;ma=+da;na=ka;oa=na;g[oa>>2]=la;pa=na+4|0;qa=pa;g[qa>>2]=ma;ra=c[j>>2]|0;sa=c[v>>2]|0;ta=sa+(ra*12|0)+8|0;g[ta>>2]=ga;ua=c[n>>2]|0;va=sa+(ua*12|0)|0;wa=+ea;xa=+fa;ya=va;za=ya;g[za>>2]=wa;Aa=ya+4|0;Ba=Aa;g[Ba>>2]=xa;Ca=c[n>>2]|0;Da=c[v>>2]|0;Ea=Da+(Ca*12|0)+8|0;g[Ea>>2]=ha;i=e;return}else{u=d+8|0;y=+g[u>>2];G=y*+g[f>>2];g[f>>2]=G;f=b+84|0;w=y*+g[f>>2];g[f>>2]=w;f=b+88|0;y=+g[u>>2]*+g[f>>2];g[f>>2]=y;ca=B-N*G;da=C-N*w;ea=H+P*G;fa=I+P*w;ga=D-O*(y+(w*Q-G*R));ha=J+M*(y+(w*U-G*V));ia=c[j>>
2]|0;ja=c[v>>2]|0;ka=ja+(ia*12|0)|0;la=+ca;ma=+da;na=ka;oa=na;g[oa>>2]=la;pa=na+4|0;qa=pa;g[qa>>2]=ma;ra=c[j>>2]|0;sa=c[v>>2]|0;ta=sa+(ra*12|0)+8|0;g[ta>>2]=ga;ua=c[n>>2]|0;va=sa+(ua*12|0)|0;wa=+ea;xa=+fa;ya=va;za=ya;g[za>>2]=wa;Aa=ya+4|0;Ba=Aa;g[Ba>>2]=xa;Ca=c[n>>2]|0;Da=c[v>>2]|0;Ea=Da+(Ca*12|0)+8|0;g[Ea>>2]=ha;i=e;return}}function Lf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0;d=i;e=a+104|
0;f=c[e>>2]|0;h=b+32|0;j=c[h>>2]|0;k=j+(f*12|0)|0;l=+g[k>>2];m=+g[k+4>>2];n=+g[j+(f*12|0)+8>>2];f=a+108|0;k=c[f>>2]|0;o=j+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[j+(k*12|0)+8>>2];s=+g[a+156>>2];t=+g[a+160>>2];u=+g[a+164>>2];v=+g[a+168>>2];w=+g[b>>2];x=+g[b+4>>2]*+g[a+100>>2];b=a+88|0;y=+g[b>>2];z=w*+g[a+96>>2];A=y-+g[a+188>>2]*(r-n+x*+g[a+152>>2]);B=-z;C=A<z?A:z;z=C<B?B:C;g[b>>2]=z;C=z-y;y=n-u*C;n=r+v*C;C=+g[a+124>>2];r=+g[a+120>>2];z=+g[a+116>>2];B=+g[a+112>>2];A=+g[a+144>>2]*x+(z*y+(p-C*n-l));D=
x*+g[a+148>>2]+(q+r*n-m-B*y);x=+g[a+176>>2]*A+ +g[a+184>>2]*D;b=a+80|0;k=b;E=+g[k>>2];F=+g[k+4>>2];G=E-(+g[a+172>>2]*A+ +g[a+180>>2]*D);g[b>>2]=G;k=a+84|0;D=+g[k>>2]-x;g[k>>2]=D;x=w*+g[a+92>>2];w=G*G+D*D;if(w>x*x){A=+Q(+w);if(A<1.1920928955078125E-7){H=G;I=D}else{w=1/A;A=G*w;g[b>>2]=A;J=D*w;g[k>>2]=J;H=A;I=J}J=x*H;g[b>>2]=J;H=x*I;g[k>>2]=H;K=J;L=H}else{K=G;L=D}D=K-E;E=L-F;F=+(l-s*D);l=+(m-s*E);k=(c[h>>2]|0)+((c[e>>2]|0)*12|0)|0;g[k>>2]=F;g[k+4>>2]=l;k=c[h>>2]|0;g[k+((c[e>>2]|0)*12|0)+8>>2]=y-u*(B*
E-D*z);z=+(p+t*D);p=+(q+t*E);e=k+((c[f>>2]|0)*12|0)|0;g[e>>2]=z;g[e+4>>2]=p;g[(c[h>>2]|0)+((c[f>>2]|0)*12|0)+8>>2]=n+v*(E*r-D*C);i=d;return}function Mf(a,b){a=a|0;b=b|0;return 1}function Nf(a,b){a=a|0;b=b|0;var d=0,e=0;d=(c[b+48>>2]|0)+12|0;b=c[d+4>>2]|0;e=a;c[e>>2]=c[d>>2];c[e+4>>2]=b;return}function Of(a,b){a=a|0;b=b|0;var d=0,e=0;d=(c[b+52>>2]|0)+12|0;b=c[d+4>>2]|0;e=a;c[e>>2]=c[d>>2];c[e+4>>2]=b;return}function Pf(a,b,c){a=a|0;b=b|0;c=+c;var d=0;d=+g[b+84>>2]*c;g[a>>2]=+g[b+80>>2]*c;g[a+4>>2]=
d;return}function Qf(a,b){a=a|0;b=+b;return+(+g[a+88>>2]*b)}function Rf(a,d){a=a|0;d=d|0;var f=0,h=0,j=0,k=0,l=0;f=i;h=a+68|0;if(!(+g[d>>2]!=+g[h>>2])?!(+g[d+4>>2]!=+g[a+72>>2]):0){i=f;return}j=c[a+48>>2]|0;k=j+4|0;l=e[k>>1]|0;if((l&2|0)==0){b[k>>1]=l|2;g[j+160>>2]=0}j=c[a+52>>2]|0;a=j+4|0;l=e[a>>1]|0;if((l&2|0)==0){b[a>>1]=l|2;g[j+160>>2]=0}j=d;d=c[j+4>>2]|0;l=h;c[l>>2]=c[j>>2];c[l+4>>2]=d;i=f;return}function Sf(a,d){a=a|0;d=+d;var f=0,h=0,j=0,k=0,l=0;f=i;h=a+76|0;if(!(+g[h>>2]!=d)){i=f;return}j=
c[a+48>>2]|0;k=j+4|0;l=e[k>>1]|0;if((l&2|0)==0){b[k>>1]=l|2;g[j+160>>2]=0}j=c[a+52>>2]|0;a=j+4|0;l=e[a>>1]|0;if((l&2|0)==0){b[a>>1]=l|2;g[j+160>>2]=0}g[h>>2]=d;i=f;return}function Tf(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(1104,e);c[e>>2]=f;Rm(1128,e);c[e>>2]=j;Rm(1160,e);c[e>>2]=d[a+61>>0]|0;Rm(1192,e);l=+g[a+72>>2];h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(1232,
e);h[k>>3]=+g[a+76>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(1280,e);h[k>>3]=+g[a+92>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(1312,e);h[k>>3]=+g[a+96>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(1344,e);h[k>>3]=+g[a+100>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(1376,e);c[e>>2]=c[a+56>>2];Rm(1416,e);i=b;return}function Uf(a,b){a=a|0;b=b|0;return}function Vf(a){a=a|0;return}function Wf(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Xf(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=
0,n=0,o=0,p=0;h=i;c[a+8>>2]=b;c[a+12>>2]=d;j=+g[e>>2]-+g[b+12>>2];k=e+4|0;l=+g[k>>2]-+g[b+16>>2];m=+g[b+24>>2];n=+g[b+20>>2];o=+(j*m+l*n);p=+(m*l-j*n);b=a+20|0;g[b>>2]=o;g[b+4>>2]=p;p=+g[f>>2]-+g[d+12>>2];b=f+4|0;o=+g[b>>2]-+g[d+16>>2];n=+g[d+24>>2];j=+g[d+20>>2];l=+(p*n+o*j);m=+(n*o-p*j);d=a+28|0;g[d>>2]=l;g[d+4>>2]=m;m=+g[f>>2]-+g[e>>2];l=+g[b>>2]-+g[k>>2];g[a+36>>2]=+Q(+(m*m+l*l));i=h;return}function Yf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0;d=i;vh(a,b);c[a>>2]=1504;e=b+20|0;f=c[e+4>>2]|0;h=a+80|
0;c[h>>2]=c[e>>2];c[h+4>>2]=f;f=b+28|0;h=c[f+4>>2]|0;e=a+88|0;c[e>>2]=c[f>>2];c[e+4>>2]=h;g[a+104>>2]=+g[b+36>>2];g[a+68>>2]=+g[b+40>>2];g[a+72>>2]=+g[b+44>>2];g[a+100>>2]=0;g[a+96>>2]=0;g[a+76>>2]=0;i=d;return}function Zf(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=
0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+108|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+112|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+140|0;c[o>>2]=p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+148|0;c[o>>2]=r;c[o+4>>2]=s;s=b+156|0;g[s>>2]=+g[f+136>>2];o=b+160|0;g[o>>2]=+g[l+136>>2];t=b+164|0;g[t>>2]=+g[f+144>>2];f=b+168|0;g[f>>2]=+g[l+144>>2];l=c[d+28>>2]|0;u=l+(h*12|0)|0;v=+g[u>>2];w=+g[u+4>>2];x=+g[l+(h*12|0)+8>>2];u=d+32|0;y=c[u>>2]|
0;z=y+(h*12|0)|0;A=+g[z>>2];B=+g[z+4>>2];C=+g[y+(h*12|0)+8>>2];h=l+(m*12|0)|0;D=+g[h>>2];E=+g[h+4>>2];F=+g[l+(m*12|0)+8>>2];l=y+(m*12|0)|0;G=+g[l>>2];H=+g[l+4>>2];I=+g[y+(m*12|0)+8>>2];J=+T(+x);K=+S(+x);x=+T(+F);L=+S(+F);F=+g[b+80>>2]-(c[k>>2]=p,+g[k>>2]);M=+g[b+84>>2]-(c[k>>2]=q,+g[k>>2]);N=K*F-J*M;O=J*F+K*M;M=+N;K=+O;q=b+124|0;g[q>>2]=M;g[q+4>>2]=K;K=+g[b+88>>2]-(c[k>>2]=r,+g[k>>2]);M=+g[b+92>>2]-+g[b+152>>2];F=L*K-x*M;J=x*K+L*M;M=+F;L=+J;r=b+132|0;g[r>>2]=M;g[r+4>>2]=L;r=b+116|0;L=D+F-v-N;v=E+
J-w-O;w=+L;E=+v;q=r;g[q>>2]=w;g[q+4>>2]=E;E=+Q(+(L*L+v*v));if(E>.004999999888241291){w=1/E;D=L*w;g[r>>2]=D;P=w*v;R=D}else{g[r>>2]=0;P=0;R=0}g[b+120>>2]=P;D=P*N-O*R;v=P*F-R*J;w=+g[s>>2];L=+g[t>>2];M=+g[o>>2];K=+g[f>>2];x=M+(w+D*D*L)+v*v*K;if(x!=0)U=1/x;else U=0;f=b+172|0;g[f>>2]=U;v=+g[b+68>>2];if(v>0){D=E-+g[b+104>>2];E=v*6.2831854820251465;v=E*U*E;V=+g[d>>2];W=V*(E*U*2*+g[b+72>>2]+v*V);o=b+96|0;g[o>>2]=W;if(W!=0)X=1/W;else X=0;g[o>>2]=X;g[b+76>>2]=v*D*V*X;V=x+X;if(V!=0)Y=1/V;else Y=0;g[f>>2]=Y}else{g[b+
96>>2]=0;g[b+76>>2]=0}if((a[d+24>>0]|0)==0){g[b+100>>2]=0;Z=A;_=B;$=G;aa=H;ba=C;ca=I;da=c[j>>2]|0;ea=c[u>>2]|0;fa=ea+(da*12|0)|0;ga=+Z;ha=+_;ia=fa;ja=ia;g[ja>>2]=ga;ka=ia+4|0;la=ka;g[la>>2]=ha;ma=c[j>>2]|0;na=c[u>>2]|0;oa=na+(ma*12|0)+8|0;g[oa>>2]=ba;pa=c[n>>2]|0;qa=na+(pa*12|0)|0;ra=+$;sa=+aa;ta=qa;ua=ta;g[ua>>2]=ra;va=ta+4|0;wa=va;g[wa>>2]=sa;xa=c[n>>2]|0;ya=c[u>>2]|0;za=ya+(xa*12|0)+8|0;g[za>>2]=ca;i=e;return}else{f=b+100|0;Y=+g[d+8>>2]*+g[f>>2];g[f>>2]=Y;V=R*Y;R=Y*P;Z=A-V*w;_=B-R*w;$=G+V*M;aa=
H+R*M;ba=C-L*(R*N-V*O);ca=I+K*(R*F-V*J);da=c[j>>2]|0;ea=c[u>>2]|0;fa=ea+(da*12|0)|0;ga=+Z;ha=+_;ia=fa;ja=ia;g[ja>>2]=ga;ka=ia+4|0;la=ka;g[la>>2]=ha;ma=c[j>>2]|0;na=c[u>>2]|0;oa=na+(ma*12|0)+8|0;g[oa>>2]=ba;pa=c[n>>2]|0;qa=na+(pa*12|0)|0;ra=+$;sa=+aa;ta=qa;ua=ta;g[ua>>2]=ra;va=ta+4|0;wa=va;g[wa>>2]=sa;xa=c[n>>2]|0;ya=c[u>>2]|0;za=ya+(xa*12|0)+8|0;g[za>>2]=ca;i=e;return}}function _f(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;d=i;e=a+
108|0;f=c[e>>2]|0;h=b+32|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=j;l=+g[k>>2];m=+g[k+4>>2];n=+g[b+(f*12|0)+8>>2];f=a+112|0;k=c[f>>2]|0;o=b+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[b+(k*12|0)+8>>2];s=+g[a+128>>2];t=+g[a+124>>2];u=+g[a+136>>2];v=+g[a+132>>2];w=+g[a+116>>2];x=+g[a+120>>2];k=a+100|0;y=+g[k>>2];z=+g[a+172>>2]*(+g[a+76>>2]+(w*(p-r*u-(l-n*s))+x*(q+r*v-(m+n*t)))+ +g[a+96>>2]*y);A=-z;g[k>>2]=y-z;z=w*A;w=x*A;A=+g[a+156>>2];x=n-+g[a+164>>2]*(t*w-z*s);s=+g[a+160>>2];t=r+ +g[a+168>>2]*(w*v-z*u);u=+(l-A*
z);l=+(m-A*w);a=j;g[a>>2]=u;g[a+4>>2]=l;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=x;x=+(p+z*s);z=+(q+w*s);e=a+((c[f>>2]|0)*12|0)|0;g[e>>2]=x;g[e+4>>2]=z;g[(c[h>>2]|0)+((c[f>>2]|0)*12|0)+8>>2]=t;i=d;return}function $f(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0;d=i;if(+g[a+68>>2]>0){e=1;i=d;return e|0}f=a+108|0;h=c[f>>2]|0;j=b+28|0;b=c[j>>2]|0;k=b+(h*12|0)|0;l=k;m=+g[l>>2];n=+g[l+4>>2];o=+g[b+(h*12|0)+8>>2];h=a+112|0;l=
c[h>>2]|0;p=b+(l*12|0)|0;q=+g[p>>2];r=+g[p+4>>2];s=+g[b+(l*12|0)+8>>2];t=+T(+o);u=+S(+o);v=+T(+s);w=+S(+s);x=+g[a+80>>2]-+g[a+140>>2];y=+g[a+84>>2]-+g[a+144>>2];z=u*x-t*y;A=t*x+u*y;y=+g[a+88>>2]-+g[a+148>>2];u=+g[a+92>>2]-+g[a+152>>2];x=w*y-v*u;t=v*y+w*u;u=q+x-m-z;w=r+t-n-A;y=+Q(+(u*u+w*w));if(y<1.1920928955078125E-7){B=0;C=u;D=w}else{v=1/y;B=y;C=u*v;D=w*v}v=B-+g[a+104>>2];B=v<.20000000298023224?v:.20000000298023224;v=B<-.20000000298023224?-.20000000298023224:B;B=-(+g[a+172>>2]*v);w=C*B;C=D*B;B=+g[a+
156>>2];D=o-+g[a+164>>2]*(z*C-A*w);A=+g[a+160>>2];z=s+ +g[a+168>>2]*(x*C-t*w);t=+(m-B*w);m=+(n-B*C);a=k;g[a>>2]=t;g[a+4>>2]=m;a=c[j>>2]|0;g[a+((c[f>>2]|0)*12|0)+8>>2]=D;D=+(q+A*w);w=+(r+A*C);f=a+((c[h>>2]|0)*12|0)|0;g[f>>2]=D;g[f+4>>2]=w;g[(c[j>>2]|0)+((c[h>>2]|0)*12|0)+8>>2]=z;if(v>0)E=v;else E=-v;e=E<.004999999888241291;i=d;return e|0}function ag(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+80>>2];h=+g[d+20>>2];i=+g[b+84>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+
12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function bg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+88>>2];h=+g[d+20>>2];i=+g[b+92>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function cg(a,b,c){a=a|0;b=b|0;c=+c;var d=0;d=+g[b+100>>2]*c;c=d*+g[b+120>>2];g[a>>2]=+g[b+116>>2]*d;g[a+4>>2]=c;return}function dg(a,b){a=a|0;b=+b;return 0}function eg(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+
8>>2]|0;Rm(1552,e);c[e>>2]=f;Rm(1584,e);c[e>>2]=j;Rm(1616,e);c[e>>2]=d[a+61>>0]|0;Rm(1648,e);l=+g[a+84>>2];h[k>>3]=+g[a+80>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(1688,e);l=+g[a+92>>2];h[k>>3]=+g[a+88>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(1736,e);h[k>>3]=+g[a+104>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(1784,e);h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(1808,e);h[k>>
3]=+g[a+72>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(1840,e);c[e>>2]=c[a+56>>2];Rm(1872,e);i=b;return}function fg(a){a=a|0;return}function gg(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function hg(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;f=i;c[a+8>>2]=b;c[a+12>>2]=d;h=+g[e>>2]-+g[b+12>>2];j=e+4|0;k=+g[j>>2]-+g[b+16>>2];l=+g[b+24>>2];m=+g[b+20>>2];n=+(h*l+k*m);o=+(l*k-h*m);b=a+20|0;g[b>>2]=n;g[b+4>>2]=o;o=+g[e>>2]-+g[d+12>>2];n=+g[j>>2]-+g[d+16>>2];m=+g[d+24>>2];h=+g[d+20>>
2];k=+(o*m+n*h);l=+(m*n-o*h);d=a+28|0;g[d>>2]=k;g[d+4>>2]=l;i=f;return}function ig(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0;d=i;vh(a,b);c[a>>2]=1968;e=b+20|0;f=c[e+4>>2]|0;h=a+68|0;c[h>>2]=c[e>>2];c[h+4>>2]=f;f=b+28|0;h=c[f+4>>2]|0;e=a+76|0;c[e>>2]=c[f>>2];c[e+4>>2]=h;g[a+84>>2]=0;g[a+88>>2]=0;g[a+92>>2]=0;g[a+96>>2]=+g[b+36>>2];g[a+100>>2]=+g[b+40>>2];i=d;return}function jg(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=
0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+104|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+108|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+128|0;c[o>>2]=p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+136|0;c[o>>2]=r;c[o+4>>2]=s;o=b+144|0;g[o>>2]=+g[f+136>>2];t=+g[l+136>>2];g[b+148>>2]=t;u=+g[f+144>>2];g[b+152>>2]=u;v=
+g[l+144>>2];g[b+156>>2]=v;l=c[d+28>>2]|0;w=+g[l+(h*12|0)+8>>2];f=d+32|0;x=c[f>>2]|0;y=x+(h*12|0)|0;z=+g[y>>2];A=+g[y+4>>2];B=+g[x+(h*12|0)+8>>2];C=+g[l+(m*12|0)+8>>2];l=x+(m*12|0)|0;D=+g[l>>2];E=+g[l+4>>2];F=+g[x+(m*12|0)+8>>2];G=+T(+w);H=+S(+w);w=+T(+C);I=+S(+C);C=+g[b+68>>2]-(c[k>>2]=p,+g[k>>2]);J=+g[b+72>>2]-(c[k>>2]=q,+g[k>>2]);K=H*C-G*J;L=G*C+H*J;J=+K;H=+L;q=b+112|0;g[q>>2]=J;g[q+4>>2]=H;H=+g[b+76>>2]-(c[k>>2]=r,+g[k>>2]);J=+g[b+80>>2]-(c[k>>2]=s,+g[k>>2]);C=I*H-w*J;G=w*H+I*J;J=+C;I=+G;s=b+
120|0;g[s>>2]=J;g[s+4>>2]=I;I=+g[o>>2];J=I+t;H=J+L*u*L+G*v*G;w=u*K;M=v*C;N=-(L*w)-G*M;O=J+K*w+C*M;M=H*O-N*N;if(M!=0)P=1/M;else P=M;M=-(N*P);g[b+160>>2]=O*P;g[b+164>>2]=M;g[b+168>>2]=M;g[b+172>>2]=H*P;P=u+v;if(P>0)Q=1/P;else Q=P;g[b+176>>2]=Q;o=b+84|0;if((a[d+24>>0]|0)==0){g[o>>2]=0;g[b+88>>2]=0;g[b+92>>2]=0;R=z;U=A;V=D;W=E;X=B;Y=F;Z=c[j>>2]|0;_=c[f>>2]|0;$=_+(Z*12|0)|0;aa=+R;ba=+U;ca=$;da=ca;g[da>>2]=aa;ea=ca+4|0;fa=ea;g[fa>>2]=ba;ga=c[j>>2]|0;ha=c[f>>2]|0;ia=ha+(ga*12|0)+8|0;g[ia>>2]=X;ja=c[n>>2]|
0;ka=ha+(ja*12|0)|0;la=+V;ma=+W;na=ka;oa=na;g[oa>>2]=la;pa=na+4|0;qa=pa;g[qa>>2]=ma;ra=c[n>>2]|0;sa=c[f>>2]|0;ta=sa+(ra*12|0)+8|0;g[ta>>2]=Y;i=e;return}else{s=d+8|0;Q=+g[s>>2];P=Q*+g[o>>2];g[o>>2]=P;o=b+88|0;H=Q*+g[o>>2];g[o>>2]=H;o=b+92|0;Q=+g[s>>2]*+g[o>>2];g[o>>2]=Q;R=z-I*P;U=A-I*H;V=D+t*P;W=E+t*H;X=B-u*(Q+(H*K-P*L));Y=F+v*(Q+(H*C-P*G));Z=c[j>>2]|0;_=c[f>>2]|0;$=_+(Z*12|0)|0;aa=+R;ba=+U;ca=$;da=ca;g[da>>2]=aa;ea=ca+4|0;fa=ea;g[fa>>2]=ba;ga=c[j>>2]|0;ha=c[f>>2]|0;ia=ha+(ga*12|0)+8|0;g[ia>>2]=X;
ja=c[n>>2]|0;ka=ha+(ja*12|0)|0;la=+V;ma=+W;na=ka;oa=na;g[oa>>2]=la;pa=na+4|0;qa=pa;g[qa>>2]=ma;ra=c[n>>2]|0;sa=c[f>>2]|0;ta=sa+(ra*12|0)+8|0;g[ta>>2]=Y;i=e;return}}function kg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0;d=i;e=a+104|0;f=c[e>>2]|0;h=b+32|0;j=c[h>>2]|0;k=j+(f*12|0)|0;l=+g[k>>2];m=+g[k+4>>2];n=+g[j+(f*12|0)+8>>2];f=a+108|0;k=c[f>>2]|0;o=j+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[j+
(k*12|0)+8>>2];s=+g[a+144>>2];t=+g[a+148>>2];u=+g[a+152>>2];v=+g[a+156>>2];w=+g[b>>2];b=a+92|0;x=+g[b>>2];y=w*+g[a+100>>2];z=x-(r-n)*+g[a+176>>2];A=-y;B=z<y?z:y;y=B<A?A:B;g[b>>2]=y;B=y-x;x=n-u*B;n=r+v*B;B=+g[a+124>>2];r=+g[a+120>>2];y=+g[a+116>>2];A=+g[a+112>>2];z=y*x+(p-B*n-l);C=q+r*n-m-A*x;D=+g[a+164>>2]*z+ +g[a+172>>2]*C;b=a+84|0;k=b;E=+g[k>>2];F=+g[k+4>>2];G=E-(+g[a+160>>2]*z+ +g[a+168>>2]*C);g[b>>2]=G;k=a+88|0;C=+g[k>>2]-D;g[k>>2]=C;D=w*+g[a+96>>2];w=G*G+C*C;if(w>D*D){z=+Q(+w);if(z<1.1920928955078125E-7){H=
G;I=C}else{w=1/z;z=G*w;g[b>>2]=z;J=C*w;g[k>>2]=J;H=z;I=J}J=D*H;g[b>>2]=J;H=D*I;g[k>>2]=H;K=J;L=H}else{K=G;L=C}C=K-E;E=L-F;F=+(l-s*C);l=+(m-s*E);k=(c[h>>2]|0)+((c[e>>2]|0)*12|0)|0;g[k>>2]=F;g[k+4>>2]=l;k=c[h>>2]|0;g[k+((c[e>>2]|0)*12|0)+8>>2]=x-u*(A*E-C*y);y=+(p+t*C);p=+(q+t*E);e=k+((c[f>>2]|0)*12|0)|0;g[e>>2]=y;g[e+4>>2]=p;g[(c[h>>2]|0)+((c[f>>2]|0)*12|0)+8>>2]=n+v*(E*r-C*B);i=d;return}function lg(a,b){a=a|0;b=b|0;return 1}function mg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=
+g[d+24>>2];f=+g[b+68>>2];h=+g[d+20>>2];i=+g[b+72>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function ng(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+76>>2];h=+g[d+20>>2];i=+g[b+80>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function og(a,b,c){a=a|0;b=b|0;c=+c;var d=0;d=+g[b+88>>2]*c;g[a>>2]=+g[b+84>>2]*c;g[a+4>>2]=d;return}function pg(a,b){a=a|0;b=+b;return+(+g[a+92>>2]*b)}function qg(a){a=a|0;var b=
0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(2016,e);c[e>>2]=f;Rm(2048,e);c[e>>2]=j;Rm(2080,e);c[e>>2]=d[a+61>>0]|0;Rm(2112,e);l=+g[a+72>>2];h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(2152,e);l=+g[a+80>>2];h[k>>3]=+g[a+76>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(2200,e);h[k>>3]=+g[a+96>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(2248,
e);h[k>>3]=+g[a+100>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(2280,e);c[e>>2]=c[a+56>>2];Rm(2312,e);i=b;return}function rg(a){a=a|0;return}function sg(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function tg(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;f=i;c[a+8>>2]=b;c[a+12>>2]=d;h=+g[e>>2]-+g[b+12>>2];j=e+4|0;k=+g[j>>2]-+g[b+16>>2];l=+g[b+24>>2];m=+g[b+20>>2];n=+(h*l+k*m);o=+(l*k-h*m);p=a+20|0;g[p>>2]=n;g[p+4>>2]=o;o=+g[e>>2]-+g[d+12>>2];n=+g[j>>2]-+g[d+16>>2];m=+g[d+24>>2];
h=+g[d+20>>2];k=+(o*m+n*h);l=+(m*n-o*h);j=a+28|0;g[j>>2]=k;g[j+4>>2]=l;g[a+36>>2]=+g[d+72>>2]-+g[b+72>>2];i=f;return}function ug(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0;d=i;vh(a,b);c[a>>2]=2408;e=b+20|0;f=c[e+4>>2]|0;h=a+80|0;c[h>>2]=c[e>>2];c[h+4>>2]=f;f=b+28|0;h=c[f+4>>2]|0;e=a+88|0;c[e>>2]=c[f>>2];c[e+4>>2]=h;g[a+96>>2]=+g[b+36>>2];g[a+68>>2]=+g[b+40>>2];g[a+72>>2]=+g[b+44>>2];g[a+104>>2]=0;g[a+108>>2]=0;g[a+112>>2]=0;i=d;return}function vg(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,
q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0;e=i;i=i+48|0;f=e;h=c[b+48>>2]|0;j=c[h+8>>2]|0;l=b+116|0;c[l>>2]=j;m=c[b+52>>2]|0;n=c[m+8>>2]|0;o=b+120|0;c[o>>2]=n;p=h+44|0;q=c[p>>2]|0;r=c[p+4>>2]|0;p=b+140|0;c[p>>2]=q;c[p+4>>2]=r;p=m+44|0;s=c[p>>2]|0;t=c[p+4>>2]|0;p=b+148|0;c[p>>2]=s;c[p+4>>2]=t;p=b+
156|0;g[p>>2]=+g[h+136>>2];u=+g[m+136>>2];g[b+160>>2]=u;v=+g[h+144>>2];g[b+164>>2]=v;w=+g[m+144>>2];g[b+168>>2]=w;m=c[d+28>>2]|0;x=+g[m+(j*12|0)+8>>2];h=d+32|0;y=c[h>>2]|0;z=y+(j*12|0)|0;A=+g[z>>2];B=+g[z+4>>2];C=+g[y+(j*12|0)+8>>2];D=+g[m+(n*12|0)+8>>2];m=y+(n*12|0)|0;E=+g[m>>2];F=+g[m+4>>2];G=+g[y+(n*12|0)+8>>2];H=+T(+x);I=+S(+x);J=+T(+D);K=+S(+D);n=b+124|0;L=+g[b+80>>2]-(c[k>>2]=q,+g[k>>2]);M=+g[b+84>>2]-(c[k>>2]=r,+g[k>>2]);N=I*L-H*M;O=H*L+I*M;M=+N;I=+O;r=n;g[r>>2]=M;g[r+4>>2]=I;r=b+132|0;I=+g[b+
88>>2]-(c[k>>2]=s,+g[k>>2]);M=+g[b+92>>2]-(c[k>>2]=t,+g[k>>2]);L=K*I-J*M;H=J*I+K*M;M=+L;K=+H;t=r;g[t>>2]=M;g[t+4>>2]=K;K=+g[p>>2];M=K+u;p=b+128|0;t=b+136|0;g[f>>2]=M+v*O*O+w*H*H;I=-(v*O*N)-w*H*L;g[f+12>>2]=I;J=-(v*O)-w*H;g[f+24>>2]=J;g[f+4>>2]=I;g[f+16>>2]=M+v*N*N+w*L*L;M=v*N+w*L;g[f+28>>2]=M;g[f+8>>2]=J;g[f+20>>2]=M;M=v+w;g[f+32>>2]=M;s=b+68|0;q=b+172|0;if(+g[s>>2]>0){Im(f,q);if(M>0)P=1/M;else P=0;J=D-x-+g[b+96>>2];x=+g[s>>2]*6.2831854820251465;D=x*P*x;L=+g[d>>2];N=L*(x*P*2*+g[b+72>>2]+L*D);s=b+
100|0;g[s>>2]=N;if(N!=0)Q=1/N;else Q=0;g[s>>2]=Q;g[b+76>>2]=J*L*D*Q;D=M+Q;if(D!=0)R=1/D;else R=0;g[b+204>>2]=R}else{Jm(f,q);g[b+100>>2]=0;g[b+76>>2]=0}q=b+104|0;if((a[d+24>>0]|0)==0){g[q>>2]=0;g[b+108>>2]=0;g[b+112>>2]=0;U=A;V=B;W=E;X=F;Y=C;Z=G;_=c[l>>2]|0;$=c[h>>2]|0;aa=$+(_*12|0)|0;ba=+U;ca=+V;da=aa;ea=da;g[ea>>2]=ba;fa=da+4|0;ga=fa;g[ga>>2]=ca;ha=c[l>>2]|0;ia=c[h>>2]|0;ja=ia+(ha*12|0)+8|0;g[ja>>2]=Y;ka=c[o>>2]|0;la=ia+(ka*12|0)|0;ma=+W;na=+X;oa=la;pa=oa;g[pa>>2]=ma;qa=oa+4|0;ra=qa;g[ra>>2]=na;
sa=c[o>>2]|0;ta=c[h>>2]|0;ua=ta+(sa*12|0)+8|0;g[ua>>2]=Z;i=e;return}else{R=+g[d+8>>2];D=R*+g[q>>2];g[q>>2]=D;q=b+108|0;Q=R*+g[q>>2];g[q>>2]=Q;q=b+112|0;M=R*+g[q>>2];g[q>>2]=M;U=A-K*D;V=B-K*Q;W=E+u*D;X=F+u*Q;Y=C-v*(M+(Q*+g[n>>2]-D*+g[p>>2]));Z=G+w*(M+(Q*+g[r>>2]-D*+g[t>>2]));_=c[l>>2]|0;$=c[h>>2]|0;aa=$+(_*12|0)|0;ba=+U;ca=+V;da=aa;ea=da;g[ea>>2]=ba;fa=da+4|0;ga=fa;g[ga>>2]=ca;ha=c[l>>2]|0;ia=c[h>>2]|0;ja=ia+(ha*12|0)+8|0;g[ja>>2]=Y;ka=c[o>>2]|0;la=ia+(ka*12|0)|0;ma=+W;na=+X;oa=la;pa=oa;g[pa>>2]=ma;
qa=oa+4|0;ra=qa;g[ra>>2]=na;sa=c[o>>2]|0;ta=c[h>>2]|0;ua=ta+(sa*12|0)+8|0;g[ua>>2]=Z;i=e;return}}function wg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0;d=i;e=a+116|0;f=c[e>>2]|0;h=b+32|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=j;l=+g[k>>2];m=+g[k+4>>2];n=+g[b+(f*12|0)+8>>2];f=a+120|0;k=c[f>>
2]|0;o=b+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[b+(k*12|0)+8>>2];s=+g[a+156>>2];t=+g[a+160>>2];u=+g[a+164>>2];v=+g[a+168>>2];if(+g[a+68>>2]>0){k=a+112|0;w=+g[k>>2];x=+g[a+204>>2]*(r-n+ +g[a+76>>2]+ +g[a+100>>2]*w);y=-x;g[k>>2]=w-x;x=n-u*y;w=r+v*y;y=+g[a+136>>2];z=+g[a+132>>2];A=+g[a+128>>2];B=+g[a+124>>2];C=A*x+(p-y*w-l);D=q+z*w-m-B*x;E=+g[a+172>>2]*C+ +g[a+184>>2]*D;F=+g[a+176>>2]*C+ +g[a+188>>2]*D;D=-E;C=-F;k=a+104|0;g[k>>2]=+g[k>>2]-E;k=a+108|0;g[k>>2]=+g[k>>2]-F;G=C;H=D;I=x-u*(B*C-A*D);J=w+v*
(z*C-y*D);K=t*H;L=t*G;M=s*H;N=s*G;O=p+K;P=q+L;Q=l-M;R=m-N;S=+Q;T=+R;U=j;V=U;g[V>>2]=S;W=U+4|0;X=W;g[X>>2]=T;Y=c[e>>2]|0;Z=c[h>>2]|0;_=Z+(Y*12|0)+8|0;g[_>>2]=I;$=c[f>>2]|0;aa=Z+($*12|0)|0;ba=+O;ca=+P;da=aa;ea=da;g[ea>>2]=ba;fa=da+4|0;ga=fa;g[ga>>2]=ca;ha=c[f>>2]|0;ia=c[h>>2]|0;ja=ia+(ha*12|0)+8|0;g[ja>>2]=J;i=d;return}else{D=+g[a+136>>2];y=+g[a+132>>2];C=+g[a+128>>2];z=+g[a+124>>2];w=p-r*D-l+n*C;A=q+r*y-m-n*z;B=r-n;x=w*+g[a+172>>2]+A*+g[a+184>>2]+B*+g[a+196>>2];F=w*+g[a+176>>2]+A*+g[a+188>>2]+B*+g[a+
200>>2];E=w*+g[a+180>>2]+A*+g[a+192>>2]+B*+g[a+204>>2];B=-x;A=-F;k=a+104|0;g[k>>2]=+g[k>>2]-x;k=a+108|0;g[k>>2]=+g[k>>2]-F;k=a+112|0;g[k>>2]=+g[k>>2]-E;G=A;H=B;I=n-u*(z*A-C*B-E);J=r+v*(y*A-D*B-E);K=t*H;L=t*G;M=s*H;N=s*G;O=p+K;P=q+L;Q=l-M;R=m-N;S=+Q;T=+R;U=j;V=U;g[V>>2]=S;W=U+4|0;X=W;g[X>>2]=T;Y=c[e>>2]|0;Z=c[h>>2]|0;_=Z+(Y*12|0)+8|0;g[_>>2]=I;$=c[f>>2]|0;aa=Z+($*12|0)|0;ba=+O;ca=+P;da=aa;ea=da;g[ea>>2]=ba;fa=da+4|0;ga=fa;g[ga>>2]=ca;ha=c[f>>2]|0;ia=c[h>>2]|0;ja=ia+(ha*12|0)+8|0;g[ja>>2]=J;i=d;return}}
function xg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0;d=i;i=i+80|0;e=d+40|0;f=d+32|0;h=d+24|0;j=d+12|0;k=d;l=a+116|0;m=c[l>>2]|0;n=b+28|0;b=c[n>>2]|0;o=b+(m*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[b+(m*12|0)+8>>2];m=a+120|0;o=c[m>>2]|0;s=b+(o*12|0)|0;t=+g[s>>2];u=+g[s+4>>2];v=+g[b+(o*12|0)+8>>2];w=+T(+r);x=+S(+r);y=+T(+v);z=+S(+v);A=+g[a+156>>2];B=+g[a+160>>2];C=+g[a+164>>
2];D=+g[a+168>>2];E=+g[a+80>>2]-+g[a+140>>2];F=+g[a+84>>2]-+g[a+144>>2];G=x*E-w*F;H=w*E+x*F;F=+g[a+88>>2]-+g[a+148>>2];x=+g[a+92>>2]-+g[a+152>>2];E=z*F-y*x;w=y*F+z*x;x=A+B;g[e>>2]=x+C*H*H+D*w*w;z=-(C*H*G)-D*w*E;g[e+12>>2]=z;F=-(C*H)-D*w;g[e+24>>2]=F;g[e+4>>2]=z;g[e+16>>2]=x+C*G*G+D*E*E;x=C*G+D*E;g[e+28>>2]=x;g[e+8>>2]=F;g[e+20>>2]=x;g[e+32>>2]=C+D;x=t+E-p-G;F=u+w-q-H;if(+g[a+68>>2]>0){g[f>>2]=x;g[f+4>>2]=F;z=+Q(+(F*F+x*x));Hm(h,e,f);y=-+g[h>>2];I=-+g[h+4>>2];J=I;K=y;L=E*I-w*y;M=G*I-H*y;N=0;O=z}else{z=
v-r-+g[a+96>>2];y=+Q(+(x*x+F*F));if(z>0)P=z;else P=-z;g[j>>2]=x;g[j+4>>2]=F;g[j+8>>2]=z;Gm(k,e,j);z=-+g[k>>2];F=-+g[k+4>>2];x=+g[k+8>>2];J=F;K=z;L=E*F-w*z-x;M=G*F-H*z-x;N=P;O=y}y=+(p-A*K);p=+(q-A*J);k=(c[n>>2]|0)+((c[l>>2]|0)*12|0)|0;g[k>>2]=y;g[k+4>>2]=p;k=c[n>>2]|0;g[k+((c[l>>2]|0)*12|0)+8>>2]=r-C*M;M=+(t+B*K);K=+(u+B*J);l=k+((c[m>>2]|0)*12|0)|0;g[l>>2]=M;g[l+4>>2]=K;g[(c[n>>2]|0)+((c[m>>2]|0)*12|0)+8>>2]=v+D*L;if(!(O<=.004999999888241291)){R=0;i=d;return R|0}R=N<=.03490658849477768;i=d;return R|
0}function yg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+80>>2];h=+g[d+20>>2];i=+g[b+84>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function zg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+88>>2];h=+g[d+20>>2];i=+g[b+92>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Ag(a,b,c){a=a|0;b=b|0;c=+c;var d=0;d=+g[b+108>>2]*c;g[a>>2]=+g[b+104>>2]*c;g[a+4>>2]=d;return}
function Bg(a,b){a=a|0;b=+b;return+(+g[a+112>>2]*b)}function Cg(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(2456,e);c[e>>2]=f;Rm(2480,e);c[e>>2]=j;Rm(2512,e);c[e>>2]=d[a+61>>0]|0;Rm(2544,e);l=+g[a+84>>2];h[k>>3]=+g[a+80>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(2584,e);l=+g[a+92>>2];h[k>>3]=+g[a+88>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=
c[k+4>>2];Rm(2632,e);h[k>>3]=+g[a+96>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(2680,e);h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(2712,e);h[k>>3]=+g[a+72>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(2744,e);c[e>>2]=c[a+56>>2];Rm(2776,e);i=b;return}function Dg(a){a=a|0;return}function Eg(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Fg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,
M=0,N=0,O=0,P=0,Q=0,R=0;d=i;vh(a,b);c[a>>2]=2864;e=a+92|0;f=a+100|0;h=a+108|0;j=a+116|0;l=a+124|0;m=a+132|0;n=b+20|0;o=c[n>>2]|0;c[a+68>>2]=o;p=b+24|0;q=c[p>>2]|0;c[a+72>>2]=q;r=c[o+4>>2]|0;c[a+76>>2]=r;s=c[q+4>>2]|0;c[a+80>>2]=s;t=c[o+48>>2]|0;c[a+84>>2]=t;u=c[o+52>>2]|0;c[a+48>>2]=u;v=+g[u+20>>2];w=+g[u+24>>2];x=+g[t+20>>2];y=+g[t+24>>2];o=c[n>>2]|0;if((r|0)==1){z=+g[u+72>>2];A=+g[t+72>>2];r=o+68|0;n=c[r+4>>2]|0;B=h;c[B>>2]=c[r>>2];c[B+4>>2]=n;n=o+76|0;B=c[n+4>>2]|0;r=e;c[r>>2]=c[n>>2];c[r+4>>2]=
B;C=+g[o+116>>2];g[a+140>>2]=C;g[l>>2]=0;g[a+128>>2]=0;D=z-A-C}else{C=+g[t+16>>2];A=+g[t+12>>2];z=+g[u+16>>2];E=+g[u+12>>2];u=o+68|0;t=c[u>>2]|0;B=c[u+4>>2]|0;u=h;c[u>>2]=t;c[u+4>>2]=B;u=o+76|0;h=c[u>>2]|0;r=c[u+4>>2]|0;u=e;c[u>>2]=h;c[u+4>>2]=r;g[a+140>>2]=+g[o+100>>2];u=o+84|0;o=c[u>>2]|0;e=c[u+4>>2]|0;u=l;c[u>>2]=o;c[u+4>>2]=e;F=(c[k>>2]=t,+g[k>>2]);G=(c[k>>2]=B,+g[k>>2]);H=(c[k>>2]=h,+g[k>>2]);I=(c[k>>2]=r,+g[k>>2]);J=E-A+(w*H-v*I);A=z-C+(v*H+w*I);I=(c[k>>2]=o,+g[k>>2])*(y*J+x*A-F);D=I+(c[k>>
2]=e,+g[k>>2])*(y*A-x*J-G)}e=c[q+48>>2]|0;c[a+88>>2]=e;o=c[q+52>>2]|0;c[a+52>>2]=o;G=+g[o+20>>2];J=+g[o+24>>2];x=+g[e+20>>2];A=+g[e+24>>2];q=c[p>>2]|0;if((s|0)==1){y=+g[o+72>>2];I=+g[e+72>>2];s=q+68|0;p=c[s+4>>2]|0;r=j;c[r>>2]=c[s>>2];c[r+4>>2]=p;p=q+76|0;r=c[p+4>>2]|0;s=f;c[s>>2]=c[p>>2];c[s+4>>2]=r;F=+g[q+116>>2];g[a+144>>2]=F;g[m>>2]=0;g[a+136>>2]=0;K=y-I-F;L=b+28|0;M=+g[L>>2];N=a+152|0;g[N>>2]=M;O=K*M;P=D+O;Q=a+148|0;g[Q>>2]=P;R=a+156|0;g[R>>2]=0;i=d;return}else{F=+g[e+16>>2];I=+g[e+12>>2];y=
+g[o+16>>2];w=+g[o+12>>2];o=q+68|0;e=c[o>>2]|0;r=c[o+4>>2]|0;o=j;c[o>>2]=e;c[o+4>>2]=r;o=q+76|0;j=c[o>>2]|0;s=c[o+4>>2]|0;o=f;c[o>>2]=j;c[o+4>>2]=s;g[a+144>>2]=+g[q+100>>2];o=q+84|0;q=c[o>>2]|0;f=c[o+4>>2]|0;o=m;c[o>>2]=q;c[o+4>>2]=f;H=(c[k>>2]=e,+g[k>>2]);v=(c[k>>2]=r,+g[k>>2]);C=(c[k>>2]=j,+g[k>>2]);z=(c[k>>2]=s,+g[k>>2]);E=w-I+(J*C-G*z);I=y-F+(G*C+J*z);z=(c[k>>2]=q,+g[k>>2])*(A*E+x*I-H);K=z+(c[k>>2]=f,+g[k>>2])*(A*I-x*E-v);L=b+28|0;M=+g[L>>2];N=a+152|0;g[N>>2]=M;O=K*M;P=D+O;Q=a+148|0;g[Q>>2]=P;
R=a+156|0;g[R>>2]=0;i=d;return}}function Gg(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=
0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0,ob=0,pb=0,qb=0,rb=0,sb=0,tb=0,ub=0,vb=0,wb=0,xb=0,yb=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+160|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+164|0;c[n>>2]=m;o=c[b+84>>2]|0;p=c[o+8>>2]|0;q=b+168|0;c[q>>2]=p;r=c[b+88>>2]|0;s=c[r+8>>2]|0;t=b+172|0;c[t>>2]=s;u=b+176|0;v=f+44|0;w=c[v+4>>2]|0;x=u;c[x>>2]=c[v>>2];c[x+4>>2]=w;w=b+184|0;x=l+44|0;v=c[x+4>>2]|0;y=w;c[y>>2]=c[x>>2];c[y+4>>2]=v;v=b+192|0;y=o+44|0;x=c[y+4>>2]|0;z=
v;c[z>>2]=c[y>>2];c[z+4>>2]=x;x=r+44|0;z=c[x>>2]|0;y=c[x+4>>2]|0;x=b+200|0;c[x>>2]=z;c[x+4>>2]=y;A=+g[f+136>>2];g[b+208>>2]=A;B=+g[l+136>>2];g[b+212>>2]=B;C=+g[o+136>>2];g[b+216>>2]=C;D=+g[r+136>>2];g[b+220>>2]=D;E=+g[f+144>>2];g[b+224>>2]=E;F=+g[l+144>>2];g[b+228>>2]=F;G=+g[o+144>>2];g[b+232>>2]=G;H=+g[r+144>>2];g[b+236>>2]=H;r=c[d+28>>2]|0;I=+g[r+(h*12|0)+8>>2];o=d+32|0;l=c[o>>2]|0;f=l+(h*12|0)|0;J=+g[f>>2];K=+g[f+4>>2];L=+g[l+(h*12|0)+8>>2];M=+g[r+(m*12|0)+8>>2];h=l+(m*12|0)|0;N=+g[h>>2];O=+g[h+
4>>2];P=+g[l+(m*12|0)+8>>2];Q=+g[r+(p*12|0)+8>>2];m=l+(p*12|0)|0;R=+g[m>>2];U=+g[m+4>>2];V=+g[l+(p*12|0)+8>>2];W=+g[r+(s*12|0)+8>>2];r=l+(s*12|0)|0;X=+g[r>>2];Y=+g[r+4>>2];Z=+g[l+(s*12|0)+8>>2];_=+T(+I);$=+S(+I);I=+T(+M);aa=+S(+M);M=+T(+Q);ba=+S(+Q);Q=+T(+W);ca=+S(+W);s=b+272|0;g[s>>2]=0;W=(c[k>>2]=z,+g[k>>2]);if((c[b+76>>2]|0)==1){g[b+240>>2]=0;g[b+244>>2]=0;g[b+256>>2]=1;g[b+264>>2]=1;da=E+G;ea=0;fa=0;ga=1;ha=1}else{ia=+g[b+124>>2];ja=+g[b+128>>2];ka=ba*ia-M*ja;la=M*ia+ba*ja;ja=+g[b+108>>2]-+g[v>>
2];ia=+g[b+112>>2]-+g[b+196>>2];ma=+g[b+92>>2]-+g[u>>2];na=+g[b+96>>2]-+g[b+180>>2];oa=+ka;pa=+la;u=b+240|0;g[u>>2]=oa;g[u+4>>2]=pa;pa=la*(ba*ja-M*ia)-ka*(M*ja+ba*ia);g[b+264>>2]=pa;ia=la*($*ma-_*na)-ka*(_*ma+$*na);g[b+256>>2]=ia;da=C+A+pa*G*pa+ia*E*ia;ea=ka;fa=la;ga=ia;ha=pa}pa=da+0;g[s>>2]=pa;if((c[b+80>>2]|0)==1){g[b+248>>2]=0;g[b+252>>2]=0;da=+g[b+152>>2];g[b+260>>2]=da;g[b+268>>2]=da;qa=da*da*(F+H);ra=0;sa=0;ta=da;ua=da}else{da=+g[b+132>>2];ia=+g[b+136>>2];la=ca*da-Q*ia;ka=Q*da+ca*ia;ia=+g[b+
116>>2]-W;W=+g[b+120>>2]-+g[b+204>>2];da=+g[b+100>>2]-+g[w>>2];na=+g[b+104>>2]-+g[b+188>>2];$=+g[b+152>>2];ma=la*$;_=ka*$;ba=+ma;ja=+_;w=b+248|0;g[w>>2]=ba;g[w+4>>2]=ja;ja=(ka*(ca*ia-Q*W)-la*(Q*ia+ca*W))*$;g[b+268>>2]=ja;W=$*(ka*(aa*da-I*na)-la*(I*da+aa*na));g[b+260>>2]=W;qa=$*$*(D+B)+ja*H*ja+W*W*F;ra=ma;sa=_;ta=W;ua=ja}ja=pa+qa;g[s>>2]=ja;if(ja>0)va=1/ja;else va=0;g[s>>2]=va;s=b+156|0;if((a[d+24>>0]|0)==0){g[s>>2]=0;wa=J;xa=K;ya=N;za=O;Aa=R;Ba=U;Ca=X;Da=Y;Ea=L;Fa=P;Ga=V;Ha=Z;Ia=c[j>>2]|0;Ja=c[o>>
2]|0;Ka=Ja+(Ia*12|0)|0;La=+wa;Ma=+xa;Na=Ka;Oa=Na;g[Oa>>2]=La;Pa=Na+4|0;Qa=Pa;g[Qa>>2]=Ma;Ra=c[j>>2]|0;Sa=c[o>>2]|0;Ta=Sa+(Ra*12|0)+8|0;g[Ta>>2]=Ea;Ua=c[n>>2]|0;Va=Sa+(Ua*12|0)|0;Wa=+ya;Xa=+za;Ya=Va;Za=Ya;g[Za>>2]=Wa;_a=Ya+4|0;$a=_a;g[$a>>2]=Xa;ab=c[n>>2]|0;bb=c[o>>2]|0;cb=bb+(ab*12|0)+8|0;g[cb>>2]=Fa;db=c[q>>2]|0;eb=bb+(db*12|0)|0;fb=+Aa;gb=+Ba;hb=eb;ib=hb;g[ib>>2]=fb;jb=hb+4|0;kb=jb;g[kb>>2]=gb;lb=c[q>>2]|0;mb=c[o>>2]|0;nb=mb+(lb*12|0)+8|0;g[nb>>2]=Ga;ob=c[t>>2]|0;pb=mb+(ob*12|0)|0;qb=+Ca;rb=+Da;
sb=pb;tb=sb;g[tb>>2]=qb;ub=sb+4|0;vb=ub;g[vb>>2]=rb;wb=c[t>>2]|0;xb=c[o>>2]|0;yb=xb+(wb*12|0)+8|0;g[yb>>2]=Ha;i=e;return}else{va=+g[s>>2];ja=A*va;A=va*B;B=va*C;C=va*D;wa=J+ea*ja;xa=K+ja*fa;ya=N+ra*A;za=O+A*sa;Aa=R-ea*B;Ba=U-fa*B;Ca=X-ra*C;Da=Y-sa*C;Ea=L+va*E*ga;Fa=P+va*F*ta;Ga=V-va*G*ha;Ha=Z-va*H*ua;Ia=c[j>>2]|0;Ja=c[o>>2]|0;Ka=Ja+(Ia*12|0)|0;La=+wa;Ma=+xa;Na=Ka;Oa=Na;g[Oa>>2]=La;Pa=Na+4|0;Qa=Pa;g[Qa>>2]=Ma;Ra=c[j>>2]|0;Sa=c[o>>2]|0;Ta=Sa+(Ra*12|0)+8|0;g[Ta>>2]=Ea;Ua=c[n>>2]|0;Va=Sa+(Ua*12|0)|0;Wa=
+ya;Xa=+za;Ya=Va;Za=Ya;g[Za>>2]=Wa;_a=Ya+4|0;$a=_a;g[$a>>2]=Xa;ab=c[n>>2]|0;bb=c[o>>2]|0;cb=bb+(ab*12|0)+8|0;g[cb>>2]=Fa;db=c[q>>2]|0;eb=bb+(db*12|0)|0;fb=+Aa;gb=+Ba;hb=eb;ib=hb;g[ib>>2]=fb;jb=hb+4|0;kb=jb;g[kb>>2]=gb;lb=c[q>>2]|0;mb=c[o>>2]|0;nb=mb+(lb*12|0)+8|0;g[nb>>2]=Ga;ob=c[t>>2]|0;pb=mb+(ob*12|0)|0;qb=+Ca;rb=+Da;sb=pb;tb=sb;g[tb>>2]=qb;ub=sb+4|0;vb=ub;g[vb>>2]=rb;wb=c[t>>2]|0;xb=c[o>>2]|0;yb=xb+(wb*12|0)+8|0;g[yb>>2]=Ha;i=e;return}}function Hg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=
0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0;d=i;e=a+160|0;f=c[e>>2]|0;h=b+32|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=+g[j>>2];l=+g[j+4>>2];m=+g[b+(f*12|0)+8>>2];f=a+164|0;j=c[f>>2]|0;n=b+(j*12|0)|0;o=+g[n>>2];p=+g[n+4>>2];q=+g[b+(j*12|0)+8>>2];j=a+168|0;n=c[j>>2]|0;r=b+(n*12|0)|0;s=+g[r>>2];t=+g[r+4>>2];u=+g[b+(n*12|0)+8>>2];n=a+172|0;r=c[n>>2]|0;v=b+(r*12|0)|0;w=+g[v>>2];x=+g[v+4>>2];y=+g[b+(r*12|0)+8>>2];z=+g[a+240>>2];A=+g[a+244>>2];B=+g[a+248>>2];C=
+g[a+252>>2];D=+g[a+256>>2];E=+g[a+264>>2];F=+g[a+260>>2];G=+g[a+268>>2];H=+g[a+272>>2]*((k-s)*z+(l-t)*A+((o-w)*B+(p-x)*C)+(m*D-u*E+(q*F-y*G)));I=-H;r=a+156|0;g[r>>2]=+g[r>>2]-H;H=+g[a+208>>2]*I;J=m+ +g[a+224>>2]*I*D;D=+g[a+212>>2]*I;m=q+ +g[a+228>>2]*I*F;F=+g[a+216>>2]*I;q=u-+g[a+232>>2]*I*E;E=+g[a+220>>2]*I;u=y-+g[a+236>>2]*I*G;G=+(k+z*H);k=+(l+A*H);a=(c[h>>2]|0)+((c[e>>2]|0)*12|0)|0;g[a>>2]=G;g[a+4>>2]=k;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=J;J=+(o+B*D);o=+(p+D*C);e=a+((c[f>>2]|0)*12|0)|0;
g[e>>2]=J;g[e+4>>2]=o;e=c[h>>2]|0;g[e+((c[f>>2]|0)*12|0)+8>>2]=m;m=+(s-z*F);z=+(t-A*F);f=e+((c[j>>2]|0)*12|0)|0;g[f>>2]=m;g[f+4>>2]=z;f=c[h>>2]|0;g[f+((c[j>>2]|0)*12|0)+8>>2]=q;q=+(w-B*E);B=+(x-C*E);j=f+((c[n>>2]|0)*12|0)|0;g[j>>2]=q;g[j+4>>2]=B;g[(c[h>>2]|0)+((c[n>>2]|0)*12|0)+8>>2]=u;i=d;return}function Ig(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=
0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0;d=i;e=a+160|0;f=c[e>>2]|0;h=b+28|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=j;l=+g[k>>2];m=+g[k+4>>2];n=+g[b+(f*12|0)+8>>2];f=a+164|0;k=c[f>>2]|0;o=b+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[b+(k*12|0)+8>>2];k=a+168|0;o=c[k>>2]|0;s=b+(o*12|0)|0;t=+g[s>>2];u=+g[s+4>>2];v=+g[b+(o*12|0)+8>>2];o=a+172|0;s=c[o>>2]|0;w=b+(s*12|0)|0;x=+g[w>>2];y=+g[w+4>>2];z=+g[b+(s*12|0)+8>>2];A=+T(+n);B=+S(+n);C=+T(+r);D=+S(+r);E=+T(+v);F=+S(+v);G=+T(+z);H=+S(+z);
if((c[a+76>>2]|0)==1){I=+g[a+224>>2];J=+g[a+232>>2];K=0;L=0;M=I;N=J;O=1;P=1;Q=n-v-+g[a+140>>2];R=I+J}else{J=+g[a+124>>2];I=+g[a+128>>2];U=F*J-E*I;V=E*J+F*I;W=+g[a+108>>2]-+g[a+192>>2];X=+g[a+112>>2]-+g[a+196>>2];Y=+g[a+92>>2]-+g[a+176>>2];Z=+g[a+96>>2]-+g[a+180>>2];_=B*Y-A*Z;$=A*Y+B*Z;Z=V*(F*W-E*X)-U*(E*W+F*X);B=V*_-U*$;Y=+g[a+232>>2];A=+g[a+224>>2];aa=l-t+_;_=m-u+$;K=U;L=V;M=A;N=Y;O=B;P=Z;Q=J*(F*aa+E*_-W)+I*(F*_-E*aa-X);R=+g[a+216>>2]+ +g[a+208>>2]+Z*Z*Y+B*A*B}if((c[a+80>>2]|0)==1){B=+g[a+152>>2];
A=+g[a+228>>2];Y=+g[a+236>>2];ba=B*B*(A+Y);ca=B;da=0;ea=0;fa=A;ga=Y;ha=B;ia=B;ja=r-z-+g[a+144>>2]}else{B=+g[a+132>>2];Y=+g[a+136>>2];A=H*B-G*Y;Z=G*B+H*Y;X=+g[a+116>>2]-+g[a+200>>2];aa=+g[a+120>>2]-+g[a+204>>2];E=+g[a+100>>2]-+g[a+184>>2];_=+g[a+104>>2]-+g[a+188>>2];F=D*E-C*_;I=C*E+D*_;_=+g[a+152>>2];D=_*(Z*(H*X-G*aa)-A*(G*X+H*aa));E=_*(Z*F-A*I);C=+g[a+236>>2];W=+g[a+228>>2];J=p-x+F;F=q-y+I;ba=_*_*(+g[a+220>>2]+ +g[a+212>>2])+D*D*C+E*W*E;ca=_;da=A*_;ea=Z*_;fa=W;ga=C;ha=E;ia=D;ja=B*(H*J+G*F-X)+Y*(H*
F-G*J-aa)}aa=R+0+ba;if(aa>0)ka=-(Q+ja*ca-+g[a+148>>2])/aa;else ka=0;aa=ka*+g[a+208>>2];ca=ka*+g[a+212>>2];ja=ka*+g[a+216>>2];Q=ka*+g[a+220>>2];ba=+(l+K*aa);l=+(m+L*aa);a=j;g[a>>2]=ba;g[a+4>>2]=l;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=n+O*ka*M;M=+(p+da*ca);p=+(q+ea*ca);e=a+((c[f>>2]|0)*12|0)|0;g[e>>2]=M;g[e+4>>2]=p;e=c[h>>2]|0;g[e+((c[f>>2]|0)*12|0)+8>>2]=r+ha*ka*fa;fa=+(t-K*ja);K=+(u-L*ja);f=e+((c[k>>2]|0)*12|0)|0;g[f>>2]=fa;g[f+4>>2]=K;f=c[h>>2]|0;g[f+((c[k>>2]|0)*12|0)+8>>2]=v-P*ka*N;N=+(x-da*
Q);da=+(y-ea*Q);k=f+((c[o>>2]|0)*12|0)|0;g[k>>2]=N;g[k+4>>2]=da;g[(c[h>>2]|0)+((c[o>>2]|0)*12|0)+8>>2]=z-ia*ka*ga;i=d;return 1}function Jg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+92>>2];h=+g[d+20>>2];i=+g[b+96>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Kg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+100>>2];h=+g[d+20>>2];i=+g[b+104>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*
f-h*i);g[a+4>>2]=j;return}function Lg(a,b,c){a=a|0;b=b|0;c=+c;var d=0,e=0;d=+g[b+156>>2];e=d*+g[b+244>>2]*c;g[a>>2]=d*+g[b+240>>2]*c;g[a+4>>2]=e;return}function Mg(a,b){a=a|0;b=+b;return+(+g[a+156>>2]*+g[a+256>>2]*b)}function Ng(a){a=a|0;return+ +g[a+152>>2]}function Og(a){a=a|0;var b=0,e=0,f=0,j=0,l=0,m=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;l=c[(c[a+68>>2]|0)+56>>2]|0;m=c[(c[a+72>>2]|0)+56>>2]|0;Rm(2912,e);c[e>>2]=f;Rm(2936,e);c[e>>2]=j;Rm(2968,e);c[e>>2]=d[a+61>>
0]|0;Rm(3E3,e);c[e>>2]=l;Rm(3040,e);c[e>>2]=m;Rm(3072,e);h[k>>3]=+g[a+152>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(3104,e);c[e>>2]=c[a+56>>2];Rm(3128,e);i=b;return}function Pg(a){a=a|0;return}function Qg(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Rg(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;h=i;c[a+8>>2]=b;c[a+12>>2]=d;j=+g[e>>2]-+g[b+12>>2];k=e+4|0;l=+g[k>>2]-+g[b+16>>2];m=b+24|0;n=+g[m>>2];o=b+20|0;p=+g[o>>2];q=+(j*n+l*p);r=+(n*l-j*p);s=a+20|
0;g[s>>2]=q;g[s+4>>2]=r;r=+g[e>>2]-+g[d+12>>2];q=+g[k>>2]-+g[d+16>>2];p=+g[d+24>>2];j=+g[d+20>>2];l=+(r*p+q*j);n=+(p*q-r*j);k=a+28|0;g[k>>2]=l;g[k+4>>2]=n;n=+g[m>>2];l=+g[f>>2];j=+g[o>>2];r=+g[f+4>>2];q=+(n*l+j*r);p=+(n*r-l*j);f=a+36|0;g[f>>2]=q;g[f+4>>2]=p;g[a+44>>2]=+g[d+72>>2]-+g[b+72>>2];i=h;return}function Sg(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;e=i;vh(b,d);c[b>>2]=3216;f=b+84|0;h=d+20|0;j=c[h+4>>2]|0;l=b+68|0;c[l>>2]=c[h>>2];c[l+4>>2]=j;j=d+28|0;l=c[j+4>>2]|0;h=b+
76|0;c[h>>2]=c[j>>2];c[h+4>>2]=l;l=d+36|0;h=c[l>>2]|0;j=c[l+4>>2]|0;l=f;c[l>>2]=h;c[l+4>>2]=j;m=(c[k>>2]=h,+g[k>>2]);n=(c[k>>2]=j,+g[k>>2]);o=+Q(+(m*m+n*n));if(o<1.1920928955078125E-7){p=n;q=m}else{r=1/o;o=m*r;g[f>>2]=o;m=n*r;g[b+88>>2]=m;p=m;q=o}o=+-p;p=+q;f=b+92|0;g[f>>2]=o;g[f+4>>2]=p;g[b+100>>2]=+g[d+44>>2];f=b+104|0;g[b+252>>2]=0;j=d+52|0;c[f+0>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;g[b+120>>2]=+g[j>>2];g[b+124>>2]=+g[d+56>>2];g[b+128>>2]=+g[d+64>>2];g[b+132>>2]=+g[d+68>>2];a[b+136>>0]=a[d+
48>>0]|0;a[b+137>>0]=a[d+60>>0]|0;c[b+140>>2]=0;d=b+184|0;c[d+0>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;i=e;return}function Tg(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0;e=i;f=c[b+48>>2]|0;h=
c[f+8>>2]|0;j=b+144|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+148|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+152|0;c[o>>2]=p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+160|0;c[o>>2]=r;c[o+4>>2]=s;o=b+168|0;g[o>>2]=+g[f+136>>2];t=b+172|0;g[t>>2]=+g[l+136>>2];u=+g[f+144>>2];g[b+176>>2]=u;v=+g[l+144>>2];g[b+180>>2]=v;l=c[d+28>>2]|0;f=l+(h*12|0)|0;w=+g[f>>2];x=+g[f+4>>2];y=+g[l+(h*12|0)+8>>2];f=d+32|0;z=c[f>>2]|0;A=z+(h*12|0)|0;B=+g[A>>2];C=+g[A+4>>2];D=+g[z+(h*12|0)+8>>2];h=l+(m*12|
0)|0;E=+g[h>>2];F=+g[h+4>>2];G=+g[l+(m*12|0)+8>>2];l=z+(m*12|0)|0;H=+g[l>>2];I=+g[l+4>>2];J=+g[z+(m*12|0)+8>>2];K=+T(+y);L=+S(+y);y=+T(+G);M=+S(+G);G=+g[b+68>>2]-(c[k>>2]=p,+g[k>>2]);N=+g[b+72>>2]-(c[k>>2]=q,+g[k>>2]);O=L*G-K*N;P=K*G+L*N;N=+g[b+76>>2]-(c[k>>2]=r,+g[k>>2]);G=+g[b+80>>2]-(c[k>>2]=s,+g[k>>2]);Q=M*N-y*G;R=y*N+M*G;G=E-w+Q-O;w=F-x+R-P;x=+g[o>>2];F=+g[t>>2];E=+g[b+84>>2];M=+g[b+88>>2];N=L*E-K*M;y=K*E+L*M;M=+N;E=+y;t=b+184|0;g[t>>2]=M;g[t+4>>2]=E;E=O+G;O=P+w;P=E*y-O*N;g[b+208>>2]=P;M=Q*y-
R*N;g[b+212>>2]=M;U=x+F;V=u*P;W=v*M;X=U+P*V+M*W;if(X>0)Y=1/X;else Y=X;g[b+252>>2]=Y;Y=+g[b+92>>2];Z=+g[b+96>>2];_=L*Y-K*Z;$=K*Y+L*Z;Z=+_;L=+$;t=b+192|0;g[t>>2]=Z;g[t+4>>2]=L;L=E*$-O*_;g[b+200>>2]=L;O=Q*$-R*_;g[b+204>>2]=O;R=u*L;Q=v*O;E=R+Q;Z=R*P+Q*M;Y=v+u;K=V+W;g[b+216>>2]=U+L*R+O*Q;g[b+220>>2]=E;g[b+224>>2]=Z;g[b+228>>2]=E;g[b+232>>2]=Y==0?1:Y;g[b+236>>2]=K;g[b+240>>2]=Z;g[b+244>>2]=K;g[b+248>>2]=X;do if((a[b+136>>0]|0)!=0){X=G*N+w*y;K=+g[b+124>>2];Z=+g[b+120>>2];Y=K-Z;if(Y>0)aa=Y;else aa=-Y;if(aa<
.009999999776482582){c[b+140>>2]=3;break}if(X<=Z){t=b+140|0;if((c[t>>2]|0)==1)break;c[t>>2]=1;g[b+112>>2]=0;break}t=b+140|0;if(!(X>=K)){c[t>>2]=0;g[b+112>>2]=0;break}if((c[t>>2]|0)!=2){c[t>>2]=2;g[b+112>>2]=0}}else{c[b+140>>2]=0;g[b+112>>2]=0}while(0);if((a[b+137>>0]|0)==0)g[b+116>>2]=0;t=b+104|0;if((a[d+24>>0]|0)==0){c[t+0>>2]=0;c[t+4>>2]=0;c[t+8>>2]=0;c[t+12>>2]=0;ba=B;ca=C;da=H;ea=I;fa=D;ga=J;ha=c[j>>2]|0;ia=c[f>>2]|0;ja=ia+(ha*12|0)|0;ka=+ba;la=+ca;ma=ja;na=ma;g[na>>2]=ka;oa=ma+4|0;pa=oa;g[pa>>
2]=la;qa=c[j>>2]|0;ra=c[f>>2]|0;sa=ra+(qa*12|0)+8|0;g[sa>>2]=fa;ta=c[n>>2]|0;ua=ra+(ta*12|0)|0;va=+da;wa=+ea;xa=ua;ya=xa;g[ya>>2]=va;za=xa+4|0;Aa=za;g[Aa>>2]=wa;Ba=c[n>>2]|0;Ca=c[f>>2]|0;Da=Ca+(Ba*12|0)+8|0;g[Da>>2]=ga;i=e;return}else{o=d+8|0;aa=+g[o>>2];w=aa*+g[t>>2];g[t>>2]=w;t=b+108|0;G=aa*+g[t>>2];g[t>>2]=G;t=b+112|0;K=aa*+g[t>>2];g[t>>2]=K;t=b+116|0;aa=+g[o>>2]*+g[t>>2];g[t>>2]=aa;X=aa+K;K=w*_+N*X;N=w*$+X*y;ba=B-x*K;ca=C-x*N;da=H+F*K;ea=I+F*N;fa=D-u*(w*L+G+X*P);ga=J+v*(G+w*O+X*M);ha=c[j>>2]|
0;ia=c[f>>2]|0;ja=ia+(ha*12|0)|0;ka=+ba;la=+ca;ma=ja;na=ma;g[na>>2]=ka;oa=ma+4|0;pa=oa;g[pa>>2]=la;qa=c[j>>2]|0;ra=c[f>>2]|0;sa=ra+(qa*12|0)+8|0;g[sa>>2]=fa;ta=c[n>>2]|0;ua=ra+(ta*12|0)|0;va=+da;wa=+ea;xa=ua;ya=xa;g[ya>>2]=va;za=xa+4|0;Aa=za;g[Aa>>2]=wa;Ba=c[n>>2]|0;Ca=c[f>>2]|0;Da=Ca+(Ba*12|0)+8|0;g[Da>>2]=ga;i=e;return}}function Ug(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,
Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0;e=i;i=i+64|0;f=e+44|0;h=e+32|0;j=e+24|0;k=e+16|0;l=e+8|0;m=e;n=b+144|0;o=c[n>>2]|0;p=d+32|0;q=c[p>>2]|0;r=q+(o*12|0)|0;s=+g[r>>2];t=+g[r+4>>2];u=+g[q+(o*12|0)+8>>2];o=b+148|0;r=c[o>>2]|0;v=q+(r*12|0)|0;w=+g[v>>2];x=+g[v+4>>2];y=+g[q+(r*12|0)+8>>2];
z=+g[b+168>>2];A=+g[b+172>>2];B=+g[b+176>>2];C=+g[b+180>>2];if((a[b+137>>0]|0)!=0?(c[b+140>>2]|0)!=3:0){D=+g[b+184>>2];E=+g[b+188>>2];F=+g[b+212>>2];G=+g[b+208>>2];r=b+116|0;H=+g[r>>2];I=+g[d>>2]*+g[b+128>>2];J=H+ +g[b+252>>2]*(+g[b+132>>2]-((w-s)*D+(x-t)*E+y*F-u*G));K=-I;L=J<I?J:I;I=L<K?K:L;g[r>>2]=I;L=I-H;H=D*L;D=E*L;M=t-z*D;N=x+A*D;O=s-z*H;P=w+A*H;Q=u-B*G*L;R=y+C*F*L}else{M=t;N=x;O=s;P=w;Q=u;R=y}y=P-O;u=N-M;r=b+192|0;d=b+196|0;q=b+204|0;v=b+200|0;w=y*+g[r>>2]+u*+g[d>>2]+R*+g[q>>2]-Q*+g[v>>2];s=
R-Q;if((a[b+136>>0]|0)!=0?(S=b+140|0,(c[S>>2]|0)!=0):0){T=b+184|0;U=b+188|0;V=b+212|0;W=b+208|0;X=b+104|0;x=+g[X>>2];Y=b+108|0;t=+g[Y>>2];Z=b+112|0;L=+g[Z>>2];_=b+216|0;F=-w;G=-s;H=-(y*+g[T>>2]+u*+g[U>>2]+R*+g[V>>2]-Q*+g[W>>2]);g[h>>2]=F;g[h+4>>2]=G;g[h+8>>2]=H;Gm(f,_,h);g[X>>2]=+g[f>>2]+ +g[X>>2];h=f+4|0;g[Y>>2]=+g[h>>2]+ +g[Y>>2];$=f+8|0;H=+g[$>>2]+ +g[Z>>2];g[Z>>2]=H;aa=c[S>>2]|0;if((aa|0)==2){u=H<0?H:0;g[Z>>2]=u;ba=u}else if((aa|0)==1){u=H>0?H:0;g[Z>>2]=u;ba=u}else ba=H;H=ba-L;ba=G-H*+g[b+244>>
2];g[j>>2]=F-+g[b+240>>2]*H;g[j+4>>2]=ba;Hm(k,_,j);ba=x+ +g[k>>2];H=t+ +g[k+4>>2];g[X>>2]=ba;g[Y>>2]=H;F=ba-x;x=H-t;t=+g[Z>>2]-L;g[f>>2]=F;g[h>>2]=x;g[$>>2]=t;ca=x+F*+g[q>>2]+t*+g[V>>2];da=F*+g[r>>2]+t*+g[T>>2];ea=F*+g[v>>2]+x+t*+g[W>>2];fa=F*+g[d>>2]+t*+g[U>>2];ga=z*fa;ha=z*da;ia=O-ha;ja=M-ga;ka=A*da;la=A*fa;ma=P+ka;na=N+la;oa=B*ea;pa=C*ca;qa=Q-oa;ra=R+pa;sa=c[n>>2]|0;ta=c[p>>2]|0;ua=ta+(sa*12|0)|0;va=+ia;wa=+ja;xa=ua;ya=xa;g[ya>>2]=va;za=xa+4|0;Aa=za;g[Aa>>2]=wa;Ba=c[n>>2]|0;Ca=c[p>>2]|0;Da=Ca+
(Ba*12|0)+8|0;g[Da>>2]=qa;Ea=c[o>>2]|0;Fa=Ca+(Ea*12|0)|0;Ga=+ma;Ha=+na;Ia=Fa;Ja=Ia;g[Ja>>2]=Ga;Ka=Ia+4|0;La=Ka;g[La>>2]=Ha;Ma=c[o>>2]|0;Na=c[p>>2]|0;Oa=Na+(Ma*12|0)+8|0;g[Oa>>2]=ra;i=e;return}g[m>>2]=-w;g[m+4>>2]=-s;Hm(l,b+216|0,m);s=+g[l>>2];m=b+104|0;g[m>>2]=s+ +g[m>>2];w=+g[l+4>>2];l=b+108|0;g[l>>2]=w+ +g[l>>2];ca=w+s*+g[q>>2];da=s*+g[r>>2];ea=s*+g[v>>2]+w;fa=s*+g[d>>2];ga=z*fa;ha=z*da;ia=O-ha;ja=M-ga;ka=A*da;la=A*fa;ma=P+ka;na=N+la;oa=B*ea;pa=C*ca;qa=Q-oa;ra=R+pa;sa=c[n>>2]|0;ta=c[p>>2]|0;ua=
ta+(sa*12|0)|0;va=+ia;wa=+ja;xa=ua;ya=xa;g[ya>>2]=va;za=xa+4|0;Aa=za;g[Aa>>2]=wa;Ba=c[n>>2]|0;Ca=c[p>>2]|0;Da=Ca+(Ba*12|0)+8|0;g[Da>>2]=qa;Ea=c[o>>2]|0;Fa=Ca+(Ea*12|0)|0;Ga=+ma;Ha=+na;Ia=Fa;Ja=Ia;g[Ja>>2]=Ga;Ka=Ia+4|0;La=Ka;g[La>>2]=Ha;Ma=c[o>>2]|0;Na=c[p>>2]|0;Oa=Na+(Ma*12|0)+8|0;g[Oa>>2]=ra;i=e;return}function Vg(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,
X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0;e=i;i=i+64|0;f=e+24|0;h=e+12|0;j=e;k=b+144|0;l=c[k>>2]|0;m=d+28|0;d=c[m>>2]|0;n=d+(l*12|0)|0;o=+g[n>>2];p=+g[n+4>>2];q=+g[d+(l*12|0)+8>>2];l=b+148|0;n=c[l>>2]|0;r=d+(n*12|0)|0;s=+g[r>>2];t=+g[r+4>>2];u=+g[d+(n*12|0)+8>>2];v=+T(+q);w=+S(+q);x=+T(+u);y=+S(+u);z=+g[b+168>>2];A=+g[b+172>>2];B=+g[b+176>>2];C=+g[b+180>>2];D=+g[b+68>>2]-+g[b+152>>2];E=+g[b+72>>2]-+g[b+156>>2];F=w*D-v*E;G=v*D+w*E;E=+g[b+76>>2]-+g[b+160>>2];D=+g[b+80>>2]-+g[b+164>>2];H=y*E-x*D;I=x*E+y*D;D=s+H-
o-F;y=t+I-p-G;E=+g[b+84>>2];x=+g[b+88>>2];J=w*E-v*x;K=v*E+w*x;x=F+D;F=G+y;G=K*x-J*F;E=H*K-I*J;L=+g[b+92>>2];M=+g[b+96>>2];N=w*L-v*M;O=v*L+w*M;M=O*x-N*F;F=H*O-I*N;I=N*D+O*y;H=u-q-+g[b+100>>2];if(I>0)P=I;else P=-I;if(H>0)Q=H;else Q=-H;do if((a[b+136>>0]|0)!=0){x=J*D+K*y;w=+g[b+124>>2];L=+g[b+120>>2];v=w-L;if(v>0)R=v;else R=-v;if(R<.009999999776482582){v=x<.20000000298023224?x:.20000000298023224;if(x>0)U=x;else U=-x;V=v<-.20000000298023224?-.20000000298023224:v;W=1;X=P>U?P:U;break}if(x<=L){v=x-L+.004999999888241291;
Y=v<0?v:0;v=L-x;V=Y<-.20000000298023224?-.20000000298023224:Y;W=1;X=P>v?P:v;break}if(x>=w){v=x-w;w=v+-.004999999888241291;x=w<.20000000298023224?w:.20000000298023224;V=x<0?0:x;W=1;X=P>v?P:v}else{V=0;W=0;X=P}}else{V=0;W=0;X=P}while(0);P=z+A;U=B*M;R=C*F;y=F*R+(P+M*U);D=R+U;if(W){v=E*R+G*U;U=B+C;R=B*G;x=C*E;w=x+R;g[f>>2]=y;g[f+4>>2]=D;g[f+8>>2]=v;g[f+12>>2]=D;g[f+16>>2]=U==0?1:U;g[f+20>>2]=w;g[f+24>>2]=v;g[f+28>>2]=w;g[f+32>>2]=E*x+(P+G*R);g[j>>2]=-I;g[j+4>>2]=-H;g[j+8>>2]=-V;Gm(h,f,j);Z=+g[h>>2];_=
+g[h+8>>2];$=+g[h+4>>2]}else{V=B+C;R=V==0?1:V;V=-I;I=-H;H=R*y-D*D;if(H!=0)aa=1/H;else aa=H;Z=(R*V-D*I)*aa;_=0;$=(y*I-D*V)*aa}aa=J*_+N*Z;N=K*_+O*Z;O=+(o-z*aa);o=+(p-z*N);h=(c[m>>2]|0)+((c[k>>2]|0)*12|0)|0;g[h>>2]=O;g[h+4>>2]=o;h=c[m>>2]|0;g[h+((c[k>>2]|0)*12|0)+8>>2]=q-B*(G*_+($+M*Z));M=+(s+A*aa);aa=+(t+A*N);k=h+((c[l>>2]|0)*12|0)|0;g[k>>2]=M;g[k+4>>2]=aa;g[(c[m>>2]|0)+((c[l>>2]|0)*12|0)+8>>2]=u+C*(E*_+($+F*Z));if(!(X<=.004999999888241291)){ba=0;i=e;return ba|0}ba=Q<=.03490658849477768;i=e;return ba|
0}function Wg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+68>>2];h=+g[d+20>>2];i=+g[b+72>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Xg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+76>>2];h=+g[d+20>>2];i=+g[b+80>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Yg(a,b,c){a=a|0;b=b|0;c=+c;var d=0,e=0,f=0;d=+g[b+104>>2];e=+g[b+116>>2]+ +g[b+112>>2];f=(d*
+g[b+196>>2]+e*+g[b+188>>2])*c;g[a>>2]=(d*+g[b+192>>2]+ +g[b+184>>2]*e)*c;g[a+4>>2]=f;return}function Zg(a,b){a=a|0;b=+b;return+(+g[a+108>>2]*b)}function _g(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;b=c[a+48>>2]|0;d=+g[b+24>>2];e=+g[a+68>>2];f=+g[b+20>>2];h=+g[a+72>>2];i=c[a+52>>2]|0;j=+g[i+24>>2];k=+g[a+76>>2];l=+g[i+20>>2];m=+g[a+80>>2];n=+g[a+84>>2];o=+g[a+88>>2];return+((+g[i+12>>2]+(j*k-l*m)-(+g[b+12>>2]+(d*e-f*h)))*(d*n-f*o)+(k*l+j*m+ +g[i+16>>2]-(e*f+d*h+ +g[b+16>>2]))*(f*
n+d*o))}function $g(b){b=b|0;return(a[b+136>>0]|0)!=0|0}function ah(f,h){f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0;j=i;k=f+136|0;if((h&1|0)==(d[k>>0]|0|0)){i=j;return}l=c[f+48>>2]|0;m=l+4|0;n=e[m>>1]|0;if((n&2|0)==0){b[m>>1]=n|2;g[l+160>>2]=0}l=c[f+52>>2]|0;n=l+4|0;m=e[n>>1]|0;if((m&2|0)==0){b[n>>1]=m|2;g[l+160>>2]=0}a[k>>0]=h&1;g[f+112>>2]=0;i=j;return}function bh(b){b=b|0;return(a[b+137>>0]|0)!=0|0}function ch(d,f){d=d|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0;h=i;j=c[d+48>>2]|0;k=j+4|0;l=e[k>>1]|0;if((l&2|
0)==0){b[k>>1]=l|2;g[j+160>>2]=0}j=c[d+52>>2]|0;l=j+4|0;k=e[l>>1]|0;if((k&2|0)!=0){m=d+137|0;n=f&1;a[m>>0]=n;i=h;return}b[l>>1]=k|2;g[j+160>>2]=0;m=d+137|0;n=f&1;a[m>>0]=n;i=h;return}function dh(a,d){a=a|0;d=+d;var f=0,h=0,j=0,k=0,l=0;f=i;h=c[a+48>>2]|0;j=h+4|0;k=e[j>>1]|0;if((k&2|0)==0){b[j>>1]=k|2;g[h+160>>2]=0}h=c[a+52>>2]|0;k=h+4|0;j=e[k>>1]|0;if((j&2|0)!=0){l=a+132|0;g[l>>2]=d;i=f;return}b[k>>1]=j|2;g[h+160>>2]=0;l=a+132|0;g[l>>2]=d;i=f;return}function eh(a,b){a=a|0;b=+b;return+(+g[a+116>>2]*
b)}function fh(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(3264,e);c[e>>2]=f;Rm(3296,e);c[e>>2]=j;Rm(3328,e);c[e>>2]=d[a+61>>0]|0;Rm(3360,e);l=+g[a+72>>2];h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(3400,e);l=+g[a+80>>2];h[k>>3]=+g[a+76>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(3448,e);l=+g[a+88>>2];h[k>>3]=+g[a+
84>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(3496,e);h[k>>3]=+g[a+100>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(3536,e);c[e>>2]=d[a+136>>0]|0;Rm(3568,e);h[k>>3]=+g[a+120>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(3600,e);h[k>>3]=+g[a+124>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(3640,e);c[e>>2]=d[a+137>>0]|0;Rm(3680,e);h[k>>3]=+g[a+132>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(3712,e);h[k>>3]=+g[a+128>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];
Rm(3744,e);c[e>>2]=c[a+56>>2];Rm(3776,e);i=b;return}function gh(a){a=a|0;return}function hh(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function ih(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0;d=i;vh(a,b);c[a>>2]=3872;e=b+20|0;f=c[e+4>>2]|0;h=a+68|0;c[h>>2]=c[e>>2];c[h+4>>2]=f;f=b+28|0;h=c[f+4>>2]|0;e=a+76|0;c[e>>2]=c[f>>2];c[e+4>>2]=h;g[a+84>>2]=+g[b+36>>2];g[a+160>>2]=0;g[a+92>>2]=0;c[a+164>>2]=0;g[a+88>>2]=0;i=d;return}function jh(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,
v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+96|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+100|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+128|0;c[o>>2]=p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+136|0;c[o>>2]=r;c[o+4>>2]=s;s=b+144|0;g[s>>2]=+g[f+136>>2];o=b+148|0;g[o>>2]=+g[l+136>>2];t=b+152|0;g[t>>2]=+g[f+144>>2];f=b+156|0;g[f>>2]=+g[l+144>>2];l=c[d+28>>2]|0;u=l+(h*12|0)|0;
v=+g[u>>2];w=+g[u+4>>2];x=+g[l+(h*12|0)+8>>2];u=d+32|0;y=c[u>>2]|0;z=y+(h*12|0)|0;A=+g[z>>2];B=+g[z+4>>2];C=+g[y+(h*12|0)+8>>2];h=l+(m*12|0)|0;D=+g[h>>2];E=+g[h+4>>2];F=+g[l+(m*12|0)+8>>2];l=y+(m*12|0)|0;G=+g[l>>2];H=+g[l+4>>2];I=+g[y+(m*12|0)+8>>2];J=+T(+x);K=+S(+x);x=+T(+F);L=+S(+F);F=+g[b+68>>2]-(c[k>>2]=p,+g[k>>2]);M=+g[b+72>>2]-(c[k>>2]=q,+g[k>>2]);N=K*F-J*M;O=J*F+K*M;M=+N;K=+O;q=b+112|0;g[q>>2]=M;g[q+4>>2]=K;K=+g[b+76>>2]-(c[k>>2]=r,+g[k>>2]);M=+g[b+80>>2]-+g[b+140>>2];F=L*K-x*M;J=x*K+L*M;M=
+F;L=+J;r=b+120|0;g[r>>2]=M;g[r+4>>2]=L;r=b+104|0;L=D+F-v-N;v=E+J-w-O;w=+L;E=+v;q=r;g[q>>2]=w;g[q+4>>2]=E;q=b+108|0;E=+Q(+(L*L+v*v));g[b+88>>2]=E;c[b+164>>2]=E-+g[b+84>>2]>0?2:0;if(!(E>.004999999888241291)){g[r>>2]=0;g[q>>2]=0;g[b+160>>2]=0;g[b+92>>2]=0;i=e;return}w=1/E;E=w*L;g[r>>2]=E;L=w*v;g[q>>2]=L;v=N*L-O*E;w=L*F-E*J;D=+g[s>>2];M=+g[t>>2];K=+g[o>>2];x=+g[f>>2];P=K+(D+v*v*M)+w*w*x;if(P!=0)R=1/P;else R=0;g[b+160>>2]=R;if((a[d+24>>0]|0)==0){g[b+92>>2]=0;U=A;V=B;W=G;X=H;Y=C;Z=I}else{f=b+92|0;R=+g[d+
8>>2]*+g[f>>2];g[f>>2]=R;P=E*R;E=R*L;U=A-P*D;V=B-E*D;W=G+P*K;X=H+E*K;Y=C-M*(E*N-P*O);Z=I+x*(E*F-P*J)}J=+U;U=+V;f=(c[u>>2]|0)+((c[j>>2]|0)*12|0)|0;g[f>>2]=J;g[f+4>>2]=U;f=c[u>>2]|0;g[f+((c[j>>2]|0)*12|0)+8>>2]=Y;Y=+W;W=+X;j=f+((c[n>>2]|0)*12|0)|0;g[j>>2]=Y;g[j+4>>2]=W;g[(c[u>>2]|0)+((c[n>>2]|0)*12|0)+8>>2]=Z;i=e;return}function kh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0;d=i;e=a+96|0;f=c[e>>2]|0;h=b+32|0;j=c[h>>2]|0;k=j+(f*12|
0)|0;l=k;m=+g[l>>2];n=+g[l+4>>2];o=+g[j+(f*12|0)+8>>2];f=a+100|0;l=c[f>>2]|0;p=j+(l*12|0)|0;q=+g[p>>2];r=+g[p+4>>2];s=+g[j+(l*12|0)+8>>2];t=+g[a+116>>2];u=+g[a+112>>2];v=+g[a+124>>2];w=+g[a+120>>2];x=+g[a+88>>2]-+g[a+84>>2];y=+g[a+104>>2];z=+g[a+108>>2];A=(q-s*v-(m-o*t))*y+(r+s*w-(n+o*u))*z;if(x<0)B=A+x*+g[b+4>>2];else B=A;b=a+92|0;A=+g[b>>2];x=A-B*+g[a+160>>2];B=x>0?0:x;g[b>>2]=B;x=B-A;A=y*x;y=z*x;x=+g[a+144>>2];z=o-+g[a+152>>2]*(u*y-A*t);t=+g[a+148>>2];u=s+ +g[a+156>>2]*(y*w-A*v);v=+(m-x*A);m=+(n-
x*y);a=k;g[a>>2]=v;g[a+4>>2]=m;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=z;z=+(q+A*t);A=+(r+y*t);e=a+((c[f>>2]|0)*12|0)|0;g[e>>2]=z;g[e+4>>2]=A;g[(c[h>>2]|0)+((c[f>>2]|0)*12|0)+8>>2]=u;i=d;return}function lh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;d=i;e=a+96|0;f=c[e>>2]|0;h=b+28|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=j;l=+g[k>>2];m=+g[k+4>>2];n=+g[b+(f*12|0)+8>>2];f=a+100|0;k=c[f>>2]|0;o=b+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[b+
(k*12|0)+8>>2];s=+T(+n);t=+S(+n);u=+T(+r);v=+S(+r);w=+g[a+68>>2]-+g[a+128>>2];x=+g[a+72>>2]-+g[a+132>>2];y=t*w-s*x;z=s*w+t*x;x=+g[a+76>>2]-+g[a+136>>2];t=+g[a+80>>2]-+g[a+140>>2];w=v*x-u*t;s=u*x+v*t;t=p+w-l-y;v=q+s-m-z;x=+Q(+(t*t+v*v));if(x<1.1920928955078125E-7){A=0;B=t;C=v}else{u=1/x;A=x;B=t*u;C=v*u}k=a+84|0;u=A-+g[k>>2];v=u<.20000000298023224?u:.20000000298023224;u=-(+g[a+160>>2]*(v<0?0:v));v=B*u;B=C*u;u=+g[a+144>>2];C=n-+g[a+152>>2]*(y*B-z*v);z=+g[a+148>>2];y=r+ +g[a+156>>2]*(w*B-s*v);s=+(l-u*
v);l=+(m-u*B);a=j;g[a>>2]=s;g[a+4>>2]=l;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=C;C=+(p+z*v);v=+(q+z*B);e=a+((c[f>>2]|0)*12|0)|0;g[e>>2]=C;g[e+4>>2]=v;g[(c[h>>2]|0)+((c[f>>2]|0)*12|0)+8>>2]=y;i=d;return A-+g[k>>2]<.004999999888241291|0}function mh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+68>>2];h=+g[d+20>>2];i=+g[b+72>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function nh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>
2]|0;e=+g[d+24>>2];f=+g[b+76>>2];h=+g[d+20>>2];i=+g[b+80>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function oh(a,b,c){a=a|0;b=b|0;c=+c;var d=0;d=+g[b+92>>2]*c;c=d*+g[b+108>>2];g[a>>2]=+g[b+104>>2]*d;g[a+4>>2]=c;return}function ph(a,b){a=a|0;b=+b;return 0}function qh(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(3920,e);c[e>>2]=f;Rm(3944,e);c[e>>2]=j;Rm(3976,e);c[e>>2]=d[a+61>>0]|0;Rm(4008,e);l=+g[a+72>>
2];h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(4048,e);l=+g[a+80>>2];h[k>>3]=+g[a+76>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(4096,e);h[k>>3]=+g[a+84>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(4144,e);c[e>>2]=c[a+56>>2];Rm(4176,e);i=b;return}function rh(a){a=a|0;return}function sh(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function th(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,
k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;d=i;do switch(c[a>>2]|0){case 5:e=Em(b,168)|0;if((e|0)==0)f=0;else{vf(e,a);f=e}g=f;break;case 2:e=Em(b,256)|0;if((e|0)==0)h=0;else{Sg(e,a);h=e}g=h;break;case 7:e=Em(b,224)|0;if((e|0)==0)j=0;else{Sh(e,a);j=e}g=j;break;case 4:e=Em(b,196)|0;if((e|0)==0)k=0;else{di(e,a);k=e}g=k;break;case 3:e=Em(b,176)|0;if((e|0)==0)l=0;else{Yf(e,a);l=e}g=l;break;case 9:e=Em(b,180)|0;if((e|0)==0)m=0;else{ig(e,a);m=e}g=m;break;case 11:e=Em(b,192)|0;if((e|0)==0)n=0;else{Jf(e,a);n=e}g=n;break;
case 1:e=Em(b,228)|0;if((e|0)==0)o=0;else{Ah(e,a);o=e}g=o;break;case 8:e=Em(b,208)|0;if((e|0)==0)p=0;else{ug(e,a);p=e}g=p;break;case 6:e=Em(b,276)|0;if((e|0)==0)q=0;else{Fg(e,a);q=e}g=q;break;case 10:e=Em(b,168)|0;if((e|0)==0)r=0;else{ih(e,a);r=e}g=r;break;default:g=0}while(0);i=d;return g|0}function uh(a,b){a=a|0;b=b|0;var d=0;d=i;eb[c[(c[a>>2]|0)+24>>2]&127](a);do switch(c[a+4>>2]|0){case 9:Fm(b,a,180);break;case 2:Fm(b,a,256);break;case 1:Fm(b,a,228);break;case 7:Fm(b,a,224);break;case 8:Fm(b,
a,208);break;case 5:Fm(b,a,168);break;case 3:Fm(b,a,176);break;case 11:Fm(b,a,192);break;case 4:Fm(b,a,196);break;case 10:Fm(b,a,168);break;case 6:Fm(b,a,276);break;default:}while(0);i=d;return}function vh(b,d){b=b|0;d=d|0;var e=0;e=i;c[b>>2]=4264;c[b+4>>2]=c[d>>2];c[b+8>>2]=0;c[b+12>>2]=0;c[b+48>>2]=c[d+8>>2];c[b+52>>2]=c[d+12>>2];c[b+56>>2]=0;a[b+61>>0]=a[d+16>>0]|0;a[b+60>>0]=0;c[b+64>>2]=c[d+4>>2];d=b+16|0;c[d+0>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;c[d+16>>2]=0;c[d+20>>2]=0;c[d+24>>2]=0;
c[d+28>>2]=0;i=e;return}function wh(a){a=a|0;a=i;i=i+16|0;Rm(4312,a);i=a;return}function xh(a){a=a|0;return}function yh(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function zh(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;f=i;c[a+8>>2]=b;c[a+12>>2]=d;h=+g[e>>2]-+g[b+12>>2];j=e+4|0;k=+g[j>>2]-+g[b+16>>2];l=+g[b+24>>2];m=+g[b+20>>2];n=+(h*l+k*m);o=+(l*k-h*m);p=a+20|0;g[p>>2]=n;g[p+4>>2]=o;o=+g[e>>2]-+g[d+12>>2];n=+g[j>>2]-+g[d+16>>2];m=+g[d+24>>2];h=+g[d+20>>2];k=+(o*m+n*h);l=+(m*
n-o*h);j=a+28|0;g[j>>2]=k;g[j+4>>2]=l;g[a+36>>2]=+g[d+72>>2]-+g[b+72>>2];i=f;return}function Ah(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0;e=i;vh(b,d);c[b>>2]=4368;f=d+20|0;h=c[f+4>>2]|0;j=b+68|0;c[j>>2]=c[f>>2];c[j+4>>2]=h;h=d+28|0;j=c[h+4>>2]|0;f=b+76|0;c[f>>2]=c[h>>2];c[f+4>>2]=j;g[b+116>>2]=+g[d+36>>2];j=b+84|0;f=d+44|0;c[j+0>>2]=0;c[j+4>>2]=0;c[j+8>>2]=0;c[j+12>>2]=0;g[b+120>>2]=+g[f>>2];g[b+124>>2]=+g[d+48>>2];g[b+104>>2]=+g[d+60>>2];g[b+108>>2]=+g[d+56>>2];a[b+112>>0]=a[d+40>>0]|0;a[b+100>>0]=a[d+
52>>0]|0;c[b+224>>2]=0;i=e;return}function Bh(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+128|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+132|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+152|0;c[o>>2]=
p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+160|0;c[o>>2]=r;c[o+4>>2]=s;o=b+168|0;g[o>>2]=+g[f+136>>2];t=+g[l+136>>2];g[b+172>>2]=t;u=+g[f+144>>2];g[b+176>>2]=u;v=+g[l+144>>2];g[b+180>>2]=v;l=c[d+28>>2]|0;w=+g[l+(h*12|0)+8>>2];f=d+32|0;x=c[f>>2]|0;y=x+(h*12|0)|0;z=+g[y>>2];A=+g[y+4>>2];B=+g[x+(h*12|0)+8>>2];C=+g[l+(m*12|0)+8>>2];l=x+(m*12|0)|0;D=+g[l>>2];E=+g[l+4>>2];F=+g[x+(m*12|0)+8>>2];G=+T(+w);H=+S(+w);I=+T(+C);J=+S(+C);m=b+136|0;K=+g[b+68>>2]-(c[k>>2]=p,+g[k>>2]);L=+g[b+72>>2]-(c[k>>
2]=q,+g[k>>2]);M=H*K-G*L;N=G*K+H*L;L=+M;H=+N;q=m;g[q>>2]=L;g[q+4>>2]=H;H=+g[b+76>>2]-(c[k>>2]=r,+g[k>>2]);L=+g[b+80>>2]-(c[k>>2]=s,+g[k>>2]);K=J*H-I*L;G=I*H+J*L;L=+K;J=+G;s=b+144|0;g[s>>2]=L;g[s+4>>2]=J;J=+g[o>>2];L=u+v;o=L==0;H=J+t;s=b+140|0;g[b+184>>2]=H+u*N*N+v*G*G;I=-(u*N*M)-v*G*K;g[b+196>>2]=I;O=-(u*N)-v*G;g[b+208>>2]=O;g[b+188>>2]=I;g[b+200>>2]=H+u*M*M+v*K*K;H=u*M+v*K;g[b+212>>2]=H;g[b+192>>2]=O;g[b+204>>2]=H;g[b+216>>2]=L;if(L>0)P=1/L;else P=L;g[b+220>>2]=P;if((a[b+100>>0]|0)==0|o)g[b+96>>
2]=0;do if((a[b+112>>0]|0)==0|o)c[b+224>>2]=0;else{P=C-w-+g[b+116>>2];L=+g[b+124>>2];H=+g[b+120>>2];O=L-H;if(O>0)Q=O;else Q=-O;if(Q<.06981317698955536){c[b+224>>2]=3;break}if(P<=H){r=b+224|0;if((c[r>>2]|0)!=1)g[b+92>>2]=0;c[r>>2]=1;break}r=b+224|0;if(!(P>=L)){c[r>>2]=0;g[b+92>>2]=0;break}if((c[r>>2]|0)!=2)g[b+92>>2]=0;c[r>>2]=2}while(0);o=b+84|0;if((a[d+24>>0]|0)==0){c[o+0>>2]=0;c[o+4>>2]=0;c[o+8>>2]=0;c[o+12>>2]=0;R=z;U=A;V=D;W=E;X=B;Y=F;Z=c[j>>2]|0;_=c[f>>2]|0;$=_+(Z*12|0)|0;aa=+R;ba=+U;ca=$;da=
ca;g[da>>2]=aa;ea=ca+4|0;fa=ea;g[fa>>2]=ba;ga=c[j>>2]|0;ha=c[f>>2]|0;ia=ha+(ga*12|0)+8|0;g[ia>>2]=X;ja=c[n>>2]|0;ka=ha+(ja*12|0)|0;la=+V;ma=+W;na=ka;oa=na;g[oa>>2]=la;pa=na+4|0;qa=pa;g[qa>>2]=ma;ra=c[n>>2]|0;sa=c[f>>2]|0;ta=sa+(ra*12|0)+8|0;g[ta>>2]=Y;i=e;return}else{r=d+8|0;Q=+g[r>>2];w=Q*+g[o>>2];g[o>>2]=w;o=b+88|0;C=Q*+g[o>>2];g[o>>2]=C;o=b+92|0;L=Q*+g[o>>2];g[o>>2]=L;o=b+96|0;Q=+g[r>>2]*+g[o>>2];g[o>>2]=Q;R=z-J*w;U=A-J*C;V=D+t*w;W=E+t*C;X=B-u*(L+(Q+(C*+g[m>>2]-w*+g[s>>2])));Y=F+v*(L+(Q+(C*K-w*
G)));Z=c[j>>2]|0;_=c[f>>2]|0;$=_+(Z*12|0)|0;aa=+R;ba=+U;ca=$;da=ca;g[da>>2]=aa;ea=ca+4|0;fa=ea;g[fa>>2]=ba;ga=c[j>>2]|0;ha=c[f>>2]|0;ia=ha+(ga*12|0)+8|0;g[ia>>2]=X;ja=c[n>>2]|0;ka=ha+(ja*12|0)|0;la=+V;ma=+W;na=ka;oa=na;g[oa>>2]=la;pa=na+4|0;qa=pa;g[qa>>2]=ma;ra=c[n>>2]|0;sa=c[f>>2]|0;ta=sa+(ra*12|0)+8|0;g[ta>>2]=Y;i=e;return}}function Ch(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,
P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0;e=i;i=i+80|0;f=e+60|0;h=e+48|0;j=e+40|0;k=e+32|0;l=e+24|0;m=e+16|0;n=e+8|0;o=e;p=b+128|0;q=c[p>>2]|0;r=d+32|0;s=c[r>>2]|0;t=s+(q*12|0)|0;u=+g[t>>2];v=+g[t+4>>2];w=+g[s+(q*12|0)+8>>2];q=b+132|0;t=c[q>>2]|0;x=s+(t*12|0)|0;y=+g[x>>2];z=+g[x+4>>2];A=+g[s+(t*12|0)+8>>2];B=+g[b+168>>2];
C=+g[b+172>>2];D=+g[b+176>>2];E=+g[b+180>>2];t=D+E==0;if((a[b+100>>0]|0)!=0?!((c[b+224>>2]|0)==3|t):0){s=b+96|0;F=+g[s>>2];G=+g[d>>2]*+g[b+104>>2];H=F-+g[b+220>>2]*(A-w-+g[b+108>>2]);I=-G;J=H<G?H:G;G=J<I?I:J;g[s>>2]=G;J=G-F;K=w-D*J;L=A+E*J}else{K=w;L=A}if((a[b+112>>0]|0)!=0?(s=b+224|0,!((c[s>>2]|0)==0|t)):0){t=b+148|0;d=b+144|0;x=b+140|0;M=b+136|0;A=y-L*+g[t>>2]-u+K*+g[x>>2];w=z+L*+g[d>>2]-v-K*+g[M>>2];g[f>>2]=A;g[f+4>>2]=w;g[f+8>>2]=L-K;N=b+184|0;Gm(h,N,f);J=+g[h>>2];F=-J;G=+g[h+4>>2];I=-G;H=+g[h+
8>>2];O=-H;h=c[s>>2]|0;do if((h|0)==2){s=b+84|0;f=b+92|0;P=+g[f>>2];Q=P-H;if(Q>0){R=P*+g[b+212>>2]-w;g[l>>2]=P*+g[b+208>>2]-A;g[l+4>>2]=R;Hm(m,N,l);R=+g[m>>2];P=+g[m+4>>2];S=-+g[f>>2];g[s>>2]=R+ +g[s>>2];T=b+88|0;g[T>>2]=P+ +g[T>>2];g[f>>2]=0;U=P;V=R;W=S;break}else{g[s>>2]=+g[s>>2]-J;s=b+88|0;g[s>>2]=+g[s>>2]-G;g[f>>2]=Q;U=I;V=F;W=O;break}}else if((h|0)==3){f=b+84|0;g[f>>2]=+g[f>>2]-J;f=b+88|0;g[f>>2]=+g[f>>2]-G;f=b+92|0;g[f>>2]=+g[f>>2]-H;U=I;V=F;W=O}else if((h|0)==1){f=b+84|0;s=b+92|0;Q=+g[s>>2];
S=Q-H;if(S<0){R=Q*+g[b+212>>2]-w;g[j>>2]=Q*+g[b+208>>2]-A;g[j+4>>2]=R;Hm(k,N,j);R=+g[k>>2];Q=+g[k+4>>2];P=-+g[s>>2];g[f>>2]=R+ +g[f>>2];T=b+88|0;g[T>>2]=Q+ +g[T>>2];g[s>>2]=0;U=Q;V=R;W=P;break}else{g[f>>2]=+g[f>>2]-J;f=b+88|0;g[f>>2]=+g[f>>2]-G;g[s>>2]=S;U=I;V=F;W=O;break}}else{U=I;V=F;W=O}while(0);X=W+(U*+g[d>>2]-V*+g[t>>2]);Y=W+(U*+g[M>>2]-V*+g[x>>2]);Z=U;_=V;$=C*_;aa=C*Z;ba=B*_;ca=B*Z;da=y+$;ea=z+aa;fa=u-ba;ga=v-ca;ha=D*Y;ia=E*X;ja=K-ha;ka=L+ia;la=c[p>>2]|0;ma=c[r>>2]|0;na=ma+(la*12|0)|0;oa=+fa;
pa=+ga;qa=na;ra=qa;g[ra>>2]=oa;sa=qa+4|0;ta=sa;g[ta>>2]=pa;ua=c[p>>2]|0;va=c[r>>2]|0;wa=va+(ua*12|0)+8|0;g[wa>>2]=ja;xa=c[q>>2]|0;ya=va+(xa*12|0)|0;za=+da;Aa=+ea;Ba=ya;Ca=Ba;g[Ca>>2]=za;Da=Ba+4|0;Ea=Da;g[Ea>>2]=Aa;Fa=c[q>>2]|0;Ga=c[r>>2]|0;Ha=Ga+(Fa*12|0)+8|0;g[Ha>>2]=ka;i=e;return}x=b+148|0;M=b+144|0;t=b+140|0;d=b+136|0;V=-(z+L*+g[M>>2]-v-K*+g[d>>2]);g[o>>2]=-(y-L*+g[x>>2]-u+K*+g[t>>2]);g[o+4>>2]=V;Hm(n,b+184|0,o);V=+g[n>>2];o=b+84|0;g[o>>2]=V+ +g[o>>2];U=+g[n+4>>2];n=b+88|0;g[n>>2]=U+ +g[n>>2];
X=U*+g[M>>2]-V*+g[x>>2];Y=U*+g[d>>2]-V*+g[t>>2];Z=U;_=V;$=C*_;aa=C*Z;ba=B*_;ca=B*Z;da=y+$;ea=z+aa;fa=u-ba;ga=v-ca;ha=D*Y;ia=E*X;ja=K-ha;ka=L+ia;la=c[p>>2]|0;ma=c[r>>2]|0;na=ma+(la*12|0)|0;oa=+fa;pa=+ga;qa=na;ra=qa;g[ra>>2]=oa;sa=qa+4|0;ta=sa;g[ta>>2]=pa;ua=c[p>>2]|0;va=c[r>>2]|0;wa=va+(ua*12|0)+8|0;g[wa>>2]=ja;xa=c[q>>2]|0;ya=va+(xa*12|0)|0;za=+da;Aa=+ea;Ba=ya;Ca=Ba;g[Ca>>2]=za;Da=Ba+4|0;Ea=Da;g[Ea>>2]=Aa;Fa=c[q>>2]|0;Ga=c[r>>2]|0;Ha=Ga+(Fa*12|0)+8|0;g[Ha>>2]=ka;i=e;return}function Dh(b,d){b=b|0;
d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0;e=i;f=b+128|0;h=c[f>>2]|0;j=d+28|0;d=c[j>>2]|0;k=d+(h*12|0)|0;l=k;m=+g[l>>2];n=+g[l+4>>2];o=+g[d+(h*12|0)+8>>2];h=b+132|0;l=c[h>>2]|0;p=d+(l*12|0)|0;q=+g[p>>2];r=+g[p+4>>2];s=+g[d+(l*12|0)+8>>2];l=b+176|0;d=b+180|0;if((a[b+112>>0]|0)!=0){t=+g[d>>2];u=+g[l>>2];p=c[b+224>>2]|0;if((p|0)==0|t+u==0){v=u;w=t;x=o;y=s;z=0}else{A=s-o-+g[b+116>>2];if((p|0)==1){B=A-+g[b+
120>>2];C=B+.03490658849477768;D=C<0?C:0;E=-B;F=-(+g[b+220>>2]*(D<-.13962635397911072?-.13962635397911072:D))}else if((p|0)==3){D=A-+g[b+120>>2];B=D<.13962635397911072?D:.13962635397911072;D=B<-.13962635397911072?-.13962635397911072:B;B=-(+g[b+220>>2]*D);if(D>0){E=D;F=B}else{E=-D;F=B}}else if((p|0)==2){B=A-+g[b+124>>2];A=B+-.03490658849477768;D=A<.13962635397911072?A:.13962635397911072;E=B;F=-(+g[b+220>>2]*(D<0?0:D))}else{E=0;F=0}v=u;w=t;x=o-F*u;y=s+F*t;z=E}}else{v=+g[l>>2];w=+g[d>>2];x=o;y=s;z=0}s=
+T(+x);o=+S(+x);E=+T(+y);t=+S(+y);F=+g[b+68>>2]-+g[b+152>>2];u=+g[b+72>>2]-+g[b+156>>2];D=o*F-s*u;B=s*F+o*u;u=+g[b+76>>2]-+g[b+160>>2];o=+g[b+80>>2]-+g[b+164>>2];F=t*u-E*o;s=E*u+t*o;o=q+F-m-D;t=r+s-n-B;u=+Q(+(o*o+t*t));E=+g[b+168>>2];A=+g[b+172>>2];C=E+A;G=C+B*B*v+s*s*w;H=D*v;I=F*w;J=-(B*H)-s*I;K=C+D*H+F*I;I=G*K-J*J;if(I!=0)L=1/I;else L=I;I=-((o*K-t*J)*L);K=-((t*G-o*J)*L);L=+(m-E*I);m=+(n-E*K);b=k;g[b>>2]=L;g[b+4>>2]=m;b=c[j>>2]|0;g[b+((c[f>>2]|0)*12|0)+8>>2]=x-v*(D*K-B*I);B=+(q+A*I);q=+(r+A*K);f=
b+((c[h>>2]|0)*12|0)|0;g[f>>2]=B;g[f+4>>2]=q;g[(c[j>>2]|0)+((c[h>>2]|0)*12|0)+8>>2]=y+w*(F*K-s*I);if(!(u<=.004999999888241291)){M=0;i=e;return M|0}M=z<=.03490658849477768;i=e;return M|0}function Eh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+68>>2];h=+g[d+20>>2];i=+g[b+72>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Fh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+76>>2];h=+g[d+20>>2];i=
+g[b+80>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Gh(a,b,c){a=a|0;b=b|0;c=+c;var d=0;d=+g[b+88>>2]*c;g[a>>2]=+g[b+84>>2]*c;g[a+4>>2]=d;return}function Hh(a,b){a=a|0;b=+b;return+(+g[a+92>>2]*b)}function Ih(a){a=a|0;return+(+g[(c[a+52>>2]|0)+72>>2]-+g[(c[a+48>>2]|0)+72>>2]-+g[a+116>>2])}function Jh(b){b=b|0;return(a[b+100>>0]|0)!=0|0}function Kh(d,f){d=d|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0;h=i;j=c[d+48>>2]|0;k=j+4|0;l=e[k>>1]|0;if((l&2|0)==0){b[k>>1]=l|2;g[j+
160>>2]=0}j=c[d+52>>2]|0;l=j+4|0;k=e[l>>1]|0;if((k&2|0)!=0){m=d+100|0;n=f&1;a[m>>0]=n;i=h;return}b[l>>1]=k|2;g[j+160>>2]=0;m=d+100|0;n=f&1;a[m>>0]=n;i=h;return}function Lh(a,d){a=a|0;d=+d;var f=0,h=0,j=0,k=0,l=0;f=i;h=c[a+48>>2]|0;j=h+4|0;k=e[j>>1]|0;if((k&2|0)==0){b[j>>1]=k|2;g[h+160>>2]=0}h=c[a+52>>2]|0;k=h+4|0;j=e[k>>1]|0;if((j&2|0)!=0){l=a+108|0;g[l>>2]=d;i=f;return}b[k>>1]=j|2;g[h+160>>2]=0;l=a+108|0;g[l>>2]=d;i=f;return}function Mh(b){b=b|0;return(a[b+112>>0]|0)!=0|0}function Nh(f,h){f=f|0;
h=h|0;var j=0,k=0,l=0,m=0,n=0;j=i;k=f+112|0;if((h&1|0)==(d[k>>0]|0|0)){i=j;return}l=c[f+48>>2]|0;m=l+4|0;n=e[m>>1]|0;if((n&2|0)==0){b[m>>1]=n|2;g[l+160>>2]=0}l=c[f+52>>2]|0;n=l+4|0;m=e[n>>1]|0;if((m&2|0)==0){b[n>>1]=m|2;g[l+160>>2]=0}a[k>>0]=h&1;g[f+92>>2]=0;i=j;return}function Oh(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(4416,e);c[e>>2]=f;Rm(4448,e);c[e>>2]=j;Rm(4480,e);c[e>>2]=d[a+61>>0]|0;Rm(4512,e);l=+g[a+72>>2];h[k>>3]=+g[a+68>>
2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(4552,e);l=+g[a+80>>2];h[k>>3]=+g[a+76>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(4600,e);h[k>>3]=+g[a+116>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(4648,e);c[e>>2]=d[a+112>>0]|0;Rm(4680,e);h[k>>3]=+g[a+120>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(4712,e);h[k>>3]=+g[a+124>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(4744,e);c[e>>2]=d[a+100>>0]|0;Rm(4776,
e);h[k>>3]=+g[a+108>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(4808,e);h[k>>3]=+g[a+104>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(4840,e);c[e>>2]=c[a+56>>2];Rm(4872,e);i=b;return}function Ph(a){a=a|0;return}function Qh(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Rh(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;h=i;c[a+8>>2]=b;c[a+12>>2]=d;j=+g[e>>2]-+g[b+12>>2];k=e+4|0;l=+g[k>>2]-+g[b+16>>2];m=b+24|0;n=+g[m>>2];o=b+20|0;p=+g[o>>2];q=+(j*n+l*p);r=+(n*l-j*
p);b=a+20|0;g[b>>2]=q;g[b+4>>2]=r;r=+g[e>>2]-+g[d+12>>2];q=+g[k>>2]-+g[d+16>>2];p=+g[d+24>>2];j=+g[d+20>>2];l=+(r*p+q*j);n=+(p*q-r*j);d=a+28|0;g[d>>2]=l;g[d+4>>2]=n;n=+g[m>>2];l=+g[f>>2];j=+g[o>>2];r=+g[f+4>>2];q=+(n*l+j*r);p=+(n*r-l*j);f=a+36|0;g[f>>2]=q;g[f+4>>2]=p;i=h;return}function Sh(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0;e=i;vh(b,d);c[b>>2]=4968;f=d+20|0;h=c[f+4>>2]|0;j=b+76|0;c[j>>2]=c[f>>2];c[j+4>>2]=h;h=d+28|0;j=c[h+4>>2]|0;f=b+84|0;c[f>>2]=c[h>>2];c[f+4>>2]=j;j=d+36|0;f=c[j>>2]|0;h=c[j+4>>
2]|0;j=b+92|0;c[j>>2]=f;c[j+4>>2]=h;j=b+100|0;g[j>>2]=-(c[k>>2]=h,+g[k>>2]);c[j+4>>2]=f;g[b+204>>2]=0;g[b+108>>2]=0;g[b+208>>2]=0;g[b+112>>2]=0;g[b+212>>2]=0;g[b+116>>2]=0;g[b+120>>2]=+g[d+48>>2];g[b+124>>2]=+g[d+52>>2];a[b+128>>0]=a[d+44>>0]|0;g[b+68>>2]=+g[d+56>>2];g[b+72>>2]=+g[d+60>>2];g[b+216>>2]=0;g[b+220>>2]=0;d=b+172|0;c[d+0>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;i=e;return}function Th(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,
B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+132|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+136|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+140|0;c[o>>2]=p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+148|0;c[o>>2]=r;c[o+4>>2]=s;t=+g[f+136>>2];o=b+156|0;
g[o>>2]=t;u=+g[l+136>>2];v=b+160|0;g[v>>2]=u;w=+g[f+144>>2];f=b+164|0;g[f>>2]=w;x=+g[l+144>>2];l=b+168|0;g[l>>2]=x;y=c[d+28>>2]|0;z=y+(h*12|0)|0;A=+g[z>>2];B=+g[z+4>>2];C=+g[y+(h*12|0)+8>>2];z=d+32|0;D=c[z>>2]|0;E=D+(h*12|0)|0;F=+g[E>>2];G=+g[E+4>>2];H=+g[D+(h*12|0)+8>>2];h=y+(m*12|0)|0;I=+g[h>>2];J=+g[h+4>>2];K=+g[y+(m*12|0)+8>>2];y=D+(m*12|0)|0;L=+g[y>>2];M=+g[y+4>>2];N=+g[D+(m*12|0)+8>>2];O=+T(+C);P=+S(+C);C=+T(+K);Q=+S(+K);K=+g[b+76>>2]-(c[k>>2]=p,+g[k>>2]);R=+g[b+80>>2]-(c[k>>2]=q,+g[k>>2]);
U=P*K-O*R;V=O*K+P*R;R=+g[b+84>>2]-(c[k>>2]=r,+g[k>>2]);K=+g[b+88>>2]-(c[k>>2]=s,+g[k>>2]);W=Q*R-C*K;X=C*R+Q*K;K=I+W-A-U;A=J+X-B-V;B=+g[b+100>>2];J=+g[b+104>>2];I=P*B-O*J;Q=O*B+P*J;J=+I;B=+Q;s=b+180|0;g[s>>2]=J;g[s+4>>2]=B;B=U+K;U=V+A;V=Q*B-I*U;g[b+196>>2]=V;J=W*Q-X*I;g[b+200>>2]=J;R=t+u;u=R+V*w*V+J*x*J;if(u>0)Y=1/u;else Y=u;g[b+204>>2]=Y;s=b+212|0;g[s>>2]=0;r=b+216|0;g[r>>2]=0;q=b+220|0;g[q>>2]=0;Y=+g[b+68>>2];if(Y>0){u=+g[b+92>>2];t=+g[b+96>>2];C=P*u-O*t;Z=O*u+P*t;t=+C;P=+Z;p=b+172|0;g[p>>2]=t;g[p+
4>>2]=P;P=B*Z-U*C;g[b+188>>2]=P;U=W*Z-X*C;g[b+192>>2]=U;X=R+P*w*P+U*x*U;if(X>0){U=1/X;g[s>>2]=U;P=Y*6.2831854820251465;Y=P*U*P;R=+g[d>>2];W=R*(P*U*2*+g[b+72>>2]+R*Y);if(W>0)_=1/W;else _=W;g[q>>2]=_;g[r>>2]=(K*C+A*Z)*R*Y*_;Y=X+_;g[s>>2]=Y;if(Y>0)g[s>>2]=1/Y}}else g[b+116>>2]=0;if((a[b+128>>0]|0)!=0){Y=x+w;s=b+208|0;g[s>>2]=Y;if(Y>0)g[s>>2]=1/Y}else{g[b+208>>2]=0;g[b+112>>2]=0}if((a[d+24>>0]|0)==0){g[b+108>>2]=0;g[b+116>>2]=0;g[b+112>>2]=0;$=F;aa=G;ba=L;ca=M;da=H;ea=N;fa=c[j>>2]|0;ga=c[z>>2]|0;ha=ga+
(fa*12|0)|0;ia=+$;ja=+aa;ka=ha;la=ka;g[la>>2]=ia;ma=ka+4|0;na=ma;g[na>>2]=ja;oa=c[j>>2]|0;pa=c[z>>2]|0;qa=pa+(oa*12|0)+8|0;g[qa>>2]=da;ra=c[n>>2]|0;sa=pa+(ra*12|0)|0;ta=+ba;ua=+ca;va=sa;wa=va;g[wa>>2]=ta;xa=va+4|0;ya=xa;g[ya>>2]=ua;za=c[n>>2]|0;Aa=c[z>>2]|0;Ba=Aa+(za*12|0)+8|0;g[Ba>>2]=ea;i=e;return}else{s=d+8|0;d=b+108|0;Y=+g[s>>2]*+g[d>>2];g[d>>2]=Y;d=b+116|0;w=+g[s>>2]*+g[d>>2];g[d>>2]=w;d=b+112|0;x=+g[s>>2]*+g[d>>2];g[d>>2]=x;_=Y*I+w*+g[b+172>>2];I=Y*Q+w*+g[b+176>>2];Q=+g[o>>2];X=+g[v>>2];$=F-
_*Q;aa=G-I*Q;ba=L+_*X;ca=M+I*X;da=H-(x+(Y*V+w*+g[b+188>>2]))*+g[f>>2];ea=N+(x+(Y*J+w*+g[b+192>>2]))*+g[l>>2];fa=c[j>>2]|0;ga=c[z>>2]|0;ha=ga+(fa*12|0)|0;ia=+$;ja=+aa;ka=ha;la=ka;g[la>>2]=ia;ma=ka+4|0;na=ma;g[na>>2]=ja;oa=c[j>>2]|0;pa=c[z>>2]|0;qa=pa+(oa*12|0)+8|0;g[qa>>2]=da;ra=c[n>>2]|0;sa=pa+(ra*12|0)|0;ta=+ba;ua=+ca;va=sa;wa=va;g[wa>>2]=ta;xa=va+4|0;ya=xa;g[ya>>2]=ua;za=c[n>>2]|0;Aa=c[z>>2]|0;Ba=Aa+(za*12|0)+8|0;g[Ba>>2]=ea;i=e;return}}function Uh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=
0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;d=i;e=+g[a+156>>2];f=+g[a+160>>2];h=+g[a+164>>2];j=+g[a+168>>2];k=a+132|0;l=c[k>>2]|0;m=b+32|0;n=c[m>>2]|0;o=n+(l*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[n+(l*12|0)+8>>2];l=a+136|0;o=c[l>>2]|0;s=n+(o*12|0)|0;t=+g[s>>2];u=+g[s+4>>2];v=+g[n+(o*12|0)+8>>2];w=+g[a+172>>2];x=+g[a+176>>2];y=+g[a+192>>2];z=+g[a+188>>2];o=a+116|0;A=+g[o>>2];B=+g[a+212>>2]*(+g[a+216>>2]+(v*y+(w*(t-p)+x*(u-q))-r*z)+ +g[a+220>>2]*A);C=-B;g[o>>2]=A-B;B=w*C;w=
x*C;x=p-e*B;p=q-e*w;q=r-h*z*C;z=t+f*B;B=u+f*w;w=v+j*y*C;o=a+112|0;C=+g[o>>2];y=+g[b>>2]*+g[a+120>>2];v=C-+g[a+208>>2]*(w-q-+g[a+124>>2]);u=-y;t=v<y?v:y;y=t<u?u:t;g[o>>2]=y;t=y-C;C=q-h*t;q=w+j*t;t=+g[a+180>>2];w=+g[a+184>>2];y=+g[a+200>>2];u=+g[a+196>>2];v=+g[a+204>>2]*((z-x)*t+(B-p)*w+y*q-u*C);r=-v;o=a+108|0;g[o>>2]=+g[o>>2]-v;v=t*r;t=w*r;w=+(x-e*v);x=+(p-e*t);o=(c[m>>2]|0)+((c[k>>2]|0)*12|0)|0;g[o>>2]=w;g[o+4>>2]=x;o=c[m>>2]|0;g[o+((c[k>>2]|0)*12|0)+8>>2]=C-h*u*r;u=+(z+f*v);v=+(B+f*t);k=o+((c[l>>
2]|0)*12|0)|0;g[k>>2]=u;g[k+4>>2]=v;g[(c[m>>2]|0)+((c[l>>2]|0)*12|0)+8>>2]=q+j*y*r;i=d;return}function Vh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0;d=i;e=a+132|0;f=c[e>>2]|0;h=b+28|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=+g[j>>2];l=+g[j+4>>2];m=+g[b+(f*12|0)+8>>2];f=a+136|0;j=c[f>>2]|0;n=b+(j*12|0)|0;o=+g[n>>2];p=+g[n+4>>2];q=+g[b+(j*12|0)+8>>2];r=+T(+m);s=+S(+m);t=+T(+q);u=+S(+q);v=+g[a+76>>2]-+g[a+140>>
2];w=+g[a+80>>2]-+g[a+144>>2];x=s*v-r*w;y=r*v+s*w;w=+g[a+84>>2]-+g[a+148>>2];v=+g[a+88>>2]-+g[a+152>>2];z=u*w-t*v;A=t*w+u*v;v=o-k+z-x;u=p-l+A-y;w=+g[a+100>>2];t=+g[a+104>>2];B=s*w-r*t;C=r*w+s*t;t=B*v+C*u;s=+g[a+156>>2];w=+g[a+160>>2];r=+g[a+164>>2];D=+g[a+196>>2];E=+g[a+168>>2];F=+g[a+200>>2];G=s+w+D*r*D+F*E*F;if(G!=0)H=-t/G;else H=0;G=B*H;F=C*H;D=+(k-G*s);k=+(l-F*s);a=(c[h>>2]|0)+((c[e>>2]|0)*12|0)|0;g[a>>2]=D;g[a+4>>2]=k;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=m-(C*(x+v)-B*(y+u))*H*r;r=+(o+G*w);
G=+(p+F*w);e=a+((c[f>>2]|0)*12|0)|0;g[e>>2]=r;g[e+4>>2]=G;g[(c[h>>2]|0)+((c[f>>2]|0)*12|0)+8>>2]=q+(z*C-A*B)*H*E;if(t>0){I=t;J=I<=.004999999888241291;i=d;return J|0}I=-t;J=I<=.004999999888241291;i=d;return J|0}function Wh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+76>>2];h=+g[d+20>>2];i=+g[b+80>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Xh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+
84>>2];h=+g[d+20>>2];i=+g[b+88>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Yh(a,b,c){a=a|0;b=b|0;c=+c;var d=0,e=0,f=0;d=+g[b+108>>2];e=+g[b+116>>2];f=(d*+g[b+184>>2]+e*+g[b+176>>2])*c;g[a>>2]=(d*+g[b+180>>2]+e*+g[b+172>>2])*c;g[a+4>>2]=f;return}function Zh(a,b){a=a|0;b=+b;return+(+g[a+112>>2]*b)}function _h(a,d){a=a|0;d=+d;var f=0,h=0,j=0,k=0,l=0;f=i;h=c[a+48>>2]|0;j=h+4|0;k=e[j>>1]|0;if((k&2|0)==0){b[j>>1]=k|2;g[h+160>>2]=0}h=c[a+52>>2]|0;k=h+4|0;j=e[k>>1]|
0;if((j&2|0)!=0){l=a+124|0;g[l>>2]=d;i=f;return}b[k>>1]=j|2;g[h+160>>2]=0;l=a+124|0;g[l>>2]=d;i=f;return}function $h(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(5016,e);c[e>>2]=f;Rm(5040,e);c[e>>2]=j;Rm(5072,e);c[e>>2]=d[a+61>>0]|0;Rm(5104,e);l=+g[a+80>>2];h[k>>3]=+g[a+76>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(5144,e);l=+g[a+88>>2];h[k>>3]=+g[a+84>>2];c[e>>2]=c[k>>2];c[e+4>>2]=
c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(5192,e);l=+g[a+96>>2];h[k>>3]=+g[a+92>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(5240,e);c[e>>2]=d[a+128>>0]|0;Rm(5280,e);h[k>>3]=+g[a+124>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(5312,e);h[k>>3]=+g[a+120>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(5344,e);h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(5376,e);h[k>>3]=+g[a+72>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];
Rm(5408,e);c[e>>2]=c[a+56>>2];Rm(5440,e);i=b;return}function ai(a){a=a|0;return}function bi(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function ci(a,b,d,e,f,h,j,k){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;h=h|0;j=j|0;k=+k;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;l=i;c[a+8>>2]=b;c[a+12>>2]=d;m=e;n=c[m+4>>2]|0;o=a+20|0;c[o>>2]=c[m>>2];c[o+4>>2]=n;n=f;o=c[n+4>>2]|0;m=a+28|0;c[m>>2]=c[n>>2];c[m+4>>2]=o;p=+g[h>>2]-+g[b+12>>2];o=h+4|0;q=+g[o>>2]-+g[b+16>>2];r=+g[b+24>>2];s=+g[b+20>>2];t=+(p*r+q*s);u=+(r*q-p*s);b=a+
36|0;g[b>>2]=t;g[b+4>>2]=u;u=+g[j>>2]-+g[d+12>>2];b=j+4|0;t=+g[b>>2]-+g[d+16>>2];s=+g[d+24>>2];p=+g[d+20>>2];q=+(u*s+t*p);r=+(s*t-u*p);d=a+44|0;g[d>>2]=q;g[d+4>>2]=r;r=+g[h>>2]-+g[e>>2];q=+g[o>>2]-+g[e+4>>2];g[a+52>>2]=+Q(+(r*r+q*q));q=+g[j>>2]-+g[f>>2];r=+g[b>>2]-+g[f+4>>2];g[a+56>>2]=+Q(+(q*q+r*r));g[a+60>>2]=k;i=l;return}function di(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0;d=i;vh(a,b);c[a>>2]=5528;e=b+20|0;f=c[e+4>>2]|0;h=a+68|0;c[h>>2]=c[e>>2];c[h+4>>2]=f;f=b+28|0;h=c[f+4>>2]|0;e=a+76|0;c[e>>
2]=c[f>>2];c[e+4>>2]=h;h=b+36|0;e=c[h+4>>2]|0;f=a+92|0;c[f>>2]=c[h>>2];c[f+4>>2]=e;e=b+44|0;f=c[e+4>>2]|0;h=a+100|0;c[h>>2]=c[e>>2];c[h+4>>2]=f;f=b+52|0;g[a+84>>2]=+g[f>>2];h=b+56|0;g[a+88>>2]=+g[h>>2];j=+g[b+60>>2];g[a+112>>2]=j;g[a+108>>2]=+g[f>>2]+j*+g[h>>2];g[a+116>>2]=0;i=d;return}function ei(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,
ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+120|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+124|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+160|0;c[o>>2]=p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+168|0;c[o>>2]=r;c[o+4>>2]=s;s=b+176|0;g[s>>2]=+g[f+136>>2];o=b+180|0;g[o>>2]=+g[l+136>>2];t=b+184|0;g[t>>2]=+g[f+144>>2];f=b+188|0;g[f>>2]=+g[l+144>>2];l=c[d+28>>2]|0;u=l+(h*12|0)|
0;v=+g[u>>2];w=+g[u+4>>2];x=+g[l+(h*12|0)+8>>2];u=d+32|0;y=c[u>>2]|0;z=y+(h*12|0)|0;A=+g[z>>2];B=+g[z+4>>2];C=+g[y+(h*12|0)+8>>2];h=l+(m*12|0)|0;D=+g[h>>2];E=+g[h+4>>2];F=+g[l+(m*12|0)+8>>2];l=y+(m*12|0)|0;G=+g[l>>2];H=+g[l+4>>2];I=+g[y+(m*12|0)+8>>2];J=+T(+x);K=+S(+x);x=+T(+F);L=+S(+F);m=b+144|0;F=+g[b+92>>2]-(c[k>>2]=p,+g[k>>2]);M=+g[b+96>>2]-(c[k>>2]=q,+g[k>>2]);N=K*F-J*M;O=J*F+K*M;M=+N;K=+O;q=m;g[q>>2]=M;g[q+4>>2]=K;K=+g[b+100>>2]-(c[k>>2]=r,+g[k>>2]);M=+g[b+104>>2]-+g[b+172>>2];F=L*K-x*M;J=x*
K+L*M;M=+F;L=+J;r=b+152|0;g[r>>2]=M;g[r+4>>2]=L;r=b+128|0;L=v+N-+g[b+68>>2];N=w+O-+g[b+72>>2];O=+L;w=+N;q=r;g[q>>2]=O;g[q+4>>2]=w;q=b+136|0;w=D+F-+g[b+76>>2];D=E+J-+g[b+80>>2];E=+w;O=+D;p=q;g[p>>2]=E;g[p+4>>2]=O;O=+Q(+(L*L+N*N));E=+Q(+(w*w+D*D));if(O>.04999999701976776){v=1/O;O=L*v;g[r>>2]=O;P=v*N;R=O}else{g[r>>2]=0;P=0;R=0}g[b+132>>2]=P;if(E>.04999999701976776){O=1/E;E=O*w;g[q>>2]=E;U=O*D;V=E}else{g[q>>2]=0;U=0;V=0}g[b+140>>2]=U;E=+g[m>>2];D=+g[b+148>>2];O=E*P-D*R;w=F*U-J*V;N=+g[s>>2];v=+g[t>>2];
L=+g[o>>2];M=+g[f>>2];K=+g[b+112>>2];x=N+O*O*v+K*K*(L+w*w*M);if(x>0)W=1/x;else W=x;g[b+192>>2]=W;if((a[d+24>>0]|0)==0){g[b+116>>2]=0;X=A;Y=B;Z=G;_=H;$=C;aa=I;ba=c[j>>2]|0;ca=c[u>>2]|0;da=ca+(ba*12|0)|0;ea=+X;fa=+Y;ga=da;ha=ga;g[ha>>2]=ea;ia=ga+4|0;ja=ia;g[ja>>2]=fa;ka=c[j>>2]|0;la=c[u>>2]|0;ma=la+(ka*12|0)+8|0;g[ma>>2]=$;na=c[n>>2]|0;oa=la+(na*12|0)|0;pa=+Z;qa=+_;ra=oa;sa=ra;g[sa>>2]=pa;ta=ra+4|0;ua=ta;g[ua>>2]=qa;va=c[n>>2]|0;wa=c[u>>2]|0;xa=wa+(va*12|0)+8|0;g[xa>>2]=aa;i=e;return}else{f=b+116|0;
W=+g[d+8>>2]*+g[f>>2];g[f>>2]=W;x=-W;w=R*x;R=P*x;x=-(W*K);K=V*x;V=U*x;X=A+w*N;Y=B+R*N;Z=G+K*L;_=H+V*L;$=C+v*(R*E-w*D);aa=I+M*(V*F-K*J);ba=c[j>>2]|0;ca=c[u>>2]|0;da=ca+(ba*12|0)|0;ea=+X;fa=+Y;ga=da;ha=ga;g[ha>>2]=ea;ia=ga+4|0;ja=ia;g[ja>>2]=fa;ka=c[j>>2]|0;la=c[u>>2]|0;ma=la+(ka*12|0)+8|0;g[ma>>2]=$;na=c[n>>2]|0;oa=la+(na*12|0)|0;pa=+Z;qa=+_;ra=oa;sa=ra;g[sa>>2]=pa;ta=ra+4|0;ua=ta;g[ua>>2]=qa;va=c[n>>2]|0;wa=c[u>>2]|0;xa=wa+(va*12|0)+8|0;g[xa>>2]=aa;i=e;return}}function fi(a,b){a=a|0;b=b|0;var d=0,
e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;d=i;e=a+120|0;f=c[e>>2]|0;h=b+32|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=j;l=+g[k>>2];m=+g[k+4>>2];n=+g[b+(f*12|0)+8>>2];f=a+124|0;k=c[f>>2]|0;o=b+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[b+(k*12|0)+8>>2];s=+g[a+148>>2];t=+g[a+144>>2];u=+g[a+156>>2];v=+g[a+152>>2];w=+g[a+128>>2];x=+g[a+132>>2];y=+g[a+112>>2];z=+g[a+136>>2];A=+g[a+140>>2];B=+g[a+192>>2]*(-((l-n*s)*w+(m+n*t)*x)-y*((p-r*u)*z+(q+r*v)*A));k=a+116|0;g[k>>
2]=+g[k>>2]-B;C=w*B;w=x*B;x=y*B;B=z*x;z=x*A;A=+g[a+176>>2];x=n+ +g[a+184>>2]*(w*t-C*s);s=+g[a+180>>2];t=r+ +g[a+188>>2]*(z*v-B*u);u=+(l+C*A);C=+(m+w*A);a=j;g[a>>2]=u;g[a+4>>2]=C;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=x;x=+(p+B*s);B=+(q+z*s);e=a+((c[f>>2]|0)*12|0)|0;g[e>>2]=x;g[e+4>>2]=B;g[(c[h>>2]|0)+((c[f>>2]|0)*12|0)+8>>2]=t;i=d;return}function gi(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=
0,L=0;d=i;e=a+120|0;f=c[e>>2]|0;h=b+28|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=j;l=+g[k>>2];m=+g[k+4>>2];n=+g[b+(f*12|0)+8>>2];f=a+124|0;k=c[f>>2]|0;o=b+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[b+(k*12|0)+8>>2];s=+T(+n);t=+S(+n);u=+T(+r);v=+S(+r);w=+g[a+92>>2]-+g[a+160>>2];x=+g[a+96>>2]-+g[a+164>>2];y=t*w-s*x;z=s*w+t*x;x=+g[a+100>>2]-+g[a+168>>2];t=+g[a+104>>2]-+g[a+172>>2];w=v*x-u*t;s=u*x+v*t;t=l+y-+g[a+68>>2];v=m+z-+g[a+72>>2];x=p+w-+g[a+76>>2];u=q+s-+g[a+80>>2];A=+Q(+(t*t+v*v));B=+Q(+(x*x+u*u));if(A>.04999999701976776){C=
1/A;D=v*C;E=t*C}else{D=0;E=0}if(B>.04999999701976776){C=1/B;F=u*C;G=x*C}else{F=0;G=0}C=y*D-z*E;x=w*F-s*G;u=+g[a+176>>2];t=+g[a+184>>2];v=+g[a+180>>2];H=+g[a+188>>2];I=+g[a+112>>2];J=u+C*C*t+I*I*(v+x*x*H);if(J>0)K=1/J;else K=J;J=+g[a+108>>2]-A-B*I;if(J>0)L=J;else L=-J;B=K*J;J=E*B;E=D*B;D=B*I;I=G*D;G=F*D;D=+(l+J*u);l=+(m+E*u);a=j;g[a>>2]=D;g[a+4>>2]=l;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=n+(y*E-z*J)*t;t=+(p+I*v);p=+(q+G*v);e=a+((c[f>>2]|0)*12|0)|0;g[e>>2]=t;g[e+4>>2]=p;g[(c[h>>2]|0)+((c[f>>2]|0)*
12|0)+8>>2]=r+H*(w*G-s*I);i=d;return L<.004999999888241291|0}function hi(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+92>>2];h=+g[d+20>>2];i=+g[b+96>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function ii(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+100>>2];h=+g[d+20>>2];i=+g[b+104>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function ji(a,b,c){a=a|0;b=b|0;c=+c;var d=
0,e=0;d=+g[b+116>>2];e=d*+g[b+140>>2]*c;g[a>>2]=d*+g[b+136>>2]*c;g[a+4>>2]=e;return}function ki(a,b){a=a|0;b=+b;return 0}function li(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(5576,e);c[e>>2]=f;Rm(5600,e);c[e>>2]=j;Rm(5632,e);c[e>>2]=d[a+61>>0]|0;Rm(5664,e);l=+g[a+72>>2];h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(5704,e);l=+g[a+80>>2];h[k>>3]=+g[a+76>>2];c[e>>2]=c[k>>
2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(5752,e);l=+g[a+96>>2];h[k>>3]=+g[a+92>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(5800,e);l=+g[a+104>>2];h[k>>3]=+g[a+100>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(5848,e);h[k>>3]=+g[a+84>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(5896,e);h[k>>3]=+g[a+88>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(5928,e);h[k>>3]=
+g[a+112>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(5960,e);c[e>>2]=c[a+56>>2];Rm(5984,e);i=b;return}function mi(a,b){a=a|0;b=b|0;var c=0,d=0;c=a+68|0;g[c>>2]=+g[c>>2]-+g[b>>2];c=b+4|0;d=a+72|0;g[d>>2]=+g[d>>2]-+g[c>>2];d=a+76|0;g[d>>2]=+g[d>>2]-+g[b>>2];b=a+80|0;g[b>>2]=+g[b>>2]-+g[c>>2];return}function ni(a){a=a|0;return}function oi(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function pi(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0;g=i;h=Em(f,148)|0;if((h|0)==0){j=0;i=g;return j|0}wi(h,a,
b,d,e);c[h>>2]=6072;j=h;i=g;return j|0}function qi(a,b){a=a|0;b=b|0;var d=0;d=i;eb[c[(c[a>>2]|0)+4>>2]&127](a);Fm(b,a,148);i=d;return}function ri(a,d,e,f){a=a|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0;h=i;i=i+48|0;j=h;k=c[(c[a+48>>2]|0)+12>>2]|0;c[j>>2]=488;c[j+4>>2]=1;g[j+8>>2]=.009999999776482582;l=j+28|0;c[l+0>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;b[l+16>>1]=0;Ge(k,j,c[a+56>>2]|0);ff(d,j,e,c[(c[a+52>>2]|0)+12>>2]|0,f);i=h;return}function si(a){a=a|0;return}function ti(a){a=a|0;var b=0;b=i;sn(a);
i=b;return}function ui(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0;h=i;if((a[6352]|0)==0){c[1540]=6;c[6164>>2]=53;a[6168>>0]=1;c[6256>>2]=7;c[6260>>2]=54;a[6264>>0]=1;c[6184>>2]=7;c[6188>>2]=54;a[6192>>0]=0;c[6280>>2]=8;c[6284>>2]=55;a[6288>>0]=1;c[6208>>2]=9;c[6212>>2]=56;a[6216>>0]=1;c[6172>>2]=9;c[6176>>2]=56;a[6180>>0]=0;c[6232>>2]=10;c[6236>>2]=57;a[6240>>0]=1;c[6268>>2]=10;c[6272>>2]=57;a[6276>>0]=0;c[6304>>2]=11;c[6308>>2]=58;a[6312>>0]=1;c[6196>>2]=11;c[6200>>2]=58;a[6204>>
0]=0;c[6328>>2]=12;c[6332>>2]=59;a[6336>>0]=1;c[6292>>2]=12;c[6296>>2]=59;a[6300>>0]=0;a[6352]=1}j=c[(c[b+12>>2]|0)+4>>2]|0;k=c[(c[e+12>>2]|0)+4>>2]|0;l=c[6160+(j*48|0)+(k*12|0)>>2]|0;if((l|0)==0){m=0;i=h;return m|0}if((a[6160+(j*48|0)+(k*12|0)+8>>0]|0)==0){m=ob[l&15](e,f,b,d,g)|0;i=h;return m|0}else{m=ob[l&15](b,d,e,f,g)|0;i=h;return m|0}return 0}function vi(d,f){d=d|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0;h=i;j=c[d+48>>2]|0;k=c[d+52>>2]|0;if(((c[d+124>>2]|0)>0?(a[j+38>>0]|0)==0:0)?(a[k+38>>0]|0)==0:
0){l=c[j+8>>2]|0;m=l+4|0;n=e[m>>1]|0;if((n&2|0)==0){b[m>>1]=n|2;g[l+160>>2]=0}l=c[k+8>>2]|0;n=l+4|0;m=e[n>>1]|0;if((m&2|0)==0){b[n>>1]=m|2;g[l+160>>2]=0}}gb[c[6160+((c[(c[j+12>>2]|0)+4>>2]|0)*48|0)+((c[(c[k+12>>2]|0)+4>>2]|0)*12|0)+4>>2]&63](d,f);i=h;return}function wi(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0;h=i;c[a>>2]=6368;c[a+4>>2]=4;c[a+48>>2]=b;c[a+52>>2]=e;c[a+56>>2]=d;c[a+60>>2]=f;c[a+124>>2]=0;c[a+128>>2]=0;f=b+16|0;d=a+8|0;j=d+40|0;do{c[d>>2]=0;d=d+4|0}while((d|0)<(j|
0));g[a+136>>2]=+Q(+(+g[f>>2]*+g[e+16>>2]));k=+g[b+20>>2];l=+g[e+20>>2];g[a+140>>2]=k>l?k:l;g[a+144>>2]=0;i=h;return}function xi(d,f){d=d|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0;h=i;i=i+64|0;j=h;k=d+64|0;l=j+0|0;m=k+0|0;n=l+64|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));m=d+4|0;l=c[m>>2]|0;c[m>>2]=l|4;n=l>>>1;l=c[d+48>>2]|0;o=c[d+52>>2]|0;p=(a[o+38>>0]|a[l+38>>0])<<24>>24!=0;q=c[l+8>>2]|0;r=c[o+8>>2]|0;s=q+12|0;t=r+12|0;if(!p){pb[c[c[d>>
2]>>2]&31](d,k,s,t);k=d+124|0;u=(c[k>>2]|0)>0;a:do if(u){v=c[j+60>>2]|0;if((v|0)>0)w=0;else{x=0;while(1){g[d+(x*20|0)+72>>2]=0;g[d+(x*20|0)+76>>2]=0;x=x+1|0;if((x|0)>=(c[k>>2]|0))break a}}do{x=d+(w*20|0)+72|0;g[x>>2]=0;y=d+(w*20|0)+76|0;g[y>>2]=0;z=c[d+(w*20|0)+80>>2]|0;A=0;while(1){B=A+1|0;if((c[j+(A*20|0)+16>>2]|0)==(z|0)){C=7;break}if((B|0)<(v|0))A=B;else break}if((C|0)==7){C=0;g[x>>2]=+g[j+(A*20|0)+8>>2];g[y>>2]=+g[j+(A*20|0)+12>>2]}w=w+1|0}while((w|0)<(c[k>>2]|0))}while(0);k=n&1;if(u^(k|0)!=
0){w=q+4|0;C=e[w>>1]|0;if((C&2|0)==0){b[w>>1]=C|2;g[q+160>>2]=0}q=r+4|0;C=e[q>>1]|0;if((C&2|0)==0){b[q>>1]=C|2;g[r+160>>2]=0;D=k;E=u}else{D=k;E=u}}else{D=k;E=u}}else{u=lf(c[l+12>>2]|0,c[d+56>>2]|0,c[o+12>>2]|0,c[d+60>>2]|0,s,t)|0;c[d+124>>2]=0;D=n&1;E=u}u=c[m>>2]|0;c[m>>2]=E?u|2:u&-3;u=(D|0)==0;D=E^1;m=(f|0)==0;if(!(u^1|D|m))gb[c[(c[f>>2]|0)+8>>2]&63](f,d);if(!(u|E|m))gb[c[(c[f>>2]|0)+12>>2]&63](f,d);if(p|D|m){i=h;return}ib[c[(c[f>>2]|0)+32>>2]&7](f,d,j);i=h;return}function yi(a){a=a|0;return}function zi(a){a=
a|0;var b=0;b=i;sn(a);i=b;return}function Ai(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0;e=i;b=Em(f,148)|0;if((b|0)==0){g=0;i=e;return g|0}wi(b,a,0,d,0);c[b>>2]=6392;g=b;i=e;return g|0}function Bi(a,b){a=a|0;b=b|0;var d=0;d=i;eb[c[(c[a>>2]|0)+4>>2]&127](a);Fm(b,a,148);i=d;return}function Ci(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;Ue(b,c[(c[a+48>>2]|0)+12>>2]|0,d,c[(c[a+52>>2]|0)+12>>2]|0,e);i=f;return}function Di(a){a=a|0;return}function Ei(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Fi(a,
b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0;e=i;b=Em(f,148)|0;if((b|0)==0){g=0;i=e;return g|0}wi(b,a,0,d,0);c[b>>2]=6464;g=b;i=e;return g|0}function Gi(a,b){a=a|0;b=b|0;var d=0;d=i;eb[c[(c[a>>2]|0)+4>>2]&127](a);Fm(b,a,148);i=d;return}function Hi(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;Te(b,c[(c[a+48>>2]|0)+12>>2]|0,d,c[(c[a+52>>2]|0)+12>>2]|0,e);i=f;return}function Ii(a){a=a|0;return}function Ji(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Ki(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=
0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;e=i;c[b+0>>2]=c[d+0>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];f=c[d+44>>2]|0;h=b+36|0;c[h>>2]=f;j=c[d+32>>2]|0;k=b+52|0;c[k>>2]=j;l=b+40|0;c[l>>2]=Ym(f,j*88|0)|0;j=Ym(c[h>>2]|0,(c[k>>2]|0)*156|0)|0;h=b+44|0;c[h>>2]=j;c[b+28>>2]=c[d+36>>2];c[b+32>>2]=c[d+40>>2];f=c[d+28>>2]|0;d=b+48|0;c[d>>2]=f;if((c[k>>2]|0)<=0){i=e;return}m=b+24|0;n=b+8|0;b=f;f=j;
j=0;while(1){o=c[b+(j<<2)>>2]|0;p=c[o+48>>2]|0;q=c[o+52>>2]|0;r=+g[(c[p+12>>2]|0)+8>>2];s=+g[(c[q+12>>2]|0)+8>>2];t=c[p+8>>2]|0;p=c[q+8>>2]|0;q=c[o+124>>2]|0;g[f+(j*156|0)+136>>2]=+g[o+136>>2];g[f+(j*156|0)+140>>2]=+g[o+140>>2];g[f+(j*156|0)+144>>2]=+g[o+144>>2];u=t+8|0;c[f+(j*156|0)+112>>2]=c[u>>2];v=p+8|0;c[f+(j*156|0)+116>>2]=c[v>>2];w=t+136|0;g[f+(j*156|0)+120>>2]=+g[w>>2];x=p+136|0;g[f+(j*156|0)+124>>2]=+g[x>>2];y=t+144|0;g[f+(j*156|0)+128>>2]=+g[y>>2];z=p+144|0;g[f+(j*156|0)+132>>2]=+g[z>>2];
c[f+(j*156|0)+152>>2]=j;c[f+(j*156|0)+148>>2]=q;A=f+(j*156|0)+80|0;c[A+0>>2]=0;c[A+4>>2]=0;c[A+8>>2]=0;c[A+12>>2]=0;c[A+16>>2]=0;c[A+20>>2]=0;c[A+24>>2]=0;c[A+28>>2]=0;A=c[l>>2]|0;c[A+(j*88|0)+32>>2]=c[u>>2];c[A+(j*88|0)+36>>2]=c[v>>2];g[A+(j*88|0)+40>>2]=+g[w>>2];g[A+(j*88|0)+44>>2]=+g[x>>2];x=t+44|0;t=c[x+4>>2]|0;w=A+(j*88|0)+48|0;c[w>>2]=c[x>>2];c[w+4>>2]=t;t=p+44|0;p=c[t+4>>2]|0;w=A+(j*88|0)+56|0;c[w>>2]=c[t>>2];c[w+4>>2]=p;g[A+(j*88|0)+64>>2]=+g[y>>2];g[A+(j*88|0)+68>>2]=+g[z>>2];z=o+104|0;y=
c[z+4>>2]|0;p=A+(j*88|0)+16|0;c[p>>2]=c[z>>2];c[p+4>>2]=y;y=o+112|0;p=c[y+4>>2]|0;z=A+(j*88|0)+24|0;c[z>>2]=c[y>>2];c[z+4>>2]=p;c[A+(j*88|0)+84>>2]=q;g[A+(j*88|0)+76>>2]=r;g[A+(j*88|0)+80>>2]=s;c[A+(j*88|0)+72>>2]=c[o+120>>2];if((q|0)>0){p=0;do{z=o+(p*20|0)+64|0;if((a[m>>0]|0)==0){g[f+(j*156|0)+(p*36|0)+16>>2]=0;g[f+(j*156|0)+(p*36|0)+20>>2]=0}else{g[f+(j*156|0)+(p*36|0)+16>>2]=+g[n>>2]*+g[o+(p*20|0)+72>>2];g[f+(j*156|0)+(p*36|0)+20>>2]=+g[n>>2]*+g[o+(p*20|0)+76>>2]}y=f+(j*156|0)+(p*36|0)|0;g[f+(j*
156|0)+(p*36|0)+24>>2]=0;g[f+(j*156|0)+(p*36|0)+28>>2]=0;g[f+(j*156|0)+(p*36|0)+32>>2]=0;w=A+(j*88|0)+(p<<3)|0;c[y+0>>2]=0;c[y+4>>2]=0;c[y+8>>2]=0;c[y+12>>2]=0;y=z;z=c[y+4>>2]|0;t=w;c[t>>2]=c[y>>2];c[t+4>>2]=z;p=p+1|0}while((p|0)!=(q|0))}q=j+1|0;if((q|0)>=(c[k>>2]|0))break;b=c[d>>2]|0;f=c[h>>2]|0;j=q}i=e;return}function Li(a){a=a|0;var b=0,d=0;b=i;d=a+36|0;_m(c[d>>2]|0,c[a+44>>2]|0);_m(c[d>>2]|0,c[a+40>>2]|0);i=b;return}function Mi(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,
r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0;b=i;i=i+64|0;d=b+48|0;e=b+32|0;f=b;h=a+52|0;if((c[h>>2]|0)<=0){i=b;return}j=a+44|0;k=a+40|0;l=a+48|0;m=a+28|0;n=a+32|0;a=d+8|0;o=d+12|0;p=e+8|0;q=e+12|0;r=0;do{s=c[j>>2]|0;t=c[k>>2]|0;u=+g[t+(r*88|0)+76>>2];v=+g[t+(r*88|0)+80>>2];w=(c[(c[l>>2]|0)+(c[s+(r*156|0)+152>>2]<<2)>>2]|0)+64|0;x=c[s+(r*156|0)+112>>2]|0;y=c[s+(r*156|0)+116>>2]|
0;z=+g[s+(r*156|0)+120>>2];A=+g[s+(r*156|0)+124>>2];B=+g[s+(r*156|0)+128>>2];C=+g[s+(r*156|0)+132>>2];D=t+(r*88|0)+48|0;E=+g[D>>2];F=+g[D+4>>2];D=t+(r*88|0)+56|0;G=+g[D>>2];H=+g[D+4>>2];D=c[m>>2]|0;t=D+(x*12|0)|0;I=+g[t>>2];J=+g[t+4>>2];K=+g[D+(x*12|0)+8>>2];t=c[n>>2]|0;L=t+(x*12|0)|0;M=+g[L>>2];N=+g[L+4>>2];O=+g[t+(x*12|0)+8>>2];x=D+(y*12|0)|0;P=+g[x>>2];Q=+g[x+4>>2];R=+g[D+(y*12|0)+8>>2];D=t+(y*12|0)|0;U=+g[D>>2];V=+g[D+4>>2];W=+g[t+(y*12|0)+8>>2];X=+T(+K);g[a>>2]=X;Y=+S(+K);g[o>>2]=Y;K=+T(+R);
g[p>>2]=K;Z=+S(+R);g[q>>2]=Z;R=+(I-(E*Y-F*X));_=+(J-(F*Y+E*X));y=d;g[y>>2]=R;g[y+4>>2]=_;_=+(P-(G*Z-H*K));R=+(Q-(H*Z+G*K));y=e;g[y>>2]=_;g[y+4>>2]=R;jf(f,w,d,u,e,v);w=s+(r*156|0)+72|0;y=f;t=c[y+4>>2]|0;D=w;c[D>>2]=c[y>>2];c[D+4>>2]=t;t=s+(r*156|0)+148|0;D=c[t>>2]|0;do if((D|0)>0){y=s+(r*156|0)+76|0;v=z+A;x=s+(r*156|0)+140|0;L=0;do{$=f+(L<<3)+8|0;u=+g[$>>2]-I;aa=f+(L<<3)+12|0;R=+u;_=+(+g[aa>>2]-J);ba=s+(r*156|0)+(L*36|0)|0;g[ba>>2]=R;g[ba+4>>2]=_;_=+g[$>>2]-P;R=+_;K=+(+g[aa>>2]-Q);aa=s+(r*156|0)+(L*
36|0)+8|0;g[aa>>2]=R;g[aa+4>>2]=K;K=+g[y>>2];R=+g[s+(r*156|0)+(L*36|0)+4>>2];G=+g[w>>2];Z=u*K-R*G;H=+g[s+(r*156|0)+(L*36|0)+12>>2];X=K*_-G*H;G=v+Z*B*Z+X*C*X;if(G>0)ca=1/G;else ca=0;g[s+(r*156|0)+(L*36|0)+24>>2]=ca;G=+g[y>>2];X=-+g[w>>2];Z=u*X-G*R;K=_*X-G*H;G=v+Z*B*Z+K*C*K;if(G>0)da=1/G;else da=0;g[s+(r*156|0)+(L*36|0)+28>>2]=da;aa=s+(r*156|0)+(L*36|0)+32|0;g[aa>>2]=0;G=+g[w>>2]*(U-W*H-M+O*R)+ +g[y>>2]*(V+W*_-N-O*u);if(G<-1)g[aa>>2]=-(G*+g[x>>2]);L=L+1|0}while((L|0)!=(D|0));if((c[t>>2]|0)==2){v=+g[s+
(r*156|0)+76>>2];G=+g[w>>2];u=+g[s+(r*156|0)>>2]*v-+g[s+(r*156|0)+4>>2]*G;_=v*+g[s+(r*156|0)+8>>2]-G*+g[s+(r*156|0)+12>>2];R=v*+g[s+(r*156|0)+36>>2]-G*+g[s+(r*156|0)+40>>2];H=v*+g[s+(r*156|0)+44>>2]-G*+g[s+(r*156|0)+48>>2];G=z+A;v=B*u;K=C*_;Z=G+u*v+_*K;_=G+R*B*R+H*C*H;u=G+v*R+K*H;H=Z*_-u*u;if(!(Z*Z<H*1E3)){c[t>>2]=1;break}g[s+(r*156|0)+96>>2]=Z;g[s+(r*156|0)+100>>2]=u;g[s+(r*156|0)+104>>2]=u;g[s+(r*156|0)+108>>2]=_;if(H!=0)ea=1/H;else ea=H;H=-(ea*u);g[s+(r*156|0)+80>>2]=_*ea;g[s+(r*156|0)+84>>2]=
H;g[s+(r*156|0)+88>>2]=H;g[s+(r*156|0)+92>>2]=Z*ea}}while(0);r=r+1|0}while((r|0)<(c[h>>2]|0));i=b;return}function Ni(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0;b=i;d=a+52|0;if((c[d>>2]|0)<=0){i=b;return}e=a+44|0;f=a+32|0;a=c[f>>2]|0;h=0;do{j=c[e>>2]|0;k=c[j+(h*156|0)+112>>2]|0;l=c[j+(h*156|0)+116>>2]|0;m=+g[j+(h*156|0)+120>>2];n=+g[j+(h*156|0)+128>>2];o=+g[j+(h*
156|0)+124>>2];p=+g[j+(h*156|0)+132>>2];q=c[j+(h*156|0)+148>>2]|0;r=a+(k*12|0)|0;s=r;t=+g[s>>2];u=+g[s+4>>2];v=+g[a+(k*12|0)+8>>2];s=a+(l*12|0)|0;w=+g[s>>2];x=+g[s+4>>2];y=+g[a+(l*12|0)+8>>2];s=j+(h*156|0)+72|0;z=+g[s>>2];A=+g[s+4>>2];if((q|0)>0){B=t;C=u;D=w;E=x;s=0;F=v;G=y;while(1){H=+g[j+(h*156|0)+(s*36|0)+16>>2];I=+g[j+(h*156|0)+(s*36|0)+20>>2];J=z*H+A*I;K=A*H-z*I;I=F-n*(+g[j+(h*156|0)+(s*36|0)>>2]*K-+g[j+(h*156|0)+(s*36|0)+4>>2]*J);H=B-m*J;L=C-m*K;M=G+p*(K*+g[j+(h*156|0)+(s*36|0)+8>>2]-J*+g[j+
(h*156|0)+(s*36|0)+12>>2]);N=D+o*J;J=E+o*K;s=s+1|0;if((s|0)==(q|0)){O=L;P=J;Q=N;R=H;S=I;T=M;break}else{B=H;C=L;D=N;E=J;F=I;G=M}}}else{O=u;P=x;Q=w;R=t;S=v;T=y}G=+R;F=+O;q=r;g[q>>2]=G;g[q+4>>2]=F;q=c[f>>2]|0;g[q+(k*12|0)+8>>2]=S;F=+Q;G=+P;s=q+(l*12|0)|0;g[s>>2]=F;g[s+4>>2]=G;a=c[f>>2]|0;g[a+(l*12|0)+8>>2]=T;h=h+1|0}while((h|0)<(c[d>>2]|0));i=b;return}function Oi(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=
0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0;b=i;d=a+52|0;if((c[d>>2]|0)<=0){i=b;return}e=a+44|0;f=a+32|0;a=c[f>>2]|0;h=0;do{j=c[e>>2]|0;k=j+(h*156|0)|0;l=c[j+(h*156|0)+112>>2]|0;m=c[j+(h*156|0)+116>>2]|0;n=+g[j+(h*156|0)+120>>2];o=+g[j+(h*156|0)+128>>2];p=+g[j+(h*156|0)+124>>2];q=+g[j+(h*156|0)+132>>2];r=j+(h*156|0)+148|0;s=c[r>>2]|0;t=a+(l*12|0)|0;u=t;v=+g[u>>2];w=+g[u+4>>2];x=
+g[a+(l*12|0)+8>>2];u=a+(m*12|0)|0;y=+g[u>>2];z=+g[u+4>>2];A=+g[a+(m*12|0)+8>>2];u=j+(h*156|0)+72|0;B=+g[u>>2];C=+g[u+4>>2];D=-B;E=+g[j+(h*156|0)+136>>2];if((s|0)>0){u=j+(h*156|0)+144|0;F=y;G=z;H=v;I=w;J=0;K=x;L=A;do{M=+g[j+(h*156|0)+(J*36|0)+12>>2];N=+g[j+(h*156|0)+(J*36|0)+8>>2];O=+g[j+(h*156|0)+(J*36|0)+4>>2];P=+g[j+(h*156|0)+(J*36|0)>>2];Q=E*+g[j+(h*156|0)+(J*36|0)+16>>2];R=j+(h*156|0)+(J*36|0)+20|0;S=+g[R>>2];T=S-+g[j+(h*156|0)+(J*36|0)+28>>2]*(C*(F-L*M-H+K*O)+(G+L*N-I-K*P)*D-+g[u>>2]);U=-Q;
V=T<Q?T:Q;Q=V<U?U:V;V=Q-S;g[R>>2]=Q;Q=C*V;S=V*D;H=H-n*Q;I=I-n*S;K=K-o*(P*S-O*Q);F=F+p*Q;G=G+p*S;L=L+q*(N*S-M*Q);J=J+1|0}while((J|0)!=(s|0));if((c[r>>2]|0)==1){D=+g[j+(h*156|0)+12>>2];E=+g[j+(h*156|0)+8>>2];Q=+g[j+(h*156|0)+4>>2];M=+g[k>>2];s=j+(h*156|0)+16|0;S=+g[s>>2];N=S-+g[j+(h*156|0)+24>>2]*(B*(F-L*D-H+K*Q)+C*(G+L*E-I-K*M)-+g[j+(h*156|0)+32>>2]);O=N>0?N:0;N=O-S;g[s>>2]=O;O=B*N;S=C*N;W=H-n*O;X=I-n*S;Y=F+p*O;Z=G+p*S;_=K-o*(M*S-Q*O);$=L+q*(E*S-D*O)}else{aa=I;ba=H;ca=G;da=F;ea=K;fa=L;ga=8}}else{aa=
w;ba=v;ca=z;da=y;ea=x;fa=A;ga=8}do if((ga|0)==8){ga=0;s=j+(h*156|0)+16|0;O=+g[s>>2];J=j+(h*156|0)+52|0;D=+g[J>>2];S=+g[j+(h*156|0)+12>>2];E=+g[j+(h*156|0)+8>>2];Q=+g[j+(h*156|0)+4>>2];M=+g[k>>2];N=+g[j+(h*156|0)+48>>2];P=+g[j+(h*156|0)+44>>2];V=+g[j+(h*156|0)+40>>2];U=+g[j+(h*156|0)+36>>2];T=+g[j+(h*156|0)+104>>2];ha=+g[j+(h*156|0)+100>>2];ia=B*(da-fa*S-ba+ea*Q)+C*(ca+fa*E-aa-ea*M)-+g[j+(h*156|0)+32>>2]-(O*+g[j+(h*156|0)+96>>2]+D*T);ja=B*(da-fa*N-ba+ea*V)+C*(ca+fa*P-aa-ea*U)-+g[j+(h*156|0)+68>>2]-
(O*ha+D*+g[j+(h*156|0)+108>>2]);ka=+g[j+(h*156|0)+80>>2]*ia+ +g[j+(h*156|0)+88>>2]*ja;la=ia*+g[j+(h*156|0)+84>>2]+ja*+g[j+(h*156|0)+92>>2];ma=-ka;na=-la;if(!(!(ka<=-0)|!(la<=-0))){la=ma-O;ka=na-D;oa=B*la;pa=C*la;la=B*ka;qa=C*ka;ka=oa+la;ra=pa+qa;g[s>>2]=ma;g[J>>2]=na;W=ba-n*ka;X=aa-n*ra;Y=da+p*ka;Z=ca+p*ra;_=ea-o*(M*pa-Q*oa+(U*qa-V*la));$=fa+q*(E*pa-S*oa+(P*qa-N*la));break}la=ia*+g[j+(h*156|0)+24>>2];qa=-la;if(la<=-0?ja+ha*qa>=0:0){ha=qa-O;la=0-D;oa=B*ha;pa=C*ha;ha=B*la;ra=C*la;la=ha+oa;ka=ra+pa;
g[s>>2]=qa;g[J>>2]=0;W=ba-n*la;X=aa-n*ka;Y=da+p*la;Z=ca+p*ka;_=ea-o*(pa*M-oa*Q+(ra*U-ha*V));$=fa+q*(pa*E-oa*S+(ra*P-ha*N));break}ha=ja*+g[j+(h*156|0)+60>>2];ra=-ha;if(ha<=-0?ia+T*ra>=0:0){T=0-O;ha=ra-D;oa=B*T;pa=C*T;T=B*ha;ka=C*ha;ha=oa+T;la=pa+ka;g[s>>2]=0;g[J>>2]=ra;W=ba-n*ha;X=aa-n*la;Y=da+p*ha;Z=ca+p*la;_=ea-o*(pa*M-oa*Q+(ka*U-T*V));$=fa+q*(pa*E-oa*S+(ka*P-T*N));break}if(!(ia>=0)|!(ja>=0)){W=ba;X=aa;Y=da;Z=ca;_=ea;$=fa}else{ja=0-O;O=0-D;D=B*ja;ia=C*ja;ja=B*O;T=C*O;O=D+ja;ka=ia+T;g[s>>2]=0;g[J>>
2]=0;W=ba-n*O;X=aa-n*ka;Y=da+p*O;Z=ca+p*ka;_=ea-o*(ia*M-D*Q+(T*U-ja*V));$=fa+q*(ia*E-D*S+(T*P-ja*N))}}while(0);q=+W;o=+X;j=t;g[j>>2]=q;g[j+4>>2]=o;j=c[f>>2]|0;g[j+(l*12|0)+8>>2]=_;o=+Y;q=+Z;k=j+(m*12|0)|0;g[k>>2]=o;g[k+4>>2]=q;a=c[f>>2]|0;g[a+(m*12|0)+8>>2]=$;h=h+1|0}while((h|0)<(c[d>>2]|0));i=b;return}function Pi(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0,k=0;b=i;d=c[a+52>>2]|0;if((d|0)<=0){i=b;return}e=c[a+44>>2]|0;f=c[a+48>>2]|0;a=0;do{h=c[f+(c[e+(a*156|0)+152>>2]<<2)>>2]|0;j=c[e+(a*156|0)+148>>2]|0;
if((j|0)>0){k=0;do{g[h+(k*20|0)+72>>2]=+g[e+(a*156|0)+(k*36|0)+16>>2];g[h+(k*20|0)+76>>2]=+g[e+(a*156|0)+(k*36|0)+20>>2];k=k+1|0}while((k|0)<(j|0))}a=a+1|0}while((a|0)<(d|0));i=b;return}function Qi(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0;b=i;i=i+64|0;d=b+40|
0;e=b+24|0;f=b;h=a+52|0;if((c[h>>2]|0)<=0){j=0;k=j>=-.014999999664723873;i=b;return k|0}l=a+40|0;m=a+28|0;a=d+8|0;n=d+12|0;o=e+8|0;p=e+12|0;q=f+8|0;r=f+16|0;s=c[m>>2]|0;t=0;u=0;while(1){v=c[l>>2]|0;w=v+(t*88|0)|0;x=c[v+(t*88|0)+32>>2]|0;y=c[v+(t*88|0)+36>>2]|0;z=v+(t*88|0)+48|0;A=+g[z>>2];B=+g[z+4>>2];C=+g[v+(t*88|0)+40>>2];D=+g[v+(t*88|0)+64>>2];z=v+(t*88|0)+56|0;E=+g[z>>2];F=+g[z+4>>2];G=+g[v+(t*88|0)+44>>2];H=+g[v+(t*88|0)+68>>2];z=c[v+(t*88|0)+84>>2]|0;v=s+(x*12|0)|0;I=+g[v>>2];J=+g[v+4>>2];K=
+g[s+(x*12|0)+8>>2];v=s+(y*12|0)|0;L=+g[v>>2];M=+g[v+4>>2];N=+g[s+(y*12|0)+8>>2];if((z|0)>0){O=C+G;P=I;Q=J;R=L;U=M;V=K;W=N;v=0;X=u;do{Y=+T(+V);g[a>>2]=Y;Z=+S(+V);g[n>>2]=Z;_=+T(+W);g[o>>2]=_;$=+S(+W);g[p>>2]=$;aa=+(P-(A*Z-B*Y));ba=+(Q-(B*Z+A*Y));ca=d;g[ca>>2]=aa;g[ca+4>>2]=ba;ba=+(R-(E*$-F*_));aa=+(U-(F*$+E*_));ca=e;g[ca>>2]=ba;g[ca+4>>2]=aa;Ri(f,w,d,e,v);ca=f;aa=+g[ca>>2];ba=+g[ca+4>>2];ca=q;_=+g[ca>>2];$=+g[ca+4>>2];Y=+g[r>>2];Z=_-P;da=$-Q;ea=_-R;_=$-U;X=X<Y?X:Y;$=(Y+.004999999888241291)*.20000000298023224;
Y=$<0?$:0;$=ba*Z-aa*da;fa=ba*ea-aa*_;ga=fa*H*fa+(O+$*D*$);if(ga>0)ha=-(Y<-.20000000298023224?-.20000000298023224:Y)/ga;else ha=0;ga=aa*ha;aa=ba*ha;P=P-C*ga;Q=Q-C*aa;V=V-D*(Z*aa-da*ga);R=R+G*ga;U=U+G*aa;W=W+H*(ea*aa-_*ga);v=v+1|0}while((v|0)!=(z|0));ia=Q;ja=P;ka=U;la=R;ma=c[m>>2]|0;na=V;oa=W;pa=X}else{ia=J;ja=I;ka=M;la=L;ma=s;na=K;oa=N;pa=u}H=+ja;G=+ia;z=ma+(x*12|0)|0;g[z>>2]=H;g[z+4>>2]=G;z=c[m>>2]|0;g[z+(x*12|0)+8>>2]=na;G=+la;H=+ka;v=z+(y*12|0)|0;g[v>>2]=G;g[v+4>>2]=H;s=c[m>>2]|0;g[s+(y*12|0)+8>>
2]=oa;t=t+1|0;if((t|0)>=(c[h>>2]|0)){j=pa;break}else u=pa}k=j>=-.014999999664723873;i=b;return k|0}function Ri(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;h=i;j=c[b+72>>2]|0;if((j|0)==2){k=e+12|0;l=+g[k>>2];m=+g[b+16>>2];n=e+8|0;o=+g[n>>2];p=+g[b+20>>2];q=l*m-o*p;r=m*o+l*p;p=+q;l=+r;s=a;g[s>>2]=p;g[s+4>>2]=l;l=+g[k>>2];p=+g[b+24>>2];o=+g[n>>2];m=+g[b+28>>2];t=+g[d+12>>2];u=+g[b+(f<<3)>>2];v=+g[d+8>>2];w=+g[b+(f<<3)+4>>2];
x=+g[d>>2]+(t*u-v*w);y=u*v+t*w+ +g[d+4>>2];g[a+16>>2]=q*(x-(+g[e>>2]+(l*p-o*m)))+(y-(p*o+l*m+ +g[e+4>>2]))*r-+g[b+76>>2]-+g[b+80>>2];m=+x;x=+y;n=a+8|0;g[n>>2]=m;g[n+4>>2]=x;x=+-q;q=+-r;n=a;g[n>>2]=x;g[n+4>>2]=q;i=h;return}else if((j|0)==1){n=d+12|0;q=+g[n>>2];x=+g[b+16>>2];k=d+8|0;r=+g[k>>2];m=+g[b+20>>2];y=q*x-r*m;l=x*r+q*m;m=+y;q=+l;s=a;g[s>>2]=m;g[s+4>>2]=q;q=+g[n>>2];m=+g[b+24>>2];r=+g[k>>2];x=+g[b+28>>2];o=+g[e+12>>2];p=+g[b+(f<<3)>>2];w=+g[e+8>>2];t=+g[b+(f<<3)+4>>2];v=+g[e>>2]+(o*p-w*t);u=
p*w+o*t+ +g[e+4>>2];g[a+16>>2]=y*(v-(+g[d>>2]+(q*m-r*x)))+(u-(m*r+q*x+ +g[d+4>>2]))*l-+g[b+76>>2]-+g[b+80>>2];l=+v;v=+u;f=a+8|0;g[f>>2]=l;g[f+4>>2]=v;i=h;return}else if((j|0)==0){v=+g[d+12>>2];l=+g[b+24>>2];u=+g[d+8>>2];x=+g[b+28>>2];q=+g[d>>2]+(v*l-u*x);r=l*u+v*x+ +g[d+4>>2];x=+g[e+12>>2];v=+g[b>>2];u=+g[e+8>>2];l=+g[b+4>>2];m=+g[e>>2]+(x*v-u*l);y=v*u+x*l+ +g[e+4>>2];l=m-q;x=y-r;u=+l;v=+x;e=a;g[e>>2]=u;g[e+4>>2]=v;v=+Q(+(l*l+x*x));if(v<1.1920928955078125E-7){z=l;A=x}else{u=1/v;v=l*u;g[a>>2]=v;t=
x*u;g[a+4>>2]=t;z=v;A=t}t=+((q+m)*.5);m=+((r+y)*.5);e=a+8|0;g[e>>2]=t;g[e+4>>2]=m;g[a+16>>2]=l*z+x*A-+g[b+76>>2]-+g[b+80>>2];i=h;return}else{g[a+16>>2]=0;b=8784;e=c[b+4>>2]|0;d=a;c[d>>2]=c[b>>2];c[d+4>>2]=e;e=8784;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;i=h;return}}function Si(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,
aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0;e=i;i=i+64|0;f=e+40|0;h=e+24|0;j=e;k=a+52|0;if((c[k>>2]|0)<=0){l=0;m=l>=-.007499999832361937;i=e;return m|0}n=a+40|0;o=a+28|0;a=f+8|0;p=f+12|0;q=h+8|0;r=h+12|0;s=j+8|0;t=j+16|0;u=0;v=0;while(1){w=c[n>>2]|0;x=w+(u*88|0)|0;y=c[w+(u*88|0)+32>>2]|0;z=c[w+(u*88|0)+36>>2]|0;A=w+(u*88|0)+48|0;B=+g[A>>2];C=+g[A+4>>2];A=w+(u*88|0)+56|0;D=+g[A>>2];E=+g[A+4>>2];A=c[w+(u*88|0)+84>>2]|0;if((y|0)==(b|0)|(y|0)==(d|0)){F=+g[w+
(u*88|0)+64>>2];G=+g[w+(u*88|0)+40>>2]}else{F=0;G=0}if((z|0)==(b|0)|(z|0)==(d|0)){H=+g[w+(u*88|0)+68>>2];I=+g[w+(u*88|0)+44>>2]}else{H=0;I=0}w=c[o>>2]|0;J=w+(y*12|0)|0;K=+g[J>>2];L=+g[J+4>>2];M=+g[w+(y*12|0)+8>>2];J=w+(z*12|0)|0;N=+g[J>>2];O=+g[J+4>>2];P=+g[w+(z*12|0)+8>>2];if((A|0)>0){Q=G+I;R=N;U=O;V=K;W=L;X=M;Y=P;J=0;Z=v;do{_=+T(+X);g[a>>2]=_;$=+S(+X);g[p>>2]=$;aa=+T(+Y);g[q>>2]=aa;ba=+S(+Y);g[r>>2]=ba;ca=+(V-(B*$-C*_));da=+(W-(C*$+B*_));ea=f;g[ea>>2]=ca;g[ea+4>>2]=da;da=+(R-(D*ba-E*aa));ca=+(U-
(E*ba+D*aa));ea=h;g[ea>>2]=da;g[ea+4>>2]=ca;Ri(j,x,f,h,J);ea=j;ca=+g[ea>>2];da=+g[ea+4>>2];ea=s;aa=+g[ea>>2];ba=+g[ea+4>>2];_=+g[t>>2];$=aa-V;fa=ba-W;ga=aa-R;aa=ba-U;Z=Z<_?Z:_;ba=(_+.004999999888241291)*.75;_=ba<0?ba:0;ba=da*$-ca*fa;ha=da*ga-ca*aa;ia=ha*H*ha+(Q+ba*F*ba);if(ia>0)ja=-(_<-.20000000298023224?-.20000000298023224:_)/ia;else ja=0;ia=ca*ja;ca=da*ja;V=V-G*ia;W=W-G*ca;X=X-F*($*ca-fa*ia);R=R+I*ia;U=U+I*ca;Y=Y+H*(ga*ca-aa*ia);J=J+1|0}while((J|0)!=(A|0));ka=W;la=V;ma=U;na=R;oa=c[o>>2]|0;pa=X;
qa=Y;ra=Z}else{ka=L;la=K;ma=O;na=N;oa=w;pa=M;qa=P;ra=v}Q=+la;D=+ka;A=oa+(y*12|0)|0;g[A>>2]=Q;g[A+4>>2]=D;A=c[o>>2]|0;g[A+(y*12|0)+8>>2]=pa;D=+na;Q=+ma;J=A+(z*12|0)|0;g[J>>2]=D;g[J+4>>2]=Q;g[(c[o>>2]|0)+(z*12|0)+8>>2]=qa;u=u+1|0;if((u|0)>=(c[k>>2]|0)){l=ra;break}else v=ra}m=l>=-.007499999832361937;i=e;return m|0}function Ti(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0;e=i;b=Em(f,148)|0;if((b|0)==0){g=0;i=e;return g|0}wi(b,a,0,d,0);c[b>>2]=6528;g=b;i=e;return g|0}function Ui(a,b){a=a|0;b=b|0;var d=
0;d=i;eb[c[(c[a>>2]|0)+4>>2]&127](a);Fm(b,a,148);i=d;return}function Vi(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;cf(b,c[(c[a+48>>2]|0)+12>>2]|0,d,c[(c[a+52>>2]|0)+12>>2]|0,e);i=f;return}function Wi(a){a=a|0;return}function Xi(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Yi(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0;g=i;h=Em(f,148)|0;if((h|0)==0){j=0;i=g;return j|0}wi(h,a,b,d,e);c[h>>2]=6600;j=h;i=g;return j|0}function Zi(a,b){a=a|0;b=b|0;var d=0;d=i;eb[c[(c[a>>2]|0)+4>>2]&127](a);
Fm(b,a,148);i=d;return}function _i(a,d,e,f){a=a|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0;h=i;i=i+48|0;j=h;k=c[(c[a+48>>2]|0)+12>>2]|0;c[j>>2]=488;c[j+4>>2]=1;g[j+8>>2]=.009999999776482582;l=j+28|0;c[l+0>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;b[l+16>>1]=0;Ge(k,j,c[a+56>>2]|0);cf(d,j,e,c[(c[a+52>>2]|0)+12>>2]|0,f);i=h;return}function $i(a){a=a|0;return}function aj(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function bj(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0;e=i;b=Em(f,148)|0;if((b|0)==0){g=0;
i=e;return g|0}wi(b,a,0,d,0);c[b>>2]=6672;g=b;i=e;return g|0}function cj(a,b){a=a|0;b=b|0;var d=0;d=i;eb[c[(c[a>>2]|0)+4>>2]&127](a);Fm(b,a,148);i=d;return}function dj(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;ff(b,c[(c[a+48>>2]|0)+12>>2]|0,d,c[(c[a+52>>2]|0)+12>>2]|0,e);i=f;return}function ej(a){a=a|0;return}function fj(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function gj(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0;e=i;b=Em(f,148)|0;if((b|0)==0){g=0;i=e;return g|0}wi(b,a,0,d,0);c[b>>2]=6744;
g=b;i=e;return g|0}function hj(a,b){a=a|0;b=b|0;var d=0;d=i;eb[c[(c[a>>2]|0)+4>>2]&127](a);Fm(b,a,148);i=d;return}function ij(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;gf(b,c[(c[a+48>>2]|0)+12>>2]|0,d,c[(c[a+52>>2]|0)+12>>2]|0,e);i=f;return}function jj(a){a=a|0;return}function kj(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function lj(a){a=a|0;var d=0;d=i;b[a+32>>1]=1;b[a+34>>1]=-1;b[a+36>>1]=0;c[a+40>>2]=0;c[a+24>>2]=0;c[a+28>>2]=0;c[a+0>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;c[a+12>>2]=0;i=d;return}function mj(d,
e,f,h){d=d|0;e=e|0;f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0;j=i;c[d+40>>2]=c[h+4>>2];g[d+16>>2]=+g[h+8>>2];g[d+20>>2]=+g[h+12>>2];c[d+8>>2]=f;c[d+4>>2]=0;f=d+32|0;k=h+22|0;b[f+0>>1]=b[k+0>>1]|0;b[f+2>>1]=b[k+2>>1]|0;b[f+4>>1]=b[k+4>>1]|0;a[d+38>>0]=a[h+20>>0]|0;k=c[h>>2]|0;f=nb[c[(c[k>>2]|0)+8>>2]&31](k,e)|0;c[d+12>>2]=f;k=bb[c[(c[f>>2]|0)+12>>2]&7](f)|0;f=Em(e,k*28|0)|0;e=d+24|0;c[e>>2]=f;if((k|0)>0){l=f;m=0}else{n=d+28|0;c[n>>2]=0;o=h+16|0;p=+g[o>>2];g[d>>2]=p;i=j;return}do{c[l+(m*28|0)+16>>
2]=0;l=c[e>>2]|0;c[l+(m*28|0)+24>>2]=-1;m=m+1|0}while((m|0)!=(k|0));n=d+28|0;c[n>>2]=0;o=h+16|0;p=+g[o>>2];g[d>>2]=p;i=j;return}function nj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;e=a+12|0;f=c[e>>2]|0;g=bb[c[(c[f>>2]|0)+12>>2]&7](f)|0;f=a+24|0;Fm(b,c[f>>2]|0,g*28|0);c[f>>2]=0;f=c[e>>2]|0;g=c[f+4>>2]|0;if((g|0)==1){eb[c[c[f>>2]>>2]&127](f);Fm(b,f,48);c[e>>2]=0;i=d;return}else if((g|0)==3){eb[c[c[f>>2]>>2]&127](f);Fm(b,f,40);c[e>>2]=0;i=d;return}else if((g|0)==0){eb[c[c[f>>2]>>2]&127](f);Fm(b,f,20);
c[e>>2]=0;i=d;return}else if((g|0)==2){eb[c[c[f>>2]>>2]&127](f);Fm(b,f,152);c[e>>2]=0;i=d;return}else{c[e>>2]=0;i=d;return}}function oj(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;e=i;f=a+12|0;g=c[f>>2]|0;h=bb[c[(c[g>>2]|0)+12>>2]&7](g)|0;g=a+28|0;c[g>>2]=h;if((h|0)<=0){i=e;return}h=a+24|0;j=0;do{k=c[h>>2]|0;l=k+(j*28|0)|0;m=c[f>>2]|0;pb[c[(c[m>>2]|0)+28>>2]&31](m,l,d,j);c[k+(j*28|0)+24>>2]=Oe(b,l,l)|0;c[k+(j*28|0)+16>>2]=a;c[k+(j*28|0)+20>>2]=j;j=j+1|0}while((j|0)<(c[g>>2]|0));i=
e;return}function pj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;e=a+28|0;if((c[e>>2]|0)<=0){c[e>>2]=0;i=d;return}f=a+24|0;a=0;do{g=(c[f>>2]|0)+(a*28|0)+24|0;Pe(b,c[g>>2]|0);c[g>>2]=-1;a=a+1|0}while((a|0)<(c[e>>2]|0));c[e>>2]=0;i=d;return}function qj(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0;f=i;i=i+48|0;h=f+24|0;j=f+8|0;k=f;l=a+28|0;if((c[l>>2]|0)<=0){i=f;return}m=a+24|0;n=a+12|0;a=h+4|0;o=j+4|0;p=h+8|0;q=j+8|
0;r=h+12|0;s=j+12|0;t=e+4|0;u=d+4|0;v=k+4|0;w=0;do{x=c[m>>2]|0;y=c[n>>2]|0;z=x+(w*28|0)+20|0;pb[c[(c[y>>2]|0)+28>>2]&31](y,h,d,c[z>>2]|0);y=c[n>>2]|0;pb[c[(c[y>>2]|0)+28>>2]&31](y,j,e,c[z>>2]|0);z=x+(w*28|0)|0;A=+g[h>>2];B=+g[j>>2];C=+g[a>>2];D=+g[o>>2];E=+(A<B?A:B);B=+(C<D?C:D);y=z;g[y>>2]=E;g[y+4>>2]=B;B=+g[p>>2];E=+g[q>>2];D=+g[r>>2];C=+g[s>>2];A=+(B>E?B:E);E=+(D>C?D:C);y=x+(w*28|0)+8|0;g[y>>2]=A;g[y+4>>2]=E;E=+g[t>>2]-+g[u>>2];g[k>>2]=+g[e>>2]-+g[d>>2];g[v>>2]=E;Qe(b,c[x+(w*28|0)+24>>2]|0,z,k);
w=w+1|0}while((w|0)<(c[l>>2]|0));i=f;return}function rj(b,d){b=b|0;d=d|0;var e=0,f=0,h=0;e=i;Cm(b);Wm(b+76|0);Sj(b+102880|0);c[b+102992>>2]=0;c[b+102996>>2]=0;f=b+102960|0;h=b+103004|0;c[f+0>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;c[f+16>>2]=0;a[h>>0]=1;a[b+103005>>0]=1;a[b+103006>>0]=0;a[b+103007>>0]=1;a[b+102988>>0]=1;h=d;d=c[h+4>>2]|0;f=b+102980|0;c[f>>2]=c[h>>2];c[f+4>>2]=d;c[b+102876>>2]=4;g[b+103E3>>2]=0;c[b+102956>>2]=b;c[b+103040>>2]=8792;c[b+103044>>2]=c[2206];d=b+103008|0;c[d+0>>2]=0;
c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;c[d+16>>2]=0;c[d+20>>2]=0;c[d+24>>2]=0;c[d+28>>2]=0;i=e;return}function qb(a){a=a|0;var b=0;b=i;i=i+a|0;i=i+7&-8;return b|0}function rb(){return i|0}function sb(a){a=a|0;i=a}function tb(a,b){a=a|0;b=b|0;if((p|0)==0){p=a;q=b}}function ub(b){b=b|0;a[k>>0]=a[b>>0];a[k+1>>0]=a[b+1>>0];a[k+2>>0]=a[b+2>>0];a[k+3>>0]=a[b+3>>0]}function vb(b){b=b|0;a[k>>0]=a[b>>0];a[k+1>>0]=a[b+1>>0];a[k+2>>0]=a[b+2>>0];a[k+3>>0]=a[b+3>>0];a[k+4>>0]=a[b+4>>0];a[k+5>>0]=a[b+5>>0];a[k+6>>
0]=a[b+6>>0];a[k+7>>0]=a[b+7>>0]}function wb(a){a=a|0;E=a}function xb(){return E|0}function yb(a){a=a|0;return+ +(c[a+60>>2]|0)}function zb(d,e,f,j,k,l,m,n,o,p,q){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=p|0;q=+q;var r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;r=i;i=i+1104|0;s=r;t=r+1072|0;u=r+1032|0;v=r+8|0;h[s>>3]=l;c[t>>2]=0;g[t+16>>2]=e;g[t+8>>2]=f;a[t+20>>0]=j!=0&1;g[t+12>>2]=k;c[t+4>>2]=s;b[t+22>>1]=~~m;b[t+26>>1]=~~n;b[t+24>>1]=~~o;c[u>>2]=760;c[u+4>>2]=3;g[u+8>>2]=.009999999776482582;c[u+12>>
2]=0;c[u+16>>2]=0;a[u+36>>0]=0;a[u+37>>0]=0;s=~~(q*.5);if(q>0){w=0;x=0}else{De(u,v,s);c[t>>2]=u;y=Mj(d,t)|0;Ce(u);i=r;return y|0}while(1){o=+ +g[p+(w<<2)>>2];n=+ +g[p+((w|1)<<2)>>2];z=v+(x<<3)|0;g[z>>2]=o;g[z+4>>2]=n;w=w+2|0;if(!(+(w|0)<q))break;else x=x+1|0}De(u,v,s);c[t>>2]=u;y=Mj(d,t)|0;Ce(u);i=r;return y|0}function Ab(a){a=a|0;Ha(a|0)|0;xa()}function Bb(d,e,f,j,k,l,m,n,o,p,q,r){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;var s=0,t=0,u=0,v=0;s=i;i=i+64|0;t=s;u=s+28|0;v=s+8|0;h[t>>
3]=l;g[u+16>>2]=e;g[u+8>>2]=f;a[u+20>>0]=j!=0&1;g[u+12>>2]=k;c[u+4>>2]=t;b[u+22>>1]=~~m;b[u+26>>1]=~~n;b[u+24>>1]=~~o;c[v>>2]=680;t=v+4|0;c[t+0>>2]=0;c[t+4>>2]=0;c[t+8>>2]=0;g[v+12>>2]=p;g[v+16>>2]=q;g[v+8>>2]=r;c[u>>2]=v;v=Mj(d,u)|0;i=s;return v|0}function Cb(a){a=a|0;return}function Db(b,d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B){b=b|0;d=+d;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;w=+w;x=+x;y=+y;z=+z;A=+A;B=+B;var C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=
0,O=0,P=0,Q=0;C=i;i=i+112|0;D=C;E=C+28|0;F=C+8|0;h[D>>3]=y;G=E+8|0;H=E+20|0;I=E+4|0;J=E+16|0;K=E+28|0;L=E+32|0;M=E+33|0;N=E+34|0;O=E+35|0;P=E+36|0;Q=E+40|0;c[Q+0>>2]=0;c[Q+4>>2]=0;c[Q+8>>2]=0;c[Q+12>>2]=0;c[Q+16>>2]=0;c[Q+20>>2]=0;c[Q+24>>2]=0;g[J>>2]=d;g[K>>2]=e;a[L>>0]=~~f;a[M>>0]=~~j;a[N>>0]=~~k;a[O>>0]=~~l;c[E>>2]=~~m>>>0;c[E+72>>2]=0;c[I>>2]=~~o>>>0;g[E+64>>2]=p;p=+q;q=+r;I=H;g[I>>2]=p;g[I+4>>2]=q;q=+s;s=+t;I=G;g[I>>2]=q;g[I+4>>2]=s;c[E+60>>2]=0;c[E+56>>2]=~~v;c[E+48>>2]=0;c[E+44>>2]=0;g[P>>
2]=w;g[E+52>>2]=x;c[E+68>>2]=D;c[F>>2]=680;c[F+4>>2]=0;x=+z;z=+A;D=F+12|0;g[D>>2]=x;g[D+4>>2]=z;g[F+8>>2]=B;c[Q>>2]=F;F=Fk(b,E)|0;i=C;return F|0}function Eb(a,b,d,e,f,h,j,k){a=a|0;b=+b;d=+d;e=+e;f=+f;h=+h;j=+j;k=+k;var l=0,m=0,n=0,o=0;l=i;i=i+48|0;m=l+16|0;n=l;c[m>>2]=680;o=m+4|0;c[o+0>>2]=0;c[o+4>>2]=0;c[o+8>>2]=0;g[m+12>>2]=b;g[m+16>>2]=d;g[m+8>>2]=e;g[n>>2]=f;g[n+4>>2]=h;g[n+8>>2]=j;g[n+12>>2]=k;k=+(Ck(a,m,n,0)|0);i=l;return+k}function Fb(d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y){d=d|0;e=+e;f=+f;
j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;w=+w;x=+x;y=+y;var z=0,A=0,B=0,C=0;z=i;i=i+96|0;A=z;B=z+56|0;C=z+8|0;h[A>>3]=l;g[B+16>>2]=e;g[B+8>>2]=f;a[B+20>>0]=j!=0&1;g[B+12>>2]=k;c[B+4>>2]=A;b[B+22>>1]=~~m;b[B+26>>1]=~~n;b[B+24>>1]=~~o;c[C>>2]=488;c[C+4>>2]=1;g[C+8>>2]=.009999999776482582;A=C+28|0;c[A+0>>2]=0;c[A+4>>2]=0;c[A+8>>2]=0;c[A+12>>2]=0;b[A+16>>1]=0;o=+r;r=+s;A=C+28|0;g[A>>2]=o;g[A+4>>2]=r;r=+t;t=+u;A=C+12|0;g[A>>2]=r;g[A+4>>2]=t;t=+v;v=+w;A=C+20|0;g[A>>2]=t;g[A+4>>2]=
v;v=+x;x=+y;A=C+36|0;g[A>>2]=v;g[A+4>>2]=x;a[C+44>>0]=p!=0&1;a[C+45>>0]=q!=0&1;c[B>>2]=C;C=Mj(d,B)|0;i=z;return C|0}function Gb(a){a=a|0;return}function Hb(d,e,f,j,k,l,m,n,o,p,q,r,s,t,u){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;var v=0,w=0,x=0,y=0,z=0;v=i;i=i+224|0;w=v;x=v+184|0;y=v+160|0;z=v+8|0;h[w>>3]=l;g[x+16>>2]=e;g[x+8>>2]=f;a[x+20>>0]=j!=0&1;g[x+12>>2]=k;c[x+4>>2]=w;b[x+22>>1]=~~m;b[x+26>>1]=~~n;b[x+24>>1]=~~o;g[y>>2]=p;g[y+4>>2]=q;g[y+8>>2]=r;g[y+12>>2]=
s;g[y+16>>2]=t;g[y+20>>2]=u;c[z>>2]=592;c[z+4>>2]=2;g[z+8>>2]=.009999999776482582;c[z+148>>2]=0;g[z+12>>2]=0;g[z+16>>2]=0;oe(z,y,3);c[x>>2]=z;z=Mj(d,x)|0;i=v;return z|0}function Ib(a){a=a|0;return}function Jb(d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;w=+w;var x=0,y=0,z=0,A=0,B=0;x=i;i=i+224|0;y=x;z=x+192|0;A=x+160|0;B=x+8|0;h[y>>3]=l;g[z+16>>2]=e;g[z+8>>2]=f;a[z+20>>0]=j!=0&1;g[z+12>>2]=k;c[z+4>>2]=y;b[z+22>>1]=~~m;b[z+26>>
1]=~~n;b[z+24>>1]=~~o;g[A>>2]=p;g[A+4>>2]=q;g[A+8>>2]=r;g[A+12>>2]=s;g[A+16>>2]=t;g[A+20>>2]=u;g[A+24>>2]=v;g[A+28>>2]=w;c[B>>2]=592;c[B+4>>2]=2;g[B+8>>2]=.009999999776482582;c[B+148>>2]=0;g[B+12>>2]=0;g[B+16>>2]=0;oe(B,A,4);c[z>>2]=B;B=Mj(d,z)|0;i=x;return B|0}function Kb(d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;w=+w;x=+x;y=+y;var z=0,A=0,B=0,C=0,D=0;z=i;i=i+240|0;A=z;B=z+200|0;C=z+160|0;D=z+8|0;h[A>>3]=l;g[B+16>>2]=e;
g[B+8>>2]=f;a[B+20>>0]=j!=0&1;g[B+12>>2]=k;c[B+4>>2]=A;b[B+22>>1]=~~m;b[B+26>>1]=~~n;b[B+24>>1]=~~o;g[C>>2]=p;g[C+4>>2]=q;g[C+8>>2]=r;g[C+12>>2]=s;g[C+16>>2]=t;g[C+20>>2]=u;g[C+24>>2]=v;g[C+28>>2]=w;g[C+32>>2]=x;g[C+36>>2]=y;c[D>>2]=592;c[D+4>>2]=2;g[D+8>>2]=.009999999776482582;c[D+148>>2]=0;g[D+12>>2]=0;g[D+16>>2]=0;oe(D,C,5);c[B>>2]=D;D=Mj(d,B)|0;i=z;return D|0}function Lb(d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;
w=+w;x=+x;y=+y;z=+z;A=+A;var B=0,C=0,D=0,E=0,F=0;B=i;i=i+240|0;C=B;D=B+208|0;E=B+160|0;F=B+8|0;h[C>>3]=l;g[D+16>>2]=e;g[D+8>>2]=f;a[D+20>>0]=j!=0&1;g[D+12>>2]=k;c[D+4>>2]=C;b[D+22>>1]=~~m;b[D+26>>1]=~~n;b[D+24>>1]=~~o;g[E>>2]=p;g[E+4>>2]=q;g[E+8>>2]=r;g[E+12>>2]=s;g[E+16>>2]=t;g[E+20>>2]=u;g[E+24>>2]=v;g[E+28>>2]=w;g[E+32>>2]=x;g[E+36>>2]=y;g[E+40>>2]=z;g[E+44>>2]=A;c[F>>2]=592;c[F+4>>2]=2;g[F+8>>2]=.009999999776482582;c[F+148>>2]=0;g[F+12>>2]=0;g[F+16>>2]=0;oe(F,E,6);c[D>>2]=F;F=Mj(d,D)|0;i=B;return F|
0}function Mb(d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;w=+w;x=+x;y=+y;z=+z;A=+A;B=+B;C=+C;var D=0,E=0,F=0,G=0,H=0;D=i;i=i+256|0;E=D;F=D+216|0;G=D+160|0;H=D+8|0;h[E>>3]=l;g[F+16>>2]=e;g[F+8>>2]=f;a[F+20>>0]=j!=0&1;g[F+12>>2]=k;c[F+4>>2]=E;b[F+22>>1]=~~m;b[F+26>>1]=~~n;b[F+24>>1]=~~o;g[G>>2]=p;g[G+4>>2]=q;g[G+8>>2]=r;g[G+12>>2]=s;g[G+16>>2]=t;g[G+20>>2]=u;g[G+24>>2]=v;g[G+28>>2]=w;g[G+32>>2]=x;g[G+36>>2]=y;g[G+40>>
2]=z;g[G+44>>2]=A;g[G+48>>2]=B;g[G+52>>2]=C;c[H>>2]=592;c[H+4>>2]=2;g[H+8>>2]=.009999999776482582;c[H+148>>2]=0;g[H+12>>2]=0;g[H+16>>2]=0;oe(H,G,7);c[F>>2]=H;H=Mj(d,F)|0;i=D;return H|0}function Nb(d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;w=+w;x=+x;y=+y;z=+z;A=+A;B=+B;C=+C;D=+D;E=+E;var F=0,G=0,H=0,I=0,J=0;F=i;i=i+256|0;G=F;H=F+224|0;I=F+160|0;J=F+8|0;h[G>>3]=l;g[H+16>>2]=e;g[H+8>>2]=f;a[H+20>>0]=j!=0&1;g[H+
12>>2]=k;c[H+4>>2]=G;b[H+22>>1]=~~m;b[H+26>>1]=~~n;b[H+24>>1]=~~o;g[I>>2]=p;g[I+4>>2]=q;g[I+8>>2]=r;g[I+12>>2]=s;g[I+16>>2]=t;g[I+20>>2]=u;g[I+24>>2]=v;g[I+28>>2]=w;g[I+32>>2]=x;g[I+36>>2]=y;g[I+40>>2]=z;g[I+44>>2]=A;g[I+48>>2]=B;g[I+52>>2]=C;g[I+56>>2]=D;g[I+60>>2]=E;c[J>>2]=592;c[J+4>>2]=2;g[J+8>>2]=.009999999776482582;c[J+148>>2]=0;g[J+12>>2]=0;g[J+16>>2]=0;oe(J,I,8);c[H>>2]=J;J=Mj(d,H)|0;i=F;return J|0}function Ob(b,d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G){b=b|0;d=+d;e=+e;f=+f;j=
+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;w=+w;x=+x;y=+y;z=+z;A=+A;B=+B;C=+C;D=+D;E=+E;F=+F;G=+G;var H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0;H=i;i=i+272|0;I=H;J=H+192|0;K=H+160|0;L=H+8|0;h[I>>3]=y;M=J+8|0;N=J+20|0;O=J+4|0;P=J+16|0;Q=J+28|0;R=J+32|0;S=J+33|0;T=J+34|0;U=J+35|0;V=J+36|0;W=J+40|0;c[W+0>>2]=0;c[W+4>>2]=0;c[W+8>>2]=0;c[W+12>>2]=0;c[W+16>>2]=0;c[W+20>>2]=0;c[W+24>>2]=0;g[P>>2]=d;g[Q>>2]=e;a[R>>0]=~~f;a[S>>0]=~~j;a[T>>0]=~~k;a[U>>0]=~~l;c[J>>2]=
~~m>>>0;c[J+72>>2]=0;c[O>>2]=~~o>>>0;g[J+64>>2]=p;p=+q;q=+r;O=N;g[O>>2]=p;g[O+4>>2]=q;q=+s;s=+t;O=M;g[O>>2]=q;g[O+4>>2]=s;c[J+60>>2]=0;c[J+56>>2]=~~v;c[J+48>>2]=0;c[J+44>>2]=0;g[V>>2]=w;g[J+52>>2]=x;c[J+68>>2]=I;g[K>>2]=z;g[K+4>>2]=A;g[K+8>>2]=B;g[K+12>>2]=C;g[K+16>>2]=D;g[K+20>>2]=E;g[K+24>>2]=F;g[K+28>>2]=G;c[L>>2]=592;c[L+4>>2]=2;g[L+8>>2]=.009999999776482582;c[L+148>>2]=0;g[L+12>>2]=0;g[L+16>>2]=0;oe(L,K,4);c[W>>2]=L;L=Fk(b,J)|0;i=H;return L|0}function Pb(a,b,d,e,f,h,j,k,l,m,n,o,p){a=a|0;b=+b;
d=+d;e=+e;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;var q=0,r=0,s=0,t=0;q=i;i=i+208|0;r=q+168|0;s=q+16|0;t=q;g[r>>2]=b;g[r+4>>2]=d;g[r+8>>2]=e;g[r+12>>2]=f;g[r+16>>2]=h;g[r+20>>2]=j;g[r+24>>2]=k;g[r+28>>2]=l;c[s>>2]=592;c[s+4>>2]=2;g[s+8>>2]=.009999999776482582;c[s+148>>2]=0;g[s+12>>2]=0;g[s+16>>2]=0;oe(s,r,4);g[t>>2]=m;g[t+4>>2]=n;g[t+8>>2]=o;g[t+12>>2]=p;p=+(Ck(a,s,t,0)|0);i=q;return+p}function Qb(a,d,e){a=a|0;d=+d;e=+e;var f=0,h=0,j=0,k=0,l=0,m=0,n=0;f=i;h=d;if((c[a>>2]|0)!=2){i=f;return}j=
a+4|0;k=b[j>>1]|0;if((e!=0?(k&2)==0:0)?(l=k&65535,(l&2|0)==0):0){m=(l|2)&65535;b[j>>1]=m;g[a+160>>2]=0;n=m}else n=k;if((n&2)==0){i=f;return}n=a+88|0;g[n>>2]=+g[n>>2]+h*+g[a+144>>2];i=f;return}function Rb(a,d,e,f,h,j){a=a|0;d=+d;e=+e;f=+f;h=+h;j=+j;var k=0,l=0,m=0,n=0,o=0,p=0,q=0;k=i;l=d;d=e;e=f;f=h;if((c[a>>2]|0)!=2){i=k;return}m=a+4|0;n=b[m>>1]|0;if((j!=0?(n&2)==0:0)?(o=n&65535,(o&2|0)==0):0){p=(o|2)&65535;b[m>>1]=p;g[a+160>>2]=0;q=p}else q=n;if((q&2)==0){i=k;return}q=a+92|0;g[q>>2]=l+ +g[q>>2];
q=a+96|0;g[q>>2]=d+ +g[q>>2];q=a+100|0;g[q>>2]=+g[q>>2]+(d*(e-+g[a+60>>2])-l*(f-+g[a+64>>2]));i=k;return}function Sb(a,d,e,f){a=a|0;d=+d;e=+e;f=+f;var h=0,j=0,k=0,l=0,m=0,n=0,o=0;h=i;j=d;d=e;if((c[a>>2]|0)!=2){i=h;return}k=a+4|0;l=b[k>>1]|0;if((f!=0?(l&2)==0:0)?(m=l&65535,(m&2|0)==0):0){n=(m|2)&65535;b[k>>1]=n;g[a+160>>2]=0;o=n}else o=l;if((o&2)==0){i=h;return}o=a+92|0;g[o>>2]=j+ +g[o>>2];o=a+96|0;g[o>>2]=d+ +g[o>>2];i=h;return}function Tb(a,d,e){a=a|0;d=+d;e=+e;var f=0,h=0,j=0,k=0,l=0,m=0,n=0;f=
i;h=d;if((c[a>>2]|0)!=2){i=f;return}j=a+4|0;k=b[j>>1]|0;if((e!=0?(k&2)==0:0)?(l=k&65535,(l&2|0)==0):0){m=(l|2)&65535;b[j>>1]=m;g[a+160>>2]=0;n=m}else n=k;if((n&2)==0){i=f;return}n=a+100|0;g[n>>2]=h+ +g[n>>2];i=f;return}function Ub(a,b){a=a|0;b=b|0;var c=0;c=i;Nj(a,b);i=c;return}function Vb(a){a=a|0;return+ +g[a+72>>2]}function Wb(a){a=a|0;return+ +g[a+88>>2]}function Xb(a){a=a|0;var b=0,c=0;b=+g[a+44>>2];c=+g[a+48>>2];return+(+g[a+140>>2]+ +g[a+132>>2]*(b*b+c*c))}function Yb(a,b){a=a|0;b=b|0;var c=
0;c=+g[a+84>>2];g[b>>2]=+g[a+80>>2];g[b+4>>2]=c;return}function Zb(a,b,c,d){a=a|0;b=+b;c=+c;d=d|0;var e=0,f=0;e=b-+g[a+12>>2];b=c-+g[a+16>>2];c=+g[a+24>>2];f=+g[a+20>>2];g[d>>2]=e*c+b*f;g[d+4>>2]=c*b-e*f;return}function _b(a,b,c,d){a=a|0;b=+b;c=+c;d=d|0;var e=0,f=0;e=b-+g[a+12>>2];b=c-+g[a+16>>2];c=+g[a+24>>2];f=+g[a+20>>2];g[d>>2]=e*c+b*f;g[d+4>>2]=c*b-e*f;return}function $b(a){a=a|0;return+ +g[a+132>>2]}function ac(a,b){a=a|0;b=b|0;var c=0;c=+g[a+16>>2];g[b>>2]=+g[a+12>>2];g[b+4>>2]=c;return}function bc(a,
b){a=a|0;b=b|0;g[b>>2]=+g[a+12>>2];g[b+4>>2]=+g[a+16>>2];g[b+8>>2]=+g[a+20>>2];g[b+12>>2]=+g[a+24>>2];return}function cc(a){a=a|0;return+ +((c[a>>2]|0)>>>0)}function dc(a,b){a=a|0;b=b|0;var c=0;c=+g[a+64>>2];g[b>>2]=+g[a+60>>2];g[b+4>>2]=c;return}function ec(a,b,c,d){a=a|0;b=+b;c=+c;d=d|0;var e=0,f=0,h=0;e=b;b=c;c=+g[a+24>>2];f=+g[a+20>>2];h=b*c+e*f+ +g[a+16>>2];g[d>>2]=+g[a+12>>2]+(e*c-b*f);g[d+4>>2]=h;return}function fc(a,b,c,d){a=a|0;b=+b;c=+c;d=d|0;var e=0,f=0,h=0;e=b;b=c;c=+g[a+24>>2];f=+g[a+
20>>2];h=b*c+e*f+ +g[a+16>>2];g[d>>2]=+g[a+12>>2]+(e*c-b*f);g[d+4>>2]=h;return}function gc(a,d){a=a|0;d=+d;var f=0,h=0,j=0,k=0;f=i;h=a+4|0;j=e[h>>1]|0;if(!(d!=0)){b[h>>1]=j&65533;g[a+160>>2]=0;k=a+80|0;c[k+0>>2]=0;c[k+4>>2]=0;c[k+8>>2]=0;c[k+12>>2]=0;c[k+16>>2]=0;c[k+20>>2]=0;i=f;return}if((j&2|0)!=0){i=f;return}b[h>>1]=j|2;g[a+160>>2]=0;i=f;return}function hc(a,d){a=a|0;d=+d;var f=0,h=0,j=0,k=0;f=i;h=d;if((c[a>>2]|0)==0){i=f;return}if(h*h>0?(j=a+4|0,k=e[j>>1]|0,(k&2|0)==0):0){b[j>>1]=k|2;g[a+160>>
2]=0}g[a+88>>2]=h;i=f;return}function ic(a,d,f){a=a|0;d=+d;f=+f;var h=0,j=0,k=0,l=0;h=i;j=d;d=f;if((c[a>>2]|0)==0){i=h;return}if(j*j+d*d>0?(k=a+4|0,l=e[k>>1]|0,(l&2|0)==0):0){b[k>>1]=l|2;g[a+160>>2]=0}f=+j;j=+d;l=a+80|0;g[l>>2]=f;g[l+4>>2]=j;i=h;return}function jc(a,b,c,d,e){a=a|0;b=+b;c=+c;d=+d;e=+e;var f=0,h=0;f=i;i=i+16|0;h=f;g[h>>2]=b;g[h+4>>2]=c;g[h+8>>2]=d;g[h+12>>2]=e;Oj(a,h);i=f;return}function kc(a,b,c,d){a=a|0;b=+b;c=+c;d=+d;var e=0,f=0;e=i;i=i+16|0;f=e;g[f>>2]=b;g[f+4>>2]=c;Qj(a,f,d);i=
e;return}function lc(a,b){a=a|0;b=+b;var c=0;c=i;Jj(a,~~b>>>0);i=c;return}function mc(a,b,d){a=a|0;b=+b;d=+d;var e=0,f=0,h=0;e=i;i=i+16|0;f=e;g[f>>2]=b;g[f+4>>2]=d;h=c[a+12>>2]|0;d=+((hb[c[(c[h>>2]|0)+16>>2]&15](h,(c[a+8>>2]|0)+12|0,f)|0)&1);i=e;return+d}function nc(a){a=a|0;return}function oc(a){a=a|0;return}function pc(a){a=a|0;return}function qc(a,b){a=+a;b=+b;var c=0,d=0,e=0;c=i;i=i+16|0;d=c;e=qn(103048)|0;g[d>>2]=a;g[d+4>>2]=b;rj(e,d);i=c;return e|0}function rc(b,d,e,f,h,j,k,l,m,n,o,p,q,r,s,
t,u){b=b|0;d=+d;e=+e;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=u|0;var v=0,w=0,x=0,y=0,z=0;v=i;i=i+64|0;w=v;x=w+44|0;y=w+4|0;z=w+36|0;c[y+0>>2]=0;c[y+4>>2]=0;c[y+8>>2]=0;c[y+12>>2]=0;c[y+16>>2]=0;c[y+20>>2]=0;a[w+40>>0]=d!=0&1;a[z>>0]=e!=0&1;g[w+12>>2]=f;g[w+24>>2]=h;g[w+32>>2]=j;a[w+37>>0]=k!=0&1;a[w+39>>0]=l!=0&1;a[w+38>>0]=m!=0&1;g[w+48>>2]=n;g[w+28>>2]=o;g[w+16>>2]=p;g[w+20>>2]=q;g[y>>2]=r;g[w+8>>2]=s;c[w>>2]=~~t>>>0;c[x>>2]=u;u=vj(b,w)|0;i=v;return u|0}function sc(b,
d,e,f,h,j,k,l,m,n,o,p,q,r,s,t,u,v){b=b|0;d=+d;e=+e;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;var w=0,x=0,y=0;w=i;i=i+96|0;x=w;a[x>>0]=0;g[x+4>>2]=1;g[x+8>>2]=1;c[x+16>>2]=0;g[x+72>>2]=d;g[x+24>>2]=e;a[x+76>>0]=f!=0&1;g[x+56>>2]=h;g[x+28>>2]=j;g[x+80>>2]=k;g[x+52>>2]=l;g[x+20>>2]=m;g[x+12>>2]=n;g[x+48>>2]=o;g[x+32>>2]=p;c[x+68>>2]=~~q;g[x+64>>2]=r;g[x+60>>2]=s;g[x+44>>2]=t;g[x+40>>2]=u;g[x+36>>2]=v;y=zj(b,x)|0;i=w;return y|0}function tc(a){a=a|0;var b=0;b=i;if((a|0)!=
0){sj(a);sn(a)}i=b;return}function uc(a,b){a=a|0;b=b|0;var c=0;c=i;wj(a,b);i=c;return}function vc(a,b){a=a|0;b=b|0;var c=0;c=i;xj(a,b);i=c;return}function wc(a,b){a=a|0;b=b|0;var c=0;c=i;tj(a,b);i=c;return}function xc(a,b,c,d,e){a=a|0;b=+b;c=+c;d=+d;e=+e;var f=0,h=0,j=0,k=0;f=i;i=i+16|0;h=f;j=+b;b=+c;k=h;g[k>>2]=j;g[k+4>>2]=b;b=+d;d=+e;k=h+8|0;g[k>>2]=b;g[k+4>>2]=d;Dj(a,16,h);i=f;return}function yc(a,b,c,d,e){a=a|0;b=+b;c=+c;d=+d;e=+e;var f=0,h=0,j=0;f=i;i=i+16|0;h=f+8|0;j=f;g[h>>2]=b;g[h+4>>2]=c;
g[j>>2]=d;g[j+4>>2]=e;Ej(a,24,h,j);i=f;return}function zc(a){a=a|0;var b=0;b=i;uj(a,8);i=b;return}function Ac(a,b,c){a=a|0;b=+b;c=+c;var d=0,e=0,f=0;d=i;e=+b;b=+c;f=a+102980|0;g[f>>2]=e;g[f+4>>2]=b;i=d;return}function Bc(a,b,c,d){a=a|0;b=+b;c=+c;d=+d;var e=0;e=i;Cj(a,b,~~c,~~d,3);i=e;return}function Cc(a){a=a|0;return a+64|0}function Dc(a){a=a|0;var b=0,d=0,e=0;b=i;d=c[a+48>>2]|0;e=c[a+52>>2]|0;jf(32,a+64|0,(c[d+8>>2]|0)+12|0,+g[(c[d+12>>2]|0)+8>>2],(c[e+8>>2]|0)+12|0,+g[(c[e+12>>2]|0)+8>>2]);i=b;
return 32}function Ec(b,d,e,f,h,j,k,l,m,n,o){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;var p=0,q=0,r=0;p=i;i=i+48|0;q=p;c[q+0>>2]=0;c[q+4>>2]=0;c[q+8>>2]=0;c[q+12>>2]=0;c[q>>2]=3;r=q+20|0;c[r>>2]=0;c[r+4>>2]=0;c[q+8>>2]=d;c[q+12>>2]=e;a[q+16>>0]=f!=0&1;g[q+44>>2]=h;g[q+40>>2]=j;g[q+36>>2]=k;k=+l;l=+m;e=q+20|0;g[e>>2]=k;g[e+4>>2]=l;l=+n;n=+o;e=q+28|0;g[e>>2]=l;g[e+4>>2]=n;e=yj(b,q)|0;i=p;return e|0}function Fc(b,d,e,f,h,j,k,l,m,n){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;
var o=0,p=0,q=0,r=0,s=0,t=0;o=i;i=i+64|0;p=o+16|0;q=o+8|0;r=o;c[p+0>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;c[p+12>>2]=0;c[p>>2]=3;s=p+20|0;t=p+36|0;c[s+0>>2]=0;c[s+4>>2]=0;c[s+8>>2]=0;c[s+12>>2]=0;g[t>>2]=1;a[p+16>>0]=l!=0&1;g[p+44>>2]=m;g[p+40>>2]=n;g[q>>2]=f;g[q+4>>2]=h;g[r>>2]=j;g[r+4>>2]=k;Xf(p,d,e,q,r);r=yj(b,p)|0;i=o;return r|0}function Gc(b,d,e,f,h,j,k,l,m,n){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;var o=0,p=0,q=0;o=i;i=i+48|0;p=o;c[p+0>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;c[p+12>>2]=0;c[p>>2]=
9;q=p+20|0;c[q+0>>2]=0;c[q+4>>2]=0;c[q+8>>2]=0;c[q+12>>2]=0;c[q+16>>2]=0;c[p+8>>2]=d;c[p+12>>2]=e;a[p+16>>0]=f!=0&1;f=+h;h=+j;e=p+20|0;g[e>>2]=f;g[e+4>>2]=h;h=+k;k=+l;e=p+28|0;g[e>>2]=h;g[e+4>>2]=k;g[p+36>>2]=m;g[p+40>>2]=n;e=yj(b,p)|0;i=o;return e|0}function Hc(b,d,e,f,h,j,k,l){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;var m=0,n=0,o=0,p=0;m=i;i=i+64|0;n=m+8|0;o=m;c[n+0>>2]=0;c[n+4>>2]=0;c[n+8>>2]=0;c[n+12>>2]=0;c[n>>2]=9;p=n+20|0;c[p+0>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;c[p+12>>2]=0;c[p+16>>2]=0;a[n+
16>>0]=j!=0&1;g[n+36>>2]=k;g[n+40>>2]=l;g[o>>2]=f;g[o+4>>2]=h;hg(n,d,e,o);o=yj(b,n)|0;i=m;return o|0}function Ic(a){a=a|0;var b=0,c=0;b=i;c=+Ng(a);i=b;return+c}function Jc(b,d,e,f,h,j,k){b=b|0;d=d|0;e=e|0;f=+f;h=h|0;j=j|0;k=+k;var l=0,m=0;l=i;i=i+32|0;m=l;c[m+0>>2]=0;c[m+4>>2]=0;c[m+8>>2]=0;c[m+12>>2]=0;c[m>>2]=6;c[m+8>>2]=d;c[m+12>>2]=e;a[m+16>>0]=f!=0&1;c[m+20>>2]=h;c[m+24>>2]=j;g[m+28>>2]=k;j=yj(b,m)|0;i=l;return j|0}function Kc(a){a=a|0;return c[a+48>>2]|0}function Lc(a){a=a|0;return c[a+52>>
2]|0}function Mc(a,b){a=a|0;b=+b;var c=0;c=i;Sf(a,b);i=c;return}function Nc(a,b,c){a=a|0;b=+b;c=+c;var d=0,e=0;d=i;i=i+16|0;e=d;g[e>>2]=b;g[e+4>>2]=c;Rf(a,e);i=d;return}function Oc(b,d,e,f,h,j,k,l,m,n){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;var o=0,p=0;o=i;i=i+48|0;p=o;c[p+0>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;c[p+12>>2]=0;c[p>>2]=11;c[p+8>>2]=d;c[p+12>>2]=e;a[p+16>>0]=f!=0&1;g[p+28>>2]=h;g[p+40>>2]=j;j=+k;k=+l;e=p+20|0;g[e>>2]=j;g[e+4>>2]=k;g[p+32>>2]=m;g[p+36>>2]=n;e=yj(b,p)|0;i=o;return e|
0}function Pc(b,d,e,f,h,j,k){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;var l=0,m=0;l=i;i=i+48|0;m=l;c[m+0>>2]=0;c[m+4>>2]=0;c[m+8>>2]=0;c[m+12>>2]=0;c[m>>2]=11;g[m+20>>2]=0;g[m+24>>2]=0;g[m+28>>2]=0;a[m+16>>0]=f!=0&1;g[m+40>>2]=h;g[m+32>>2]=j;g[m+36>>2]=k;If(m,d,e);e=yj(b,m)|0;i=l;return e|0}function Qc(a,b,c){a=a|0;b=+b;c=+c;var d=0,e=0;d=i;i=i+16|0;e=d;g[e>>2]=b;g[e+4>>2]=c;wf(a,e);i=d;return}function Rc(b,d,e,f,h,j,k,l,m){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;var n=0,o=0;n=i;i=i+48|0;o=n;
c[o+0>>2]=0;c[o+4>>2]=0;c[o+8>>2]=0;c[o+12>>2]=0;c[o>>2]=5;c[o+8>>2]=d;c[o+12>>2]=e;a[o+16>>0]=f!=0&1;g[o+36>>2]=h;g[o+32>>2]=j;g[o+28>>2]=k;k=+l;l=+m;e=o+20|0;g[e>>2]=k;g[e+4>>2]=l;e=yj(b,o)|0;i=n;return e|0}function Sc(a,b){a=a|0;b=+b;var c=0;c=i;ah(a,b!=0);i=c;return}function Tc(a,b){a=a|0;b=+b;var c=0;c=i;ch(a,b!=0);i=c;return}function Uc(a){a=a|0;var b=0,c=0;b=i;c=+_g(a);i=b;return+c}function Vc(a){a=a|0;return+ +g[a+132>>2]}function Wc(a,b){a=a|0;b=+b;var c=0,d=0;c=i;d=+eh(a,b);i=c;return+d}
function Xc(a){a=a|0;var b=0,c=0;b=i;c=+(($g(a)|0)&1);i=b;return+c}function Yc(a){a=a|0;var b=0,c=0;b=i;c=+((bh(a)|0)&1);i=b;return+c}function Zc(a,b){a=a|0;b=+b;var c=0;c=i;dh(a,b);i=c;return}function _c(b,d,e,f,h,j,k,l,m,n,o,p,q,r,s,t,u){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;var v=0,w=0,x=0;v=i;i=i+80|0;w=v;c[w+0>>2]=0;c[w+4>>2]=0;c[w+8>>2]=0;c[w+12>>2]=0;c[w>>2]=2;x=w+20|0;c[x>>2]=0;c[x+4>>2]=0;c[w+8>>2]=d;c[w+12>>2]=e;a[w+16>>0]=f!=0&1;a[w+48>>
0]=h!=0&1;a[w+60>>0]=j!=0&1;j=+k;k=+l;e=w+20|0;g[e>>2]=j;g[e+4>>2]=k;k=+m;m=+n;e=w+28|0;g[e>>2]=k;g[e+4>>2]=m;m=+o;o=+p;e=w+36|0;g[e>>2]=m;g[e+4>>2]=o;g[w+52>>2]=q;g[w+64>>2]=r;g[w+68>>2]=s;g[w+44>>2]=t;g[w+56>>2]=u;e=yj(b,w)|0;i=v;return e|0}function $c(b,d,e,f,h,j,k,l,m,n,o,p,q,r){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;var s=0,t=0,u=0,v=0,w=0,x=0;s=i;i=i+96|0;t=s+16|0;u=s+8|0;v=s;c[t+0>>2]=0;c[t+4>>2]=0;c[t+8>>2]=0;c[t+12>>2]=0;c[t>>2]=2;w=t+20|0;x=t+36|0;c[w+0>>
2]=0;c[w+4>>2]=0;c[w+8>>2]=0;c[w+12>>2]=0;g[x>>2]=1;g[t+40>>2]=0;g[t+44>>2]=0;a[t+16>>0]=l!=0&1;a[t+48>>0]=m!=0&1;a[t+60>>0]=n!=0&1;g[t+52>>2]=o;g[t+64>>2]=p;g[t+68>>2]=q;g[t+56>>2]=r;g[u>>2]=f;g[u+4>>2]=h;g[v>>2]=j;g[v+4>>2]=k;Rg(t,d,e,u,v);v=yj(b,t)|0;i=s;return v|0}function ad(b,d,e,f,h,j,k,l,m,n,o,p,q,r,s){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;var t=0,u=0;t=i;i=i+64|0;u=t;c[u+0>>2]=0;c[u+4>>2]=0;c[u+8>>2]=0;c[u>>2]=4;c[u+8>>2]=d;c[u+12>>2]=e;a[u+16>>0]=
f!=0&1;f=+h;h=+j;e=u+20|0;g[e>>2]=f;g[e+4>>2]=h;h=+k;k=+l;e=u+28|0;g[e>>2]=h;g[e+4>>2]=k;g[u+52>>2]=m;g[u+56>>2]=n;n=+o;o=+p;e=u+36|0;g[e>>2]=n;g[e+4>>2]=o;o=+q;q=+r;e=u+44|0;g[e>>2]=o;g[e+4>>2]=q;g[u+60>>2]=s;e=yj(b,u)|0;i=t;return e|0}function bd(b,d,e,f,h,j,k,l,m,n,o,p,q){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;var r=0,s=0,t=0,u=0,v=0,w=0;r=i;i=i+96|0;s=r+32|0;t=r+24|0;u=r+16|0;v=r+8|0;w=r;c[s+0>>2]=0;c[s+4>>2]=0;c[s+8>>2]=0;c[s+12>>2]=0;c[s>>2]=4;g[s+20>>2]=-1;g[s+
24>>2]=1;g[s+28>>2]=1;g[s+32>>2]=1;g[s+36>>2]=-1;g[s+40>>2]=0;g[s+44>>2]=1;g[s+48>>2]=0;g[s+52>>2]=0;g[s+56>>2]=0;g[s+60>>2]=1;a[s+16>>0]=q!=0&1;g[t>>2]=l;g[t+4>>2]=m;g[u>>2]=n;g[u+4>>2]=o;g[v>>2]=f;g[v+4>>2]=h;g[w>>2]=j;g[w+4>>2]=k;ci(s,d,e,t,u,v,w,p);w=yj(b,s)|0;i=r;return w|0}function cd(a,b){a=a|0;b=+b;var c=0;c=i;Nh(a,b!=0);i=c;return}function dd(a,b){a=a|0;b=+b;var c=0;c=i;Kh(a,b!=0);i=c;return}function ed(a){a=a|0;var b=0,c=0;b=i;c=+Ih(a);i=b;return+c}function fd(a){a=a|0;var b=0,c=0;b=i;c=
+((Mh(a)|0)&1);i=b;return+c}function gd(a){a=a|0;var b=0,c=0;b=i;c=+((Jh(a)|0)&1);i=b;return+c}function hd(b,d,e,f,h,j,k,l,m,n,o,p,q,r,s){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;var t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;t=i;i=i+64|0;u=t;c[u+0>>2]=0;c[u+4>>2]=0;c[u+8>>2]=0;c[u+12>>2]=0;c[u>>2]=1;v=u+20|0;w=u+44|0;x=u+48|0;y=u+60|0;z=u+56|0;A=u+52|0;c[v+0>>2]=0;c[v+4>>2]=0;c[v+8>>2]=0;c[v+12>>2]=0;c[u+8>>2]=d;c[u+12>>2]=e;a[u+16>>0]=f!=0&1;a[u+40>>0]=h!=0&1;a[A>>0]=j!=
0&1;j=+l;l=+m;A=u+20|0;g[A>>2]=j;g[A+4>>2]=l;l=+n;n=+o;A=u+28|0;g[A>>2]=l;g[A+4>>2]=n;g[w>>2]=k;g[y>>2]=p;g[z>>2]=q;g[u+36>>2]=r;g[x>>2]=s;x=yj(b,u)|0;i=t;return x|0}function id(b,d,e,f,h,j,k,l,m,n,o,p){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;var q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;q=i;i=i+80|0;r=q+8|0;s=q;c[r+0>>2]=0;c[r+4>>2]=0;c[r+8>>2]=0;c[r+12>>2]=0;c[r>>2]=1;t=r+20|0;u=r+44|0;v=r+48|0;w=r+60|0;x=r+56|0;y=r+52|0;c[t+0>>2]=0;c[t+4>>2]=0;c[t+8>>2]=0;c[t+12>>2]=0;c[t+16>>
2]=0;a[r+16>>0]=j!=0&1;a[r+40>>0]=k!=0&1;a[y>>0]=l!=0&1;g[u>>2]=m;g[w>>2]=n;g[x>>2]=o;g[v>>2]=p;g[s>>2]=f;g[s+4>>2]=h;zh(r,d,e,s);s=yj(b,r)|0;i=q;return s|0}function jd(a,b){a=a|0;b=+b;var c=0;c=i;Lh(a,b);i=c;return}function kd(b,d,e,f,h,j,k,l,m){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;var n=0,o=0;n=i;i=i+48|0;o=n;c[o+0>>2]=0;c[o+4>>2]=0;c[o+8>>2]=0;c[o+12>>2]=0;c[o>>2]=10;c[o+8>>2]=d;c[o+12>>2]=e;a[o+16>>0]=f!=0&1;f=+h;h=+j;e=o+20|0;g[e>>2]=f;g[e+4>>2]=h;h=+k;k=+l;e=o+28|0;g[e>>2]=h;g[e+
4>>2]=k;g[o+36>>2]=m;e=yj(b,o)|0;i=n;return e|0}function ld(b,d,e,f,h,j,k,l,m,n,o){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;var p=0,q=0,r=0;p=i;i=i+48|0;q=p;c[q+0>>2]=0;c[q+4>>2]=0;c[q+8>>2]=0;c[q+12>>2]=0;c[q>>2]=8;r=q+20|0;c[r+0>>2]=0;c[r+4>>2]=0;c[r+8>>2]=0;c[r+12>>2]=0;c[q+8>>2]=d;c[q+12>>2]=e;a[q+16>>0]=f!=0&1;g[q+44>>2]=h;g[q+40>>2]=j;j=+k;k=+l;e=q+20|0;g[e>>2]=j;g[e+4>>2]=k;k=+m;m=+n;e=q+28|0;g[e>>2]=k;g[e+4>>2]=m;g[q+36>>2]=o;e=yj(b,q)|0;i=p;return e|0}function md(b,d,e,f,
h,j,k,l){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;var m=0,n=0,o=0,p=0;m=i;i=i+64|0;n=m+8|0;o=m;c[n+0>>2]=0;c[n+4>>2]=0;c[n+8>>2]=0;c[n+12>>2]=0;c[n>>2]=8;p=n+20|0;c[p+0>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;c[p+12>>2]=0;c[p+16>>2]=0;a[n+16>>0]=j!=0&1;g[n+44>>2]=k;g[n+40>>2]=l;g[o>>2]=f;g[o+4>>2]=h;tg(n,d,e,o);o=yj(b,n)|0;i=m;return o|0}function nd(a,b){a=a|0;b=+b;var c=0;c=i;_h(a,b);i=c;return}function od(a,b){a=a|0;b=+b;g[a+68>>2]=b;return}function pd(b,d,e,f,h,j,k,l,m,n,o,p,q,r,s){b=b|0;d=d|0;e=e|0;f=
+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;var t=0,u=0,v=0;t=i;i=i+64|0;u=t;c[u+0>>2]=0;c[u+4>>2]=0;c[u+8>>2]=0;c[u+12>>2]=0;c[u>>2]=7;v=u+20|0;c[v>>2]=0;c[v+4>>2]=0;c[u+8>>2]=d;c[u+12>>2]=e;a[u+16>>0]=f!=0&1;g[u+60>>2]=h;a[u+44>>0]=j!=0&1;g[u+56>>2]=k;k=+l;l=+m;e=u+20|0;g[e>>2]=k;g[e+4>>2]=l;l=+n;n=+o;e=u+28|0;g[e>>2]=l;g[e+4>>2]=n;n=+p;p=+q;e=u+36|0;g[e>>2]=n;g[e+4>>2]=p;g[u+48>>2]=r;g[u+52>>2]=s;e=yj(b,u)|0;i=t;return e|0}function qd(b,d,e,f,h,j,k,l,m,n,o,p,q){b=b|0;d=d|0;e=e|0;
f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;var r=0,s=0,t=0,u=0,v=0,w=0;r=i;i=i+80|0;s=r+16|0;t=r+8|0;u=r;c[s+0>>2]=0;c[s+4>>2]=0;c[s+8>>2]=0;c[s+12>>2]=0;c[s>>2]=7;v=s+20|0;w=s+36|0;c[v+0>>2]=0;c[v+4>>2]=0;c[v+8>>2]=0;c[v+12>>2]=0;g[w>>2]=1;g[s+40>>2]=0;a[s+16>>0]=l!=0&1;g[s+60>>2]=m;a[s+44>>0]=n!=0&1;g[s+56>>2]=o;g[s+48>>2]=p;g[s+52>>2]=q;g[t>>2]=f;g[t+4>>2]=h;g[u>>2]=j;g[u+4>>2]=k;Rh(s,d,e,t,u);u=yj(b,s)|0;i=r;return u|0}function rd(a,b,c){a=a|0;b=+b;c=+c;var d=0,e=0;d=i;i=i+16|0;e=d;g[e>>
2]=b;g[e+4>>2]=c;ok(a,e);i=d;return}function sd(a,b,c){a=a|0;b=+b;c=+c;var d=0,e=0;d=i;i=i+16|0;e=d;g[e>>2]=b;g[e+4>>2]=c;pk(a,e);i=d;return}function td(a,b){a=a|0;b=+b;var c=0;c=i;qk(a,b!=0);i=c;return}function ud(a){a=a|0;return+ +(c[a+4>>2]|0)}function vd(a){a=a|0;return+ +((c[a+8>>2]|0)-(c[a+4>>2]|0)|0)}function wd(b,d,e,f,j,k,l,m,n,o,p,q,r){b=b|0;d=+d;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;var s=0,t=0,u=0,v=0;s=i;i=i+64|0;t=s+8|0;u=s;v=s+16|0;h[t>>3]=l;h[u>>3]=p;a[v+20>>0]=~~d;
a[v+21>>0]=~~f;a[v+22>>0]=~~e;a[v+23>>0]=~~j;c[v>>2]=~~k>>>0;c[v+32>>2]=t;g[v+24>>2]=m;m=+n;n=+o;t=v+4|0;g[t>>2]=m;g[t+4>>2]=n;c[v+28>>2]=u;n=+q;q=+r;u=v+12|0;g[u>>2]=n;g[u+4>>2]=q;q=+(wk(b,v)|0);i=s;return+q}function xd(a){a=a|0;var b=0,c=0;b=i;c=uk(a)|0;i=b;return c|0}function yd(a){a=a|0;return+ +(c[a+44>>2]|0)}function zd(a){a=a|0;return c[a+96>>2]|0}function Ad(a){a=a|0;return c[a+104>>2]|0}function Bd(a,b){a=a|0;b=+b;g[a+340>>2]=b;return}function Cd(a,b){a=a|0;b=+b;var c=0;c=b;g[a+320>>2]=c;
g[a+28>>2]=1/c;return}function Dd(a,b){a=a|0;b=+b;var c=0;c=b*2;g[a+32>>2]=c;g[a+40>>2]=c*c;g[a+36>>2]=1/c;return}function Ed(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Fd(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=+e;var f=0;a=i;f=+La(b|0,+ +g[c>>2],+ +g[c+4>>2],+ +g[d>>2],+ +g[d+4>>2],+e);i=a;return+f}function Gd(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=+f;return 0}function Hd(a,b){a=a|0;b=b|0;return 1}function Id(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Jd(a,b){a=a|0;b=b|0;var c=0;a=i;
c=Xa(b|0)|0;i=a;return c|0}function Kd(a,b,c){a=a|0;b=b|0;c=c|0;return 0}function Ld(a,b){a=a|0;b=b|0;return 1}function Md(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Nd(a,b){a=a|0;b=b|0;a=i;Pa(b|0);i=a;return}function Od(a,b){a=a|0;b=b|0;a=i;Wa(b|0);i=a;return}function Pd(a,b,c){a=a|0;b=b|0;c=c|0;return}function Qd(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return}function Rd(a,b,c){a=a|0;b=b|0;c=c|0;return}function Sd(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return}function Td(a,b,c){a=a|0;b=b|0;c=c|0;a=i;ya(b|
0,c|0);i=a;return}function Ud(a,b,c){a=a|0;b=b|0;c=c|0;a=i;Ya(b|0,c|0);i=a;return}function Vd(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Wd(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Xd(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Yd(){c[2]=280;c[4]=176;c[6]=72;return}function Zd(d,e){d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=
0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0;f=i;i=i+320|0;h=f;j=f+284|0;k=f+248|0;l=f+236|0;m=f+144|0;n=f+120|0;o=f+16|0;p=f+12|0;q=f+8|0;Km(h);c[104]=(c[104]|0)+1;c[d>>2]=0;r=e+128|0;s=d+4|0;g[s>>2]=+g[r>>2];t=e+28|0;u=j+0|0;v=e+56|0;w=u+36|0;do{c[u>>2]=c[v>>2];u=u+4|0;v=v+4|0}while((u|0)<(w|0));u=k+0|0;v=e+92|0;w=u+36|0;do{c[u>>2]=c[v>>2];u=u+4|0;v=v+4|0}while((u|0)<(w|0));v=j+24|0;x=
+g[v>>2];y=+O(+(x/6.2831854820251465))*6.2831854820251465;z=x-y;g[v>>2]=z;u=j+28|0;x=+g[u>>2]-y;g[u>>2]=x;w=k+24|0;y=+g[w>>2];A=+O(+(y/6.2831854820251465))*6.2831854820251465;B=y-A;g[w>>2]=B;C=k+28|0;y=+g[C>>2]-A;g[C>>2]=y;A=+g[r>>2];D=+g[e+24>>2]+ +g[e+52>>2]+-.014999999664723873;E=D<.004999999888241291?.004999999888241291:D;b[l+4>>1]=0;c[m+0>>2]=c[e+0>>2];c[m+4>>2]=c[e+4>>2];c[m+8>>2]=c[e+8>>2];c[m+12>>2]=c[e+12>>2];c[m+16>>2]=c[e+16>>2];c[m+20>>2]=c[e+20>>2];c[m+24>>2]=c[e+24>>2];r=m+28|0;c[r+
0>>2]=c[t+0>>2];c[r+4>>2]=c[t+4>>2];c[r+8>>2]=c[t+8>>2];c[r+12>>2]=c[t+12>>2];c[r+16>>2]=c[t+16>>2];c[r+20>>2]=c[t+20>>2];c[r+24>>2]=c[t+24>>2];a[m+88>>0]=0;r=j+8|0;F=j+12|0;G=j+16|0;H=j+20|0;I=j+4|0;J=k+8|0;K=k+12|0;L=k+16|0;M=k+20|0;N=k+4|0;P=m+56|0;Q=m+64|0;R=m+68|0;U=m+72|0;V=m+80|0;W=m+84|0;X=n+16|0;D=E+.0012499999720603228;Y=E+-.0012499999720603228;Z=z;z=x;x=B;B=y;_=0;y=0;a:while(1){$=1-y;aa=$*Z+y*z;ba=+T(+aa);ca=+S(+aa);aa=+g[j>>2];da=+g[I>>2];ea=$*x+y*B;fa=+T(+ea);ga=+S(+ea);ea=+g[k>>2];ha=
+g[N>>2];ia=$*+g[J>>2]+y*+g[L>>2]-(ga*ea-fa*ha);ja=$*+g[K>>2]+y*+g[M>>2]-(fa*ea+ga*ha);ha=+($*+g[r>>2]+y*+g[G>>2]-(ca*aa-ba*da));ea=+($*+g[F>>2]+y*+g[H>>2]-(ba*aa+ca*da));ka=P;g[ka>>2]=ha;g[ka+4>>2]=ea;g[Q>>2]=ba;g[R>>2]=ca;ca=+ia;ia=+ja;ka=U;g[ka>>2]=ca;g[ka+4>>2]=ia;g[V>>2]=fa;g[W>>2]=ga;de(n,l,m);ga=+g[X>>2];if(ga<=0){la=3;break}if(ga<D){la=5;break}+_d(o,l,e,j,t,k,y);ka=0;ga=A;while(1){fa=+$d(o,p,q,ga);if(fa>D){la=8;break a}if(fa>Y){ma=ga;break}na=c[p>>2]|0;oa=c[q>>2]|0;ia=+ae(o,na,oa,y);if(ia<
Y){la=11;break a}if(!(ia<=D)){pa=y;qa=ga;ra=0;sa=ia;ta=fa}else{la=13;break a}while(1){if((ra&1|0)==0)ua=(pa+qa)*.5;else ua=pa+(E-sa)*(qa-pa)/(ta-sa);ra=ra+1|0;c[110]=(c[110]|0)+1;fa=+ae(o,na,oa,ua);ia=fa-E;if(ia>0)va=ia;else va=-ia;if(va<.0012499999720603228){wa=ua;break}xa=fa>E;if((ra|0)==50){wa=ga;break}else{pa=xa?ua:pa;qa=xa?qa:ua;sa=xa?fa:sa;ta=xa?ta:fa}}oa=c[112]|0;c[112]=(oa|0)>(ra|0)?oa:ra;ka=ka+1|0;if((ka|0)==8){ma=y;break}else ga=wa}ka=_+1|0;c[106]=(c[106]|0)+1;if((ka|0)==20){la=25;break}Z=
+g[v>>2];z=+g[u>>2];x=+g[w>>2];B=+g[C>>2];_=ka;y=ma}if((la|0)==3){c[d>>2]=2;g[s>>2]=0;ya=_;za=c[108]|0;Aa=(za|0)>(ya|0);Ba=Aa?za:ya;c[108]=Ba;Ca=+Mm(h);Da=+g[102];Ea=Da>Ca;Fa=Ea?Da:Ca;g[102]=Fa;Ga=+g[100];Ha=Ca+Ga;g[100]=Ha;i=f;return}else if((la|0)==5){c[d>>2]=3;g[s>>2]=y;ya=_;za=c[108]|0;Aa=(za|0)>(ya|0);Ba=Aa?za:ya;c[108]=Ba;Ca=+Mm(h);Da=+g[102];Ea=Da>Ca;Fa=Ea?Da:Ca;g[102]=Fa;Ga=+g[100];Ha=Ca+Ga;g[100]=Ha;i=f;return}else if((la|0)==8){c[d>>2]=4;g[s>>2]=A}else if((la|0)==11){c[d>>2]=1;g[s>>2]=y}else if((la|
0)==13){c[d>>2]=3;g[s>>2]=y}else if((la|0)==25){c[d>>2]=1;g[s>>2]=ma;ya=20;za=c[108]|0;Aa=(za|0)>(ya|0);Ba=Aa?za:ya;c[108]=Ba;Ca=+Mm(h);Da=+g[102];Ea=Da>Ca;Fa=Ea?Da:Ca;g[102]=Fa;Ga=+g[100];Ha=Ca+Ga;g[100]=Ha;i=f;return}c[106]=(c[106]|0)+1;ya=_+1|0;za=c[108]|0;Aa=(za|0)>(ya|0);Ba=Aa?za:ya;c[108]=Ba;Ca=+Mm(h);Da=+g[102];Ea=Da>Ca;Fa=Ea?Da:Ca;g[102]=Fa;Ga=+g[100];Ha=Ca+Ga;g[100]=Ha;i=f;return}function _d(e,f,h,j,k,l,m){e=e|0;f=f|0;h=h|0;j=j|0;k=k|0;l=l|0;m=+m;var n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=
0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0;n=i;c[e>>2]=h;c[e+4>>2]=k;o=b[f+4>>1]|0;p=e+8|0;q=p+0|0;r=j+0|0;j=q+36|0;do{c[q>>2]=c[r>>2];q=q+4|0;r=r+4|0}while((q|0)<(j|0));s=e+44|0;q=s+0|0;r=l+0|0;j=q+36|0;do{c[q>>2]=c[r>>2];q=q+4|0;r=r+4|0}while((q|0)<(j|0));t=1-m;u=t*+g[e+32>>2]+ +g[e+36>>2]*m;v=+T(+u);w=+S(+u);u=+g[p>>2];x=+g[e+12>>2];y=t*+g[e+16>>2]+ +g[e+24>>2]*m-(w*u-v*x);z=t*+g[e+20>>2]+ +g[e+28>>2]*m-(v*u+w*x);x=t*+g[e+68>>2]+ +g[e+72>>2]*m;u=+T(+x);A=+S(+x);x=+g[s>>
2];B=+g[e+48>>2];C=t*+g[e+52>>2]+ +g[e+60>>2]*m-(A*x-u*B);D=t*+g[e+56>>2]+ +g[e+64>>2]*m-(u*x+A*B);if(o<<16>>16==1){c[e+80>>2]=0;o=(c[h+16>>2]|0)+(d[f+6>>0]<<3)|0;B=+g[o>>2];x=+g[o+4>>2];o=(c[k+16>>2]|0)+(d[f+9>>0]<<3)|0;m=+g[o>>2];t=+g[o+4>>2];o=e+92|0;E=C+(A*m-u*t)-(y+(w*B-v*x));F=D+(u*m+A*t)-(z+(v*B+w*x));x=+E;B=+F;s=o;g[s>>2]=x;g[s+4>>2]=B;B=+Q(+(E*E+F*F));if(B<1.1920928955078125E-7)G=0;else{x=1/B;g[o>>2]=E*x;g[e+96>>2]=F*x;G=B}o=8784;s=c[o+4>>2]|0;p=e+84|0;c[p>>2]=c[o>>2];c[p+4>>2]=s;H=G;i=n;
return+H}s=f+6|0;p=f+7|0;o=e+80|0;if((a[s>>0]|0)==(a[p>>0]|0)){c[o>>2]=2;r=c[k+16>>2]|0;q=r+(d[f+9>>0]<<3)|0;G=+g[q>>2];B=+g[q+4>>2];q=r+(d[f+10>>0]<<3)|0;x=+g[q>>2];F=+g[q+4>>2];q=e+92|0;E=x-G;t=F-B;m=-E;I=+t;J=+m;r=q;g[r>>2]=I;g[r+4>>2]=J;J=+Q(+(t*t+E*E));if(J<1.1920928955078125E-7){K=t;L=m}else{E=1/J;J=t*E;g[q>>2]=J;t=E*m;g[e+96>>2]=t;K=J;L=t}t=(G+x)*.5;x=(B+F)*.5;F=+t;B=+x;r=e+84|0;g[r>>2]=F;g[r+4>>2]=B;r=(c[h+16>>2]|0)+(d[s>>0]<<3)|0;B=+g[r>>2];F=+g[r+4>>2];G=(A*K-u*L)*(y+(w*B-v*F)-(C+(A*t-u*
x)))+(u*K+A*L)*(z+(v*B+w*F)-(D+(u*t+A*x)));if(!(G<0)){H=G;i=n;return+H}x=+-K;K=+-L;r=q;g[r>>2]=x;g[r+4>>2]=K;H=-G;i=n;return+H}else{c[o>>2]=1;o=c[h+16>>2]|0;h=o+(d[s>>0]<<3)|0;G=+g[h>>2];K=+g[h+4>>2];h=o+(d[p>>0]<<3)|0;x=+g[h>>2];L=+g[h+4>>2];h=e+92|0;t=x-G;F=L-K;B=-t;J=+F;m=+B;p=h;g[p>>2]=J;g[p+4>>2]=m;m=+Q(+(F*F+t*t));if(m<1.1920928955078125E-7){M=F;N=B}else{t=1/m;m=F*t;g[h>>2]=m;F=t*B;g[e+96>>2]=F;M=m;N=F}F=(G+x)*.5;x=(K+L)*.5;L=+F;K=+x;p=e+84|0;g[p>>2]=L;g[p+4>>2]=K;p=(c[k+16>>2]|0)+(d[f+9>>0]<<
3)|0;K=+g[p>>2];L=+g[p+4>>2];G=(w*M-v*N)*(C+(A*K-u*L)-(y+(w*F-v*x)))+(v*M+w*N)*(D+(u*K+A*L)-(z+(v*F+w*x)));if(!(G<0)){H=G;i=n;return+H}x=+-M;M=+-N;p=h;g[p>>2]=x;g[p+4>>2]=M;H=-G;i=n;return+H}return 0}function $d(a,b,d,e){a=a|0;b=b|0;d=d|0;e=+e;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0;f=i;h=1-e;j=h*+g[a+32>>2]+ +g[a+36>>2]*e;k=+T(+j);l=+S(+j);j=+g[a+8>>2];m=+g[a+12>>2];n=h*+g[a+16>>2]+ +g[a+24>>2]*e-(l*j-k*m);o=h*+g[a+20>>2]+
+g[a+28>>2]*e-(k*j+l*m);m=h*+g[a+68>>2]+ +g[a+72>>2]*e;j=+T(+m);p=+S(+m);m=+g[a+44>>2];q=+g[a+48>>2];r=h*+g[a+52>>2]+ +g[a+60>>2]*e-(p*m-j*q);s=h*+g[a+56>>2]+ +g[a+64>>2]*e-(j*m+p*q);t=c[a+80>>2]|0;if((t|0)==0){q=+g[a+92>>2];m=+g[a+96>>2];e=l*q+k*m;h=l*m-k*q;u=-q;v=-m;w=p*u+j*v;x=p*v-j*u;y=c[a>>2]|0;z=c[y+16>>2]|0;A=c[y+20>>2]|0;if((A|0)>1){y=0;u=h*+g[z+4>>2]+e*+g[z>>2];B=1;while(1){v=e*+g[z+(B<<3)>>2]+h*+g[z+(B<<3)+4>>2];C=v>u;D=C?B:y;B=B+1|0;if((B|0)==(A|0)){E=D;break}else{y=D;u=C?v:u}}}else E=
0;c[b>>2]=E;E=c[a+4>>2]|0;y=c[E+16>>2]|0;A=c[E+20>>2]|0;if((A|0)>1){E=0;u=x*+g[y+4>>2]+w*+g[y>>2];B=1;while(1){h=w*+g[y+(B<<3)>>2]+x*+g[y+(B<<3)+4>>2];C=h>u;D=C?B:E;B=B+1|0;if((B|0)==(A|0)){F=D;break}else{E=D;u=C?h:u}}}else F=0;c[d>>2]=F;E=z+(c[b>>2]<<3)|0;u=+g[E>>2];x=+g[E+4>>2];E=y+(F<<3)|0;w=+g[E>>2];h=+g[E+4>>2];G=q*(r+(p*w-j*h)-(n+(l*u-k*x)))+m*(s+(j*w+p*h)-(o+(k*u+l*x)));i=f;return+G}else if((t|0)==1){x=+g[a+92>>2];u=+g[a+96>>2];h=l*x-k*u;w=k*x+l*u;u=+g[a+84>>2];x=+g[a+88>>2];m=n+(l*u-k*x);
q=o+(k*u+l*x);x=-h;u=-w;e=p*x+j*u;v=p*u-j*x;c[b>>2]=-1;E=c[a+4>>2]|0;F=c[E+16>>2]|0;y=c[E+20>>2]|0;if((y|0)>1){E=0;x=v*+g[F+4>>2]+e*+g[F>>2];z=1;while(1){u=e*+g[F+(z<<3)>>2]+v*+g[F+(z<<3)+4>>2];A=u>x;B=A?z:E;z=z+1|0;if((z|0)==(y|0)){H=B;break}else{E=B;x=A?u:x}}}else H=0;c[d>>2]=H;E=F+(H<<3)|0;x=+g[E>>2];v=+g[E+4>>2];G=h*(r+(p*x-j*v)-m)+w*(s+(j*x+p*v)-q);i=f;return+G}else if((t|0)==2){q=+g[a+92>>2];v=+g[a+96>>2];x=p*q-j*v;w=j*q+p*v;v=+g[a+84>>2];q=+g[a+88>>2];m=r+(p*v-j*q);r=s+(j*v+p*q);q=-x;p=-w;
v=l*q+k*p;j=l*p-k*q;c[d>>2]=-1;t=c[a>>2]|0;a=c[t+16>>2]|0;E=c[t+20>>2]|0;if((E|0)>1){t=0;q=j*+g[a+4>>2]+v*+g[a>>2];H=1;while(1){p=v*+g[a+(H<<3)>>2]+j*+g[a+(H<<3)+4>>2];F=p>q;y=F?H:t;H=H+1|0;if((H|0)==(E|0)){I=y;break}else{t=y;q=F?p:q}}}else I=0;c[b>>2]=I;t=a+(I<<3)|0;q=+g[t>>2];j=+g[t+4>>2];G=x*(n+(l*q-k*j)-m)+w*(o+(k*q+l*j)-r);i=f;return+G}else{c[b>>2]=-1;c[d>>2]=-1;G=0;i=f;return+G}return 0}function ae(a,b,d,e){a=a|0;b=b|0;d=d|0;e=+e;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=
0,w=0,x=0;f=i;h=1-e;j=h*+g[a+32>>2]+ +g[a+36>>2]*e;k=+T(+j);l=+S(+j);j=+g[a+8>>2];m=+g[a+12>>2];n=h*+g[a+16>>2]+ +g[a+24>>2]*e-(l*j-k*m);o=h*+g[a+20>>2]+ +g[a+28>>2]*e-(k*j+l*m);m=h*+g[a+68>>2]+ +g[a+72>>2]*e;j=+T(+m);p=+S(+m);m=+g[a+44>>2];q=+g[a+48>>2];r=h*+g[a+52>>2]+ +g[a+60>>2]*e-(p*m-j*q);s=h*+g[a+56>>2]+ +g[a+64>>2]*e-(j*m+p*q);t=c[a+80>>2]|0;if((t|0)==0){u=(c[(c[a>>2]|0)+16>>2]|0)+(b<<3)|0;q=+g[u>>2];m=+g[u+4>>2];u=(c[(c[a+4>>2]|0)+16>>2]|0)+(d<<3)|0;e=+g[u>>2];h=+g[u+4>>2];v=+g[a+92>>2]*
(r+(p*e-j*h)-(n+(l*q-k*m)))+ +g[a+96>>2]*(s+(j*e+p*h)-(o+(k*q+l*m)));i=f;return+v}else if((t|0)==1){m=+g[a+92>>2];q=+g[a+96>>2];h=+g[a+84>>2];e=+g[a+88>>2];u=(c[(c[a+4>>2]|0)+16>>2]|0)+(d<<3)|0;w=+g[u>>2];x=+g[u+4>>2];v=(l*m-k*q)*(r+(p*w-j*x)-(n+(l*h-k*e)))+(k*m+l*q)*(s+(j*w+p*x)-(o+(k*h+l*e)));i=f;return+v}else if((t|0)==2){e=+g[a+92>>2];h=+g[a+96>>2];x=+g[a+84>>2];w=+g[a+88>>2];t=(c[(c[a>>2]|0)+16>>2]|0)+(b<<3)|0;q=+g[t>>2];m=+g[t+4>>2];v=(p*e-j*h)*(n+(l*q-k*m)-(r+(p*x-j*w)))+(j*e+p*h)*(o+(k*q+
l*m)-(s+(j*x+p*w)));i=f;return+v}else{v=0;i=f;return+v}return 0}function be(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0;e=i;f=c[b+4>>2]|0;if((f|0)==0){c[a+16>>2]=b+12;c[a+20>>2]=1;g[a+24>>2]=+g[b+8>>2];i=e;return}else if((f|0)==2){c[a+16>>2]=b+20;c[a+20>>2]=c[b+148>>2];g[a+24>>2]=+g[b+8>>2];i=e;return}else if((f|0)==1){c[a+16>>2]=b+12;c[a+20>>2]=2;g[a+24>>2]=+g[b+8>>2];i=e;return}else if((f|0)==3){f=b+12|0;h=(c[f>>2]|0)+(d<<3)|0;j=c[h+4>>2]|0;k=a;c[k>>2]=c[h>>2];c[k+4>>2]=j;j=d+1|0;d=a+8|0;k=
c[f>>2]|0;if((j|0)<(c[b+16>>2]|0)){f=k+(j<<3)|0;j=c[f+4>>2]|0;h=d;c[h>>2]=c[f>>2];c[h+4>>2]=j}else{j=k;k=c[j+4>>2]|0;h=d;c[h>>2]=c[j>>2];c[h+4>>2]=k}c[a+16>>2]=a;c[a+20>>2]=2;g[a+24>>2]=+g[b+8>>2];i=e;return}else{i=e;return}}function ce(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;b=i;d=a+16|0;e=+g[d>>2];f=+g[d+4>>2];d=a+36|0;h=a+52|0;j=+g[h>>2];k=+g[h+4>>2];h=a+72|0;l=a+88|0;m=+g[l>>2];n=+g[l+4>>2];o=j-e;p=k-f;q=e*o+f*p;r=j*o+k*
p;s=m-e;t=n-f;u=e*s+f*t;v=m*s+n*t;w=m-j;x=n-k;y=j*w+k*x;z=m*w+n*x;x=o*t-p*s;s=(j*n-k*m)*x;p=(f*m-e*n)*x;n=(e*k-f*j)*x;if(!(!(q>=-0)|!(u>=-0))){g[a+24>>2]=1;c[a+108>>2]=1;i=b;return}if(!(!(q<-0)|!(r>0)|!(n<=0))){x=1/(r-q);g[a+24>>2]=r*x;g[a+60>>2]=-(q*x);c[a+108>>2]=2;i=b;return}if(!(!(u<-0)|!(v>0)|!(p<=0))){x=1/(v-u);g[a+24>>2]=v*x;g[a+96>>2]=-(u*x);c[a+108>>2]=2;A=d+0|0;B=h+0|0;C=A+36|0;do{c[A>>2]=c[B>>2];A=A+4|0;B=B+4|0}while((A|0)<(C|0));i=b;return}if(!(!(r<=0)|!(y>=-0))){g[a+60>>2]=1;c[a+108>>
2]=1;A=a+0|0;B=d+0|0;C=A+36|0;do{c[A>>2]=c[B>>2];A=A+4|0;B=B+4|0}while((A|0)<(C|0));i=b;return}if(!(!(v<=0)|!(z<=0))){g[a+96>>2]=1;c[a+108>>2]=1;A=a+0|0;B=h+0|0;C=A+36|0;do{c[A>>2]=c[B>>2];A=A+4|0;B=B+4|0}while((A|0)<(C|0));i=b;return}if(!(y<-0)|!(z>0)|!(s<=0)){v=1/(n+(s+p));g[a+24>>2]=s*v;g[a+60>>2]=p*v;g[a+96>>2]=n*v;c[a+108>>2]=3;i=b;return}else{v=1/(z-y);g[a+60>>2]=z*v;g[a+96>>2]=-(y*v);c[a+108>>2]=2;A=a+0|0;B=h+0|0;C=A+36|0;do{c[A>>2]=c[B>>2];A=A+4|0;B=B+4|0}while((A|0)<(C|0));i=b;return}}function de(d,
e,f){d=d|0;e=e|0;f=f|0;var h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0;h=i;i=i+176|0;j=h+152|0;l=h+136|0;m=h;n=h+124|0;o=h+112|0;c[114]=(c[114]|0)+1;p=f+28|0;q=f+56|0;c[j+0>>2]=c[q+0>>2];c[j+4>>2]=c[q+4>>2];c[j+8>>2]=c[q+8>>2];c[j+12>>2]=c[q+12>>2];q=f+72|
0;c[l+0>>2]=c[q+0>>2];c[l+4>>2]=c[q+4>>2];c[l+8>>2]=c[q+8>>2];c[l+12>>2]=c[q+12>>2];ee(m,e,f,j,p,l);c[n+0>>2]=0;c[n+4>>2]=0;c[n+8>>2]=0;c[o+0>>2]=0;c[o+4>>2]=0;c[o+8>>2]=0;p=m+108|0;r=+g[j+12>>2];s=+g[j+8>>2];q=f+16|0;t=f+20|0;u=+g[j>>2];v=+g[j+4>>2];w=+g[l+12>>2];x=+g[l+8>>2];j=f+44|0;y=f+48|0;z=+g[l>>2];A=+g[l+4>>2];l=m+16|0;B=m+20|0;C=m+52|0;D=m+56|0;E=m+16|0;F=m+36|0;G=m+52|0;H=m+24|0;I=m+60|0;J=c[p>>2]|0;K=0;a:while(1){L=(J|0)>0;if(L){M=0;do{c[n+(M<<2)>>2]=c[m+(M*36|0)+28>>2];c[o+(M<<2)>>2]=
c[m+(M*36|0)+32>>2];M=M+1|0}while((M|0)!=(J|0))}do if((J|0)==2){M=E;N=+g[M>>2];O=+g[M+4>>2];M=G;P=+g[M>>2];R=+g[M+4>>2];S=P-N;T=R-O;U=N*S+O*T;if(U>=-0){g[H>>2]=1;c[p>>2]=1;V=13;break}O=P*S+R*T;if(!(O<=0)){T=1/(O-U);g[H>>2]=O*T;g[I>>2]=-(U*T);c[p>>2]=2;V=14;break}else{g[I>>2]=1;c[p>>2]=1;M=m+0|0;W=F+0|0;X=M+36|0;do{c[M>>2]=c[W>>2];M=M+4|0;W=W+4|0}while((M|0)<(X|0));V=13;break}}else if((J|0)==3){ce(m);W=c[p>>2]|0;if((W|0)==3){V=11;break a}else{Y=W;V=12}}else{Y=J;V=12}while(0);do if((V|0)==12){V=0;if((Y|
0)==1){V=13;break}else if((Y|0)==2){V=14;break}W=8784;T=+g[W>>2];Z=T;_=+g[W+4>>2];$=Y}while(0);do if((V|0)==13){V=0;Z=-+g[l>>2];_=-+g[B>>2];$=1}else if((V|0)==14){V=0;T=+g[l>>2];U=+g[C>>2]-T;O=+g[B>>2];R=+g[D>>2]-O;if(T*R-U*O>0){Z=-R;_=U;$=2;break}else{Z=R;_=-U;$=2;break}}while(0);if(_*_+Z*Z<1.4210854715202004E-14){aa=$;ba=K;V=31;break}W=m+($*36|0)|0;U=-Z;R=-_;O=r*U+s*R;T=r*R-s*U;M=c[q>>2]|0;X=c[t>>2]|0;if((X|0)>1){ca=0;U=T*+g[M+4>>2]+O*+g[M>>2];da=1;while(1){R=O*+g[M+(da<<3)>>2]+T*+g[M+(da<<3)+4>>
2];ea=R>U;fa=ea?da:ca;da=da+1|0;if((da|0)==(X|0)){ga=fa;break}else{ca=fa;U=ea?R:U}}}else ga=0;c[m+($*36|0)+28>>2]=ga;U=+g[M+(ga<<3)>>2];T=+g[M+(ga<<3)+4>>2];O=u+(r*U-s*T);R=+O;S=+(U*s+r*T+v);ca=W;g[ca>>2]=R;g[ca+4>>2]=S;S=Z*w+_*x;R=_*w-Z*x;ca=c[j>>2]|0;X=c[y>>2]|0;if((X|0)>1){da=0;T=R*+g[ca+4>>2]+S*+g[ca>>2];ea=1;while(1){U=S*+g[ca+(ea<<3)>>2]+R*+g[ca+(ea<<3)+4>>2];fa=U>T;ha=fa?ea:da;ea=ea+1|0;if((ea|0)==(X|0)){ia=ha;break}else{da=ha;T=fa?U:T}}}else ia=0;c[m+($*36|0)+32>>2]=ia;T=+g[ca+(ia<<3)>>2];
R=+g[ca+(ia<<3)+4>>2];S=z+(w*T-x*R);U=+S;P=+(T*x+w*R+A);da=m+($*36|0)+8|0;g[da>>2]=U;g[da+4>>2]=P;P=+(S-O);S=+(+g[m+($*36|0)+12>>2]-+g[m+($*36|0)+4>>2]);da=m+($*36|0)+16|0;g[da>>2]=P;g[da+4>>2]=S;ja=K+1|0;c[116]=(c[116]|0)+1;if(L){da=0;do{if((ga|0)==(c[n+(da<<2)>>2]|0)?(ia|0)==(c[o+(da<<2)>>2]|0):0){V=30;break a}da=da+1|0}while((da|0)<(J|0))}da=(c[p>>2]|0)+1|0;c[p>>2]=da;if((ja|0)<20){J=da;K=ja}else{aa=da;ba=ja;V=31;break}}if((V|0)==11){J=c[118]|0;c[118]=(J|0)>(K|0)?J:K;ka=d+8|0;la=K;V=35}else if((V|
0)==30){aa=c[p>>2]|0;ba=ja;V=31}do if((V|0)==31){ja=c[118]|0;c[118]=(ja|0)>(ba|0)?ja:ba;ja=d+8|0;if((aa|0)==1){p=m;K=c[p>>2]|0;J=c[p+4>>2]|0;p=d;c[p>>2]=K;c[p+4>>2]=J;p=m+8|0;o=c[p>>2]|0;ia=c[p+4>>2]|0;p=ja;c[p>>2]=o;c[p+4>>2]=ia;A=(c[k>>2]=K,+g[k>>2]);w=(c[k>>2]=o,+g[k>>2]);x=(c[k>>2]=J,+g[k>>2]);ma=w;na=A;oa=(c[k>>2]=ia,+g[k>>2]);pa=x;qa=1;ra=ja;sa=ba;break}else if((aa|0)==2){x=+g[H>>2];A=+g[I>>2];w=x*+g[m>>2]+A*+g[m+36>>2];z=x*+g[m+4>>2]+A*+g[m+40>>2];Z=+w;_=+z;ia=d;g[ia>>2]=Z;g[ia+4>>2]=_;_=x*
+g[m+8>>2]+A*+g[m+44>>2];Z=x*+g[m+12>>2]+A*+g[m+48>>2];A=+_;x=+Z;ia=ja;g[ia>>2]=A;g[ia+4>>2]=x;ma=_;na=w;oa=Z;pa=z;qa=2;ra=ja;sa=ba;break}else if((aa|0)==3){ka=ja;la=ba;V=35;break}else{ma=+g[ja>>2];na=+g[d>>2];oa=+g[d+12>>2];pa=+g[d+4>>2];qa=aa;ra=ja;sa=ba;break}}while(0);if((V|0)==35){z=+g[H>>2];Z=+g[I>>2];w=+g[m+96>>2];_=z*+g[m>>2]+Z*+g[m+36>>2]+w*+g[m+72>>2];x=z*+g[m+4>>2]+Z*+g[m+40>>2]+w*+g[m+76>>2];w=+_;Z=+x;I=d;g[I>>2]=w;g[I+4>>2]=Z;I=ka;g[I>>2]=w;g[I+4>>2]=Z;ma=_;na=_;oa=x;pa=x;qa=3;ra=ka;
sa=la}x=na-ma;la=d+4|0;ka=d+12|0;ma=pa-oa;I=d+16|0;g[I>>2]=+Q(+(x*x+ma*ma));c[d+20>>2]=sa;if((qa|0)==2){ma=+g[l>>2]-+g[C>>2];x=+g[B>>2]-+g[D>>2];ta=+Q(+(ma*ma+x*x));V=39}else if((qa|0)!=3){g[e>>2]=0;b[e+4>>1]=qa;if((qa|0)>0){ua=0;V=41}}else{x=+g[l>>2];ma=+g[B>>2];ta=(+g[C>>2]-x)*(+g[m+92>>2]-ma)-(+g[D>>2]-ma)*(+g[m+88>>2]-x);V=39}if((V|0)==39){g[e>>2]=ta;b[e+4>>1]=qa;ua=0;V=41}if((V|0)==41)while(1){V=0;a[e+ua+6>>0]=c[m+(ua*36|0)+28>>2];a[e+ua+9>>0]=c[m+(ua*36|0)+32>>2];ua=ua+1|0;if((ua|0)>=(qa|0))break;
else V=41}if((a[f+88>>0]|0)==0){i=h;return}ta=+g[f+24>>2];x=+g[f+52>>2];ma=+g[I>>2];oa=ta+x;if(!(ma>oa&ma>1.1920928955078125E-7)){pa=+((+g[d>>2]+ +g[ra>>2])*.5);na=+((+g[la>>2]+ +g[ka>>2])*.5);f=d;g[f>>2]=pa;g[f+4>>2]=na;f=ra;g[f>>2]=pa;g[f+4>>2]=na;g[I>>2]=0;i=h;return}g[I>>2]=ma-oa;oa=+g[ra>>2];ma=+g[d>>2];na=oa-ma;pa=+g[ka>>2];_=+g[la>>2];Z=pa-_;w=+Q(+(na*na+Z*Z));if(w<1.1920928955078125E-7){va=na;wa=Z}else{z=1/w;va=na*z;wa=Z*z}g[d>>2]=ta*va+ma;g[la>>2]=ta*wa+_;g[ra>>2]=oa-x*va;g[ka>>2]=pa-x*wa;
i=h;return}function ee(a,e,f,h,j,k){a=a|0;e=e|0;f=f|0;h=h|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0;l=i;m=b[e+4>>1]|0;n=m&65535;o=a+108|0;c[o>>2]=n;if(m<<16>>16==0)p=n;else{n=f+16|0;m=j+16|0;q=h+12|0;r=h+8|0;s=h+4|0;t=k+12|0;u=k+8|0;v=k+4|0;w=0;do{x=d[e+w+6>>0]|0;c[a+(w*36|0)+28>>2]=x;y=d[e+w+9>>0]|0;c[a+(w*36|0)+32>>2]=y;z=(c[n>>2]|0)+(x<<3)|0;A=+g[z>>2];B=+g[z+4>>2];z=(c[m>>2]|0)+(y<<3)|0;C=+g[z>>2];D=+g[z+4>>2];E=+g[q>>
2];F=+g[r>>2];G=+g[h>>2]+(A*E-B*F);H=+G;I=+(E*B+A*F+ +g[s>>2]);z=a+(w*36|0)|0;g[z>>2]=H;g[z+4>>2]=I;I=+g[t>>2];H=+g[u>>2];F=+g[k>>2]+(C*I-D*H);A=+F;B=+(D*I+C*H+ +g[v>>2]);z=a+(w*36|0)+8|0;g[z>>2]=A;g[z+4>>2]=B;B=+(F-G);G=+(+g[a+(w*36|0)+12>>2]-+g[a+(w*36|0)+4>>2]);z=a+(w*36|0)+16|0;g[z>>2]=B;g[z+4>>2]=G;g[a+(w*36|0)+24>>2]=0;w=w+1|0;z=c[o>>2]|0}while((w|0)<(z|0));p=z}do if((p|0)>1){G=+g[e>>2];if((p|0)==2){B=+g[a+16>>2]-+g[a+52>>2];F=+g[a+20>>2]-+g[a+56>>2];J=+Q(+(B*B+F*F))}else if((p|0)==3){F=+g[a+
16>>2];B=+g[a+20>>2];J=(+g[a+52>>2]-F)*(+g[a+92>>2]-B)-(+g[a+56>>2]-B)*(+g[a+88>>2]-F)}else J=0;if(!(J<G*.5)?!(G*2<J|J<1.1920928955078125E-7):0){K=11;break}c[o>>2]=0}else K=11;while(0);if((K|0)==11?(p|0)!=0:0){i=l;return}c[a+28>>2]=0;c[a+32>>2]=0;p=c[f+16>>2]|0;J=+g[p>>2];G=+g[p+4>>2];p=c[j+16>>2]|0;F=+g[p>>2];B=+g[p+4>>2];A=+g[h+12>>2];H=+g[h+8>>2];C=+g[h>>2]+(J*A-G*H);I=A*G+J*H+ +g[h+4>>2];H=+C;J=+I;h=a;g[h>>2]=H;g[h+4>>2]=J;J=+g[k+12>>2];H=+g[k+8>>2];G=+g[k>>2]+(F*J-B*H);A=B*J+F*H+ +g[k+4>>2];
H=+G;F=+A;k=a+8|0;g[k>>2]=H;g[k+4>>2]=F;F=+(G-C);C=+(A-I);k=a+16|0;g[k>>2]=F;g[k+4>>2]=C;g[a+24>>2]=1;c[o>>2]=1;i=l;return}function fe(a,d){a=a|0;d=d|0;var e=0,f=0,h=0,j=0;e=i;f=Em(d,48)|0;if((f|0)==0)h=0;else{c[f>>2]=488;c[f+4>>2]=1;g[f+8>>2]=.009999999776482582;d=f+28|0;c[d+0>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;b[d+16>>1]=0;h=f}f=a+4|0;d=c[f+4>>2]|0;j=h+4|0;c[j>>2]=c[f>>2];c[j+4>>2]=d;d=h+12|0;j=a+12|0;c[d+0>>2]=c[j+0>>2];c[d+4>>2]=c[j+4>>2];c[d+8>>2]=c[j+8>>2];c[d+12>>2]=c[j+12>>2];c[d+
16>>2]=c[j+16>>2];c[d+20>>2]=c[j+20>>2];c[d+24>>2]=c[j+24>>2];c[d+28>>2]=c[j+28>>2];b[d+32>>1]=b[j+32>>1]|0;i=e;return h|0}function ge(a){a=a|0;return 1}function he(a,b,c){a=a|0;b=b|0;c=c|0;return 0}function ie(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;f=i;h=+g[b+12>>2];j=+g[a+12>>2];k=+g[b+8>>2];l=+g[a+16>>2];m=+g[b>>2];n=m+(h*j-k*l);o=+g[b+4>>2];p=j*k+h*l+o;l=+g[a+20>>2];j=+g[a+24>>2];q=m+(h*l-k*j);m=
o+(k*l+h*j);j=+g[c>>2];h=j-n;l=+g[c+4>>2];k=l-p;o=q-n;n=m-p;p=h*o+k*n;do if(p>0){r=o*o+n*n;if(p>r){s=j-q;t=l-m;break}else{u=p/r;s=h-o*u;t=k-n*u;break}}else{s=h;t=k}while(0);k=+Q(+(t*t+s*s));g[d>>2]=k;if(k>0){h=1/k;v=s*h;w=t*h;x=+v;y=+w;z=e;A=z;g[A>>2]=x;B=z+4|0;C=B;g[C>>2]=y;i=f;return}else{d=8784;h=+g[d>>2];v=h;w=+g[d+4>>2];x=+v;y=+w;z=e;A=z;g[A>>2]=x;B=z+4|0;C=B;g[C>>2]=y;i=f;return}}function je(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,
v=0,w=0,x=0;e=i;f=+g[d>>2];h=+g[c>>2]-f;j=+g[d+4>>2];k=+g[c+4>>2]-j;l=d+12|0;m=+g[l>>2];n=d+8|0;o=+g[n>>2];p=h*m+k*o;q=m*k-h*o;h=+g[c+8>>2]-f;f=+g[c+12>>2]-j;j=m*h+o*f-p;k=m*f-o*h-q;d=a+12|0;h=+g[d>>2];o=+g[d+4>>2];d=a+20|0;f=+g[d>>2];m=f-h;f=+g[d+4>>2]-o;r=-m;s=m*m+f*f;t=+Q(+s);if(t<1.1920928955078125E-7){u=f;v=r}else{w=1/t;u=f*w;v=w*r}r=(o-q)*v+(h-p)*u;w=k*v+j*u;if(w==0){x=0;i=e;return x|0}t=r/w;if(t<0){x=0;i=e;return x|0}if(s==0?1:+g[c+16>>2]<t){x=0;i=e;return x|0}w=(m*(p+j*t-h)+f*(q+k*t-o))/s;
if(w<0|w>1){x=0;i=e;return x|0}g[b+8>>2]=t;t=+g[l>>2];w=+g[n>>2];s=u*t-v*w;o=v*t+u*w;if(r>0){r=+-s;w=+-o;n=b;g[n>>2]=r;g[n+4>>2]=w;x=1;i=e;return x|0}else{w=+s;s=+o;n=b;g[n>>2]=w;g[n+4>>2]=s;x=1;i=e;return x|0}return 0}function ke(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;d=i;e=+g[c+12>>2];f=+g[a+12>>2];h=+g[c+8>>2];j=+g[a+16>>2];k=+g[c>>2];l=k+(e*f-h*j);m=+g[c+4>>2];n=f*h+e*j+m;j=+g[a+20>>2];f=+g[a+24>>2];o=k+(e*j-h*f);k=m+(h*j+e*f);f=+g[a+8>>2];e=+((l<o?l:o)-f);j=
+((n<k?n:k)-f);a=b;g[a>>2]=e;g[a+4>>2]=j;j=+(f+(l>o?l:o));o=+(f+(n>k?n:k));a=b+8|0;g[a>>2]=j;g[a+4>>2]=o;i=d;return}function le(a,b,c){a=a|0;b=b|0;c=+c;var d=0,e=0;d=i;g[b>>2]=0;c=+((+g[a+12>>2]+ +g[a+20>>2])*.5);e=+((+g[a+16>>2]+ +g[a+24>>2])*.5);a=b+4|0;g[a>>2]=c;g[a+4>>2]=e;g[b+12>>2]=0;i=d;return}function me(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0;d=i;e=Em(b,152)|0;if((e|0)==0)f=0;else{c[e>>2]=592;c[e+4>>2]=2;g[e+8>>2]=.009999999776482582;c[e+148>>2]=0;g[e+12>>2]=0;g[e+16>>2]=0;f=e}e=a+4|0;b=c[e+
4>>2]|0;h=f+4|0;c[h>>2]=c[e>>2];c[h+4>>2]=b;An(f+12|0,a+12|0,140)|0;i=d;return f|0}function ne(a){a=a|0;return 1}function oe(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0;e=i;i=i+96|0;f=e+32|0;h=e;if((d|0)<3){c[a+148>>2]=4;g[a+20>>2]=-1;g[a+24>>2]=-1;g[a+28>>2]=1;g[a+32>>2]=-1;g[a+36>>2]=1;g[a+40>>2]=1;g[a+44>>2]=-1;g[a+48>>2]=1;g[a+84>>2]=0;g[a+88>>2]=-1;g[a+92>>2]=1;g[a+96>>2]=0;g[a+100>>2]=0;g[a+
104>>2]=1;g[a+108>>2]=-1;g[a+112>>2]=0;g[a+12>>2]=0;g[a+16>>2]=0;i=e;return}j=(d|0)<8?d:8;d=0;l=0;while(1){m=b+(d<<3)|0;n=c[m>>2]|0;o=c[m+4>>2]|0;p=(c[k>>2]=n,+g[k>>2]);q=(c[k>>2]=o,+g[k>>2]);a:do if((l|0)>0){m=0;while(1){r=p-+g[f+(m<<3)>>2];s=q-+g[f+(m<<3)+4>>2];m=m+1|0;if(r*r+s*s<.0024999999441206455){t=l;break a}if((m|0)>=(l|0)){u=7;break}}}else u=7;while(0);if((u|0)==7){u=0;m=f+(l<<3)|0;c[m>>2]=n;c[m+4>>2]=o;t=l+1|0}d=d+1|0;if((d|0)==(j|0))break;else l=t}if((t|0)<3){c[a+148>>2]=4;g[a+20>>2]=-1;
g[a+24>>2]=-1;g[a+28>>2]=1;g[a+32>>2]=-1;g[a+36>>2]=1;g[a+40>>2]=1;g[a+44>>2]=-1;g[a+48>>2]=1;g[a+84>>2]=0;g[a+88>>2]=-1;g[a+92>>2]=1;g[a+96>>2]=0;g[a+100>>2]=0;g[a+104>>2]=1;g[a+108>>2]=-1;g[a+112>>2]=0;g[a+12>>2]=0;g[a+16>>2]=0;i=e;return}l=0;j=1;q=+g[f>>2];while(1){p=+g[f+(j<<3)>>2];if(!(p>q))if(p==q?+g[f+(j<<3)+4>>2]<+g[f+(l<<3)+4>>2]:0)u=22;else{v=l;w=q}else u=22;if((u|0)==22){u=0;v=j;w=p}j=j+1|0;if((j|0)==(t|0)){x=v;y=0;break}else{l=v;q=w}}while(1){c[h+(y<<2)>>2]=x;l=0;j=1;while(1){if((l|0)!=
(x|0)){w=+g[f+(x<<3)>>2];q=+g[f+(l<<3)>>2]-w;p=+g[f+(x<<3)+4>>2];s=+g[f+(l<<3)+4>>2]-p;r=+g[f+(j<<3)>>2]-w;w=+g[f+(j<<3)+4>>2]-p;p=q*w-s*r;u=p<0?j:l;if(p==0?r*r+w*w>q*q+s*s:0)z=j;else z=u}else z=j;j=j+1|0;if((j|0)==(t|0))break;else l=z}A=y+1|0;if((z|0)==(v|0))break;else{x=z;y=A}}c[a+148>>2]=A;z=(y|0)>-1;if(z){x=0;do{v=f+(c[h+(x<<2)>>2]<<3)|0;t=c[v+4>>2]|0;l=a+(x<<3)+20|0;c[l>>2]=c[v>>2];c[l+4>>2]=t;x=x+1|0}while((x|0)!=(A|0));if(z){z=0;do{x=z;z=z+1|0;h=(z|0)<(A|0)?z:0;s=+g[a+(h<<3)+24>>2]-+g[a+(x<<
3)+24>>2];f=a+(x<<3)+84|0;q=+s;w=+-(+g[a+(h<<3)+20>>2]-+g[a+(x<<3)+20>>2]);h=f;g[h>>2]=q;g[h+4>>2]=w;h=a+(x<<3)+88|0;w=+g[h>>2];q=+Q(+(s*s+w*w));if(!(q<1.1920928955078125E-7)){r=1/q;g[f>>2]=s*r;g[h>>2]=w*r}}while((z|0)!=(A|0))}}z=a+12|0;h=a+20|0;if((y|0)>-1){r=0;w=0;s=0;y=0;while(1){f=a+(y<<3)+20|0;q=+g[f>>2];p=+g[f+4>>2];y=y+1|0;if((y|0)<(A|0))B=a+(y<<3)+20|0;else B=h;f=B;C=+g[f>>2];D=+g[f+4>>2];E=(q*D-p*C)*.5;F=s+E;G=E*.3333333432674408;E=r+(q+0+C)*G;C=w+(p+0+D)*G;if((y|0)==(A|0)){H=E;I=C;J=F;break}else{r=
E;w=C;s=F}}}else{H=0;I=0;J=0}s=1/J;J=+(H*s);H=+(I*s);A=z;g[A>>2]=J;g[A+4>>2]=H;i=e;return}function pe(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;e=i;f=+g[d>>2]-+g[b>>2];h=+g[d+4>>2]-+g[b+4>>2];j=+g[b+12>>2];k=+g[b+8>>2];l=f*j+h*k;m=j*h-f*k;b=c[a+148>>2]|0;if((b|0)>0)n=0;else{o=1;i=e;return o|0}while(1){if((l-+g[a+(n<<3)+20>>2])*+g[a+(n<<3)+84>>2]+(m-+g[a+(n<<3)+24>>2])*+g[a+(n<<3)+88>>2]>0){o=0;p=4;break}n=n+1|0;if((n|0)>=(b|0)){o=1;p=4;break}}if((p|0)==4){i=e;return o|0}return 0}
function qe(a,b,d,e,f,h){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0;h=i;j=+g[d>>2]-+g[b>>2];k=+g[d+4>>2]-+g[b+4>>2];d=b+12|0;l=+g[d>>2];m=b+8|0;n=+g[m>>2];o=j*l+k*n;p=l*k-j*n;b=c[a+148>>2]|0;q=(b|0)>0;if(q){n=o;j=p;r=0;k=-3.4028234663852886E38;while(1){s=a+(r<<3)+84|0;l=(o-+g[a+(r<<3)+20>>2])*+g[s>>2]+(p-+g[a+(r<<3)+24>>2])*+g[a+(r<<3)+88>>2];if(l>k){t=s;u=+g[t>>2];v=+g[t+4>>2];w=u;x=l}else{v=j;w=n;x=k}r=
r+1|0;if((r|0)>=(b|0))break;else{n=w;j=v;k=x}}if(x>0){k=x*x;if(q){j=v;n=w;q=0;l=k;while(1){u=o-+g[a+(q<<3)+20>>2];y=p-+g[a+(q<<3)+24>>2];z=u*u+y*y;r=l>z;A=r?y:j;y=r?u:n;u=r?z:l;q=q+1|0;if((q|0)>=(b|0)){B=A;C=y;D=u;break}else{j=A;n=y;l=u}}}else{B=v;C=w;D=k}g[e>>2]=+Q(+D);D=+g[d>>2];k=+g[m>>2];l=C*D-B*k;n=B*D+C*k;k=+l;C=+n;b=f;g[b>>2]=k;g[b+4>>2]=C;C=+Q(+(l*l+n*n));if(C<1.1920928955078125E-7){i=h;return}k=1/C;g[f>>2]=l*k;g[f+4>>2]=n*k;i=h;return}else{E=v;F=w;G=x}}else{E=p;F=o;G=-3.4028234663852886E38}g[e>>
2]=G;G=+g[d>>2];o=+g[m>>2];p=+(F*G-E*o);x=+(E*G+F*o);m=f;g[m>>2]=p;g[m+4>>2]=x;i=h;return}function re(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;f=i;h=+g[e>>2];j=+g[d>>2]-h;k=+g[e+4>>2];l=+g[d+4>>2]-k;m=e+12|0;n=+g[m>>2];o=e+8|0;p=+g[o>>2];q=j*n+l*p;r=n*l-j*p;j=+g[d+8>>2]-h;h=+g[d+12>>2]-k;k=n*j+p*h-q;l=n*h-p*j-r;e=c[a+148>>2]|0;if((e|0)<=0){s=0;i=f;return s|0}t=0;u=-1;j=0;p=+g[d+16>>2];a:while(1){h=+g[a+(t<<3)+84>>2];n=
+g[a+(t<<3)+88>>2];v=(+g[a+(t<<3)+20>>2]-q)*h+(+g[a+(t<<3)+24>>2]-r)*n;w=k*h+l*n;do if(w==0)if(v<0){s=0;x=15;break a}else{y=u;z=j;A=p}else{if(w<0?v<j*w:0){y=t;z=v/w;A=p;break}if(w>0?v<p*w:0){y=u;z=j;A=v/w}else{y=u;z=j;A=p}}while(0);t=t+1|0;if(A<z){s=0;x=15;break}if((t|0)>=(e|0)){x=13;break}else{u=y;j=z;p=A}}if((x|0)==13){if(!((y|0)>-1)){s=0;i=f;return s|0}g[b+8>>2]=z;z=+g[m>>2];A=+g[a+(y<<3)+84>>2];p=+g[o>>2];j=+g[a+(y<<3)+88>>2];l=+(z*A-p*j);k=+(A*p+z*j);y=b;g[y>>2]=l;g[y+4>>2]=k;s=1;i=f;return s|
0}else if((x|0)==15){i=f;return s|0}return 0}function se(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;e=i;f=+g[d+12>>2];h=+g[a+20>>2];j=+g[d+8>>2];k=+g[a+24>>2];l=+g[d>>2];m=l+(f*h-j*k);n=+g[d+4>>2];o=h*j+f*k+n;d=c[a+148>>2]|0;if((d|0)>1){k=m;h=o;p=m;q=o;r=1;while(1){s=+g[a+(r<<3)+20>>2];t=+g[a+(r<<3)+24>>2];u=l+(f*s-j*t);v=s*j+f*t+n;t=k<u?k:u;s=h<v?h:v;w=p>u?p:u;u=q>v?q:v;r=r+1|0;if((r|0)>=(d|0)){x=s;y=t;z=u;A=w;break}else{k=
t;h=s;p=w;q=u}}}else{x=o;y=m;z=o;A=m}m=+g[a+8>>2];o=+(y-m);y=+(x-m);a=b;g[a>>2]=o;g[a+4>>2]=y;y=+(A+m);A=+(z+m);a=b+8|0;g[a>>2]=y;g[a+4>>2]=A;i=e;return}function te(a,b,d){a=a|0;b=b|0;d=+d;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0;e=i;f=c[a+148>>2]|0;h=(f|0)>0;if(h){j=0;k=0;l=0;do{j=j+ +g[a+(l<<3)+20>>2];k=k+ +g[a+(l<<3)+24>>2];l=l+1|0}while((l|0)<(f|0));m=1/+(f|0);n=j*m;j=k*m;if(h){h=a+20|0;l=a+24|0;m=0;k=0;o=0;p=0;q=0;
while(1){r=+g[a+(q<<3)+20>>2]-n;s=+g[a+(q<<3)+24>>2]-j;q=q+1|0;t=(q|0)<(f|0);if(t){u=a+(q<<3)+20|0;v=a+(q<<3)+24|0}else{u=h;v=l}w=+g[u>>2]-n;x=+g[v>>2]-j;y=r*x-s*w;z=y*.5;A=p+z;B=z*.3333333432674408;z=m+(r+w)*B;C=k+(s+x)*B;B=o+y*.0833333358168602*(w*w+(r*r+r*w)+(x*x+(s*s+s*x)));if(!t){D=C;E=z;F=n;G=j;H=B;I=A;break}else{m=z;k=C;o=B;p=A}}}else{D=0;E=0;F=n;G=j;H=0;I=0}}else{j=1/+(f|0);D=0;E=0;F=j*0;G=j*0;H=0;I=0}j=I*d;g[b>>2]=j;n=1/I;I=E*n;E=D*n;n=F+I;F=G+E;G=+n;D=+F;f=b+4|0;g[f>>2]=G;g[f+4>>2]=D;g[b+
12>>2]=H*d+j*(n*n+F*F-(I*I+E*E));i=e;return}function ue(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;e=Em(b,20)|0;if((e|0)==0)f=0;else{c[e>>2]=680;b=e+4|0;c[b+0>>2]=0;c[b+4>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;f=e}e=a+4|0;b=c[e+4>>2]|0;g=f+4|0;c[g>>2]=c[e>>2];c[g+4>>2]=b;b=a+12|0;a=c[b+4>>2]|0;g=f+12|0;c[g>>2]=c[b>>2];c[g+4>>2]=a;i=d;return f|0}function ve(a){a=a|0;return 1}function we(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=+g[b+12>>2];e=+g[a+12>>2];f=+g[b+8>>2];h=+g[a+16>>2];i=+g[c>>2]-(+g[b>>
2]+(d*e-f*h));j=+g[c+4>>2]-(+g[b+4>>2]+(e*f+d*h));h=+g[a+8>>2];return i*i+j*j<=h*h|0}function xe(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0;f=i;h=+g[b+12>>2];j=+g[a+12>>2];k=+g[b+8>>2];l=+g[a+16>>2];m=+g[c>>2]-(+g[b>>2]+(h*j-k*l));n=+g[c+4>>2]-(+g[b+4>>2]+(j*k+h*l));l=+Q(+(m*m+n*n));g[d>>2]=l-+g[a+8>>2];h=1/l;l=+(m*h);m=+(n*h);a=e;g[a>>2]=l;g[a+4>>2]=m;i=f;return}function ye(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;e=i;f=+g[d+
12>>2];h=+g[a+12>>2];j=+g[d+8>>2];k=+g[a+16>>2];l=+g[c>>2];m=l-(+g[d>>2]+(f*h-j*k));n=+g[c+4>>2];o=n-(+g[d+4>>2]+(h*j+f*k));k=+g[a+8>>2];f=+g[c+8>>2]-l;l=+g[c+12>>2]-n;n=m*f+o*l;j=f*f+l*l;h=n*n-(m*m+o*o-k*k)*j;if(h<0|j<1.1920928955078125E-7){p=0;i=e;return p|0}k=n+ +Q(+h);h=-k;if(!(k<=-0)){p=0;i=e;return p|0}if(!(j*+g[c+16>>2]>=h)){p=0;i=e;return p|0}k=h/j;g[b+8>>2]=k;j=m+f*k;f=o+l*k;k=+j;l=+f;c=b;g[c>>2]=k;g[c+4>>2]=l;l=+Q(+(j*j+f*f));if(l<1.1920928955078125E-7){p=1;i=e;return p|0}k=1/l;g[b>>2]=
j*k;g[b+4>>2]=f*k;p=1;i=e;return p|0}function ze(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,h=0,i=0,j=0,k=0;e=+g[c+12>>2];f=+g[a+12>>2];h=+g[c+8>>2];i=+g[a+16>>2];j=+g[c>>2]+(e*f-h*i);k=+g[c+4>>2]+(f*h+e*i);c=a+8|0;i=+g[c>>2];g[b>>2]=j-i;g[b+4>>2]=k-i;i=+g[c>>2];g[b+8>>2]=j+i;g[b+12>>2]=k+i;return}function Ae(a,b,d){a=a|0;b=b|0;d=+d;var e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0;e=a+8|0;f=+g[e>>2];h=f*d*3.1415927410125732*f;g[b>>2]=h;i=a+12|0;j=i;k=c[j+4>>2]|0;l=b+4|0;c[l>>2]=c[j>>2];c[l+4>>2]=k;f=+g[e>>2];
d=+g[i>>2];m=+g[a+16>>2];g[b+12>>2]=h*(f*f*.5+(d*d+m*m));return}function Be(a){a=a|0;var b=0;b=i;c[a>>2]=760;Qm(c[a+12>>2]|0);sn(a);i=b;return}function Ce(a){a=a|0;var b=0,d=0;b=i;c[a>>2]=760;d=a+12|0;Qm(c[d>>2]|0);c[d>>2]=0;c[a+16>>2]=0;i=b;return}function De(a,d,e){a=a|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=i;g=a+16|0;c[g>>2]=e;h=Pm(e<<3)|0;c[a+12>>2]=h;An(h|0,d|0,c[g>>2]<<3|0)|0;g=a+20|0;c[g+0>>2]=0;c[g+4>>2]=0;c[g+8>>2]=0;c[g+12>>2]=0;b[g+16>>1]=0;i=f;return}function Ee(d,e){d=d|0;e=e|0;var f=0,h=0,
j=0,k=0,l=0;f=i;h=Em(e,40)|0;if((h|0)==0)j=0;else{c[h>>2]=760;c[h+4>>2]=3;g[h+8>>2]=.009999999776482582;c[h+12>>2]=0;c[h+16>>2]=0;a[h+36>>0]=0;a[h+37>>0]=0;j=h}h=c[d+12>>2]|0;e=c[d+16>>2]|0;k=j+16|0;c[k>>2]=e;l=Pm(e<<3)|0;c[j+12>>2]=l;An(l|0,h|0,c[k>>2]<<3|0)|0;k=j+20|0;c[k+0>>2]=0;c[k+4>>2]=0;c[k+8>>2]=0;c[k+12>>2]=0;b[k+16>>1]=0;k=d+20|0;h=c[k+4>>2]|0;l=j+20|0;c[l>>2]=c[k>>2];c[l+4>>2]=h;h=d+28|0;l=c[h+4>>2]|0;k=j+28|0;c[k>>2]=c[h>>2];c[k+4>>2]=l;a[j+36>>0]=a[d+36>>0]|0;a[j+37>>0]=a[d+37>>0]|0;
i=f;return j|0}function Fe(a){a=a|0;return(c[a+16>>2]|0)+-1|0}function Ge(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0;f=i;c[d+4>>2]=1;g[d+8>>2]=+g[b+8>>2];h=b+12|0;j=(c[h>>2]|0)+(e<<3)|0;k=c[j+4>>2]|0;l=d+12|0;c[l>>2]=c[j>>2];c[l+4>>2]=k;k=(c[h>>2]|0)+(e+1<<3)|0;l=c[k+4>>2]|0;j=d+20|0;c[j>>2]=c[k>>2];c[j+4>>2]=l;l=d+28|0;if((e|0)>0){j=(c[h>>2]|0)+(e+-1<<3)|0;k=c[j+4>>2]|0;m=l;c[m>>2]=c[j>>2];c[m+4>>2]=k;a[d+44>>0]=1}else{k=b+20|0;m=c[k+4>>2]|0;j=l;c[j>>2]=c[k>>2];c[j+4>>2]=m;a[d+44>>0]=a[b+
36>>0]|0}m=d+36|0;if(((c[b+16>>2]|0)+-2|0)>(e|0)){j=(c[h>>2]|0)+(e+2<<3)|0;e=c[j+4>>2]|0;h=m;c[h>>2]=c[j>>2];c[h+4>>2]=e;a[d+45>>0]=1;i=f;return}else{e=b+28|0;h=c[e+4>>2]|0;j=m;c[j>>2]=c[e>>2];c[j+4>>2]=h;a[d+45>>0]=a[b+37>>0]|0;i=f;return}}function He(d,e,f,h,j,k){d=d|0;e=e|0;f=f|0;h=h|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0;l=i;i=i+48|0;m=l;c[m>>2]=488;n=m+4|0;o=m+8|0;p=m+28|0;c[p+0>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;c[p+12>>2]=0;b[p+16>>1]=0;c[n>>2]=1;g[o>>2]=+g[d+8>>2];o=c[d+12>>2]|0;n=o+(k<<
3)|0;p=c[n+4>>2]|0;q=m+12|0;c[q>>2]=c[n>>2];c[q+4>>2]=p;p=o+(k+1<<3)|0;q=c[p+4>>2]|0;n=m+20|0;c[n>>2]=c[p>>2];c[n+4>>2]=q;q=m+28|0;if((k|0)>0){n=o+(k+-1<<3)|0;p=c[n+4>>2]|0;r=q;c[r>>2]=c[n>>2];c[r+4>>2]=p;a[m+44>>0]=1}else{p=d+20|0;r=c[p+4>>2]|0;n=q;c[n>>2]=c[p>>2];c[n+4>>2]=r;a[m+44>>0]=a[d+36>>0]|0}r=m+36|0;if(((c[d+16>>2]|0)+-2|0)>(k|0)){n=o+(k+2<<3)|0;k=c[n+4>>2]|0;o=r;c[o>>2]=c[n>>2];c[o+4>>2]=k;a[m+45>>0]=1;ie(m,e,f,h,j,0);i=l;return}else{k=d+28|0;o=c[k+4>>2]|0;n=r;c[n>>2]=c[k>>2];c[n+4>>2]=
o;a[m+45>>0]=a[d+37>>0]|0;ie(m,e,f,h,j,0);i=l;return}}function Ie(a,b,c){a=a|0;b=b|0;c=c|0;return 0}function Je(a,d,e,f,h){a=a|0;d=d|0;e=e|0;f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0;j=i;i=i+48|0;k=j;c[k>>2]=488;c[k+4>>2]=1;g[k+8>>2]=.009999999776482582;l=k+28|0;c[l+0>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;b[l+16>>1]=0;l=h+1|0;m=(l|0)==(c[a+16>>2]|0)?0:l;l=c[a+12>>2]|0;a=l+(h<<3)|0;h=c[a+4>>2]|0;n=k+12|0;c[n>>2]=c[a>>2];c[n+4>>2]=h;h=l+(m<<3)|0;m=c[h+4>>2]|0;l=k+20|0;c[l>>2]=c[h>>2];c[l+4>>2]=m;m=je(k,
d,e,f,0)|0;i=j;return m|0}function Ke(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;f=i;h=e+1|0;j=(h|0)==(c[a+16>>2]|0)?0:h;h=c[a+12>>2]|0;k=+g[d+12>>2];l=+g[h+(e<<3)>>2];m=+g[d+8>>2];n=+g[h+(e<<3)+4>>2];o=+g[d>>2];p=o+(k*l-m*n);q=+g[d+4>>2];r=l*m+k*n+q;n=+g[h+(j<<3)>>2];l=+g[h+(j<<3)+4>>2];s=o+(k*n-m*l);o=q+(m*n+k*l);l=+(p<s?p:s);k=+(r<o?r:o);j=b;g[j>>2]=l;g[j+4>>2]=k;k=+(p>s?p:s);s=+(r>o?r:o);j=b+8|0;g[j>>2]=k;g[j+4>>2]=s;i=f;return}function Le(a,b,d){a=a|
0;b=b|0;d=+d;a=i;c[b+0>>2]=0;c[b+4>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;i=a;return}function Me(a){a=a|0;var b=0;b=i;Ve(a);c[a+28>>2]=0;c[a+48>>2]=16;c[a+52>>2]=0;c[a+44>>2]=Pm(128)|0;c[a+36>>2]=16;c[a+40>>2]=0;c[a+32>>2]=Pm(64)|0;i=b;return}function Ne(a){a=a|0;var b=0;b=i;Qm(c[a+32>>2]|0);Qm(c[a+44>>2]|0);We(a);i=b;return}function Oe(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0;e=i;f=Ye(a,b,d)|0;d=a+28|0;c[d>>2]=(c[d>>2]|0)+1;d=a+40|0;b=c[d>>2]|0;g=a+36|0;h=a+32|0;if((b|0)==(c[g>>2]|0)){a=c[h>>2]|
0;c[g>>2]=b<<1;g=Pm(b<<3)|0;c[h>>2]=g;An(g|0,a|0,c[d>>2]<<2|0)|0;Qm(a);j=c[d>>2]|0}else j=b;c[(c[h>>2]|0)+(j<<2)>>2]=f;c[d>>2]=(c[d>>2]|0)+1;i=e;return f|0}function Pe(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0;d=i;e=a+40|0;f=c[e>>2]|0;if((f|0)>0){g=c[a+32>>2]|0;h=f;f=0;while(1){j=g+(f<<2)|0;if((c[j>>2]|0)==(b|0)){c[j>>2]=-1;k=c[e>>2]|0}else k=h;f=f+1|0;if((f|0)>=(k|0))break;else h=k}}k=a+28|0;c[k>>2]=(c[k>>2]|0)+-1;_e(a,b);i=d;return}function Qe(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,
h=0,j=0;f=i;if(!(af(a,b,d,e)|0)){i=f;return}e=a+40|0;d=c[e>>2]|0;g=a+36|0;h=a+32|0;if((d|0)==(c[g>>2]|0)){a=c[h>>2]|0;c[g>>2]=d<<1;g=Pm(d<<3)|0;c[h>>2]=g;An(g|0,a|0,c[e>>2]<<2|0)|0;Qm(a);j=c[e>>2]|0}else j=d;c[(c[h>>2]|0)+(j<<2)>>2]=b;c[e>>2]=(c[e>>2]|0)+1;i=f;return}function Re(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;e=a+40|0;f=c[e>>2]|0;g=a+36|0;h=a+32|0;if((f|0)==(c[g>>2]|0)){a=c[h>>2]|0;c[g>>2]=f<<1;g=Pm(f<<3)|0;c[h>>2]=g;An(g|0,a|0,c[e>>2]<<2|0)|0;Qm(a);j=c[e>>2]|0}else j=f;c[(c[h>>
2]|0)+(j<<2)>>2]=b;c[e>>2]=(c[e>>2]|0)+1;i=d;return}function Se(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;d=i;e=a+56|0;f=c[e>>2]|0;if((f|0)==(b|0)){i=d;return 1}g=a+52|0;h=c[g>>2]|0;j=a+48|0;k=a+44|0;if((h|0)==(c[j>>2]|0)){a=c[k>>2]|0;c[j>>2]=h<<1;j=Pm(h<<4)|0;c[k>>2]=j;An(j|0,a|0,c[g>>2]<<3|0)|0;Qm(a);l=c[e>>2]|0;m=c[g>>2]|0}else{l=f;m=h}h=c[k>>2]|0;c[h+(m<<3)>>2]=(l|0)>(b|0)?b:l;l=c[e>>2]|0;c[h+(c[g>>2]<<3)+4>>2]=(l|0)<(b|0)?b:l;c[g>>2]=(c[g>>2]|0)+1;i=d;return 1}function Te(a,b,
d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;h=i;j=a+60|0;c[j>>2]=0;k=b+12|0;l=+g[d+12>>2];m=+g[k>>2];n=+g[d+8>>2];o=+g[b+16>>2];p=e+12|0;q=+g[f+12>>2];r=+g[p>>2];s=+g[f+8>>2];t=+g[e+16>>2];u=+g[f>>2]+(q*r-s*t)-(+g[d>>2]+(l*m-n*o));v=r*s+q*t+ +g[f+4>>2]-(m*n+l*o+ +g[d+4>>2]);o=+g[b+8>>2]+ +g[e+8>>2];if(u*u+v*v>o*o){i=h;return}c[a+56>>2]=0;e=k;k=c[e+4>>2]|0;b=a+48|0;c[b>>2]=c[e>>2];c[b+4>>2]=k;g[a+40>>2]=0;g[a+44>>2]=0;c[j>>2]=1;j=p;p=c[j+4>>2]|0;
k=a;c[k>>2]=c[j>>2];c[k+4>>2]=p;c[a+16>>2]=0;i=h;return}function Ue(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0;h=i;j=a+60|0;c[j>>2]=0;l=e+12|0;m=+g[f+12>>2];n=+g[l>>2];o=+g[f+8>>2];p=+g[e+16>>2];q=+g[f>>2]+(m*n-o*p)-+g[d>>2];r=n*o+m*p+ +g[f+4>>2]-+g[d+4>>2];p=+g[d+12>>2];m=+g[d+8>>2];o=q*p+r*m;n=p*r-q*m;m=+g[b+8>>2]+ +g[e+8>>2];e=c[b+148>>2]|0;do if((e|0)>0){d=0;f=0;q=-3.4028234663852886E38;while(1){r=(o-
+g[b+(d<<3)+20>>2])*+g[b+(d<<3)+84>>2]+(n-+g[b+(d<<3)+24>>2])*+g[b+(d<<3)+88>>2];if(r>m){s=19;break}t=r>q;q=t?r:q;f=t?d:f;d=d+1|0;if((d|0)>=(e|0)){s=4;break}}if((s|0)==4){u=f;v=q<1.1920928955078125E-7;break}else if((s|0)==19){i=h;return}}else{u=0;v=1}while(0);s=u+1|0;d=b+(u<<3)+20|0;t=c[d>>2]|0;w=c[d+4>>2]|0;r=(c[k>>2]=t,+g[k>>2]);p=(c[k>>2]=w,+g[k>>2]);d=b+(((s|0)<(e|0)?s:0)<<3)+20|0;s=c[d>>2]|0;e=c[d+4>>2]|0;x=(c[k>>2]=s,+g[k>>2]);y=(c[k>>2]=e,+g[k>>2]);if(v){c[j>>2]=1;c[a+56>>2]=1;v=b+(u<<3)+84|
0;d=c[v+4>>2]|0;z=a+40|0;c[z>>2]=c[v>>2];c[z+4>>2]=d;A=+((r+x)*.5);B=+((p+y)*.5);d=a+48|0;g[d>>2]=A;g[d+4>>2]=B;d=l;z=c[d+4>>2]|0;v=a;c[v>>2]=c[d>>2];c[v+4>>2]=z;c[a+16>>2]=0;i=h;return}B=o-r;A=n-p;C=o-x;D=n-y;if(B*(x-r)+A*(y-p)<=0){if(B*B+A*A>m*m){i=h;return}c[j>>2]=1;c[a+56>>2]=1;z=a+40|0;E=+B;F=+A;v=z;g[v>>2]=E;g[v+4>>2]=F;F=+Q(+(B*B+A*A));if(!(F<1.1920928955078125E-7)){E=1/F;g[z>>2]=B*E;g[a+44>>2]=A*E}z=a+48|0;c[z>>2]=t;c[z+4>>2]=w;w=l;z=c[w+4>>2]|0;t=a;c[t>>2]=c[w>>2];c[t+4>>2]=z;c[a+16>>2]=
0;i=h;return}if(!(C*(r-x)+D*(p-y)<=0)){E=(r+x)*.5;x=(p+y)*.5;z=b+(u<<3)+84|0;if((o-E)*+g[z>>2]+(n-x)*+g[b+(u<<3)+88>>2]>m){i=h;return}c[j>>2]=1;c[a+56>>2]=1;u=z;z=c[u+4>>2]|0;b=a+40|0;c[b>>2]=c[u>>2];c[b+4>>2]=z;n=+E;E=+x;z=a+48|0;g[z>>2]=n;g[z+4>>2]=E;z=l;b=c[z+4>>2]|0;u=a;c[u>>2]=c[z>>2];c[u+4>>2]=b;c[a+16>>2]=0;i=h;return}if(C*C+D*D>m*m){i=h;return}c[j>>2]=1;c[a+56>>2]=1;j=a+40|0;m=+C;E=+D;b=j;g[b>>2]=m;g[b+4>>2]=E;E=+Q(+(C*C+D*D));if(!(E<1.1920928955078125E-7)){m=1/E;g[j>>2]=C*m;g[a+44>>2]=D*
m}j=a+48|0;c[j>>2]=s;c[j+4>>2]=e;e=l;l=c[e+4>>2]|0;j=a;c[j>>2]=c[e>>2];c[j+4>>2]=l;c[a+16>>2]=0;i=h;return}function Ve(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0;b=i;c[a>>2]=-1;d=a+12|0;c[d>>2]=16;c[a+8>>2]=0;e=Pm(576)|0;f=a+4|0;c[f>>2]=e;xn(e|0,0,(c[d>>2]|0)*36|0)|0;e=(c[d>>2]|0)+-1|0;g=c[f>>2]|0;if((e|0)>0){f=0;do{h=f;f=f+1|0;c[g+(h*36|0)+20>>2]=f;c[g+(h*36|0)+32>>2]=-1;h=(c[d>>2]|0)+-1|0}while((f|0)<(h|0));j=h}else j=e;c[g+(j*36|0)+20>>2]=-1;c[g+(((c[d>>2]|0)+-1|0)*36|0)+32>>2]=-1;c[a+16>>2]=0;c[a+
20>>2]=0;c[a+24>>2]=0;i=b;return}function We(a){a=a|0;var b=0;b=i;Qm(c[a+4>>2]|0);i=b;return}function Xe(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;b=i;d=a+16|0;e=c[d>>2]|0;f=a+4|0;g=c[f>>2]|0;if((e|0)==-1){h=a+12|0;j=c[h>>2]|0;c[h>>2]=j<<1;k=Pm(j*72|0)|0;c[f>>2]=k;j=a+8|0;An(k|0,g|0,(c[j>>2]|0)*36|0)|0;Qm(g);k=c[j>>2]|0;l=(c[h>>2]|0)+-1|0;m=c[f>>2]|0;if((k|0)<(l|0)){f=k;do{k=f;f=f+1|0;c[m+(k*36|0)+20>>2]=f;c[m+(k*36|0)+32>>2]=-1;k=(c[h>>2]|0)+-1|0}while((f|0)<(k|0));n=k}else n=
l;c[m+(n*36|0)+20>>2]=-1;c[m+(((c[h>>2]|0)+-1|0)*36|0)+32>>2]=-1;h=c[j>>2]|0;c[d>>2]=h;o=j;p=m;q=h}else{o=a+8|0;p=g;q=e}e=p+(q*36|0)+20|0;c[d>>2]=c[e>>2];c[e>>2]=-1;c[p+(q*36|0)+24>>2]=-1;c[p+(q*36|0)+28>>2]=-1;c[p+(q*36|0)+32>>2]=0;c[p+(q*36|0)+16>>2]=0;c[o>>2]=(c[o>>2]|0)+1;i=b;return q|0}function Ye(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0;e=i;f=Xe(a)|0;h=a+4|0;j=+(+g[b>>2]+-.10000000149011612);k=+(+g[b+4>>2]+-.10000000149011612);l=(c[h>>2]|0)+(f*36|0)|0;g[l>>2]=j;g[l+4>>2]=k;k=+(+g[b+
8>>2]+.10000000149011612);j=+(+g[b+12>>2]+.10000000149011612);b=(c[h>>2]|0)+(f*36|0)+8|0;g[b>>2]=k;g[b+4>>2]=j;c[(c[h>>2]|0)+(f*36|0)+16>>2]=d;c[(c[h>>2]|0)+(f*36|0)+32>>2]=0;Ze(a,f);i=e;return f|0}function Ze(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0;d=i;e=a+24|0;c[e>>2]=(c[e>>2]|0)+1;e=c[a>>2]|0;if((e|0)==-1){c[a>>2]=b;c[(c[a+4>>2]|0)+(b*36|0)+20>>2]=-1;i=d;return}f=a+4|0;h=c[f>>2]|0;j=+g[h+(b*36|0)>>
2];k=+g[h+(b*36|0)+4>>2];l=+g[h+(b*36|0)+8>>2];m=+g[h+(b*36|0)+12>>2];n=c[h+(e*36|0)+24>>2]|0;a:do if((n|0)==-1)o=e;else{p=n;q=e;while(1){r=c[h+(q*36|0)+28>>2]|0;s=+g[h+(q*36|0)+8>>2];t=+g[h+(q*36|0)>>2];u=+g[h+(q*36|0)+12>>2];v=+g[h+(q*36|0)+4>>2];w=((s>l?s:l)-(t<j?t:j)+((u>m?u:m)-(v<k?v:k)))*2;x=w*2;y=(w-(s-t+(u-v))*2)*2;v=+g[h+(p*36|0)>>2];u=j<v?j:v;t=+g[h+(p*36|0)+4>>2];s=k<t?k:t;w=+g[h+(p*36|0)+8>>2];z=l>w?l:w;A=+g[h+(p*36|0)+12>>2];B=m>A?m:A;if((c[h+(p*36|0)+24>>2]|0)==-1)C=(z-u+(B-s))*2;else C=
(z-u+(B-s))*2-(w-v+(A-t))*2;t=y+C;A=+g[h+(r*36|0)>>2];v=j<A?j:A;w=+g[h+(r*36|0)+4>>2];s=k<w?k:w;B=+g[h+(r*36|0)+8>>2];u=l>B?l:B;z=+g[h+(r*36|0)+12>>2];D=m>z?m:z;if((c[h+(r*36|0)+24>>2]|0)==-1)E=(u-v+(D-s))*2;else E=(u-v+(D-s))*2-(B-A+(z-w))*2;w=y+E;if(x<t&x<w){o=q;break a}F=t<w?p:r;p=c[h+(F*36|0)+24>>2]|0;if((p|0)==-1){o=F;break}else q=F}}while(0);e=c[h+(o*36|0)+20>>2]|0;h=Xe(a)|0;n=c[f>>2]|0;c[n+(h*36|0)+20>>2]=e;c[n+(h*36|0)+16>>2]=0;n=c[f>>2]|0;E=+g[n+(o*36|0)>>2];C=+g[n+(o*36|0)+4>>2];w=+(j<E?
j:E);E=+(k<C?k:C);q=n+(h*36|0)|0;g[q>>2]=w;g[q+4>>2]=E;E=+g[n+(o*36|0)+8>>2];w=+g[n+(o*36|0)+12>>2];C=+(l>E?l:E);E=+(m>w?m:w);q=n+(h*36|0)+8|0;g[q>>2]=C;g[q+4>>2]=E;q=c[f>>2]|0;c[q+(h*36|0)+32>>2]=(c[q+(o*36|0)+32>>2]|0)+1;if((e|0)==-1){c[q+(h*36|0)+24>>2]=o;c[q+(h*36|0)+28>>2]=b;c[q+(o*36|0)+20>>2]=h;n=q+(b*36|0)+20|0;c[n>>2]=h;c[a>>2]=h;G=c[n>>2]|0}else{n=q+(e*36|0)+24|0;if((c[n>>2]|0)==(o|0))c[n>>2]=h;else c[q+(e*36|0)+28>>2]=h;c[q+(h*36|0)+24>>2]=o;c[q+(h*36|0)+28>>2]=b;c[q+(o*36|0)+20>>2]=h;
c[q+(b*36|0)+20>>2]=h;G=h}if((G|0)==-1){i=d;return}else H=G;do{G=bf(a,H)|0;h=c[f>>2]|0;b=c[h+(G*36|0)+24>>2]|0;q=c[h+(G*36|0)+28>>2]|0;o=c[h+(b*36|0)+32>>2]|0;e=c[h+(q*36|0)+32>>2]|0;c[h+(G*36|0)+32>>2]=((o|0)>(e|0)?o:e)+1;E=+g[h+(b*36|0)>>2];C=+g[h+(q*36|0)>>2];w=+g[h+(b*36|0)+4>>2];m=+g[h+(q*36|0)+4>>2];l=+(E<C?E:C);C=+(w<m?w:m);e=h+(G*36|0)|0;g[e>>2]=l;g[e+4>>2]=C;C=+g[h+(b*36|0)+8>>2];l=+g[h+(q*36|0)+8>>2];m=+g[h+(b*36|0)+12>>2];w=+g[h+(q*36|0)+12>>2];E=+(C>l?C:l);l=+(m>w?m:w);q=h+(G*36|0)+8|
0;g[q>>2]=E;g[q+4>>2]=l;H=c[(c[f>>2]|0)+(G*36|0)+20>>2]|0}while(!((H|0)==-1));i=d;return}function _e(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=i;$e(a,b);e=a+16|0;f=c[a+4>>2]|0;c[f+(b*36|0)+20>>2]=c[e>>2];c[f+(b*36|0)+32>>2]=-1;c[e>>2]=b;b=a+8|0;c[b>>2]=(c[b>>2]|0)+-1;i=d;return}function $e(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;d=i;if((c[a>>2]|0)==(b|0)){c[a>>2]=-1;i=d;return}e=a+4|0;f=c[e>>2]|0;h=c[f+(b*36|0)+20>>2]|0;j=f+(h*36|0)+20|0;k=c[j>>2]|0;l=c[f+(h*36|0)+24>>2]|
0;if((l|0)==(b|0))m=c[f+(h*36|0)+28>>2]|0;else m=l;if((k|0)==-1){c[a>>2]=m;c[f+(m*36|0)+20>>2]=-1;l=a+16|0;c[j>>2]=c[l>>2];c[f+(h*36|0)+32>>2]=-1;c[l>>2]=h;l=a+8|0;c[l>>2]=(c[l>>2]|0)+-1;i=d;return}l=f+(k*36|0)+24|0;if((c[l>>2]|0)==(h|0))c[l>>2]=m;else c[f+(k*36|0)+28>>2]=m;c[f+(m*36|0)+20>>2]=k;m=a+16|0;c[j>>2]=c[m>>2];c[f+(h*36|0)+32>>2]=-1;c[m>>2]=h;h=a+8|0;c[h>>2]=(c[h>>2]|0)+-1;h=k;do{k=bf(a,h)|0;m=c[e>>2]|0;f=c[m+(k*36|0)+24>>2]|0;j=c[m+(k*36|0)+28>>2]|0;n=+g[m+(f*36|0)>>2];o=+g[m+(j*36|0)>>
2];p=+g[m+(f*36|0)+4>>2];q=+g[m+(j*36|0)+4>>2];r=+(n<o?n:o);o=+(p<q?p:q);l=m+(k*36|0)|0;g[l>>2]=r;g[l+4>>2]=o;o=+g[m+(f*36|0)+8>>2];r=+g[m+(j*36|0)+8>>2];q=+g[m+(f*36|0)+12>>2];p=+g[m+(j*36|0)+12>>2];n=+(o>r?o:r);r=+(q>p?q:p);l=m+(k*36|0)+8|0;g[l>>2]=n;g[l+4>>2]=r;l=c[e>>2]|0;m=c[l+(f*36|0)+32>>2]|0;f=c[l+(j*36|0)+32>>2]|0;c[l+(k*36|0)+32>>2]=((m|0)>(f|0)?m:f)+1;h=c[l+(k*36|0)+20>>2]|0}while(!((h|0)==-1));i=d;return}function af(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,
p=0,q=0,r=0,s=0,t=0,u=0;f=i;h=a+4|0;j=c[h>>2]|0;if(((+g[j+(b*36|0)>>2]<=+g[d>>2]?+g[j+(b*36|0)+4>>2]<=+g[d+4>>2]:0)?+g[d+8>>2]<=+g[j+(b*36|0)+8>>2]:0)?+g[d+12>>2]<=+g[j+(b*36|0)+12>>2]:0){k=0;i=f;return k|0}$e(a,b);j=d;l=+g[j>>2];m=+g[j+4>>2];j=d+8|0;n=+g[j>>2];o=l+-.10000000149011612;l=m+-.10000000149011612;m=n+.10000000149011612;n=+g[j+4>>2]+.10000000149011612;p=+g[e>>2]*2;q=+g[e+4>>2]*2;if(p<0){r=o+p;s=m}else{r=o;s=p+m}if(q<0){t=l+q;u=n}else{t=l;u=q+n}e=c[h>>2]|0;n=+r;r=+t;h=e+(b*36|0)|0;g[h>>
2]=n;g[h+4>>2]=r;r=+s;s=+u;h=e+(b*36|0)+8|0;g[h>>2]=r;g[h+4>>2]=s;Ze(a,b);k=1;i=f;return k|0}function bf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0;d=i;e=c[a+4>>2]|0;f=e+(b*36|0)|0;h=e+(b*36|0)+24|0;j=c[h>>2]|0;if((j|0)==-1){k=b;i=d;return k|0}l=e+(b*36|0)+32|0;if((c[l>>2]|0)<2){k=b;i=d;return k|0}m=e+(b*36|0)+28|0;n=c[m>>2]|0;o=e+(j*36|0)|0;p=e+(n*36|0)|0;q=e+(n*36|0)+32|0;r=e+(j*36|0)+32|0;
s=(c[q>>2]|0)-(c[r>>2]|0)|0;if((s|0)>1){t=e+(n*36|0)+24|0;u=c[t>>2]|0;v=e+(n*36|0)+28|0;w=c[v>>2]|0;x=e+(u*36|0)|0;y=e+(w*36|0)|0;c[t>>2]=b;t=e+(b*36|0)+20|0;z=e+(n*36|0)+20|0;c[z>>2]=c[t>>2];c[t>>2]=n;t=c[z>>2]|0;do if(!((t|0)==-1)){z=e+(t*36|0)+24|0;if((c[z>>2]|0)==(b|0)){c[z>>2]=n;break}else{c[e+(t*36|0)+28>>2]=n;break}}else c[a>>2]=n;while(0);t=e+(u*36|0)+32|0;z=e+(w*36|0)+32|0;if((c[t>>2]|0)>(c[z>>2]|0)){c[v>>2]=u;c[m>>2]=w;c[e+(w*36|0)+20>>2]=b;A=+g[o>>2];B=+g[y>>2];C=A<B?A:B;B=+g[e+(j*36|0)+
4>>2];A=+g[e+(w*36|0)+4>>2];D=+C;E=+(B<A?B:A);F=f;g[F>>2]=D;g[F+4>>2]=E;E=+g[e+(j*36|0)+8>>2];D=+g[e+(w*36|0)+8>>2];A=+g[e+(j*36|0)+12>>2];B=+g[e+(w*36|0)+12>>2];G=+(E>D?E:D);D=+(A>B?A:B);F=e+(b*36|0)+8|0;g[F>>2]=G;g[F+4>>2]=D;D=+g[x>>2];G=+g[e+(b*36|0)+4>>2];B=+g[e+(u*36|0)+4>>2];A=+(C<D?C:D);D=+(G<B?G:B);F=p;g[F>>2]=A;g[F+4>>2]=D;D=+g[e+(b*36|0)+8>>2];A=+g[e+(u*36|0)+8>>2];B=+g[e+(b*36|0)+12>>2];G=+g[e+(u*36|0)+12>>2];C=+(D>A?D:A);A=+(B>G?B:G);F=e+(n*36|0)+8|0;g[F>>2]=C;g[F+4>>2]=A;F=c[r>>2]|0;
H=c[z>>2]|0;I=((F|0)>(H|0)?F:H)+1|0;c[l>>2]=I;H=c[t>>2]|0;J=(I|0)>(H|0)?I:H}else{c[v>>2]=w;c[m>>2]=u;c[e+(u*36|0)+20>>2]=b;A=+g[o>>2];C=+g[x>>2];G=A<C?A:C;C=+g[e+(j*36|0)+4>>2];A=+g[e+(u*36|0)+4>>2];B=+G;D=+(C<A?C:A);x=f;g[x>>2]=B;g[x+4>>2]=D;D=+g[e+(j*36|0)+8>>2];B=+g[e+(u*36|0)+8>>2];A=+g[e+(j*36|0)+12>>2];C=+g[e+(u*36|0)+12>>2];E=+(D>B?D:B);B=+(A>C?A:C);u=e+(b*36|0)+8|0;g[u>>2]=E;g[u+4>>2]=B;B=+g[y>>2];E=+g[e+(b*36|0)+4>>2];C=+g[e+(w*36|0)+4>>2];A=+(G<B?G:B);B=+(E<C?E:C);y=p;g[y>>2]=A;g[y+4>>2]=
B;B=+g[e+(b*36|0)+8>>2];A=+g[e+(w*36|0)+8>>2];C=+g[e+(b*36|0)+12>>2];E=+g[e+(w*36|0)+12>>2];G=+(B>A?B:A);A=+(C>E?C:E);w=e+(n*36|0)+8|0;g[w>>2]=G;g[w+4>>2]=A;w=c[r>>2]|0;y=c[t>>2]|0;t=((w|0)>(y|0)?w:y)+1|0;c[l>>2]=t;y=c[z>>2]|0;J=(t|0)>(y|0)?t:y}c[q>>2]=J+1;k=n;i=d;return k|0}if(!((s|0)<-1)){k=b;i=d;return k|0}s=e+(j*36|0)+24|0;J=c[s>>2]|0;y=e+(j*36|0)+28|0;t=c[y>>2]|0;z=e+(J*36|0)|0;w=e+(t*36|0)|0;c[s>>2]=b;s=e+(b*36|0)+20|0;u=e+(j*36|0)+20|0;c[u>>2]=c[s>>2];c[s>>2]=j;s=c[u>>2]|0;do if(!((s|0)==-1)){u=
e+(s*36|0)+24|0;if((c[u>>2]|0)==(b|0)){c[u>>2]=j;break}else{c[e+(s*36|0)+28>>2]=j;break}}else c[a>>2]=j;while(0);a=e+(J*36|0)+32|0;s=e+(t*36|0)+32|0;if((c[a>>2]|0)>(c[s>>2]|0)){c[y>>2]=J;c[h>>2]=t;c[e+(t*36|0)+20>>2]=b;A=+g[p>>2];G=+g[w>>2];E=A<G?A:G;G=+g[e+(n*36|0)+4>>2];A=+g[e+(t*36|0)+4>>2];C=+E;B=+(G<A?G:A);u=f;g[u>>2]=C;g[u+4>>2]=B;B=+g[e+(n*36|0)+8>>2];C=+g[e+(t*36|0)+8>>2];A=+g[e+(n*36|0)+12>>2];G=+g[e+(t*36|0)+12>>2];D=+(B>C?B:C);C=+(A>G?A:G);u=e+(b*36|0)+8|0;g[u>>2]=D;g[u+4>>2]=C;C=+g[z>>
2];D=+g[e+(b*36|0)+4>>2];G=+g[e+(J*36|0)+4>>2];A=+(E<C?E:C);C=+(D<G?D:G);u=o;g[u>>2]=A;g[u+4>>2]=C;C=+g[e+(b*36|0)+8>>2];A=+g[e+(J*36|0)+8>>2];G=+g[e+(b*36|0)+12>>2];D=+g[e+(J*36|0)+12>>2];E=+(C>A?C:A);A=+(G>D?G:D);u=e+(j*36|0)+8|0;g[u>>2]=E;g[u+4>>2]=A;u=c[q>>2]|0;x=c[s>>2]|0;m=((u|0)>(x|0)?u:x)+1|0;c[l>>2]=m;x=c[a>>2]|0;K=(m|0)>(x|0)?m:x}else{c[y>>2]=t;c[h>>2]=J;c[e+(J*36|0)+20>>2]=b;A=+g[p>>2];E=+g[z>>2];D=A<E?A:E;E=+g[e+(n*36|0)+4>>2];A=+g[e+(J*36|0)+4>>2];G=+D;C=+(E<A?E:A);z=f;g[z>>2]=G;g[z+
4>>2]=C;C=+g[e+(n*36|0)+8>>2];G=+g[e+(J*36|0)+8>>2];A=+g[e+(n*36|0)+12>>2];E=+g[e+(J*36|0)+12>>2];B=+(C>G?C:G);G=+(A>E?A:E);J=e+(b*36|0)+8|0;g[J>>2]=B;g[J+4>>2]=G;G=+g[w>>2];B=+g[e+(b*36|0)+4>>2];E=+g[e+(t*36|0)+4>>2];A=+(D<G?D:G);G=+(B<E?B:E);w=o;g[w>>2]=A;g[w+4>>2]=G;G=+g[e+(b*36|0)+8>>2];A=+g[e+(t*36|0)+8>>2];E=+g[e+(b*36|0)+12>>2];B=+g[e+(t*36|0)+12>>2];D=+(G>A?G:A);A=+(E>B?E:B);t=e+(j*36|0)+8|0;g[t>>2]=D;g[t+4>>2]=A;t=c[q>>2]|0;q=c[a>>2]|0;a=((t|0)>(q|0)?t:q)+1|0;c[l>>2]=a;l=c[s>>2]|0;K=(a|0)>
(l|0)?a:l}c[r>>2]=K+1;k=j;i=d;return k|0}function cf(b,d,e,f,h){b=b|0;d=d|0;e=e|0;f=f|0;h=h|0;var j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0;j=i;l=b+60|0;c[l>>2]=0;m=f+12|0;n=+g[h+12>>2];o=+g[m>>2];p=+g[h+8>>2];q=+g[f+16>>2];r=+g[h>>2]+(n*o-p*q)-+g[e>>2];s=o*p+n*q+ +g[h+4>>2]-+g[e+4>>2];q=+g[e+12>>2];n=+g[e+8>>2];p=r*q+s*n;o=q*s-r*n;e=d+12|0;h=c[e>>2]|0;t=c[e+4>>2]|0;n=(c[k>>2]=h,+g[k>>2]);r=(c[k>>2]=t,+g[k>>2]);e=d+20|0;u=c[e>>2]|0;
v=c[e+4>>2]|0;s=(c[k>>2]=u,+g[k>>2]);q=(c[k>>2]=v,+g[k>>2]);w=s-n;x=q-r;y=w*(s-p)+x*(q-o);z=p-n;A=o-r;B=z*w+A*x;C=+g[d+8>>2]+ +g[f+8>>2];if(B<=0){if(z*z+A*A>C*C){i=j;return}if((a[d+44>>0]|0)!=0?(f=d+28|0,D=+g[f>>2],(n-p)*(n-D)+(r-o)*(r-+g[f+4>>2])>0):0){i=j;return}c[l>>2]=1;c[b+56>>2]=0;g[b+40>>2]=0;g[b+44>>2]=0;f=b+48|0;c[f>>2]=h;c[f+4>>2]=t;f=b+16|0;c[f>>2]=0;a[f>>0]=0;a[f+1>>0]=0;a[f+2>>0]=0;a[f+3>>0]=0;f=m;e=c[f+4>>2]|0;E=b;c[E>>2]=c[f>>2];c[E+4>>2]=e;i=j;return}if(y<=0){D=p-s;F=o-q;if(D*D+F*
F>C*C){i=j;return}if((a[d+45>>0]|0)!=0?(e=d+36|0,G=+g[e>>2],D*(G-s)+F*(+g[e+4>>2]-q)>0):0){i=j;return}c[l>>2]=1;c[b+56>>2]=0;g[b+40>>2]=0;g[b+44>>2]=0;e=b+48|0;c[e>>2]=u;c[e+4>>2]=v;v=b+16|0;c[v>>2]=0;a[v>>0]=1;a[v+1>>0]=0;a[v+2>>0]=0;a[v+3>>0]=0;v=m;e=c[v+4>>2]|0;u=b;c[u>>2]=c[v>>2];c[u+4>>2]=e;i=j;return}F=1/(w*w+x*x);G=p-(n*y+s*B)*F;s=o-(r*y+q*B)*F;if(G*G+s*s>C*C){i=j;return}C=-x;if(w*A+z*C<0){H=x;I=-w}else{H=C;I=w}w=+Q(+(I*I+H*H));if(w<1.1920928955078125E-7){J=H;K=I}else{C=1/w;J=H*C;K=I*C}c[l>>
2]=1;c[b+56>>2]=1;C=+J;J=+K;l=b+40|0;g[l>>2]=C;g[l+4>>2]=J;l=b+48|0;c[l>>2]=h;c[l+4>>2]=t;t=b+16|0;c[t>>2]=0;a[t>>0]=0;a[t+1>>0]=0;a[t+2>>0]=1;a[t+3>>0]=0;t=m;m=c[t+4>>2]|0;l=b;c[l>>2]=c[t>>2];c[l+4>>2]=m;i=j;return}function df(b,d,e,f,h,j){b=b|0;d=d|0;e=e|0;f=f|0;h=h|0;j=j|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=
0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0;l=i;i=i+144|0;m=l+128|0;n=l+24|0;o=l+72|0;p=l+48|0;q=l;r=b+132|0;s=+g[f+12>>2];t=+g[j+8>>2];u=+g[f+8>>2];v=+g[j+12>>2];w=s*t-u*v;x=t*u+s*v;v=+w;t=+x;y=+g[j>>2]-+g[f>>2];z=+g[j+4>>2]-+g[f+4>>2];A=s*y+u*z;B=s*z-u*y;y=+A;u=+B;f=r;g[f>>2]=y;g[f+4>>2]=u;f=b+140|0;g[f>>2]=v;g[f+4>>2]=t;f=b+144|0;t=+g[h+12>>2];j=b+140|0;v=+g[h+16>>2];u=A+(x*t-w*v);C=b+136|0;A=t*w+x*v+B;B=+u;v=+A;D=b+148|0;g[D>>2]=B;g[D+
4>>2]=v;D=e+28|0;E=c[D>>2]|0;F=c[D+4>>2]|0;D=b+156|0;c[D>>2]=E;c[D+4>>2]=F;D=b+164|0;G=e+12|0;H=c[G>>2]|0;I=c[G+4>>2]|0;G=D;c[G>>2]=H;c[G+4>>2]=I;G=b+172|0;J=e+20|0;K=c[J>>2]|0;L=c[J+4>>2]|0;J=G;c[J>>2]=K;c[J+4>>2]=L;J=e+36|0;M=c[J>>2]|0;N=c[J+4>>2]|0;J=b+180|0;c[J>>2]=M;c[J+4>>2]=N;J=(a[e+44>>0]|0)!=0;O=(a[e+45>>0]|0)!=0;v=(c[k>>2]=K,+g[k>>2]);B=(c[k>>2]=H,+g[k>>2]);x=v-B;w=(c[k>>2]=L,+g[k>>2]);L=b+168|0;t=(c[k>>2]=I,+g[k>>2]);y=w-t;z=+Q(+(x*x+y*y));s=(c[k>>2]=E,+g[k>>2]);P=(c[k>>2]=F,+g[k>>2]);
R=(c[k>>2]=M,+g[k>>2]);S=(c[k>>2]=N,+g[k>>2]);if(z<1.1920928955078125E-7){T=x;U=y}else{V=1/z;T=x*V;U=y*V}N=b+196|0;V=-T;g[N>>2]=U;M=b+200|0;g[M>>2]=V;y=(u-B)*U+(A-t)*V;if(J){V=B-s;B=t-P;t=+Q(+(V*V+B*B));if(t<1.1920928955078125E-7){W=V;X=B}else{x=1/t;W=V*x;X=B*x}x=-W;g[b+188>>2]=X;g[b+192>>2]=x;Y=U*W-T*X>=0;Z=(u-s)*X+(A-P)*x}else{Y=0;Z=0}a:do if(!O){if(!J){F=y>=0;a[b+248>>0]=F&1;E=b+212|0;if(F){_=E;$=64;break}else{aa=E;$=65;break}}E=Z>=0;if(Y){if(!E){F=y>=0;a[b+248>>0]=F&1;I=b+212|0;if(F)ba=I;else{x=
+-U;P=+T;F=I;g[F>>2]=x;g[F+4>>2]=P;F=N;I=c[F>>2]|0;H=c[F+4>>2]|0;F=b+228|0;c[F>>2]=I;c[F+4>>2]=H;H=b+236|0;g[H>>2]=-(c[k>>2]=I,+g[k>>2]);g[H+4>>2]=P;break}}else{a[b+248>>0]=1;ba=b+212|0}H=N;I=c[H+4>>2]|0;F=ba;c[F>>2]=c[H>>2];c[F+4>>2]=I;I=b+188|0;F=c[I+4>>2]|0;H=b+228|0;c[H>>2]=c[I>>2];c[H+4>>2]=F;P=+-+g[N>>2];x=+-+g[M>>2];F=b+236|0;g[F>>2]=P;g[F+4>>2]=x;break}else{if(E){E=y>=0;a[b+248>>0]=E&1;F=b+212|0;if(E){E=N;H=c[E>>2]|0;I=c[E+4>>2]|0;E=F;c[E>>2]=H;c[E+4>>2]=I;E=b+228|0;c[E>>2]=H;c[E+4>>2]=I;
x=+-(c[k>>2]=H,+g[k>>2]);P=+T;H=b+236|0;g[H>>2]=x;g[H+4>>2]=P;break}else ca=F}else{a[b+248>>0]=0;ca=b+212|0}P=+-U;x=+T;F=ca;g[F>>2]=P;g[F+4>>2]=x;F=N;H=c[F+4>>2]|0;I=b+228|0;c[I>>2]=c[F>>2];c[I+4>>2]=H;x=+-+g[b+188>>2];P=+-+g[b+192>>2];H=b+236|0;g[H>>2]=x;g[H+4>>2]=P;break}}else{P=R-v;x=S-w;X=+Q(+(P*P+x*x));if(X<1.1920928955078125E-7){da=P;ea=x}else{s=1/X;da=P*s;ea=x*s}s=-da;H=b+204|0;g[H>>2]=ea;I=b+208|0;g[I>>2]=s;F=T*ea-U*da>0;x=(u-v)*ea+(A-w)*s;if(!J){E=y>=0;if(!O){a[b+248>>0]=E&1;K=b+212|0;if(E){_=
K;$=64;break}else{aa=K;$=65;break}}if(F){if(!E){K=x>=0;a[b+248>>0]=K&1;e=b+212|0;if(K)fa=e;else{s=+-U;P=+T;K=e;g[K>>2]=s;g[K+4>>2]=P;K=b+228|0;g[K>>2]=s;g[K+4>>2]=P;K=N;e=c[K+4>>2]|0;ga=b+236|0;c[ga>>2]=c[K>>2];c[ga+4>>2]=e;break}}else{a[b+248>>0]=1;fa=b+212|0}e=N;ga=c[e+4>>2]|0;K=fa;c[K>>2]=c[e>>2];c[K+4>>2]=ga;P=+-+g[N>>2];s=+-+g[M>>2];ga=b+228|0;g[ga>>2]=P;g[ga+4>>2]=s;ga=b+204|0;K=c[ga+4>>2]|0;e=b+236|0;c[e>>2]=c[ga>>2];c[e+4>>2]=K;break}else{if(E){E=x>=0;a[b+248>>0]=E&1;K=b+212|0;if(E){E=N;e=
c[E>>2]|0;ga=c[E+4>>2]|0;E=K;c[E>>2]=e;c[E+4>>2]=ga;s=+-(c[k>>2]=e,+g[k>>2]);P=+T;E=b+228|0;g[E>>2]=s;g[E+4>>2]=P;E=b+236|0;c[E>>2]=e;c[E+4>>2]=ga;break}else ha=K}else{a[b+248>>0]=0;ha=b+212|0}P=+-U;s=+T;K=ha;g[K>>2]=P;g[K+4>>2]=s;s=+-+g[b+204>>2];P=+-+g[b+208>>2];K=b+228|0;g[K>>2]=s;g[K+4>>2]=P;K=N;ga=c[K+4>>2]|0;E=b+236|0;c[E>>2]=c[K>>2];c[E+4>>2]=ga;break}}if(Y&F){if(!(Z>=0)&!(y>=0)){ga=x>=0;a[b+248>>0]=ga&1;E=b+212|0;if(ga)ia=E;else{P=+-U;s=+T;ga=E;g[ga>>2]=P;g[ga+4>>2]=s;ga=b+228|0;g[ga>>2]=
P;g[ga+4>>2]=s;ga=b+236|0;g[ga>>2]=P;g[ga+4>>2]=s;break}}else{a[b+248>>0]=1;ia=b+212|0}ga=N;E=c[ga+4>>2]|0;K=ia;c[K>>2]=c[ga>>2];c[K+4>>2]=E;E=b+188|0;K=c[E+4>>2]|0;ga=b+228|0;c[ga>>2]=c[E>>2];c[ga+4>>2]=K;K=b+204|0;ga=c[K+4>>2]|0;E=b+236|0;c[E>>2]=c[K>>2];c[E+4>>2]=ga;break}if(Y){do if(!(Z>=0)){if(y>=0){ga=x>=0;a[b+248>>0]=ga&1;E=b+212|0;if(ga){ja=E;break}else ka=E}else{a[b+248>>0]=0;ka=b+212|0}s=+-U;P=+T;E=ka;g[E>>2]=s;g[E+4>>2]=P;P=+-+g[H>>2];s=+-+g[I>>2];E=b+228|0;g[E>>2]=P;g[E+4>>2]=s;s=+-+g[N>>
2];P=+-+g[M>>2];E=b+236|0;g[E>>2]=s;g[E+4>>2]=P;break a}else{a[b+248>>0]=1;ja=b+212|0}while(0);E=N;ga=c[E+4>>2]|0;K=ja;c[K>>2]=c[E>>2];c[K+4>>2]=ga;ga=b+188|0;K=c[ga+4>>2]|0;E=b+228|0;c[E>>2]=c[ga>>2];c[E+4>>2]=K;K=N;E=c[K+4>>2]|0;ga=b+236|0;c[ga>>2]=c[K>>2];c[ga+4>>2]=E;break}if(!F){if(!(!(Z>=0)|!(y>=0))){E=x>=0;a[b+248>>0]=E&1;ga=b+212|0;if(E){E=N;K=c[E>>2]|0;e=c[E+4>>2]|0;E=ga;c[E>>2]=K;c[E+4>>2]=e;E=b+228|0;c[E>>2]=K;c[E+4>>2]=e;E=b+236|0;c[E>>2]=K;c[E+4>>2]=e;break}else la=ga}else{a[b+248>>0]=
0;la=b+212|0}P=+-U;s=+T;ga=la;g[ga>>2]=P;g[ga+4>>2]=s;s=+-+g[H>>2];P=+-+g[I>>2];ga=b+228|0;g[ga>>2]=s;g[ga+4>>2]=P;P=+-+g[b+188>>2];s=+-+g[b+192>>2];ga=b+236|0;g[ga>>2]=P;g[ga+4>>2]=s;break}do if(!(x>=0)){if(Z>=0){ga=y>=0;a[b+248>>0]=ga&1;e=b+212|0;if(ga){ma=e;break}else na=e}else{a[b+248>>0]=0;na=b+212|0}s=+-U;P=+T;e=na;g[e>>2]=s;g[e+4>>2]=P;P=+-+g[N>>2];s=+-+g[M>>2];e=b+228|0;g[e>>2]=P;g[e+4>>2]=s;s=+-+g[b+188>>2];P=+-+g[b+192>>2];e=b+236|0;g[e>>2]=s;g[e+4>>2]=P;break a}else{a[b+248>>0]=1;ma=b+
212|0}while(0);I=N;H=c[I+4>>2]|0;F=ma;c[F>>2]=c[I>>2];c[F+4>>2]=H;H=N;F=c[H+4>>2]|0;I=b+228|0;c[I>>2]=c[H>>2];c[I+4>>2]=F;F=b+204|0;I=c[F+4>>2]|0;H=b+236|0;c[H>>2]=c[F>>2];c[H+4>>2]=I}while(0);if(($|0)==64){ma=N;na=c[ma>>2]|0;la=c[ma+4>>2]|0;ma=_;c[ma>>2]=na;c[ma+4>>2]=la;y=+-(c[k>>2]=na,+g[k>>2]);Z=+T;na=b+228|0;g[na>>2]=y;g[na+4>>2]=Z;na=b+236|0;g[na>>2]=y;g[na+4>>2]=Z}else if(($|0)==65){Z=+-U;U=+T;na=aa;g[na>>2]=Z;g[na+4>>2]=U;na=N;aa=c[na>>2]|0;la=c[na+4>>2]|0;na=b+228|0;c[na>>2]=aa;c[na+4>>2]=
la;na=b+236|0;c[na>>2]=aa;c[na+4>>2]=la}la=h+148|0;na=b+128|0;c[na>>2]=c[la>>2];if((c[la>>2]|0)>0){aa=0;do{U=+g[f>>2];Z=+g[h+(aa<<3)+20>>2];T=+g[j>>2];y=+g[h+(aa<<3)+24>>2];w=+(+g[r>>2]+(U*Z-T*y));A=+(Z*T+U*y+ +g[C>>2]);ma=b+(aa<<3)|0;g[ma>>2]=w;g[ma+4>>2]=A;A=+g[f>>2];w=+g[h+(aa<<3)+84>>2];y=+g[j>>2];U=+g[h+(aa<<3)+88>>2];T=+(A*w-y*U);Z=+(w*y+A*U);ma=b+(aa<<3)+64|0;g[ma>>2]=T;g[ma+4>>2]=Z;aa=aa+1|0}while((aa|0)<(c[la>>2]|0))}la=b+244|0;g[la>>2]=.019999999552965164;aa=d+60|0;c[aa>>2]=0;ma=b+248|0;
_=c[na>>2]|0;if((_|0)<=0){i=l;return}Z=+g[b+164>>2];T=+g[L>>2];U=+g[b+212>>2];A=+g[b+216>>2];y=3.4028234663852886E38;L=0;do{w=U*(+g[b+(L<<3)>>2]-Z)+A*(+g[b+(L<<3)+4>>2]-T);y=w<y?w:y;L=L+1|0}while((L|0)!=(_|0));if(y>.019999999552965164){i=l;return}ef(m,b);_=c[m>>2]|0;if((_|0)!=0){T=+g[m+8>>2];if(T>+g[la>>2]){i=l;return}if(T>y*.9800000190734863+.0010000000474974513){L=c[m+4>>2]|0;m=d+56|0;if((_|0)==1){oa=n;pa=m;$=77}else{c[m>>2]=2;m=D;_=c[m+4>>2]|0;ja=n;c[ja>>2]=c[m>>2];c[ja+4>>2]=_;_=n+8|0;a[_>>0]=
0;ja=L&255;a[_+1>>0]=ja;a[_+2>>0]=0;a[_+3>>0]=1;_=G;m=c[_+4>>2]|0;ka=n+12|0;c[ka>>2]=c[_>>2];c[ka+4>>2]=m;m=n+20|0;a[m>>0]=0;a[m+1>>0]=ja;a[m+2>>0]=0;a[m+3>>0]=1;c[o>>2]=L;m=L+1|0;ja=(m|0)<(c[na>>2]|0)?m:0;c[o+4>>2]=ja;m=b+(L<<3)|0;ka=c[m>>2]|0;_=c[m+4>>2]|0;m=o+8|0;c[m>>2]=ka;c[m+4>>2]=_;m=b+(ja<<3)|0;ja=c[m>>2]|0;Y=c[m+4>>2]|0;m=o+16|0;c[m>>2]=ja;c[m+4>>2]=Y;m=b+(L<<3)+64|0;ia=c[m>>2]|0;ha=c[m+4>>2]|0;m=o+24|0;c[m>>2]=ia;c[m+4>>2]=ha;qa=Y;ra=ja;sa=_;ta=ka;ua=ia;va=ha;wa=n;xa=L;ya=0}}else $=75}else $=
75;if(($|0)==75){oa=n;pa=d+56|0;$=77}do if(($|0)==77){c[pa>>2]=1;L=c[na>>2]|0;if((L|0)>1){y=+g[b+216>>2];T=+g[b+212>>2];ha=0;A=T*+g[b+64>>2]+y*+g[b+68>>2];ia=1;while(1){Z=T*+g[b+(ia<<3)+64>>2]+y*+g[b+(ia<<3)+68>>2];ka=Z<A;_=ka?ia:ha;ia=ia+1|0;if((ia|0)>=(L|0)){za=_;break}else{ha=_;A=ka?Z:A}}}else za=0;ha=za+1|0;ia=(ha|0)<(L|0)?ha:0;ha=b+(za<<3)|0;ka=c[ha+4>>2]|0;_=n;c[_>>2]=c[ha>>2];c[_+4>>2]=ka;ka=n+8|0;a[ka>>0]=0;a[ka+1>>0]=za;a[ka+2>>0]=1;a[ka+3>>0]=0;ka=b+(ia<<3)|0;_=c[ka+4>>2]|0;ha=n+12|0;c[ha>>
2]=c[ka>>2];c[ha+4>>2]=_;_=n+20|0;a[_>>0]=0;a[_+1>>0]=ia;a[_+2>>0]=1;a[_+3>>0]=0;if((a[ma>>0]|0)==0){c[o>>2]=1;c[o+4>>2]=0;_=G;ia=c[_>>2]|0;ha=c[_+4>>2]|0;_=o+8|0;c[_>>2]=ia;c[_+4>>2]=ha;_=D;ka=c[_>>2]|0;ja=c[_+4>>2]|0;_=o+16|0;c[_>>2]=ka;c[_+4>>2]=ja;_=(g[k>>2]=-+g[N>>2],c[k>>2]|0);Y=(g[k>>2]=-+g[M>>2],c[k>>2]|0);m=o+24|0;c[m>>2]=_;c[m+4>>2]=Y;qa=ja;ra=ka;sa=ha;ta=ia;ua=_;va=Y;wa=oa;xa=1;ya=1;break}else{c[o>>2]=0;c[o+4>>2]=1;Y=D;_=c[Y>>2]|0;ia=c[Y+4>>2]|0;Y=o+8|0;c[Y>>2]=_;c[Y+4>>2]=ia;Y=G;ha=c[Y>>
2]|0;ka=c[Y+4>>2]|0;Y=o+16|0;c[Y>>2]=ha;c[Y+4>>2]=ka;Y=N;ja=c[Y>>2]|0;m=c[Y+4>>2]|0;Y=o+24|0;c[Y>>2]=ja;c[Y+4>>2]=m;qa=ka;ra=ha;sa=ia;ta=_;ua=ja;va=m;wa=oa;xa=0;ya=1;break}}while(0);A=(c[k>>2]=va,+g[k>>2]);y=(c[k>>2]=ua,+g[k>>2]);T=(c[k>>2]=ta,+g[k>>2]);Z=(c[k>>2]=sa,+g[k>>2]);U=(c[k>>2]=ra,+g[k>>2]);w=(c[k>>2]=qa,+g[k>>2]);qa=o+32|0;ra=o+24|0;sa=o+28|0;ea=-y;g[qa>>2]=A;g[o+36>>2]=ea;ta=o+44|0;y=-A;va=ta;g[va>>2]=y;c[va+4>>2]=ua;va=o+8|0;oa=o+12|0;v=A*T+Z*ea;g[o+40>>2]=v;N=o+52|0;g[N>>2]=U*y+(c[k>>
2]=ua,+g[k>>2])*w;if((kf(p,wa,qa,v,xa)|0)<2){i=l;return}if((kf(q,p,ta,+g[N>>2],c[o+4>>2]|0)|0)<2){i=l;return}N=d+40|0;if(ya){ya=ra;ta=c[ya>>2]|0;p=c[ya+4>>2]|0;ya=N;c[ya>>2]=ta;c[ya+4>>2]=p;p=va;ya=c[p>>2]|0;xa=c[p+4>>2]|0;p=d+48|0;c[p>>2]=ya;c[p+4>>2]=xa;v=(c[k>>2]=ya,+g[k>>2]);w=(c[k>>2]=ta,+g[k>>2]);y=+g[oa>>2];U=+g[sa>>2];ea=+g[q>>2];Z=+g[q+4>>2];T=+g[la>>2];if(!((ea-v)*w+(Z-y)*U<=T)){Aa=T;Ba=0}else{T=ea-+g[r>>2];ea=Z-+g[C>>2];Z=+g[f>>2];A=+g[j>>2];u=+(T*Z+ea*A);da=+(Z*ea-T*A);ta=d;g[ta>>2]=u;
g[ta+4>>2]=da;c[d+16>>2]=c[q+8>>2];Aa=+g[la>>2];Ba=1}da=+g[q+12>>2];u=+g[q+16>>2];if(!((da-v)*w+(u-y)*U<=Aa))Ca=Ba;else{Aa=da-+g[r>>2];da=u-+g[C>>2];u=+g[f>>2];U=+g[j>>2];y=+(Aa*u+da*U);w=+(u*da-Aa*U);j=d+(Ba*20|0)|0;g[j>>2]=y;g[j+4>>2]=w;c[d+(Ba*20|0)+16>>2]=c[q+20>>2];Ca=Ba+1|0}}else{Ba=c[o>>2]|0;o=h+(Ba<<3)+84|0;j=c[o+4>>2]|0;f=N;c[f>>2]=c[o>>2];c[f+4>>2]=j;j=h+(Ba<<3)+20|0;Ba=c[j+4>>2]|0;h=d+48|0;c[h>>2]=c[j>>2];c[h+4>>2]=Ba;w=+g[va>>2];y=+g[ra>>2];U=+g[oa>>2];Aa=+g[sa>>2];da=+g[la>>2];if(!((+g[q>>
2]-w)*y+(+g[q+4>>2]-U)*Aa<=da)){Da=da;Ea=0}else{sa=q;oa=c[sa+4>>2]|0;ra=d;c[ra>>2]=c[sa>>2];c[ra+4>>2]=oa;oa=q+8|0;ra=d+16|0;a[ra+2>>0]=a[oa+3>>0]|0;a[ra+3>>0]=a[oa+2>>0]|0;a[ra>>0]=a[oa+1>>0]|0;a[ra+1>>0]=a[oa>>0]|0;Da=+g[la>>2];Ea=1}la=q+12|0;if(!((+g[la>>2]-w)*y+(+g[q+16>>2]-U)*Aa<=Da))Ca=Ea;else{oa=la;la=c[oa+4>>2]|0;ra=d+(Ea*20|0)|0;c[ra>>2]=c[oa>>2];c[ra+4>>2]=la;la=q+20|0;q=d+(Ea*20|0)+16|0;a[q+2>>0]=a[la+3>>0]|0;a[q+3>>0]=a[la+2>>0]|0;a[q>>0]=a[la+1>>0]|0;a[q+1>>0]=a[la>>0]|0;Ca=Ea+1|0}}c[aa>>
2]=Ca;i=l;return}function ef(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0;d=i;c[a>>2]=0;e=a+4|0;c[e>>2]=-1;f=a+8|0;g[f>>2]=-3.4028234663852886E38;h=+g[b+216>>2];j=+g[b+212>>2];k=c[b+128>>2]|0;if((k|0)<=0){i=d;return}l=+g[b+164>>2];m=+g[b+168>>2];n=+g[b+172>>2];o=+g[b+176>>2];p=+g[b+244>>2];q=b+228|0;r=b+232|0;s=b+236|0;t=b+240|0;u=-3.4028234663852886E38;v=0;while(1){w=+g[b+(v<<3)+64>>2];x=-w;y=-+g[b+(v<<3)+68>>
2];z=+g[b+(v<<3)>>2];A=+g[b+(v<<3)+4>>2];B=(z-l)*x+(A-m)*y;C=(z-n)*x+(A-o)*y;D=B<C?B:C;if(D>p)break;if(!(h*w+j*y>=0))if(D>u?!((x-+g[q>>2])*j+(y-+g[r>>2])*h<-.03490658849477768):0)E=8;else F=u;else if(D>u?!((x-+g[s>>2])*j+(y-+g[t>>2])*h<-.03490658849477768):0)E=8;else F=u;if((E|0)==8){E=0;c[a>>2]=2;c[e>>2]=v;g[f>>2]=D;F=D}G=v+1|0;if((G|0)<(k|0)){u=F;v=G}else{E=10;break}}if((E|0)==10){i=d;return}c[a>>2]=2;c[e>>2]=v;g[f>>2]=D;i=d;return}function ff(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0;f=
i;i=i+256|0;df(f,a,b,c,d,e);i=f;return}function gf(b,d,e,f,h){b=b|0;d=d|0;e=e|0;f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,S=0,T=0,U=0,V=0,W=0;j=i;i=i+96|0;k=j+92|0;l=j+88|0;m=j;n=j+80|0;o=j+56|0;p=j+32|0;q=j+24|0;r=b+60|0;c[r>>2]=0;s=+g[d+8>>2]+ +g[f+8>>2];c[k>>2]=0;t=+hf(k,d,e,f,h);if(t>s){i=j;return}c[l>>2]=0;u=+hf(l,f,h,d,e);if(u>s){i=j;return}if(u>t+5.000000237487257E-4){t=+g[h>>2];u=
+g[h+4>>2];v=+g[h+8>>2];w=+g[h+12>>2];x=+g[e>>2];y=+g[e+4>>2];z=+g[e+8>>2];A=+g[e+12>>2];B=c[l>>2]|0;c[b+56>>2]=2;C=t;D=u;E=w;F=v;G=A;H=z;I=x;J=y;K=B;L=1;M=f;N=d}else{y=+g[e>>2];x=+g[e+4>>2];z=+g[e+8>>2];A=+g[e+12>>2];v=+g[h>>2];w=+g[h+4>>2];u=+g[h+8>>2];t=+g[h+12>>2];h=c[k>>2]|0;c[b+56>>2]=1;C=y;D=x;E=A;F=z;G=t;H=u;I=v;J=w;K=h;L=0;M=d;N=f}f=c[N+148>>2]|0;w=+g[M+(K<<3)+84>>2];v=+g[M+(K<<3)+88>>2];u=E*w-F*v;t=F*w+E*v;v=G*u+H*t;w=G*t-H*u;if((f|0)>0){d=0;h=0;u=3.4028234663852886E38;while(1){t=v*+g[N+
(d<<3)+84>>2]+w*+g[N+(d<<3)+88>>2];k=t<u;e=k?d:h;d=d+1|0;if((d|0)==(f|0)){O=e;break}else{h=e;u=k?t:u}}}else O=0;h=O+1|0;d=(h|0)<(f|0)?h:0;u=+g[N+(O<<3)+20>>2];w=+g[N+(O<<3)+24>>2];v=+(I+(G*u-H*w));t=+(J+(H*u+G*w));h=m;g[h>>2]=v;g[h+4>>2]=t;h=K&255;f=m+8|0;a[f>>0]=h;a[f+1>>0]=O;a[f+2>>0]=1;a[f+3>>0]=0;t=+g[N+(d<<3)+20>>2];v=+g[N+(d<<3)+24>>2];w=+(I+(G*t-H*v));u=+(J+(H*t+G*v));N=m+12|0;g[N>>2]=w;g[N+4>>2]=u;N=m+20|0;a[N>>0]=h;a[N+1>>0]=d;a[N+2>>0]=1;a[N+3>>0]=0;N=K+1|0;d=(N|0)<(c[M+148>>2]|0)?N:0;N=
M+(K<<3)+20|0;u=+g[N>>2];w=+g[N+4>>2];N=M+(d<<3)+20|0;v=+g[N>>2];t=+g[N+4>>2];z=v-u;A=t-w;x=+Q(+(z*z+A*A));if(x<1.1920928955078125E-7){P=z;R=A}else{y=1/x;P=z*y;R=A*y}y=E*P-F*R;A=E*R+F*P;g[n>>2]=y;g[n+4>>2]=A;z=-y;x=C+(E*u-F*w);S=D+(F*u+E*w);T=x*A+S*z;g[q>>2]=z;g[q+4>>2]=-A;if((kf(o,m,q,s-(x*y+S*A),K)|0)<2){i=j;return}if((kf(p,o,n,s+((C+(E*v-F*t))*y+(D+(F*v+E*t))*A),d)|0)<2){i=j;return}E=+R;R=+-P;d=b+40|0;g[d>>2]=E;g[d+4>>2]=R;R=+((u+v)*.5);v=+((w+t)*.5);d=b+48|0;g[d>>2]=R;g[d+4>>2]=v;v=+g[p>>2];R=
+g[p+4>>2];d=!(A*v+R*z-T<=s);if(L<<24>>24==0){if(d)U=0;else{t=v-I;w=R-J;u=+(G*t+H*w);E=+(G*w-H*t);L=b;g[L>>2]=u;g[L+4>>2]=E;c[b+16>>2]=c[p+8>>2];U=1}E=+g[p+12>>2];u=+g[p+16>>2];if(!(A*E+u*z-T<=s))V=U;else{t=E-I;E=u-J;u=+(G*t+H*E);w=+(G*E-H*t);L=b+(U*20|0)|0;g[L>>2]=u;g[L+4>>2]=w;c[b+(U*20|0)+16>>2]=c[p+20>>2];V=U+1|0}}else{if(d)W=0;else{w=v-I;v=R-J;R=+(G*w+H*v);u=+(G*v-H*w);d=b;g[d>>2]=R;g[d+4>>2]=u;d=b+16|0;U=c[p+8>>2]|0;c[d>>2]=U;a[d>>0]=U>>>8;a[d+1>>0]=U;a[d+2>>0]=U>>>24;a[d+3>>0]=U>>>16;W=1}u=
+g[p+12>>2];R=+g[p+16>>2];if(!(A*u+R*z-T<=s))V=W;else{s=u-I;I=R-J;J=+(G*s+H*I);R=+(G*I-H*s);U=b+(W*20|0)|0;g[U>>2]=J;g[U+4>>2]=R;U=b+(W*20|0)+16|0;b=c[p+20>>2]|0;c[U>>2]=b;a[U>>0]=b>>>8;a[U+1>>0]=b;a[U+2>>0]=b>>>24;a[U+3>>0]=b>>>16;V=W+1|0}}c[r>>2]=V;i=j;return}function hf(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0;h=i;j=c[b+148>>2]|0;k=c[e+148>>2]|0;l=+g[f+12>>2];m=+g[d+8>>2];n=+g[f+8>>2];o=+g[d+12>>2];p=l*m-n*o;q=
m*n+l*o;o=+g[d>>2]-+g[f>>2];m=+g[d+4>>2]-+g[f+4>>2];r=l*o+n*m;s=l*m-n*o;if((j|0)<=0){t=0;u=-3.4028234663852886E38;c[a>>2]=t;i=h;return+u}if((k|0)>0){v=0;w=0;x=-3.4028234663852886E38}else{f=0;d=0;o=-3.4028234663852886E38;while(1){y=o<3.4028234663852886E38;n=y?3.4028234663852886E38:o;z=y?d:f;d=d+1|0;if((d|0)==(j|0)){t=z;u=n;break}else{f=z;o=n}}c[a>>2]=t;i=h;return+u}while(1){o=+g[b+(w<<3)+84>>2];n=+g[b+(w<<3)+88>>2];m=q*o-p*n;l=p*o+q*n;n=+g[b+(w<<3)+20>>2];o=+g[b+(w<<3)+24>>2];A=r+(q*n-p*o);B=s+(p*
n+q*o);f=0;o=3.4028234663852886E38;do{n=m*(+g[e+(f<<3)+20>>2]-A)+l*(+g[e+(f<<3)+24>>2]-B);o=n<o?n:o;f=f+1|0}while((f|0)!=(k|0));f=o>x;B=f?o:x;d=f?w:v;w=w+1|0;if((w|0)==(j|0)){t=d;u=B;break}else{v=d;x=B}}c[a>>2]=t;i=h;return+u}function jf(a,b,d,e,f,h){a=a|0;b=b|0;d=d|0;e=+e;f=f|0;h=+h;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0;j=i;k=b+60|0;if((c[k>>2]|0)==0){i=j;return}l=c[b+56>>2]|0;if((l|0)==2){m=f+12|0;n=+g[m>>2];o=+g[b+40>>2];p=f+8|0;
q=+g[p>>2];r=+g[b+44>>2];s=n*o-q*r;t=o*q+n*r;r=+s;n=+t;u=a;g[u>>2]=r;g[u+4>>2]=n;n=+g[m>>2];r=+g[b+48>>2];q=+g[p>>2];o=+g[b+52>>2];v=+g[f>>2]+(n*r-q*o);w=r*q+n*o+ +g[f+4>>2];if((c[k>>2]|0)>0){p=d+12|0;m=d+8|0;u=d+4|0;x=a+4|0;o=s;n=t;y=0;while(1){q=+g[p>>2];r=+g[b+(y*20|0)>>2];z=+g[m>>2];A=+g[b+(y*20|0)+4>>2];B=+g[d>>2]+(q*r-z*A);C=r*z+q*A+ +g[u>>2];A=h-(o*(B-v)+(C-w)*n);q=B+o*A;z=C+n*A;A=B-o*e;B=C-n*e;C=+((A+q)*.5);r=+((B+z)*.5);D=a+(y<<3)+8|0;g[D>>2]=C;g[D+4>>2]=r;g[a+(y<<2)+24>>2]=+g[a>>2]*(A-q)+
+g[x>>2]*(B-z);y=y+1|0;z=+g[a>>2];B=+g[x>>2];if((y|0)>=(c[k>>2]|0)){E=z;F=B;break}else{o=z;n=B}}}else{E=s;F=t}t=+-E;E=+-F;y=a;g[y>>2]=t;g[y+4>>2]=E;i=j;return}else if((l|0)==0){g[a>>2]=1;y=a+4|0;g[y>>2]=0;E=+g[d+12>>2];t=+g[b+48>>2];F=+g[d+8>>2];s=+g[b+52>>2];n=+g[d>>2]+(E*t-F*s);o=t*F+E*s+ +g[d+4>>2];s=+g[f+12>>2];E=+g[b>>2];F=+g[f+8>>2];t=+g[b+4>>2];w=+g[f>>2]+(s*E-F*t);v=E*F+s*t+ +g[f+4>>2];t=n-w;s=o-v;if(t*t+s*s>1.4210854715202004E-14){s=w-n;t=v-o;F=+s;E=+t;x=a;g[x>>2]=F;g[x+4>>2]=E;E=+Q(+(s*
s+t*t));if(E<1.1920928955078125E-7){G=s;H=t}else{F=1/E;E=s*F;g[a>>2]=E;s=t*F;g[y>>2]=s;G=E;H=s}}else{G=1;H=0}s=n+G*e;n=o+H*e;o=w-G*h;w=v-H*h;v=+((s+o)*.5);E=+((n+w)*.5);y=a+8|0;g[y>>2]=v;g[y+4>>2]=E;g[a+24>>2]=G*(o-s)+H*(w-n);i=j;return}else if((l|0)==1){l=d+12|0;n=+g[l>>2];w=+g[b+40>>2];y=d+8|0;H=+g[y>>2];s=+g[b+44>>2];o=n*w-H*s;G=w*H+n*s;s=+o;n=+G;x=a;g[x>>2]=s;g[x+4>>2]=n;n=+g[l>>2];s=+g[b+48>>2];H=+g[y>>2];w=+g[b+52>>2];E=+g[d>>2]+(n*s-H*w);v=s*H+n*w+ +g[d+4>>2];if((c[k>>2]|0)<=0){i=j;return}d=
f+12|0;y=f+8|0;l=f+4|0;x=a+4|0;w=o;o=G;u=0;while(1){G=+g[d>>2];n=+g[b+(u*20|0)>>2];H=+g[y>>2];s=+g[b+(u*20|0)+4>>2];F=+g[f>>2]+(G*n-H*s);t=n*H+G*s+ +g[l>>2];s=e-(w*(F-E)+(t-v)*o);G=F+w*s;H=t+o*s;s=F-w*h;F=t-o*h;t=+((s+G)*.5);n=+((F+H)*.5);m=a+(u<<3)+8|0;g[m>>2]=t;g[m+4>>2]=n;g[a+(u<<2)+24>>2]=+g[a>>2]*(s-G)+ +g[x>>2]*(F-H);m=u+1|0;if((m|0)>=(c[k>>2]|0))break;w=+g[a>>2];o=+g[x>>2];u=m}i=j;return}else{i=j;return}}function kf(b,d,e,f,h){b=b|0;d=d|0;e=e|0;f=+f;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=
0,r=0,s=0,t=0,u=0;j=i;k=+g[e>>2];l=+g[e+4>>2];e=d+4|0;m=k*+g[d>>2]+l*+g[e>>2]-f;n=d+12|0;o=d+16|0;p=k*+g[n>>2]+l*+g[o>>2]-f;if(!(m<=0))q=0;else{c[b+0>>2]=c[d+0>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];q=1}if(!(p<=0))r=q;else{s=q+1|0;t=b+(q*12|0)|0;c[t+0>>2]=c[n+0>>2];c[t+4>>2]=c[n+4>>2];c[t+8>>2]=c[n+8>>2];r=s}if(!(m*p<0)){u=r;i=j;return u|0}f=m/(m-p);p=+g[d>>2];m=+g[e>>2];l=+(p+f*(+g[n>>2]-p));p=+(m+f*(+g[o>>2]-m));o=b+(r*12|0)|0;g[o>>2]=l;g[o+4>>2]=p;o=b+(r*12|0)+8|0;a[o>>0]=h;a[o+1>>0]=a[d+
9>>0]|0;a[o+2>>0]=0;a[o+3>>0]=1;u=r+1|0;i=j;return u|0}function lf(d,e,f,h,j,k){d=d|0;e=e|0;f=f|0;h=h|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0;l=i;i=i+128|0;m=l+36|0;n=l+24|0;o=l;c[m+16>>2]=0;c[m+20>>2]=0;g[m+24>>2]=0;c[m+44>>2]=0;c[m+48>>2]=0;g[m+52>>2]=0;be(m,d,e);be(m+28|0,f,h);h=m+56|0;c[h+0>>2]=c[j+0>>2];c[h+4>>2]=c[j+4>>2];c[h+8>>2]=c[j+8>>2];c[h+12>>2]=c[j+12>>2];j=m+72|0;c[j+0>>2]=c[k+0>>2];c[j+4>>2]=c[k+4>>2];c[j+8>>2]=c[k+8>>2];c[j+12>>2]=c[k+12>>2];a[m+88>>0]=1;b[n+4>>1]=0;de(o,n,m);i=l;return+g[o+
16>>2]<1.1920928955078125E-6|0}function mf(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0;h=i;j=a+40|0;c[j>>2]=b;c[a+44>>2]=d;c[a+48>>2]=e;c[a+28>>2]=0;c[a+36>>2]=0;c[a+32>>2]=0;c[a>>2]=f;c[a+4>>2]=g;c[a+8>>2]=Ym(f,b<<2)|0;c[a+12>>2]=Ym(c[a>>2]|0,d<<2)|0;c[a+16>>2]=Ym(c[a>>2]|0,e<<2)|0;c[a+24>>2]=Ym(c[a>>2]|0,(c[j>>2]|0)*12|0)|0;c[a+20>>2]=Ym(c[a>>2]|0,(c[j>>2]|0)*12|0)|0;i=h;return}function nf(a){a=a|0;var b=0;b=i;_m(c[a>>2]|0,c[a+20>>2]|0);_m(c[a>>2]|0,c[a+24>>2]|0);_m(c[a>>2]|0,c[a+
16>>2]|0);_m(c[a>>2]|0,c[a+12>>2]|0);_m(c[a>>2]|0,c[a+8>>2]|0);i=b;return}function of(d,e,f,h,j){d=d|0;e=e|0;f=f|0;h=h|0;j=j|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,U=0,V=0,W=0,X=0,Y=0;l=i;i=i+176|0;m=l+148|0;n=l;o=l+112|0;p=l+64|0;q=l+8|0;Km(n);r=+g[f>>2];s=d+28|0;if((c[s>>2]|0)>0){t=d+8|0;u=h+4|0;v=d+20|0;w=d+24|0;x=0;do{y=c[(c[t>>2]|0)+(x<<2)>>2]|0;z=y+60|0;A=c[z>>2]|0;B=c[z+4>>2]|0;C=+g[y+72>>2];z=y+
80|0;D=+g[z>>2];E=+g[z+4>>2];F=+g[y+88>>2];z=y+52|0;c[z>>2]=A;c[z+4>>2]=B;g[y+68>>2]=C;if((c[y>>2]|0)==2){G=+g[y+156>>2];H=+g[y+136>>2];I=1/(r*+g[y+148>>2]+1);J=(D+r*(G*+g[h>>2]+H*+g[y+92>>2]))*I;K=(E+r*(G*+g[u>>2]+H*+g[y+96>>2]))*I;L=(F+r*+g[y+144>>2]*+g[y+100>>2])*(1/(r*+g[y+152>>2]+1))}else{J=D;K=E;L=F}y=(c[v>>2]|0)+(x*12|0)|0;c[y>>2]=A;c[y+4>>2]=B;g[(c[v>>2]|0)+(x*12|0)+8>>2]=C;C=+J;F=+K;B=(c[w>>2]|0)+(x*12|0)|0;g[B>>2]=C;g[B+4>>2]=F;g[(c[w>>2]|0)+(x*12|0)+8>>2]=L;x=x+1|0}while((x|0)<(c[s>>2]|
0));M=w;N=v}else{M=d+24|0;N=d+20|0}c[o+0>>2]=c[f+0>>2];c[o+4>>2]=c[f+4>>2];c[o+8>>2]=c[f+8>>2];c[o+12>>2]=c[f+12>>2];c[o+16>>2]=c[f+16>>2];c[o+20>>2]=c[f+20>>2];c[o+24>>2]=c[f+24>>2];v=c[N>>2]|0;c[o+28>>2]=v;w=c[M>>2]|0;c[o+32>>2]=w;c[p+0>>2]=c[f+0>>2];c[p+4>>2]=c[f+4>>2];c[p+8>>2]=c[f+8>>2];c[p+12>>2]=c[f+12>>2];c[p+16>>2]=c[f+16>>2];c[p+20>>2]=c[f+20>>2];c[p+24>>2]=c[f+24>>2];x=d+12|0;c[p+28>>2]=c[x>>2];u=d+36|0;c[p+32>>2]=c[u>>2];c[p+36>>2]=v;c[p+40>>2]=w;c[p+44>>2]=c[d>>2];Ki(q,p);Mi(q);if((a[f+
24>>0]|0)!=0)Ni(q);p=d+32|0;if((c[p>>2]|0)>0){w=d+16|0;v=0;do{h=c[(c[w>>2]|0)+(v<<2)>>2]|0;gb[c[(c[h>>2]|0)+32>>2]&63](h,o);v=v+1|0}while((v|0)<(c[p>>2]|0))}g[e+12>>2]=+Mm(n);v=f+12|0;if((c[v>>2]|0)>0){w=d+16|0;h=0;do{if((c[p>>2]|0)>0){t=0;do{B=c[(c[w>>2]|0)+(t<<2)>>2]|0;gb[c[(c[B>>2]|0)+36>>2]&63](B,o);t=t+1|0}while((t|0)<(c[p>>2]|0))}Oi(q);h=h+1|0}while((h|0)<(c[v>>2]|0))}Pi(q);g[e+16>>2]=+Mm(n);if((c[s>>2]|0)>0){v=c[M>>2]|0;h=0;do{w=c[N>>2]|0;t=w+(h*12|0)|0;B=t;L=+g[B>>2];K=+g[B+4>>2];J=+g[w+(h*
12|0)+8>>2];w=v+(h*12|0)|0;F=+g[w>>2];C=+g[w+4>>2];E=+g[v+(h*12|0)+8>>2];D=r*F;I=r*C;H=D*D+I*I;if(H>4){I=2/+Q(+H);O=F*I;P=C*I}else{O=F;P=C}C=r*E;if(C*C>2.4674012660980225){if(C>0)R=C;else R=-C;U=E*(1.5707963705062866/R)}else U=E;E=+(L+r*O);L=+(K+r*P);w=t;g[w>>2]=E;g[w+4>>2]=L;g[(c[N>>2]|0)+(h*12|0)+8>>2]=J+r*U;J=+O;L=+P;w=(c[M>>2]|0)+(h*12|0)|0;g[w>>2]=J;g[w+4>>2]=L;v=c[M>>2]|0;g[v+(h*12|0)+8>>2]=U;h=h+1|0}while((h|0)<(c[s>>2]|0))}h=f+16|0;a:do if((c[h>>2]|0)>0){f=d+16|0;v=0;while(1){w=Qi(q)|0;if((c[p>>
2]|0)>0){t=0;B=1;while(1){y=c[(c[f>>2]|0)+(t<<2)>>2]|0;A=B&(nb[c[(c[y>>2]|0)+40>>2]&31](y,o)|0);t=t+1|0;if((t|0)>=(c[p>>2]|0)){V=A;break}else B=A}}else V=1;v=v+1|0;if(w&V){W=0;break a}if((v|0)>=(c[h>>2]|0)){W=1;break}}}else W=1;while(0);if((c[s>>2]|0)>0){h=d+8|0;V=0;do{p=c[(c[h>>2]|0)+(V<<2)>>2]|0;o=(c[N>>2]|0)+(V*12|0)|0;v=c[o>>2]|0;f=c[o+4>>2]|0;o=p+60|0;c[o>>2]=v;c[o+4>>2]=f;U=+g[(c[N>>2]|0)+(V*12|0)+8>>2];g[p+72>>2]=U;o=(c[M>>2]|0)+(V*12|0)|0;B=c[o+4>>2]|0;t=p+80|0;c[t>>2]=c[o>>2];c[t+4>>2]=B;
g[p+88>>2]=+g[(c[M>>2]|0)+(V*12|0)+8>>2];P=+T(+U);g[p+20>>2]=P;O=+S(+U);g[p+24>>2]=O;U=+g[p+44>>2];R=+g[p+48>>2];L=(c[k>>2]=v,+g[k>>2])-(O*U-P*R);J=(c[k>>2]=f,+g[k>>2])-(P*U+O*R);R=+L;L=+J;f=p+12|0;g[f>>2]=R;g[f+4>>2]=L;V=V+1|0}while((V|0)<(c[s>>2]|0))}g[e+20>>2]=+Mm(n);n=c[q+44>>2]|0;e=d+4|0;if((c[e>>2]|0)!=0?(c[u>>2]|0)>0:0){V=m+16|0;M=0;do{N=c[(c[x>>2]|0)+(M<<2)>>2]|0;h=c[n+(M*156|0)+148>>2]|0;c[V>>2]=h;if((h|0)>0){f=0;do{g[m+(f<<2)>>2]=+g[n+(M*156|0)+(f*36|0)+16>>2];g[m+(f<<2)+8>>2]=+g[n+(M*156|
0)+(f*36|0)+20>>2];f=f+1|0}while((f|0)!=(h|0))}h=c[e>>2]|0;ib[c[(c[h>>2]|0)+36>>2]&7](h,N,m);M=M+1|0}while((M|0)<(c[u>>2]|0))}if(!j){Li(q);i=l;return}j=c[s>>2]|0;u=(j|0)>0;if(u){M=c[d+8>>2]|0;m=0;L=3.4028234663852886E38;while(1){e=c[M+(m<<2)>>2]|0;do if((c[e>>2]|0)==0)X=L;else{if((!((b[e+4>>1]&4)==0)?(R=+g[e+88>>2],!(R*R>.001218469929881394)):0)?(R=+g[e+80>>2],J=+g[e+84>>2],!(R*R+J*J>9.999999747378752E-5)):0){n=e+160|0;J=r+ +g[n>>2];g[n>>2]=J;X=L<J?L:J;break}g[e+160>>2]=0;X=0}while(0);m=m+1|0;if((m|
0)>=(j|0)){Y=X;break}else L=X}}else Y=3.4028234663852886E38;if(!(Y>=.5)|W|u^1){Li(q);i=l;return}u=d+8|0;d=0;do{W=c[(c[u>>2]|0)+(d<<2)>>2]|0;j=W+4|0;b[j>>1]=b[j>>1]&65533;g[W+160>>2]=0;j=W+80|0;c[j+0>>2]=0;c[j+4>>2]=0;c[j+8>>2]=0;c[j+12>>2]=0;c[j+16>>2]=0;c[j+20>>2]=0;d=d+1|0}while((d|0)<(c[s>>2]|0));Li(q);i=l;return}function pf(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0;f=i;i=i+128|0;h=f+
104|0;j=f+56|0;k=f;l=a+28|0;if((c[l>>2]|0)>0){m=a+8|0;n=a+20|0;o=a+24|0;p=0;do{q=c[(c[m>>2]|0)+(p<<2)>>2]|0;r=q+60|0;s=c[r+4>>2]|0;t=(c[n>>2]|0)+(p*12|0)|0;c[t>>2]=c[r>>2];c[t+4>>2]=s;g[(c[n>>2]|0)+(p*12|0)+8>>2]=+g[q+72>>2];s=q+80|0;t=c[s+4>>2]|0;r=(c[o>>2]|0)+(p*12|0)|0;c[r>>2]=c[s>>2];c[r+4>>2]=t;t=c[o>>2]|0;g[t+(p*12|0)+8>>2]=+g[q+88>>2];p=p+1|0}while((p|0)<(c[l>>2]|0));u=n;v=t}else{u=a+20|0;v=c[a+24>>2]|0}n=a+12|0;c[j+28>>2]=c[n>>2];p=a+36|0;c[j+32>>2]=c[p>>2];c[j+44>>2]=c[a>>2];c[j+0>>2]=c[b+
0>>2];c[j+4>>2]=c[b+4>>2];c[j+8>>2]=c[b+8>>2];c[j+12>>2]=c[b+12>>2];c[j+16>>2]=c[b+16>>2];c[j+20>>2]=c[b+20>>2];c[j+24>>2]=c[b+24>>2];c[j+36>>2]=c[u>>2];o=a+24|0;c[j+40>>2]=v;Ki(k,j);j=b+16|0;a:do if((c[j>>2]|0)>0){v=0;do{v=v+1|0;if(Si(k,d,e)|0)break a}while((v|0)<(c[j>>2]|0))}while(0);j=a+8|0;v=(c[u>>2]|0)+(d*12|0)|0;m=c[v+4>>2]|0;t=(c[(c[j>>2]|0)+(d<<2)>>2]|0)+52|0;c[t>>2]=c[v>>2];c[t+4>>2]=m;m=c[u>>2]|0;t=c[j>>2]|0;g[(c[t+(d<<2)>>2]|0)+68>>2]=+g[m+(d*12|0)+8>>2];d=m+(e*12|0)|0;m=c[d+4>>2]|0;v=
(c[t+(e<<2)>>2]|0)+52|0;c[v>>2]=c[d>>2];c[v+4>>2]=m;g[(c[(c[j>>2]|0)+(e<<2)>>2]|0)+68>>2]=+g[(c[u>>2]|0)+(e*12|0)+8>>2];Mi(k);e=b+12|0;if((c[e>>2]|0)>0){m=0;do{Oi(k);m=m+1|0}while((m|0)<(c[e>>2]|0))}w=+g[b>>2];if((c[l>>2]|0)>0){b=0;do{e=c[u>>2]|0;m=e+(b*12|0)|0;v=m;x=+g[v>>2];y=+g[v+4>>2];z=+g[e+(b*12|0)+8>>2];e=c[o>>2]|0;v=e+(b*12|0)|0;A=+g[v>>2];B=+g[v+4>>2];C=+g[e+(b*12|0)+8>>2];D=w*A;E=w*B;F=D*D+E*E;if(F>4){E=2/+Q(+F);G=A*E;H=B*E}else{G=A;H=B}B=w*C;if(B*B>2.4674012660980225){if(B>0)I=B;else I=
-B;J=C*(1.5707963705062866/I)}else J=C;C=x+w*G;x=y+w*H;y=z+w*J;z=+C;B=+x;e=m;g[e>>2]=z;g[e+4>>2]=B;g[(c[u>>2]|0)+(b*12|0)+8>>2]=y;A=+G;E=+H;e=(c[o>>2]|0)+(b*12|0)|0;g[e>>2]=A;g[e+4>>2]=E;g[(c[o>>2]|0)+(b*12|0)+8>>2]=J;e=c[(c[j>>2]|0)+(b<<2)>>2]|0;m=e+60|0;g[m>>2]=z;g[m+4>>2]=B;g[e+72>>2]=y;m=e+80|0;g[m>>2]=A;g[m+4>>2]=E;g[e+88>>2]=J;E=+T(+y);g[e+20>>2]=E;A=+S(+y);g[e+24>>2]=A;y=+g[e+44>>2];B=+g[e+48>>2];z=+(C-(A*y-E*B));C=+(x-(E*y+A*B));m=e+12|0;g[m>>2]=z;g[m+4>>2]=C;b=b+1|0}while((b|0)<(c[l>>2]|
0))}l=c[k+44>>2]|0;b=a+4|0;if((c[b>>2]|0)==0){Li(k);i=f;return}if((c[p>>2]|0)<=0){Li(k);i=f;return}a=h+16|0;j=0;do{o=c[(c[n>>2]|0)+(j<<2)>>2]|0;u=c[l+(j*156|0)+148>>2]|0;c[a>>2]=u;if((u|0)>0){m=0;do{g[h+(m<<2)>>2]=+g[l+(j*156|0)+(m*36|0)+16>>2];g[h+(m<<2)+8>>2]=+g[l+(j*156|0)+(m*36|0)+20>>2];m=m+1|0}while((m|0)!=(u|0))}u=c[b>>2]|0;ib[c[(c[u>>2]|0)+36>>2]&7](u,o,h);j=j+1|0}while((j|0)<(c[p>>2]|0));Li(k);i=f;return}function qf(a,c,d){a=a|0;c=c|0;d=d|0;var e=0,f=0;a=i;e=b[c+36>>1]|0;if(!(e<<16>>16==
0?1:e<<16>>16!=(b[d+36>>1]|0))){f=e<<16>>16>0;i=a;return f|0}if((b[d+32>>1]&b[c+34>>1])<<16>>16==0){f=0;i=a;return f|0}f=(b[d+34>>1]&b[c+32>>1])<<16>>16!=0;i=a;return f|0}function rf(a){a=a|0;return}function sf(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function tf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return 1}function uf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return 1}function vf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0;d=i;vh(a,b);c[a>>2]=904;e=b+20|0;f=c[e>>2]|0;h=c[e+4>>2]|0;e=a+76|0;c[e>>
2]=f;c[e+4>>2]=h;e=c[a+52>>2]|0;j=(c[k>>2]=f,+g[k>>2])-+g[e+12>>2];l=(c[k>>2]=h,+g[k>>2])-+g[e+16>>2];m=+g[e+24>>2];n=+g[e+20>>2];o=+(j*m+l*n);p=+(m*l-j*n);e=a+68|0;g[e>>2]=o;g[e+4>>2]=p;g[a+104>>2]=+g[b+28>>2];g[a+96>>2]=0;g[a+100>>2]=0;g[a+84>>2]=+g[b+32>>2];g[a+88>>2]=+g[b+36>>2];g[a+92>>2]=0;g[a+108>>2]=0;i=d;return}function wf(a,d){a=a|0;d=d|0;var e=0,f=0,h=0,j=0,k=0;e=i;f=c[a+52>>2]|0;h=f+4|0;j=b[h>>1]|0;if((j&2)==0?(k=j&65535,(k&2|0)==0):0){b[h>>1]=k|2;g[f+160>>2]=0}f=d;d=c[f+4>>2]|0;k=a+76|
0;c[k>>2]=c[f>>2];c[k+4>>2]=d;i=e;return}function xf(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0;e=i;f=c[b+52>>2]|0;h=c[f+8>>2]|0;j=b+116|0;c[j>>2]=h;l=f+44|0;m=c[l>>2]|0;n=c[l+4>>2]|0;l=b+128|0;c[l>>2]=m;c[l+4>>2]=n;o=+g[f+136>>2];g[b+136>>2]=o;p=+g[f+144>>2];g[b+140>>2]=p;l=c[d+28>>2]|0;q=l+(h*12|0)|0;r=+g[q>>2];s=+g[q+4>>2];t=+g[l+(h*12|0)+8>>2];l=d+32|0;q=c[l>>2]|
0;u=q+(h*12|0)|0;v=+g[u>>2];w=+g[u+4>>2];x=+g[q+(h*12|0)+8>>2];y=+T(+t);z=+S(+t);t=+g[f+132>>2];A=+g[b+84>>2]*6.2831854820251465;B=+g[d>>2];C=B*t*A*A;D=B*(A*t*2*+g[b+88>>2]+C);t=(c[k>>2]=m,+g[k>>2]);A=(c[k>>2]=n,+g[k>>2]);if(D!=0)E=1/D;else E=D;g[b+108>>2]=E;D=C*E;g[b+92>>2]=D;C=+g[b+68>>2]-t;t=+g[b+72>>2]-A;A=z*C-y*t;B=y*C+z*t;t=+A;z=+B;n=b+120|0;g[n>>2]=t;g[n+4>>2]=z;z=E+(o+B*p*B);t=p*A;C=B*t;y=E+(o+A*t);t=z*y-C*C;if(t!=0)F=1/t;else F=t;t=C*F;g[b+144>>2]=y*F;g[b+148>>2]=t;g[b+152>>2]=t;g[b+156>>
2]=z*F;n=b+160|0;F=r+A-+g[b+76>>2];r=s+B-+g[b+80>>2];s=+F;z=+r;m=n;g[m>>2]=s;g[m+4>>2]=z;g[n>>2]=D*F;g[b+164>>2]=D*r;r=x*.9800000190734863;n=b+96|0;if((a[d+24>>0]|0)==0){g[n>>2]=0;g[b+100>>2]=0;G=v;H=w;I=r;J=c[l>>2]|0;K=J+(h*12|0)|0;L=+G;M=+H;N=K;O=N;g[O>>2]=L;P=N+4|0;Q=P;g[Q>>2]=M;R=c[j>>2]|0;U=c[l>>2]|0;V=U+(R*12|0)+8|0;g[V>>2]=I;i=e;return}else{x=+g[d+8>>2];D=x*+g[n>>2];g[n>>2]=D;n=b+100|0;F=x*+g[n>>2];g[n>>2]=F;G=v+o*D;H=w+F*o;I=r+p*(F*A-D*B);J=c[l>>2]|0;K=J+(h*12|0)|0;L=+G;M=+H;N=K;O=N;g[O>>
2]=L;P=N+4|0;Q=P;g[Q>>2]=M;R=c[j>>2]|0;U=c[l>>2]|0;V=U+(R*12|0)+8|0;g[V>>2]=I;i=e;return}}function yf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;d=i;e=a+116|0;f=c[e>>2]|0;h=b+32|0;j=c[h>>2]|0;k=j+(f*12|0)|0;l=k;m=+g[l>>2];n=+g[l+4>>2];o=+g[j+(f*12|0)+8>>2];p=+g[a+124>>2];q=+g[a+120>>2];r=+g[a+108>>2];f=a+96|0;s=+g[f>>2];j=a+100|0;t=+g[j>>2];u=-(m-o*p+ +g[a+160>>2]+r*s);v=-(n+o*q+ +g[a+164>>2]+r*t);r=+g[a+148>>2]*u+ +g[a+156>>2]*v;l=
f;w=+g[l>>2];x=+g[l+4>>2];y=s+(+g[a+144>>2]*u+ +g[a+152>>2]*v);g[f>>2]=y;v=r+t;g[j>>2]=v;t=+g[b>>2]*+g[a+104>>2];r=v*v+y*y;if(r>t*t){u=t/+Q(+r);r=y*u;g[f>>2]=r;t=u*v;g[j>>2]=t;z=r;A=t}else{z=y;A=v}v=z-w;w=A-x;x=+g[a+136>>2];A=o+ +g[a+140>>2]*(w*q-v*p);p=+(m+v*x);v=+(n+w*x);a=k;g[a>>2]=p;g[a+4>>2]=v;g[(c[h>>2]|0)+((c[e>>2]|0)*12|0)+8>>2]=A;i=d;return}function zf(a,b){a=a|0;b=b|0;return 1}function Af(a,b){a=a|0;b=b|0;var d=0,e=0;d=b+76|0;b=c[d+4>>2]|0;e=a;c[e>>2]=c[d>>2];c[e+4>>2]=b;return}function Bf(a,
b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+68>>2];h=+g[d+20>>2];i=+g[b+72>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Cf(a,b,c){a=a|0;b=b|0;c=+c;var d=0;d=+g[b+100>>2]*c;g[a>>2]=+g[b+96>>2]*c;g[a+4>>2]=d;return}function Df(a,b){a=a|0;b=+b;return+(b*0)}function Ef(a,b){a=a|0;b=b|0;var c=0;c=a+76|0;g[c>>2]=+g[c>>2]-+g[b>>2];c=a+80|0;g[c>>2]=+g[c>>2]-+g[b+4>>2];return}function Ff(a){a=a|0;a=i;i=i+16|0;Rm(1008,a);i=a;return}
function Gf(a){a=a|0;return}function Hf(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function If(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0;e=i;c[a+8>>2]=b;c[a+12>>2]=d;f=d+12|0;h=+g[f>>2];j=h-+g[b+12>>2];h=+g[f+4>>2]-+g[b+16>>2];k=+g[b+24>>2];l=+g[b+20>>2];m=+(j*k+h*l);n=+(k*h-j*l);f=a+20|0;g[f>>2]=m;g[f+4>>2]=n;g[a+28>>2]=+g[d+72>>2]-+g[b+72>>2];i=e;return}function cm(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,
B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0;f=i;h=a+4|0;j=c[(c[h>>2]|0)+88>>2]|0;k=c[j+(d<<2)>>2]|c[j+(b<<2)>>2]|c[j+(e<<2)>>2];if((k&16|0)==0){i=f;return}j=c[a+8>>2]|0;if(!(lb[c[(c[j>>2]|0)+16>>2]&7](j,b,d,e)|0)){i=f;return}j=c[h>>2]|0;h=c[j+96>>2]|0;a=h+(b<<3)|0;l=+g[a>>2];m=h+(d<<3)|0;n=+g[m>>2];o=l-n;p=h+(b<<3)+4|0;q=+g[p>>2];r=h+(d<<3)+4|0;s=+g[r>>2];t=q-s;u=h+(e<<3)|0;v=+g[u>>2];w=n-v;x=h+(e<<3)+4|0;n=+g[x>>2];y=s-n;s=v-l;l=n-q;q=+g[j+40>>2]*4;if(o*o+t*t>q){i=f;return}if(w*w+y*y>q){i=f;return}if(s*
s+l*l>q){i=f;return}h=c[j+144>>2]|0;z=c[h+(b<<2)>>2]|0;A=c[h+(d<<2)>>2]|0;B=c[h+(e<<2)>>2]|0;h=j+264|0;C=j+268|0;D=c[C>>2]|0;E=j+272|0;F=c[E>>2]|0;if((D|0)>=(F|0)?(G=(F|0)==0?256:F<<1,(F|0)<(G|0)):0){F=j+276|0;j=Em(c[F>>2]|0,G*60|0)|0;H=c[h>>2]|0;if((H|0)!=0){An(j|0,H|0,(c[C>>2]|0)*60|0)|0;Fm(c[F>>2]|0,c[h>>2]|0,(c[E>>2]|0)*60|0)}c[E>>2]=G;c[h>>2]=j;I=c[C>>2]|0}else I=D;c[C>>2]=I+1;C=c[h>>2]|0;c[C+(I*60|0)>>2]=b;c[C+(I*60|0)+4>>2]=d;c[C+(I*60|0)+8>>2]=e;c[C+(I*60|0)+12>>2]=k;if((z|0)==0)J=1;else J=
+g[z+16>>2];if((A|0)==0)K=1;else K=+g[A+16>>2];q=J<K?J:K;if((B|0)==0)L=1;else L=+g[B+16>>2];g[C+(I*60|0)+16>>2]=q<L?q:L;L=+g[a>>2];q=+g[p>>2];K=(L+ +g[m>>2]+ +g[u>>2])*.3333333432674408;J=(q+ +g[r>>2]+ +g[x>>2])*.3333333432674408;n=+(L-K);L=+(q-J);B=C+(I*60|0)+20|0;g[B>>2]=n;g[B+4>>2]=L;L=+(+g[m>>2]-K);n=+(+g[r>>2]-J);B=C+(I*60|0)+28|0;g[B>>2]=L;g[B+4>>2]=n;n=+(+g[u>>2]-K);K=+(+g[x>>2]-J);B=C+(I*60|0)+36|0;g[B>>2]=n;g[B+4>>2]=K;g[C+(I*60|0)+44>>2]=-(o*s+t*l);g[C+(I*60|0)+48>>2]=-(o*w+t*y);g[C+(I*
60|0)+52>>2]=-(w*s+y*l);l=+g[a>>2];y=+g[r>>2];s=+g[p>>2];w=+g[m>>2];t=+g[x>>2];o=+g[u>>2];g[C+(I*60|0)+56>>2]=s*o-l*t+(l*y-s*w+(w*t-y*o));i=f;return}function dm(a){a=a|0;return}function em(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function fm(a,b){a=a|0;b=b|0;return(c[(c[a+4>>2]|0)+(b<<2)>>2]&4096|0)!=0|0}function gm(a,b,c){a=a|0;b=b|0;c=c|0;return 1}function hm(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return 1}function im(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function jm(a,b){a=a|0;b=b|0;return 1}function km(a){a=
a|0;return}function lm(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function mm(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=i;f=c[a+4>>2]|0;a=(f|0)<=(b|0);b=(f|0)>(d|0);if(a|b){i=e;return b&a|0}else{i=e;return 1}return 0}function nm(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;f=i;g=c[a+4>>2]|0;a=(g|0)>(b|0);b=(g|0)>(d|0);if(a|b|(g|0)>(e|0)){i=f;return(g|0)<=(e|0)|a&b^1|0}else{i=f;return 0}return 0}function om(a){a=a|0;return}function pm(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function qm(a,b){a=a|0;b=b|0;return 0}
function rm(a){a=a|0;return 1}function sm(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0;e=i;f=a+16|0;if((c[f>>2]|0)<=0){g=0;i=e;return g|0}h=a+12|0;a=0;while(1){j=c[(c[h>>2]|0)+(a<<2)>>2]|0;a=a+1|0;if(hb[c[(c[j>>2]|0)+16>>2]&15](j,b,d)|0){g=1;k=5;break}if((a|0)>=(c[f>>2]|0)){g=0;k=5;break}}if((k|0)==5){i=e;return g|0}return 0}function tm(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return}function um(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;return 0}function vm(a,b,d,e){a=a|0;b=b|0;d=d|
0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;e=i;i=i+16|0;f=e;g[b>>2]=3.4028234663852886E38;h=b+4|0;g[h>>2]=3.4028234663852886E38;g[b+8>>2]=-3.4028234663852886E38;j=b+12|0;g[j>>2]=-3.4028234663852886E38;k=a+16|0;if((c[k>>2]|0)<=0){i=e;return}l=a+12|0;a=f+4|0;m=b+8|0;n=f+8|0;o=f+12|0;p=0;do{q=c[(c[l>>2]|0)+(p<<2)>>2]|0;r=bb[c[(c[q>>2]|0)+12>>2]&7](q)|0;if((r|0)>0){q=0;do{s=c[(c[l>>2]|0)+(p<<2)>>2]|0;pb[c[(c[s>>2]|0)+28>>2]&31](s,f,d,q);t=+g[b>>2];u=+g[f>>2];v=+g[h>>
2];w=+g[a>>2];x=+(t<u?t:u);u=+(v<w?v:w);s=b;g[s>>2]=x;g[s+4>>2]=u;u=+g[m>>2];x=+g[n>>2];w=+g[j>>2];v=+g[o>>2];t=+(u>x?u:x);x=+(w>v?w:v);s=m;g[s>>2]=t;g[s+4>>2]=x;q=q+1|0}while((q|0)!=(r|0))}p=p+1|0}while((p|0)<(c[k>>2]|0));i=e;return}function wm(a,b,c){a=a|0;b=b|0;c=+c;return}function xm(a){a=a|0;return}function ym(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function zm(a,b){a=a|0;b=b|0;return 0}function Am(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0;f=i;g=b+4|0;if((c[g>>2]|0)!=(d|0)){h=0;i=f;return h|
0}j=c[b+8>>2]|0;if(!(hb[c[(c[j>>2]|0)+16>>2]&15](j,b+12|0,(c[d+96>>2]|0)+(e<<3)|0)|0)){h=1;i=f;return h|0}d=c[g>>2]|0;Ak(d,e,c[(c[d+88>>2]|0)+(e<<2)>>2]|((a[b+28>>0]|0)!=0?514:2));e=b+32|0;c[e>>2]=(c[e>>2]|0)+1;h=1;i=f;return h|0}function Bm(a,b){a=a|0;b=b|0;var d=0,e=0;d=b+4|0;c[(c[b>>2]|0)+4>>2]=c[d>>2];c[c[d>>2]>>2]=c[b>>2];c[d>>2]=b;c[b>>2]=b;e=a+12|0;c[d>>2]=c[e>>2];c[b>>2]=a+8;c[c[e>>2]>>2]=b;c[e>>2]=b;return}function Cm(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;e=b+68|0;c[b+72>>2]=e;c[e>>2]=
e;e=b+8|0;c[e>>2]=128;c[b+4>>2]=0;f=Pm(1024)|0;c[b>>2]=f;xn(f|0,0,c[e>>2]<<3|0)|0;e=b+12|0;b=e+56|0;do{c[e>>2]=0;e=e+4|0}while((e|0)<(b|0));if((a[8776]|0)==0){g=1;h=0}else{i=d;return}while(1){if((g|0)>(c[8072+(h<<2)>>2]|0)){e=h+1|0;a[8128+g>>0]=e;j=e}else{a[8128+g>>0]=h;j=h}g=g+1|0;if((g|0)==641)break;else h=j}a[8776]=1;i=d;return}function Dm(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0;b=i;d=a+4|0;e=c[a>>2]|0;if((c[d>>2]|0)>0){f=e;g=0;while(1){Qm(c[f+(g<<3)+4>>2]|0);g=g+1|0;h=c[a>>2]|0;if((g|0)>=(c[d>>
2]|0)){j=h;break}else f=h}}else j=e;Qm(j);j=a+68|0;Vm(j);e=a+72|0;c[(c[j>>2]|0)+4>>2]=c[e>>2];c[c[e>>2]>>2]=c[j>>2];c[e>>2]=j;c[j>>2]=j;i=b;return}function Em(a,b){a=a|0;b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;e=i;if((b|0)==0){f=0;i=e;return f|0}if((b|0)>640){f=Tm(a+68|0,b)|0;i=e;return f|0}g=d[8128+b>>0]|0;b=a+(g<<2)+12|0;h=c[b>>2]|0;if((h|0)!=0){c[b>>2]=c[h>>2];f=h;i=e;return f|0}h=a+4|0;j=c[h>>2]|0;k=a+8|0;if((j|0)==(c[k>>2]|0)){l=c[a>>2]|0;m=j+128|0;c[k>>2]=m;k=Pm(m<<3)|0;c[a>>2]=k;
An(k|0,l|0,c[h>>2]<<3|0)|0;xn((c[a>>2]|0)+(c[h>>2]<<3)|0,0,1024)|0;Qm(l);n=c[h>>2]|0}else n=j;j=c[a>>2]|0;a=Pm(16384)|0;l=j+(n<<3)+4|0;c[l>>2]=a;k=c[8072+(g<<2)>>2]|0;c[j+(n<<3)>>2]=k;n=(16384/(k|0)|0)+-1|0;if((n|0)>0){j=a;g=0;while(1){m=g;g=g+1|0;c[j+(aa(m,k)|0)>>2]=j+(aa(g,k)|0);m=c[l>>2]|0;if((g|0)==(n|0)){o=m;break}else j=m}}else o=a;c[o+(aa(n,k)|0)>>2]=0;c[b>>2]=c[c[l>>2]>>2];c[h>>2]=(c[h>>2]|0)+1;f=c[l>>2]|0;i=e;return f|0}function Fm(a,b,e){a=a|0;b=b|0;e=e|0;var f=0,g=0;f=i;if((e|0)==0){i=
f;return}if((e|0)>640){Um(a+68|0,b);i=f;return}else{g=a+((d[8128+e>>0]|0)<<2)+12|0;c[b>>2]=c[g>>2];c[g>>2]=b;i=f;return}}function Gm(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;d=+g[b+16>>2];e=+g[b+32>>2];f=+g[b+20>>2];h=+g[b+28>>2];i=d*e-f*h;j=+g[b+24>>2];k=+g[b+12>>2];l=f*j-e*k;m=h*k-d*j;n=+g[b>>2];o=+g[b+4>>2];p=+g[b+8>>2];q=i*n+o*l+m*p;if(q!=0)r=1/q;else r=q;q=+g[c>>2];s=+g[c+4>>2];t=+g[c+8>>2];g[a>>2]=r*(i*q+s*l+m*t);g[a+4>>2]=r*((s*e-t*h)*n+o*
(t*j-e*q)+(h*q-s*j)*p);g[a+8>>2]=r*((d*t-f*s)*n+o*(f*q-t*k)+(s*k-d*q)*p);return}function Hm(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,h=0,i=0,j=0,k=0;d=+g[b>>2];e=+g[b+12>>2];f=+g[b+4>>2];h=+g[b+16>>2];i=d*h-e*f;if(i!=0)j=1/i;else j=i;i=+g[c>>2];k=+g[c+4>>2];g[a>>2]=j*(h*i-e*k);g[a+4>>2]=j*(d*k-f*i);return}function Im(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0;d=i;e=+g[a>>2];f=+g[a+12>>2];h=+g[a+4>>2];j=+g[a+16>>2];k=e*j-f*h;if(k!=0)l=1/k;else l=k;g[b>>2]=j*l;j=-l;g[b+12>>2]=f*j;g[b+8>>2]=0;
g[b+4>>2]=h*j;g[b+16>>2]=e*l;a=b+20|0;c[a+0>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;c[a+12>>2]=0;i=d;return}function Jm(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;c=+g[a+16>>2];d=+g[a+32>>2];e=c*d;f=+g[a+20>>2];h=+g[a+28>>2];i=+g[a+24>>2];j=+g[a+12>>2];k=d*j;l=h*j-c*i;m=+g[a>>2];n=(e-f*h)*m+ +g[a+4>>2]*(f*i-k)+l*+g[a+8>>2];if(n!=0)o=1/n;else o=n;g[b>>2]=o*(e-h*h);e=o*(i*h-k);g[b+4>>2]=e;k=o*l;g[b+8>>2]=k;g[b+12>>2]=e;g[b+16>>2]=o*(m*d-i*i);d=o*(j*i-m*h);g[b+20>>2]=d;g[b+24>>2]=k;g[b+
28>>2]=d;g[b+32>>2]=o*(m*c-j*j);return}function Km(a){a=a|0;return}function Lm(a){a=a|0;return}function Mm(a){a=a|0;return 0}function Nm(a,b){a=a|0;b=b|0;var c=0;b=i;c=on(a)|0;i=b;return c|0}function Om(a,b){a=a|0;b=b|0;b=i;pn(a);i=b;return}function Pm(a){a=a|0;var b=0,d=0;b=i;c[2214]=(c[2214]|0)+1;d=nb[c[2208]&31](a,c[2212]|0)|0;i=b;return d|0}function Qm(a){a=a|0;var b=0;b=i;c[2214]=(c[2214]|0)+-1;gb[c[2210]&63](a,c[2212]|0);i=b;return}function Rm(a,b){a=a|0;b=b|0;return}function Sm(a){a=a|0;return a+
43&-32|0}function Tm(a,b){a=a|0;b=b|0;var d=0,e=0;d=i;e=Pm(b+44|0)|0;c[e>>2]=e;b=e+43&-32;c[b+-4>>2]=e;c[e+4>>2]=a;c[e>>2]=c[a>>2];c[(c[a>>2]|0)+4>>2]=e;c[a>>2]=e;i=d;return b|0}function Um(a,b){a=a|0;b=b|0;var d=0;a=i;d=c[b+-4>>2]|0;b=d+4|0;c[(c[d>>2]|0)+4>>2]=c[b>>2];c[c[b>>2]>>2]=c[d>>2];c[b>>2]=d;c[d>>2]=d;Qm(d);i=a;return}function Vm(a){a=a|0;var b=0,d=0,e=0,f=0;b=i;d=a+4|0;e=c[d>>2]|0;if((e|0)==(a|0)){i=b;return}else f=e;do{e=f+4|0;c[(c[f>>2]|0)+4>>2]=c[e>>2];c[c[e>>2]>>2]=c[f>>2];c[e>>2]=f;
c[f>>2]=f;Qm(f);f=c[d>>2]|0}while((f|0)!=(a|0));i=b;return}function Wm(a){a=a|0;c[a+102400>>2]=0;c[a+102404>>2]=0;c[a+102408>>2]=0;c[a+102796>>2]=0;return}function Xm(a){a=a|0;return}function Ym(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0;e=i;f=d+3&-4;d=b+102796|0;g=c[d>>2]|0;h=b+(g*12|0)+102412|0;c[b+(g*12|0)+102416>>2]=f;j=b+102400|0;k=c[j>>2]|0;if((k+f|0)>102400){c[h>>2]=Pm(f)|0;a[b+(g*12|0)+102420>>0]=1}else{c[h>>2]=b+k;a[b+(g*12|0)+102420>>0]=0;c[j>>2]=(c[j>>2]|0)+f}j=b+102404|0;g=(c[j>>2]|
0)+f|0;c[j>>2]=g;j=b+102408|0;b=c[j>>2]|0;c[j>>2]=(b|0)>(g|0)?b:g;c[d>>2]=(c[d>>2]|0)+1;i=e;return c[h>>2]|0}function Zm(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;d=i;f=(c[b+102796>>2]|0)+-1|0;g=b+(f*12|0)+102412|0;h=b+(f*12|0)+102416|0;j=e-(c[h>>2]|0)|0;if((j|0)<=0){k=c[g>>2]|0;i=d;return k|0}l=b+(f*12|0)+102420|0;do if((a[l>>0]|0)==0){f=b+102400|0;m=(c[f>>2]|0)+j|0;if((m|0)>102400){n=Pm(e)|0;An(n|0,c[g>>2]|0,c[h>>2]|0)|0;c[f>>2]=(c[f>>2]|0)-(c[h>>2]|0);c[g>>2]=n;a[l>>0]=1;break}else{c[f>>
2]=m;m=b+102404|0;f=(c[m>>2]|0)+j|0;c[m>>2]=f;m=b+102408|0;n=c[m>>2]|0;c[m>>2]=(n|0)>(f|0)?n:f;break}}else{f=Pm(e)|0;An(f|0,c[g>>2]|0,c[h>>2]|0)|0;Qm(c[g>>2]|0);c[g>>2]=f}while(0);c[h>>2]=e;k=c[g>>2]|0;i=d;return k|0}function _m(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;e=i;f=b+102796|0;g=c[f>>2]|0;h=g+-1|0;if((a[b+(h*12|0)+102420>>0]|0)==0){j=b+(h*12|0)+102416|0;k=b+102400|0;c[k>>2]=(c[k>>2]|0)-(c[j>>2]|0);l=j;m=g}else{Qm(d);l=b+(h*12|0)+102416|0;m=c[f>>2]|0}h=b+102404|0;c[h>>2]=(c[h>>
2]|0)-(c[l>>2]|0);c[f>>2]=m+-1;i=e;return}function $m(a){a=a|0;return}function an(a){a=a|0;return}function bn(a){a=a|0;return}function cn(a){a=a|0;return}function dn(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function en(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function fn(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0;e=i;i=i+64|0;f=e;if((a|0)==(b|0)){g=1;i=e;return g|0}if((b|0)==0){g=0;i=e;return g|0}h=jn(b,8928,8984,0)|0;if((h|0)==0){g=0;i=e;return g|0}b=f+0|0;j=b+56|0;do{c[b>>2]=0;b=b+4|0}while((b|
0)<(j|0));c[f>>2]=h;c[f+8>>2]=a;c[f+12>>2]=-1;c[f+48>>2]=1;pb[c[(c[h>>2]|0)+28>>2]&31](h,f,c[d>>2]|0,1);if((c[f+24>>2]|0)!=1){g=0;i=e;return g|0}c[d>>2]=c[f+16>>2];g=1;i=e;return g|0}function gn(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=i;if((c[d+8>>2]|0)!=(b|0)){i=g;return}b=d+16|0;h=c[b>>2]|0;if((h|0)==0){c[b>>2]=e;c[d+24>>2]=f;c[d+36>>2]=1;i=g;return}if((h|0)!=(e|0)){e=d+36|0;c[e>>2]=(c[e>>2]|0)+1;c[d+24>>2]=2;a[d+54>>0]=1;i=g;return}e=d+24|0;if((c[e>>2]|0)!=2){i=g;return}c[e>>2]=f;i=g;return}
function hn(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=i;if((b|0)!=(c[d+8>>2]|0)){h=c[b+8>>2]|0;pb[c[(c[h>>2]|0)+28>>2]&31](h,d,e,f);i=g;return}h=d+16|0;b=c[h>>2]|0;if((b|0)==0){c[h>>2]=e;c[d+24>>2]=f;c[d+36>>2]=1;i=g;return}if((b|0)!=(e|0)){e=d+36|0;c[e>>2]=(c[e>>2]|0)+1;c[d+24>>2]=2;a[d+54>>0]=1;i=g;return}e=d+24|0;if((c[e>>2]|0)!=2){i=g;return}c[e>>2]=f;i=g;return}function jn(d,e,f,g){d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;h=i;i=i+64|0;j=h;k=c[d>>2]|0;l=d+(c[k+
-8>>2]|0)|0;m=c[k+-4>>2]|0;c[j>>2]=f;c[j+4>>2]=d;c[j+8>>2]=e;c[j+12>>2]=g;g=j+16|0;e=j+20|0;d=j+24|0;k=j+28|0;n=j+32|0;o=j+40|0;p=(m|0)==(f|0);f=g+0|0;q=f+36|0;do{c[f>>2]=0;f=f+4|0}while((f|0)<(q|0));b[g+36>>1]=0;a[g+38>>0]=0;if(p){c[j+48>>2]=1;mb[c[(c[m>>2]|0)+20>>2]&7](m,j,l,l,1,0);r=(c[d>>2]|0)==1?l:0;i=h;return r|0}cb[c[(c[m>>2]|0)+24>>2]&3](m,j,l,1,0);l=c[j+36>>2]|0;if((l|0)==1){if((c[d>>2]|0)!=1){if((c[o>>2]|0)!=0){r=0;i=h;return r|0}if((c[k>>2]|0)!=1){r=0;i=h;return r|0}if((c[n>>2]|0)!=1){r=
0;i=h;return r|0}}r=c[g>>2]|0;i=h;return r|0}else if((l|0)==0){if((c[o>>2]|0)!=1){r=0;i=h;return r|0}if((c[k>>2]|0)!=1){r=0;i=h;return r|0}r=(c[n>>2]|0)==1?c[e>>2]|0:0;i=h;return r|0}else{r=0;i=h;return r|0}return 0}function kn(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;h=i;if((b|0)==(c[d+8>>2]|0)){if((c[d+4>>2]|0)!=(e|0)){i=h;return}j=d+28|0;if((c[j>>2]|0)==1){i=h;return}c[j>>2]=f;i=h;return}if((b|0)!=(c[d>>2]|0)){j=c[b+8>>2]|0;cb[c[(c[j>>2]|0)+24>>2]&3](j,d,e,f,
g);i=h;return}if((c[d+16>>2]|0)!=(e|0)?(j=d+20|0,(c[j>>2]|0)!=(e|0)):0){c[d+32>>2]=f;k=d+44|0;if((c[k>>2]|0)==4){i=h;return}l=d+52|0;a[l>>0]=0;m=d+53|0;a[m>>0]=0;n=c[b+8>>2]|0;mb[c[(c[n>>2]|0)+20>>2]&7](n,d,e,e,1,g);if((a[m>>0]|0)!=0){if((a[l>>0]|0)==0){o=1;p=13}}else{o=0;p=13}do if((p|0)==13){c[j>>2]=e;l=d+40|0;c[l>>2]=(c[l>>2]|0)+1;if((c[d+36>>2]|0)==1?(c[d+24>>2]|0)==2:0){a[d+54>>0]=1;if(o)break}else p=16;if((p|0)==16?o:0)break;c[k>>2]=4;i=h;return}while(0);c[k>>2]=3;i=h;return}if((f|0)!=1){i=
h;return}c[d+32>>2]=1;i=h;return}function ln(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0;g=i;if((c[d+8>>2]|0)==(b|0)){if((c[d+4>>2]|0)!=(e|0)){i=g;return}h=d+28|0;if((c[h>>2]|0)==1){i=g;return}c[h>>2]=f;i=g;return}if((c[d>>2]|0)!=(b|0)){i=g;return}if((c[d+16>>2]|0)!=(e|0)?(b=d+20|0,(c[b>>2]|0)!=(e|0)):0){c[d+32>>2]=f;c[b>>2]=e;e=d+40|0;c[e>>2]=(c[e>>2]|0)+1;if((c[d+36>>2]|0)==1?(c[d+24>>2]|0)==2:0)a[d+54>>0]=1;c[d+44>>2]=4;i=g;return}if((f|0)!=1){i=g;return}c[d+32>>2]=1;i=g;return}function mn(b,
d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0,k=0,l=0;j=i;if((b|0)!=(c[d+8>>2]|0)){k=c[b+8>>2]|0;mb[c[(c[k>>2]|0)+20>>2]&7](k,d,e,f,g,h);i=j;return}a[d+53>>0]=1;if((c[d+4>>2]|0)!=(f|0)){i=j;return}a[d+52>>0]=1;f=d+16|0;h=c[f>>2]|0;if((h|0)==0){c[f>>2]=e;c[d+24>>2]=g;c[d+36>>2]=1;if(!((g|0)==1?(c[d+48>>2]|0)==1:0)){i=j;return}a[d+54>>0]=1;i=j;return}if((h|0)!=(e|0)){e=d+36|0;c[e>>2]=(c[e>>2]|0)+1;a[d+54>>0]=1;i=j;return}e=d+24|0;h=c[e>>2]|0;if((h|0)==2){c[e>>2]=g;l=g}else l=h;if(!((l|0)==
1?(c[d+48>>2]|0)==1:0)){i=j;return}a[d+54>>0]=1;i=j;return}function nn(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0;h=i;if((c[d+8>>2]|0)!=(b|0)){i=h;return}a[d+53>>0]=1;if((c[d+4>>2]|0)!=(f|0)){i=h;return}a[d+52>>0]=1;f=d+16|0;b=c[f>>2]|0;if((b|0)==0){c[f>>2]=e;c[d+24>>2]=g;c[d+36>>2]=1;if(!((g|0)==1?(c[d+48>>2]|0)==1:0)){i=h;return}a[d+54>>0]=1;i=h;return}if((b|0)!=(e|0)){e=d+36|0;c[e>>2]=(c[e>>2]|0)+1;a[d+54>>0]=1;i=h;return}e=d+24|0;b=c[e>>2]|0;if((b|0)==2){c[e>>2]=g;j=g}else j=b;if(!((j|
0)==1?(c[d+48>>2]|0)==1:0)){i=h;return}a[d+54>>0]=1;i=h;return}function on(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Ea=0,Fa=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0;b=i;do if(a>>>0<245){if(a>>>0<
11)d=16;else d=a+11&-8;e=d>>>3;f=c[2284]|0;g=f>>>e;if((g&3|0)!=0){h=(g&1^1)+e|0;j=h<<1;k=9176+(j<<2)|0;l=9176+(j+2<<2)|0;j=c[l>>2]|0;m=j+8|0;n=c[m>>2]|0;do if((k|0)!=(n|0)){if(n>>>0<(c[9152>>2]|0)>>>0)Ua();o=n+12|0;if((c[o>>2]|0)==(j|0)){c[o>>2]=k;c[l>>2]=n;break}else Ua()}else c[2284]=f&~(1<<h);while(0);n=h<<3;c[j+4>>2]=n|3;l=j+(n|4)|0;c[l>>2]=c[l>>2]|1;p=m;i=b;return p|0}if(d>>>0>(c[9144>>2]|0)>>>0){if((g|0)!=0){l=2<<e;n=g<<e&(l|0-l);l=(n&0-n)+-1|0;n=l>>>12&16;k=l>>>n;l=k>>>5&8;o=k>>>l;k=o>>>2&
4;q=o>>>k;o=q>>>1&2;r=q>>>o;q=r>>>1&1;s=(l|n|k|o|q)+(r>>>q)|0;q=s<<1;r=9176+(q<<2)|0;o=9176+(q+2<<2)|0;q=c[o>>2]|0;k=q+8|0;n=c[k>>2]|0;do if((r|0)!=(n|0)){if(n>>>0<(c[9152>>2]|0)>>>0)Ua();l=n+12|0;if((c[l>>2]|0)==(q|0)){c[l>>2]=r;c[o>>2]=n;break}else Ua()}else c[2284]=f&~(1<<s);while(0);f=s<<3;n=f-d|0;c[q+4>>2]=d|3;o=q+d|0;c[q+(d|4)>>2]=n|1;c[q+f>>2]=n;f=c[9144>>2]|0;if((f|0)!=0){r=c[9156>>2]|0;e=f>>>3;f=e<<1;g=9176+(f<<2)|0;m=c[2284]|0;j=1<<e;if((m&j|0)!=0){e=9176+(f+2<<2)|0;h=c[e>>2]|0;if(h>>>0<
(c[9152>>2]|0)>>>0)Ua();else{t=e;u=h}}else{c[2284]=m|j;t=9176+(f+2<<2)|0;u=g}c[t>>2]=r;c[u+12>>2]=r;c[r+8>>2]=u;c[r+12>>2]=g}c[9144>>2]=n;c[9156>>2]=o;p=k;i=b;return p|0}o=c[9140>>2]|0;if((o|0)!=0){n=(o&0-o)+-1|0;o=n>>>12&16;g=n>>>o;n=g>>>5&8;r=g>>>n;g=r>>>2&4;f=r>>>g;r=f>>>1&2;j=f>>>r;f=j>>>1&1;m=c[9440+((n|o|g|r|f)+(j>>>f)<<2)>>2]|0;f=(c[m+4>>2]&-8)-d|0;j=m;r=m;while(1){m=c[j+16>>2]|0;if((m|0)==0){g=c[j+20>>2]|0;if((g|0)==0)break;else v=g}else v=m;m=(c[v+4>>2]&-8)-d|0;g=m>>>0<f>>>0;f=g?m:f;j=v;
r=g?v:r}j=c[9152>>2]|0;if(r>>>0<j>>>0)Ua();k=r+d|0;if(!(r>>>0<k>>>0))Ua();q=c[r+24>>2]|0;s=c[r+12>>2]|0;do if((s|0)==(r|0)){g=r+20|0;m=c[g>>2]|0;if((m|0)==0){o=r+16|0;n=c[o>>2]|0;if((n|0)==0){w=0;break}else{x=n;y=o}}else{x=m;y=g}while(1){g=x+20|0;m=c[g>>2]|0;if((m|0)!=0){x=m;y=g;continue}g=x+16|0;m=c[g>>2]|0;if((m|0)==0)break;else{x=m;y=g}}if(y>>>0<j>>>0)Ua();else{c[y>>2]=0;w=x;break}}else{g=c[r+8>>2]|0;if(g>>>0<j>>>0)Ua();m=g+12|0;if((c[m>>2]|0)!=(r|0))Ua();o=s+8|0;if((c[o>>2]|0)==(r|0)){c[m>>2]=
s;c[o>>2]=g;w=s;break}else Ua()}while(0);do if((q|0)!=0){s=c[r+28>>2]|0;j=9440+(s<<2)|0;if((r|0)==(c[j>>2]|0)){c[j>>2]=w;if((w|0)==0){c[9140>>2]=c[9140>>2]&~(1<<s);break}}else{if(q>>>0<(c[9152>>2]|0)>>>0)Ua();s=q+16|0;if((c[s>>2]|0)==(r|0))c[s>>2]=w;else c[q+20>>2]=w;if((w|0)==0)break}if(w>>>0<(c[9152>>2]|0)>>>0)Ua();c[w+24>>2]=q;s=c[r+16>>2]|0;do if((s|0)!=0)if(s>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[w+16>>2]=s;c[s+24>>2]=w;break}while(0);s=c[r+20>>2]|0;if((s|0)!=0)if(s>>>0<(c[9152>>2]|0)>>>0)Ua();
else{c[w+20>>2]=s;c[s+24>>2]=w;break}}while(0);if(f>>>0<16){q=f+d|0;c[r+4>>2]=q|3;s=r+(q+4)|0;c[s>>2]=c[s>>2]|1}else{c[r+4>>2]=d|3;c[r+(d|4)>>2]=f|1;c[r+(f+d)>>2]=f;s=c[9144>>2]|0;if((s|0)!=0){q=c[9156>>2]|0;j=s>>>3;s=j<<1;g=9176+(s<<2)|0;o=c[2284]|0;m=1<<j;if((o&m|0)!=0){j=9176+(s+2<<2)|0;n=c[j>>2]|0;if(n>>>0<(c[9152>>2]|0)>>>0)Ua();else{z=j;A=n}}else{c[2284]=o|m;z=9176+(s+2<<2)|0;A=g}c[z>>2]=q;c[A+12>>2]=q;c[q+8>>2]=A;c[q+12>>2]=g}c[9144>>2]=f;c[9156>>2]=k}p=r+8|0;i=b;return p|0}else B=d}else B=
d}else if(!(a>>>0>4294967231)){g=a+11|0;q=g&-8;s=c[9140>>2]|0;if((s|0)!=0){m=0-q|0;o=g>>>8;if((o|0)!=0)if(q>>>0>16777215)C=31;else{g=(o+1048320|0)>>>16&8;n=o<<g;o=(n+520192|0)>>>16&4;j=n<<o;n=(j+245760|0)>>>16&2;h=14-(o|g|n)+(j<<n>>>15)|0;C=q>>>(h+7|0)&1|h<<1}else C=0;h=c[9440+(C<<2)>>2]|0;a:do if((h|0)==0){D=m;E=0;F=0}else{if((C|0)==31)G=0;else G=25-(C>>>1)|0;n=m;j=0;g=q<<G;o=h;e=0;while(1){l=c[o+4>>2]&-8;H=l-q|0;if(H>>>0<n>>>0)if((l|0)==(q|0)){D=H;E=o;F=o;break a}else{I=H;J=o}else{I=n;J=e}H=c[o+
20>>2]|0;o=c[o+(g>>>31<<2)+16>>2]|0;l=(H|0)==0|(H|0)==(o|0)?j:H;if((o|0)==0){D=I;E=l;F=J;break}else{n=I;j=l;g=g<<1;e=J}}}while(0);if((E|0)==0&(F|0)==0){h=2<<C;m=s&(h|0-h);if((m|0)==0){B=q;break}h=(m&0-m)+-1|0;m=h>>>12&16;r=h>>>m;h=r>>>5&8;k=r>>>h;r=k>>>2&4;f=k>>>r;k=f>>>1&2;e=f>>>k;f=e>>>1&1;K=c[9440+((h|m|r|k|f)+(e>>>f)<<2)>>2]|0}else K=E;if((K|0)==0){L=D;M=F}else{f=D;e=K;k=F;while(1){r=(c[e+4>>2]&-8)-q|0;m=r>>>0<f>>>0;h=m?r:f;r=m?e:k;m=c[e+16>>2]|0;if((m|0)!=0){f=h;e=m;k=r;continue}e=c[e+20>>2]|
0;if((e|0)==0){L=h;M=r;break}else{f=h;k=r}}}if((M|0)!=0?L>>>0<((c[9144>>2]|0)-q|0)>>>0:0){k=c[9152>>2]|0;if(M>>>0<k>>>0)Ua();f=M+q|0;if(!(M>>>0<f>>>0))Ua();e=c[M+24>>2]|0;s=c[M+12>>2]|0;do if((s|0)==(M|0)){r=M+20|0;h=c[r>>2]|0;if((h|0)==0){m=M+16|0;g=c[m>>2]|0;if((g|0)==0){N=0;break}else{O=g;P=m}}else{O=h;P=r}while(1){r=O+20|0;h=c[r>>2]|0;if((h|0)!=0){O=h;P=r;continue}r=O+16|0;h=c[r>>2]|0;if((h|0)==0)break;else{O=h;P=r}}if(P>>>0<k>>>0)Ua();else{c[P>>2]=0;N=O;break}}else{r=c[M+8>>2]|0;if(r>>>0<k>>>
0)Ua();h=r+12|0;if((c[h>>2]|0)!=(M|0))Ua();m=s+8|0;if((c[m>>2]|0)==(M|0)){c[h>>2]=s;c[m>>2]=r;N=s;break}else Ua()}while(0);do if((e|0)!=0){s=c[M+28>>2]|0;k=9440+(s<<2)|0;if((M|0)==(c[k>>2]|0)){c[k>>2]=N;if((N|0)==0){c[9140>>2]=c[9140>>2]&~(1<<s);break}}else{if(e>>>0<(c[9152>>2]|0)>>>0)Ua();s=e+16|0;if((c[s>>2]|0)==(M|0))c[s>>2]=N;else c[e+20>>2]=N;if((N|0)==0)break}if(N>>>0<(c[9152>>2]|0)>>>0)Ua();c[N+24>>2]=e;s=c[M+16>>2]|0;do if((s|0)!=0)if(s>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[N+16>>2]=s;c[s+24>>
2]=N;break}while(0);s=c[M+20>>2]|0;if((s|0)!=0)if(s>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[N+20>>2]=s;c[s+24>>2]=N;break}}while(0);b:do if(!(L>>>0<16)){c[M+4>>2]=q|3;c[M+(q|4)>>2]=L|1;c[M+(L+q)>>2]=L;e=L>>>3;if(L>>>0<256){s=e<<1;k=9176+(s<<2)|0;r=c[2284]|0;m=1<<e;do if((r&m|0)==0){c[2284]=r|m;Q=9176+(s+2<<2)|0;R=k}else{e=9176+(s+2<<2)|0;h=c[e>>2]|0;if(!(h>>>0<(c[9152>>2]|0)>>>0)){Q=e;R=h;break}Ua()}while(0);c[Q>>2]=f;c[R+12>>2]=f;c[M+(q+8)>>2]=R;c[M+(q+12)>>2]=k;break}s=L>>>8;if((s|0)!=0)if(L>>>0>16777215)S=
31;else{m=(s+1048320|0)>>>16&8;r=s<<m;s=(r+520192|0)>>>16&4;h=r<<s;r=(h+245760|0)>>>16&2;e=14-(s|m|r)+(h<<r>>>15)|0;S=L>>>(e+7|0)&1|e<<1}else S=0;e=9440+(S<<2)|0;c[M+(q+28)>>2]=S;c[M+(q+20)>>2]=0;c[M+(q+16)>>2]=0;r=c[9140>>2]|0;h=1<<S;if((r&h|0)==0){c[9140>>2]=r|h;c[e>>2]=f;c[M+(q+24)>>2]=e;c[M+(q+12)>>2]=f;c[M+(q+8)>>2]=f;break}h=c[e>>2]|0;if((S|0)==31)T=0;else T=25-(S>>>1)|0;c:do if((c[h+4>>2]&-8|0)!=(L|0)){e=L<<T;r=h;while(1){U=r+(e>>>31<<2)+16|0;m=c[U>>2]|0;if((m|0)==0)break;if((c[m+4>>2]&-8|
0)==(L|0)){V=m;break c}else{e=e<<1;r=m}}if(U>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[U>>2]=f;c[M+(q+24)>>2]=r;c[M+(q+12)>>2]=f;c[M+(q+8)>>2]=f;break b}}else V=h;while(0);h=V+8|0;k=c[h>>2]|0;e=c[9152>>2]|0;if(V>>>0<e>>>0)Ua();if(k>>>0<e>>>0)Ua();else{c[k+12>>2]=f;c[h>>2]=f;c[M+(q+8)>>2]=k;c[M+(q+12)>>2]=V;c[M+(q+24)>>2]=0;break}}else{k=L+q|0;c[M+4>>2]=k|3;h=M+(k+4)|0;c[h>>2]=c[h>>2]|1}while(0);p=M+8|0;i=b;return p|0}else B=q}else B=q}else B=-1;while(0);M=c[9144>>2]|0;if(!(B>>>0>M>>>0)){L=M-B|0;V=c[9156>>
2]|0;if(L>>>0>15){c[9156>>2]=V+B;c[9144>>2]=L;c[V+(B+4)>>2]=L|1;c[V+M>>2]=L;c[V+4>>2]=B|3}else{c[9144>>2]=0;c[9156>>2]=0;c[V+4>>2]=M|3;L=V+(M+4)|0;c[L>>2]=c[L>>2]|1}p=V+8|0;i=b;return p|0}V=c[9148>>2]|0;if(B>>>0<V>>>0){L=V-B|0;c[9148>>2]=L;V=c[9160>>2]|0;c[9160>>2]=V+B;c[V+(B+4)>>2]=L|1;c[V+4>>2]=B|3;p=V+8|0;i=b;return p|0}do if((c[2402]|0)==0){V=Ta(30)|0;if((V+-1&V|0)==0){c[9616>>2]=V;c[9612>>2]=V;c[9620>>2]=-1;c[9624>>2]=-1;c[9628>>2]=0;c[9580>>2]=0;c[2402]=(Da(0)|0)&-16^1431655768;break}else Ua()}while(0);
V=B+48|0;L=c[9616>>2]|0;M=B+47|0;U=L+M|0;T=0-L|0;L=U&T;if(!(L>>>0>B>>>0)){p=0;i=b;return p|0}S=c[9576>>2]|0;if((S|0)!=0?(R=c[9568>>2]|0,Q=R+L|0,Q>>>0<=R>>>0|Q>>>0>S>>>0):0){p=0;i=b;return p|0}d:do if((c[9580>>2]&4|0)==0){S=c[9160>>2]|0;e:do if((S|0)!=0){Q=9584|0;while(1){R=c[Q>>2]|0;if(!(R>>>0>S>>>0)?(W=Q+4|0,(R+(c[W>>2]|0)|0)>>>0>S>>>0):0)break;R=c[Q+8>>2]|0;if((R|0)==0){X=182;break e}else Q=R}if((Q|0)!=0){R=U-(c[9148>>2]|0)&T;if(R>>>0<2147483647){N=Ga(R|0)|0;O=(N|0)==((c[Q>>2]|0)+(c[W>>2]|0)|0);
Y=N;Z=R;_=O?N:-1;$=O?R:0;X=191}else aa=0}else X=182}else X=182;while(0);do if((X|0)==182){S=Ga(0)|0;if((S|0)!=(-1|0)){q=S;R=c[9612>>2]|0;O=R+-1|0;if((O&q|0)==0)ba=L;else ba=L-q+(O+q&0-R)|0;R=c[9568>>2]|0;q=R+ba|0;if(ba>>>0>B>>>0&ba>>>0<2147483647){O=c[9576>>2]|0;if((O|0)!=0?q>>>0<=R>>>0|q>>>0>O>>>0:0){aa=0;break}O=Ga(ba|0)|0;q=(O|0)==(S|0);Y=O;Z=ba;_=q?S:-1;$=q?ba:0;X=191}else aa=0}else aa=0}while(0);f:do if((X|0)==191){q=0-Z|0;if((_|0)!=(-1|0)){ca=_;da=$;X=202;break d}do if((Y|0)!=(-1|0)&Z>>>0<2147483647&
Z>>>0<V>>>0?(S=c[9616>>2]|0,O=M-Z+S&0-S,O>>>0<2147483647):0)if((Ga(O|0)|0)==(-1|0)){Ga(q|0)|0;aa=$;break f}else{ea=O+Z|0;break}else ea=Z;while(0);if((Y|0)==(-1|0))aa=$;else{ca=Y;da=ea;X=202;break d}}while(0);c[9580>>2]=c[9580>>2]|4;fa=aa;X=199}else{fa=0;X=199}while(0);if((((X|0)==199?L>>>0<2147483647:0)?(aa=Ga(L|0)|0,L=Ga(0)|0,(L|0)!=(-1|0)&(aa|0)!=(-1|0)&aa>>>0<L>>>0):0)?(ea=L-aa|0,L=ea>>>0>(B+40|0)>>>0,L):0){ca=aa;da=L?ea:fa;X=202}if((X|0)==202){fa=(c[9568>>2]|0)+da|0;c[9568>>2]=fa;if(fa>>>0>(c[9572>>
2]|0)>>>0)c[9572>>2]=fa;fa=c[9160>>2]|0;g:do if((fa|0)!=0){ea=9584|0;while(1){ga=c[ea>>2]|0;ha=ea+4|0;ia=c[ha>>2]|0;if((ca|0)==(ga+ia|0)){X=214;break}L=c[ea+8>>2]|0;if((L|0)==0)break;else ea=L}if(((X|0)==214?(c[ea+12>>2]&8|0)==0:0)?fa>>>0>=ga>>>0&fa>>>0<ca>>>0:0){c[ha>>2]=ia+da;L=(c[9148>>2]|0)+da|0;aa=fa+8|0;if((aa&7|0)==0)ja=0;else ja=0-aa&7;aa=L-ja|0;c[9160>>2]=fa+ja;c[9148>>2]=aa;c[fa+(ja+4)>>2]=aa|1;c[fa+(L+4)>>2]=40;c[9164>>2]=c[9624>>2];break}if(ca>>>0<(c[9152>>2]|0)>>>0)c[9152>>2]=ca;L=ca+
da|0;aa=9584|0;while(1){if((c[aa>>2]|0)==(L|0)){X=224;break}Y=c[aa+8>>2]|0;if((Y|0)==0)break;else aa=Y}if((X|0)==224?(c[aa+12>>2]&8|0)==0:0){c[aa>>2]=ca;L=aa+4|0;c[L>>2]=(c[L>>2]|0)+da;L=ca+8|0;if((L&7|0)==0)ka=0;else ka=0-L&7;L=ca+(da+8)|0;if((L&7|0)==0)la=0;else la=0-L&7;L=ca+(la+da)|0;ea=ka+B|0;Y=ca+ea|0;$=L-(ca+ka)-B|0;c[ca+(ka+4)>>2]=B|3;h:do if((L|0)!=(c[9160>>2]|0)){if((L|0)==(c[9156>>2]|0)){Z=(c[9144>>2]|0)+$|0;c[9144>>2]=Z;c[9156>>2]=Y;c[ca+(ea+4)>>2]=Z|1;c[ca+(Z+ea)>>2]=Z;break}Z=da+4|0;
M=c[ca+(Z+la)>>2]|0;if((M&3|0)==1){V=M&-8;_=M>>>3;i:do if(!(M>>>0<256)){ba=c[ca+((la|24)+da)>>2]|0;W=c[ca+(da+12+la)>>2]|0;do if((W|0)==(L|0)){T=la|16;U=ca+(Z+T)|0;q=c[U>>2]|0;if((q|0)==0){Q=ca+(T+da)|0;T=c[Q>>2]|0;if((T|0)==0){ma=0;break}else{na=T;oa=Q}}else{na=q;oa=U}while(1){U=na+20|0;q=c[U>>2]|0;if((q|0)!=0){na=q;oa=U;continue}U=na+16|0;q=c[U>>2]|0;if((q|0)==0)break;else{na=q;oa=U}}if(oa>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[oa>>2]=0;ma=na;break}}else{U=c[ca+((la|8)+da)>>2]|0;if(U>>>0<(c[9152>>2]|
0)>>>0)Ua();q=U+12|0;if((c[q>>2]|0)!=(L|0))Ua();Q=W+8|0;if((c[Q>>2]|0)==(L|0)){c[q>>2]=W;c[Q>>2]=U;ma=W;break}else Ua()}while(0);if((ba|0)==0)break;W=c[ca+(da+28+la)>>2]|0;r=9440+(W<<2)|0;do if((L|0)!=(c[r>>2]|0)){if(ba>>>0<(c[9152>>2]|0)>>>0)Ua();U=ba+16|0;if((c[U>>2]|0)==(L|0))c[U>>2]=ma;else c[ba+20>>2]=ma;if((ma|0)==0)break i}else{c[r>>2]=ma;if((ma|0)!=0)break;c[9140>>2]=c[9140>>2]&~(1<<W);break i}while(0);if(ma>>>0<(c[9152>>2]|0)>>>0)Ua();c[ma+24>>2]=ba;W=la|16;r=c[ca+(W+da)>>2]|0;do if((r|0)!=
0)if(r>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[ma+16>>2]=r;c[r+24>>2]=ma;break}while(0);r=c[ca+(Z+W)>>2]|0;if((r|0)==0)break;if(r>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[ma+20>>2]=r;c[r+24>>2]=ma;break}}else{r=c[ca+((la|8)+da)>>2]|0;ba=c[ca+(da+12+la)>>2]|0;U=9176+(_<<1<<2)|0;do if((r|0)!=(U|0)){if(r>>>0<(c[9152>>2]|0)>>>0)Ua();if((c[r+12>>2]|0)==(L|0))break;Ua()}while(0);if((ba|0)==(r|0)){c[2284]=c[2284]&~(1<<_);break}do if((ba|0)==(U|0))pa=ba+8|0;else{if(ba>>>0<(c[9152>>2]|0)>>>0)Ua();W=ba+8|0;if((c[W>>2]|
0)==(L|0)){pa=W;break}Ua()}while(0);c[r+12>>2]=ba;c[pa>>2]=r}while(0);qa=ca+((V|la)+da)|0;ra=V+$|0}else{qa=L;ra=$}_=qa+4|0;c[_>>2]=c[_>>2]&-2;c[ca+(ea+4)>>2]=ra|1;c[ca+(ra+ea)>>2]=ra;_=ra>>>3;if(ra>>>0<256){Z=_<<1;M=9176+(Z<<2)|0;U=c[2284]|0;W=1<<_;do if((U&W|0)==0){c[2284]=U|W;sa=9176+(Z+2<<2)|0;ta=M}else{_=9176+(Z+2<<2)|0;Q=c[_>>2]|0;if(!(Q>>>0<(c[9152>>2]|0)>>>0)){sa=_;ta=Q;break}Ua()}while(0);c[sa>>2]=Y;c[ta+12>>2]=Y;c[ca+(ea+8)>>2]=ta;c[ca+(ea+12)>>2]=M;break}Z=ra>>>8;do if((Z|0)==0)ua=0;else{if(ra>>>
0>16777215){ua=31;break}W=(Z+1048320|0)>>>16&8;U=Z<<W;V=(U+520192|0)>>>16&4;Q=U<<V;U=(Q+245760|0)>>>16&2;_=14-(V|W|U)+(Q<<U>>>15)|0;ua=ra>>>(_+7|0)&1|_<<1}while(0);Z=9440+(ua<<2)|0;c[ca+(ea+28)>>2]=ua;c[ca+(ea+20)>>2]=0;c[ca+(ea+16)>>2]=0;M=c[9140>>2]|0;_=1<<ua;if((M&_|0)==0){c[9140>>2]=M|_;c[Z>>2]=Y;c[ca+(ea+24)>>2]=Z;c[ca+(ea+12)>>2]=Y;c[ca+(ea+8)>>2]=Y;break}_=c[Z>>2]|0;if((ua|0)==31)va=0;else va=25-(ua>>>1)|0;j:do if((c[_+4>>2]&-8|0)!=(ra|0)){Z=ra<<va;M=_;while(1){wa=M+(Z>>>31<<2)+16|0;U=c[wa>>
2]|0;if((U|0)==0)break;if((c[U+4>>2]&-8|0)==(ra|0)){xa=U;break j}else{Z=Z<<1;M=U}}if(wa>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[wa>>2]=Y;c[ca+(ea+24)>>2]=M;c[ca+(ea+12)>>2]=Y;c[ca+(ea+8)>>2]=Y;break h}}else xa=_;while(0);_=xa+8|0;Z=c[_>>2]|0;r=c[9152>>2]|0;if(xa>>>0<r>>>0)Ua();if(Z>>>0<r>>>0)Ua();else{c[Z+12>>2]=Y;c[_>>2]=Y;c[ca+(ea+8)>>2]=Z;c[ca+(ea+12)>>2]=xa;c[ca+(ea+24)>>2]=0;break}}else{Z=(c[9148>>2]|0)+$|0;c[9148>>2]=Z;c[9160>>2]=Y;c[ca+(ea+4)>>2]=Z|1}while(0);p=ca+(ka|8)|0;i=b;return p|0}ea=9584|
0;while(1){ya=c[ea>>2]|0;if(!(ya>>>0>fa>>>0)?(za=c[ea+4>>2]|0,Aa=ya+za|0,Aa>>>0>fa>>>0):0)break;ea=c[ea+8>>2]|0}ea=ya+(za+-39)|0;if((ea&7|0)==0)Ba=0;else Ba=0-ea&7;ea=ya+(za+-47+Ba)|0;Y=ea>>>0<(fa+16|0)>>>0?fa:ea;ea=Y+8|0;$=ca+8|0;if(($&7|0)==0)Ca=0;else Ca=0-$&7;$=da+-40-Ca|0;c[9160>>2]=ca+Ca;c[9148>>2]=$;c[ca+(Ca+4)>>2]=$|1;c[ca+(da+-36)>>2]=40;c[9164>>2]=c[9624>>2];c[Y+4>>2]=27;c[ea+0>>2]=c[9584>>2];c[ea+4>>2]=c[9588>>2];c[ea+8>>2]=c[9592>>2];c[ea+12>>2]=c[9596>>2];c[9584>>2]=ca;c[9588>>2]=da;
c[9596>>2]=0;c[9592>>2]=ea;ea=Y+28|0;c[ea>>2]=7;if((Y+32|0)>>>0<Aa>>>0){$=ea;do{ea=$;$=$+4|0;c[$>>2]=7}while((ea+8|0)>>>0<Aa>>>0)}if((Y|0)!=(fa|0)){$=Y-fa|0;ea=fa+($+4)|0;c[ea>>2]=c[ea>>2]&-2;c[fa+4>>2]=$|1;c[fa+$>>2]=$;ea=$>>>3;if($>>>0<256){L=ea<<1;aa=9176+(L<<2)|0;Z=c[2284]|0;_=1<<ea;do if((Z&_|0)==0){c[2284]=Z|_;Ea=9176+(L+2<<2)|0;Fa=aa}else{ea=9176+(L+2<<2)|0;r=c[ea>>2]|0;if(!(r>>>0<(c[9152>>2]|0)>>>0)){Ea=ea;Fa=r;break}Ua()}while(0);c[Ea>>2]=fa;c[Fa+12>>2]=fa;c[fa+8>>2]=Fa;c[fa+12>>2]=aa;break}L=
$>>>8;if((L|0)!=0)if($>>>0>16777215)Ha=31;else{_=(L+1048320|0)>>>16&8;Z=L<<_;L=(Z+520192|0)>>>16&4;Y=Z<<L;Z=(Y+245760|0)>>>16&2;r=14-(L|_|Z)+(Y<<Z>>>15)|0;Ha=$>>>(r+7|0)&1|r<<1}else Ha=0;r=9440+(Ha<<2)|0;c[fa+28>>2]=Ha;c[fa+20>>2]=0;c[fa+16>>2]=0;Z=c[9140>>2]|0;Y=1<<Ha;if((Z&Y|0)==0){c[9140>>2]=Z|Y;c[r>>2]=fa;c[fa+24>>2]=r;c[fa+12>>2]=fa;c[fa+8>>2]=fa;break}Y=c[r>>2]|0;if((Ha|0)==31)Ia=0;else Ia=25-(Ha>>>1)|0;k:do if((c[Y+4>>2]&-8|0)!=($|0)){r=$<<Ia;Z=Y;while(1){Ja=Z+(r>>>31<<2)+16|0;_=c[Ja>>2]|0;
if((_|0)==0)break;if((c[_+4>>2]&-8|0)==($|0)){Ka=_;break k}else{r=r<<1;Z=_}}if(Ja>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[Ja>>2]=fa;c[fa+24>>2]=Z;c[fa+12>>2]=fa;c[fa+8>>2]=fa;break g}}else Ka=Y;while(0);Y=Ka+8|0;$=c[Y>>2]|0;aa=c[9152>>2]|0;if(Ka>>>0<aa>>>0)Ua();if($>>>0<aa>>>0)Ua();else{c[$+12>>2]=fa;c[Y>>2]=fa;c[fa+8>>2]=$;c[fa+12>>2]=Ka;c[fa+24>>2]=0;break}}}else{$=c[9152>>2]|0;if(($|0)==0|ca>>>0<$>>>0)c[9152>>2]=ca;c[9584>>2]=ca;c[9588>>2]=da;c[9596>>2]=0;c[9172>>2]=c[2402];c[9168>>2]=-1;$=0;do{Y=$<<
1;aa=9176+(Y<<2)|0;c[9176+(Y+3<<2)>>2]=aa;c[9176+(Y+2<<2)>>2]=aa;$=$+1|0}while(($|0)!=32);$=ca+8|0;if(($&7|0)==0)La=0;else La=0-$&7;$=da+-40-La|0;c[9160>>2]=ca+La;c[9148>>2]=$;c[ca+(La+4)>>2]=$|1;c[ca+(da+-36)>>2]=40;c[9164>>2]=c[9624>>2]}while(0);da=c[9148>>2]|0;if(da>>>0>B>>>0){ca=da-B|0;c[9148>>2]=ca;da=c[9160>>2]|0;c[9160>>2]=da+B;c[da+(B+4)>>2]=ca|1;c[da+4>>2]=B|3;p=da+8|0;i=b;return p|0}}c[(Qa()|0)>>2]=12;p=0;i=b;return p|0}function pn(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=
0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0;b=i;if((a|0)==0){i=b;return}d=a+-8|0;e=c[9152>>2]|0;if(d>>>0<e>>>0)Ua();f=c[a+-4>>2]|0;g=f&3;if((g|0)==1)Ua();h=f&-8;j=a+(h+-8)|0;do if((f&1|0)==0){k=c[d>>2]|0;if((g|0)==0){i=b;return}l=-8-k|0;m=a+l|0;n=k+h|0;if(m>>>0<e>>>0)Ua();if((m|0)==(c[9156>>2]|0)){o=a+(h+-4)|0;if((c[o>>2]&3|0)!=3){p=m;q=n;break}c[9144>>2]=n;c[o>>2]=c[o>>2]&-2;c[a+(l+4)>>2]=n|1;c[j>>2]=n;i=b;return}o=k>>>3;if(k>>>0<256){k=c[a+(l+8)>>
2]|0;r=c[a+(l+12)>>2]|0;s=9176+(o<<1<<2)|0;if((k|0)!=(s|0)){if(k>>>0<e>>>0)Ua();if((c[k+12>>2]|0)!=(m|0))Ua()}if((r|0)==(k|0)){c[2284]=c[2284]&~(1<<o);p=m;q=n;break}if((r|0)!=(s|0)){if(r>>>0<e>>>0)Ua();s=r+8|0;if((c[s>>2]|0)==(m|0))t=s;else Ua()}else t=r+8|0;c[k+12>>2]=r;c[t>>2]=k;p=m;q=n;break}k=c[a+(l+24)>>2]|0;r=c[a+(l+12)>>2]|0;do if((r|0)==(m|0)){s=a+(l+20)|0;o=c[s>>2]|0;if((o|0)==0){u=a+(l+16)|0;v=c[u>>2]|0;if((v|0)==0){w=0;break}else{x=v;y=u}}else{x=o;y=s}while(1){s=x+20|0;o=c[s>>2]|0;if((o|
0)!=0){x=o;y=s;continue}s=x+16|0;o=c[s>>2]|0;if((o|0)==0)break;else{x=o;y=s}}if(y>>>0<e>>>0)Ua();else{c[y>>2]=0;w=x;break}}else{s=c[a+(l+8)>>2]|0;if(s>>>0<e>>>0)Ua();o=s+12|0;if((c[o>>2]|0)!=(m|0))Ua();u=r+8|0;if((c[u>>2]|0)==(m|0)){c[o>>2]=r;c[u>>2]=s;w=r;break}else Ua()}while(0);if((k|0)!=0){r=c[a+(l+28)>>2]|0;s=9440+(r<<2)|0;if((m|0)==(c[s>>2]|0)){c[s>>2]=w;if((w|0)==0){c[9140>>2]=c[9140>>2]&~(1<<r);p=m;q=n;break}}else{if(k>>>0<(c[9152>>2]|0)>>>0)Ua();r=k+16|0;if((c[r>>2]|0)==(m|0))c[r>>2]=w;else c[k+
20>>2]=w;if((w|0)==0){p=m;q=n;break}}if(w>>>0<(c[9152>>2]|0)>>>0)Ua();c[w+24>>2]=k;r=c[a+(l+16)>>2]|0;do if((r|0)!=0)if(r>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[w+16>>2]=r;c[r+24>>2]=w;break}while(0);r=c[a+(l+20)>>2]|0;if((r|0)!=0)if(r>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[w+20>>2]=r;c[r+24>>2]=w;p=m;q=n;break}else{p=m;q=n}}else{p=m;q=n}}else{p=d;q=h}while(0);if(!(p>>>0<j>>>0))Ua();d=a+(h+-4)|0;w=c[d>>2]|0;if((w&1|0)==0)Ua();if((w&2|0)==0){if((j|0)==(c[9160>>2]|0)){e=(c[9148>>2]|0)+q|0;c[9148>>2]=e;c[9160>>
2]=p;c[p+4>>2]=e|1;if((p|0)!=(c[9156>>2]|0)){i=b;return}c[9156>>2]=0;c[9144>>2]=0;i=b;return}if((j|0)==(c[9156>>2]|0)){e=(c[9144>>2]|0)+q|0;c[9144>>2]=e;c[9156>>2]=p;c[p+4>>2]=e|1;c[p+e>>2]=e;i=b;return}e=(w&-8)+q|0;x=w>>>3;do if(!(w>>>0<256)){y=c[a+(h+16)>>2]|0;t=c[a+(h|4)>>2]|0;do if((t|0)==(j|0)){g=a+(h+12)|0;f=c[g>>2]|0;if((f|0)==0){r=a+(h+8)|0;k=c[r>>2]|0;if((k|0)==0){z=0;break}else{A=k;B=r}}else{A=f;B=g}while(1){g=A+20|0;f=c[g>>2]|0;if((f|0)!=0){A=f;B=g;continue}g=A+16|0;f=c[g>>2]|0;if((f|0)==
0)break;else{A=f;B=g}}if(B>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[B>>2]=0;z=A;break}}else{g=c[a+h>>2]|0;if(g>>>0<(c[9152>>2]|0)>>>0)Ua();f=g+12|0;if((c[f>>2]|0)!=(j|0))Ua();r=t+8|0;if((c[r>>2]|0)==(j|0)){c[f>>2]=t;c[r>>2]=g;z=t;break}else Ua()}while(0);if((y|0)!=0){t=c[a+(h+20)>>2]|0;n=9440+(t<<2)|0;if((j|0)==(c[n>>2]|0)){c[n>>2]=z;if((z|0)==0){c[9140>>2]=c[9140>>2]&~(1<<t);break}}else{if(y>>>0<(c[9152>>2]|0)>>>0)Ua();t=y+16|0;if((c[t>>2]|0)==(j|0))c[t>>2]=z;else c[y+20>>2]=z;if((z|0)==0)break}if(z>>>
0<(c[9152>>2]|0)>>>0)Ua();c[z+24>>2]=y;t=c[a+(h+8)>>2]|0;do if((t|0)!=0)if(t>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[z+16>>2]=t;c[t+24>>2]=z;break}while(0);t=c[a+(h+12)>>2]|0;if((t|0)!=0)if(t>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[z+20>>2]=t;c[t+24>>2]=z;break}}}else{t=c[a+h>>2]|0;y=c[a+(h|4)>>2]|0;n=9176+(x<<1<<2)|0;if((t|0)!=(n|0)){if(t>>>0<(c[9152>>2]|0)>>>0)Ua();if((c[t+12>>2]|0)!=(j|0))Ua()}if((y|0)==(t|0)){c[2284]=c[2284]&~(1<<x);break}if((y|0)!=(n|0)){if(y>>>0<(c[9152>>2]|0)>>>0)Ua();n=y+8|0;if((c[n>>
2]|0)==(j|0))C=n;else Ua()}else C=y+8|0;c[t+12>>2]=y;c[C>>2]=t}while(0);c[p+4>>2]=e|1;c[p+e>>2]=e;if((p|0)==(c[9156>>2]|0)){c[9144>>2]=e;i=b;return}else D=e}else{c[d>>2]=w&-2;c[p+4>>2]=q|1;c[p+q>>2]=q;D=q}q=D>>>3;if(D>>>0<256){w=q<<1;d=9176+(w<<2)|0;e=c[2284]|0;C=1<<q;if((e&C|0)!=0){q=9176+(w+2<<2)|0;j=c[q>>2]|0;if(j>>>0<(c[9152>>2]|0)>>>0)Ua();else{E=q;F=j}}else{c[2284]=e|C;E=9176+(w+2<<2)|0;F=d}c[E>>2]=p;c[F+12>>2]=p;c[p+8>>2]=F;c[p+12>>2]=d;i=b;return}d=D>>>8;if((d|0)!=0)if(D>>>0>16777215)G=31;
else{F=(d+1048320|0)>>>16&8;E=d<<F;d=(E+520192|0)>>>16&4;w=E<<d;E=(w+245760|0)>>>16&2;C=14-(d|F|E)+(w<<E>>>15)|0;G=D>>>(C+7|0)&1|C<<1}else G=0;C=9440+(G<<2)|0;c[p+28>>2]=G;c[p+20>>2]=0;c[p+16>>2]=0;E=c[9140>>2]|0;w=1<<G;a:do if((E&w|0)!=0){F=c[C>>2]|0;if((G|0)==31)H=0;else H=25-(G>>>1)|0;b:do if((c[F+4>>2]&-8|0)!=(D|0)){d=D<<H;e=F;while(1){I=e+(d>>>31<<2)+16|0;j=c[I>>2]|0;if((j|0)==0)break;if((c[j+4>>2]&-8|0)==(D|0)){J=j;break b}else{d=d<<1;e=j}}if(I>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[I>>2]=p;c[p+
24>>2]=e;c[p+12>>2]=p;c[p+8>>2]=p;break a}}else J=F;while(0);F=J+8|0;d=c[F>>2]|0;j=c[9152>>2]|0;if(J>>>0<j>>>0)Ua();if(d>>>0<j>>>0)Ua();else{c[d+12>>2]=p;c[F>>2]=p;c[p+8>>2]=d;c[p+12>>2]=J;c[p+24>>2]=0;break}}else{c[9140>>2]=E|w;c[C>>2]=p;c[p+24>>2]=C;c[p+12>>2]=p;c[p+8>>2]=p}while(0);p=(c[9168>>2]|0)+-1|0;c[9168>>2]=p;if((p|0)==0)K=9592|0;else{i=b;return}while(1){p=c[K>>2]|0;if((p|0)==0)break;else K=p+8|0}c[9168>>2]=-1;i=b;return}function qn(a){a=a|0;var b=0,d=0,e=0,f=0;b=i;d=(a|0)==0?1:a;while(1){e=
on(d)|0;if((e|0)!=0){f=6;break}a=c[2410]|0;c[2410]=a+0;if((a|0)==0){f=5;break}jb[a&1]()}if((f|0)==5){d=Aa(4)|0;c[d>>2]=9656;Sa(d|0,9704,92)}else if((f|0)==6){i=b;return e|0}return 0}function rn(a,b){a=a|0;b=b|0;var c=0;b=i;c=qn(a)|0;i=b;return c|0}function sn(a){a=a|0;var b=0;b=i;if((a|0)!=0)pn(a);i=b;return}function tn(a){a=a|0;var b=0;b=i;Ra(a|0);sn(a);i=b;return}function un(a){a=a|0;var b=0;b=i;Ra(a|0);i=b;return}function vn(a){a=a|0;return 9672}function wn(){c[2428]=o}function xn(b,d,e){b=b|0;
d=d|0;e=e|0;var f=0,g=0,h=0,i=0;f=b+e|0;if((e|0)>=20){d=d&255;g=b&3;h=d|d<<8|d<<16|d<<24;i=f&~3;if(g){g=b+4-g|0;while((b|0)<(g|0)){a[b>>0]=d;b=b+1|0}}while((b|0)<(i|0)){c[b>>2]=h;b=b+4|0}}while((b|0)<(f|0)){a[b>>0]=d;b=b+1|0}return b-e|0}function yn(b){b=b|0;var c=0;c=b;while(a[c>>0]|0)c=c+1|0;return c-b|0}function zn(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=a+c>>>0;return(E=b+d+(e>>>0<a>>>0|0)>>>0,e|0)|0}function An(b,d,e){b=b|0;d=d|0;e=e|0;var f=0;if((e|0)>=4096)return Ma(b|0,d|0,e|0)|0;f=b|0;
if((b&3)==(d&3)){while(b&3){if((e|0)==0)return f|0;a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0}while((e|0)>=4){c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;e=e-4|0}}while((e|0)>0){a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0}return f|0}function Bn(b,c,d){b=b|0;c=c|0;d=d|0;var e=0;if((c|0)<(b|0)&(b|0)<(c+d|0)){e=b;c=c+d|0;b=b+d|0;while((d|0)>0){b=b-1|0;c=c-1|0;d=d-1|0;a[b>>0]=a[c>>0]|0}b=e}else An(b,c,d)|0;return b|0}function Cn(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=b-d>>>0;e=b-d-(c>>>0>a>>>0|0)>>>0;return(E=e,
a-c>>>0|0)|0}function Dn(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){E=b<<c|(a&(1<<c)-1<<32-c)>>>32-c;return a<<c}E=a<<c-32;return 0}function En(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){E=b>>>c;return a>>>c|(b&(1<<c)-1)<<32-c}E=0;return b>>>c-32|0}function Fn(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){E=b>>c;return a>>>c|(b&(1<<c)-1)<<32-c}E=(b|0)<0?-1:0;return b>>c-32|0}function Gn(b){b=b|0;var c=0;c=a[n+(b>>>24)>>0]|0;if((c|0)<8)return c|0;c=a[n+(b>>16&255)>>0]|0;if((c|0)<8)return c+8|0;c=a[n+(b>>8&255)>>0]|
0;if((c|0)<8)return c+16|0;return(a[n+(b&255)>>0]|0)+24|0}function Hn(b){b=b|0;var c=0;c=a[m+(b&255)>>0]|0;if((c|0)<8)return c|0;c=a[m+(b>>8&255)>>0]|0;if((c|0)<8)return c+8|0;c=a[m+(b>>16&255)>>0]|0;if((c|0)<8)return c+16|0;return(a[m+(b>>>24)>>0]|0)+24|0}function In(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;c=a&65535;d=b&65535;e=aa(d,c)|0;f=a>>>16;a=(e>>>16)+(aa(d,f)|0)|0;d=b>>>16;b=aa(d,c)|0;return(E=(a>>>16)+(aa(d,f)|0)+(((a&65535)+b|0)>>>16)|0,a+b<<16|e&65535|0)|0}function Jn(a,b,c,d){a=a|0;b=b|0;
c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=b>>31|((b|0)<0?-1:0)<<1;f=((b|0)<0?-1:0)>>31|((b|0)<0?-1:0)<<1;g=d>>31|((d|0)<0?-1:0)<<1;h=((d|0)<0?-1:0)>>31|((d|0)<0?-1:0)<<1;i=Cn(e^a,f^b,e,f)|0;b=E;a=g^e;e=h^f;f=Cn((On(i,b,Cn(g^c,h^d,g,h)|0,E,0)|0)^a,E^e,a,e)|0;return f|0}function Kn(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0;f=i;i=i+8|0;g=f|0;h=b>>31|((b|0)<0?-1:0)<<1;j=((b|0)<0?-1:0)>>31|((b|0)<0?-1:0)<<1;k=e>>31|((e|0)<0?-1:0)<<1;l=((e|0)<0?-1:0)>>31|((e|0)<0?-1:0)<<1;m=Cn(h^a,j^
b,h,j)|0;b=E;On(m,b,Cn(k^d,l^e,k,l)|0,E,g)|0;l=Cn(c[g>>2]^h,c[g+4>>2]^j,h,j)|0;j=E;i=f;return(E=j,l)|0}function Ln(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=a;a=c;c=In(e,a)|0;f=E;return(E=(aa(b,a)|0)+(aa(d,e)|0)+f|f&0,c|0|0)|0}function Mn(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=On(a,b,c,d,0)|0;return e|0}function Nn(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;f=i;i=i+8|0;g=f|0;On(a,b,d,e,g)|0;i=f;return(E=c[g+4>>2]|0,c[g>>2]|0)|0}function On(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=
0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,F=0,G=0,H=0;g=a;h=b;i=h;j=d;k=e;l=k;if((i|0)==0){m=(f|0)!=0;if((l|0)==0){if(m){c[f>>2]=(g>>>0)%(j>>>0);c[f+4>>2]=0}n=0;o=(g>>>0)/(j>>>0)>>>0;return(E=n,o)|0}else{if(!m){n=0;o=0;return(E=n,o)|0}c[f>>2]=a|0;c[f+4>>2]=b&0;n=0;o=0;return(E=n,o)|0}}m=(l|0)==0;do if((j|0)!=0){if(!m){p=(Gn(l|0)|0)-(Gn(i|0)|0)|0;if(p>>>0<=31){q=p+1|0;r=31-p|0;s=p-31>>31;t=q;u=g>>>(q>>>0)&s|i<<r;v=i>>>(q>>>0)&s;w=0;x=g<<r;break}if((f|
0)==0){n=0;o=0;return(E=n,o)|0}c[f>>2]=a|0;c[f+4>>2]=h|b&0;n=0;o=0;return(E=n,o)|0}r=j-1|0;if((r&j|0)!=0){s=(Gn(j|0)|0)+33-(Gn(i|0)|0)|0;q=64-s|0;p=32-s|0;y=p>>31;z=s-32|0;A=z>>31;t=s;u=p-1>>31&i>>>(z>>>0)|(i<<p|g>>>(s>>>0))&A;v=A&i>>>(s>>>0);w=g<<q&y;x=(i<<q|g>>>(z>>>0))&y|g<<p&s-33>>31;break}if((f|0)!=0){c[f>>2]=r&g;c[f+4>>2]=0}if((j|0)==1){n=h|b&0;o=a|0|0;return(E=n,o)|0}else{r=Hn(j|0)|0;n=i>>>(r>>>0)|0;o=i<<32-r|g>>>(r>>>0)|0;return(E=n,o)|0}}else{if(m){if((f|0)!=0){c[f>>2]=(i>>>0)%(j>>>0);c[f+
4>>2]=0}n=0;o=(i>>>0)/(j>>>0)>>>0;return(E=n,o)|0}if((g|0)==0){if((f|0)!=0){c[f>>2]=0;c[f+4>>2]=(i>>>0)%(l>>>0)}n=0;o=(i>>>0)/(l>>>0)>>>0;return(E=n,o)|0}r=l-1|0;if((r&l|0)==0){if((f|0)!=0){c[f>>2]=a|0;c[f+4>>2]=r&i|b&0}n=0;o=i>>>((Hn(l|0)|0)>>>0);return(E=n,o)|0}r=(Gn(l|0)|0)-(Gn(i|0)|0)|0;if(r>>>0<=30){s=r+1|0;p=31-r|0;t=s;u=i<<p|g>>>(s>>>0);v=i>>>(s>>>0);w=0;x=g<<p;break}if((f|0)==0){n=0;o=0;return(E=n,o)|0}c[f>>2]=a|0;c[f+4>>2]=h|b&0;n=0;o=0;return(E=n,o)|0}while(0);if((t|0)==0){B=x;C=w;D=v;F=
u;G=0;H=0}else{b=d|0|0;d=k|e&0;e=zn(b,d,-1,-1)|0;k=E;h=x;x=w;w=v;v=u;u=t;t=0;do{a=h;h=x>>>31|h<<1;x=t|x<<1;g=v<<1|a>>>31|0;a=v>>>31|w<<1|0;Cn(e,k,g,a)|0;i=E;l=i>>31|((i|0)<0?-1:0)<<1;t=l&1;v=Cn(g,a,l&b,(((i|0)<0?-1:0)>>31|((i|0)<0?-1:0)<<1)&d)|0;w=E;u=u-1|0}while((u|0)!=0);B=h;C=x;D=w;F=v;G=0;H=t}t=C;C=0;if((f|0)!=0){c[f>>2]=F;c[f+4>>2]=D}n=(t|0)>>>31|(B|C)<<1|(C<<1|t>>>31)&0|G;o=(t<<1|0>>>31)&-2|H;return(E=n,o)|0}function Pn(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=+g;return+ab[a&1](b|
0,c|0,d|0,e|0,f|0,+g)}function Qn(a,b){a=a|0;b=b|0;return bb[a&7](b|0)|0}function Rn(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;cb[a&3](b|0,c|0,d|0,e|0,f|0)}function Sn(a,b,c){a=a|0;b=b|0;c=+c;return+db[a&15](b|0,+c)}function Tn(a,b){a=a|0;b=b|0;eb[a&127](b|0)}function Un(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=+f;return+fb[a&1](b|0,c|0,d|0,e|0,+f)}function Vn(a,b,c){a=a|0;b=b|0;c=c|0;gb[a&63](b|0,c|0)}function Wn(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return hb[a&15](b|0,c|0,d|0)|0}function Xn(a,
b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;ib[a&7](b|0,c|0,d|0)}function Yn(a){a=a|0;jb[a&1]()}function Zn(a,b,c,d){a=a|0;b=b|0;c=c|0;d=+d;kb[a&31](b|0,c|0,+d)}function _n(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;return lb[a&7](b|0,c|0,d|0,e|0)|0}function $n(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;mb[a&7](b|0,c|0,d|0,e|0,f|0,g|0)}function ao(a,b,c){a=a|0;b=b|0;c=c|0;return nb[a&31](b|0,c|0)|0}function bo(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return ob[a&15](b|0,c|0,d|0,e|0,f|0)|0}
function co(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;pb[a&31](b|0,c|0,d|0,e|0)}function eo(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=+f;ba(0);return 0}function fo(a){a=a|0;ba(1);return 0}function go(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;ba(2)}function ho(a,b){a=a|0;b=+b;ba(3);return 0}function io(a){a=a|0;ba(4)}function jo(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=+e;ba(5);return 0}function ko(a,b){a=a|0;b=b|0;ba(6)}function lo(a,b,c){a=a|0;b=b|0;c=c|0;ba(7);return 0}function mo(a,b,c){a=a|0;b=b|
0;c=c|0;ba(8)}function no(){ba(9)}function oo(){_a()}function po(a,b,c){a=a|0;b=b|0;c=+c;ba(10)}function qo(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;ba(11);return 0}function ro(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;ba(12)}function so(a,b){a=a|0;b=b|0;ba(13);return 0}function to(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;ba(14);return 0}function uo(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;ba(15)}var ab=[eo,Gd];var bb=[fo,ge,ne,ve,Fe,rm,vn,fo];var cb=[go,ln,kn,go];var db=[ho,Df,Qf,dg,pg,Bg,Mg,Zg,ph,Hh,Zh,
ki,ho,ho,ho,ho];var eb=[io,pc,Ed,oc,Id,nc,Md,Gb,Wd,Ib,Vd,Cb,Xd,Ce,Be,rf,sf,Ff,Gf,Hf,Tf,Vf,Wf,eg,fg,gg,qg,rg,sg,Cg,Dg,Eg,Og,Pg,Qg,fh,gh,hh,qh,rh,sh,wh,xh,yh,Oh,Ph,Qh,$h,ai,bi,li,ni,oi,si,ti,yi,zi,Di,Ei,Ii,Ji,Wi,Xi,$i,aj,ej,fj,jj,kj,Rj,ck,Ul,Vl,Zl,_l,am,bm,dm,em,Jk,im,km,lm,om,pm,xm,ym,an,dn,bn,cn,en,un,tn,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io];var fb=[jo,Fd];var gb=[ko,Nd,Od,Af,Bf,Ef,xf,yf,Nf,Of,Uf,Kf,Lf,ag,bg,Zf,_f,mg,ng,jg,kg,yg,zg,
vg,wg,Jg,Kg,Gg,Hg,Wg,Xg,Tg,Ug,mh,nh,jh,kh,Eh,Fh,Bh,Ch,Wh,Xh,Th,Uh,hi,ii,mi,ei,fi,dk,ek,Om,Gi,Bi,hj,Ui,cj,Zi,qi,ko,ko,ko,ko];var hb=[lo,Kd,he,pe,we,Ie,qf,gm,mm,sm,Am,fn,lo,lo,lo,lo];var ib=[mo,Pd,Rd,Td,Ud,fk,gk,mo];var jb=[no,oo];var kb=[po,le,te,Ae,Le,Cf,Pf,cg,og,Ag,Lg,Yg,oh,Gh,Yh,ji,wm,po,po,po,po,po,po,po,po,po,po,po,po,po,po,po];var lb=[qo,tf,uf,hm,nm,qo,qo,qo];var mb=[ro,ie,qe,xe,He,tm,nn,mn];var nb=[so,Hd,Jd,Ld,fe,me,ue,Ee,zf,Mf,$f,lg,xg,Ig,Vg,lh,Dh,Vh,gi,Wl,Xl,fm,jm,qm,zm,Nm,Zj,Kk,Lk,Wk,Vk,
_k];var ob=[to,je,re,ye,Je,um,Fi,Ai,gj,Ti,bj,Yi,pi,to,to,to];var pb=[uo,Qd,Sd,ke,se,ze,Ke,ri,Ci,Hi,Vi,_i,dj,ij,Yl,$l,cm,vm,gn,hn,uo,uo,uo,uo,uo,uo,uo,uo,uo,uo,uo,uo];return{_b2PrismaticJoint_IsMotorEnabled:Yc,_b2Body_GetWorldVector:fc,_strlen:yn,_b2Body_GetLocalVector:_b,_b2PrismaticJoint_GetMotorSpeed:Vc,_b2RopeJointDef_Create:kd,_b2World_CreateParticleSystem:sc,_b2ParticleSystem_SetRadius:Dd,_b2FrictionJointDef_Create:Gc,_b2World_RayCast:yc,_b2MotorJointDef_InitializeAndCreate:Pc,_b2GearJoint_GetRatio:Ic,
_b2Body_GetLocalPoint:Zb,_memcpy:An,_b2RevoluteJoint_EnableLimit:cd,_b2Body_DestroyFixture:Ub,_b2World_Create:qc,_b2PolygonShape_CreateFixture_3:Hb,_b2PolygonShape_CreateFixture_6:Lb,_b2PolygonShape_CreateFixture_7:Mb,_b2PolygonShape_CreateFixture_4:Jb,_b2PolygonShape_CreateFixture_5:Kb,_b2Body_SetAwake:gc,_b2Body_GetWorldCenter:dc,_b2ParticleGroup_DestroyParticles:td,_b2PrismaticJoint_EnableLimit:Sc,_b2Fixture_TestPoint:mc,_b2MotorJoint_SetLinearOffset:Nc,_free:pn,_b2ParticleSystem_CreateParticle:wd,
_b2Body_SetLinearVelocity:ic,_b2CircleShape_CreateParticleGroup:Db,_b2WeldJointDef_Create:ld,_b2Body_GetAngularVelocity:Wb,_b2Body_ApplyForceToCenter:Sb,_b2DistanceJointDef_InitializeAndCreate:Fc,_b2Body_ApplyForce:Rb,_b2RevoluteJoint_SetMotorSpeed:jd,_b2Body_GetPosition:ac,_b2World_CreateBody:rc,_b2Body_GetLinearVelocity:Yb,_b2Body_SetMassData:jc,_b2MouseJointDef_Create:Rc,_b2ParticleSystem_GetColorBuffer:xd,_b2DistanceJointDef_Create:Ec,_b2ParticleSystem_GetPositionBuffer:zd,_b2CircleShape_DestroyParticlesInShape:Eb,
_b2World_QueryAABB:xc,_b2PolygonShape_DestroyParticlesInShape_4:Pb,_b2RevoluteJointDef_InitializeAndCreate:id,_b2GearJointDef_Create:Jc,_b2PrismaticJoint_IsLimitEnabled:Xc,_b2Contact_GetWorldManifold:Dc,_b2WheelJoint_SetSpringFrequencyHz:od,_b2Body_ApplyTorque:Tb,_b2ParticleGroup_ApplyLinearImpulse:sd,_b2PrismaticJointDef_InitializeAndCreate:$c,_memset:xn,_b2MotorJointDef_Create:Oc,_b2World_DestroyBody:uc,_b2RevoluteJointDef_Create:hd,_b2ParticleGroup_GetParticleCount:vd,_b2World_SetGravity:Ac,_b2PrismaticJoint_EnableMotor:Tc,
_b2PolygonShape_CreateParticleGroup_4:Ob,_b2PolygonShape_CreateFixture_8:Nb,_b2Body_SetAngularVelocity:hc,_b2Body_GetWorldPoint:ec,_b2WheelJoint_SetMotorSpeed:nd,_b2FrictionJointDef_InitializeAndCreate:Hc,_b2World_SetContactListener:zc,_b2ParticleSystem_SetDamping:Bd,_b2Body_SetType:lc,_b2Body_SetTransform:kc,_b2CircleShape_CreateFixture:Bb,_b2RevoluteJoint_GetJointAngle:ed,_b2ParticleGroup_ApplyForce:rd,_malloc:on,_b2Contact_GetManifold:Cc,_b2RevoluteJoint_IsMotorEnabled:gd,_b2ParticleSystem_GetVelocityBuffer:Ad,
_b2RevoluteJoint_IsLimitEnabled:fd,_b2World_DestroyParticleSystem:wc,_b2RevoluteJoint_EnableMotor:dd,_b2Body_GetTransform:bc,_b2WeldJointDef_InitializeAndCreate:md,_b2EdgeShape_CreateFixture:Fb,_b2Body_GetType:cc,_b2Manifold_GetPointCount:yb,_b2ParticleSystem_SetDensity:Cd,_b2PrismaticJoint_GetMotorForce:Wc,_b2Joint_GetBodyA:Kc,_b2PulleyJointDef_InitializeAndCreate:bd,_b2Joint_GetBodyB:Lc,_b2ParticleSystem_GetParticleCount:yd,_b2MouseJoint_SetTarget:Qc,_b2Body_ApplyAngularImpulse:Qb,_b2ChainShape_CreateFixture:zb,
_b2World_DestroyJoint:vc,_b2MotorJoint_SetAngularOffset:Mc,_b2World_Delete:tc,_b2PrismaticJoint_GetJointTranslation:Uc,_i64Add:zn,_b2Body_GetMass:$b,_b2Body_GetAngle:Vb,_b2ParticleGroup_GetBufferIndex:ud,_b2WheelJointDef_InitializeAndCreate:qd,_b2World_Step:Bc,_b2PrismaticJointDef_Create:_c,_b2WheelJointDef_Create:pd,_b2PulleyJointDef_Create:ad,_b2Body_GetInertia:Xb,_memmove:Bn,_b2PrismaticJoint_SetMotorSpeed:Zc,__GLOBAL__I_a:Yd,runPostSets:wn,stackAlloc:qb,stackSave:rb,stackRestore:sb,setThrew:tb,
setTempRet0:wb,getTempRet0:xb,dynCall_diiiiid:Pn,dynCall_ii:Qn,dynCall_viiiii:Rn,dynCall_did:Sn,dynCall_vi:Tn,dynCall_diiiid:Un,dynCall_vii:Vn,dynCall_iiii:Wn,dynCall_viii:Xn,dynCall_v:Yn,dynCall_viid:Zn,dynCall_iiiii:_n,dynCall_viiiiii:$n,dynCall_iii:ao,dynCall_iiiiii:bo,dynCall_viiii:co}}({"Math":Math,"Int8Array":Int8Array,"Int16Array":Int16Array,"Int32Array":Int32Array,"Uint8Array":Uint8Array,"Uint16Array":Uint16Array,"Uint32Array":Uint32Array,"Float32Array":Float32Array,"Float64Array":Float64Array},
{"abort":abort,"assert":assert,"asmPrintInt":asmPrintInt,"asmPrintFloat":asmPrintFloat,"min":Math_min,"invoke_diiiiid":invoke_diiiiid,"invoke_ii":invoke_ii,"invoke_viiiii":invoke_viiiii,"invoke_did":invoke_did,"invoke_vi":invoke_vi,"invoke_diiiid":invoke_diiiid,"invoke_vii":invoke_vii,"invoke_iiii":invoke_iiii,"invoke_viii":invoke_viii,"invoke_v":invoke_v,"invoke_viid":invoke_viid,"invoke_iiiii":invoke_iiiii,"invoke_viiiiii":invoke_viiiiii,"invoke_iii":invoke_iii,"invoke_iiiiii":invoke_iiiiii,"invoke_viiii":invoke_viiii,
"_cosf":_cosf,"__ZSt9terminatev":__ZSt9terminatev,"_b2WorldPreSolve":_b2WorldPreSolve,"___cxa_is_number_type":___cxa_is_number_type,"___cxa_allocate_exception":___cxa_allocate_exception,"___cxa_find_matching_catch":___cxa_find_matching_catch,"_fflush":_fflush,"_time":_time,"__exit":__exit,"___setErrNo":___setErrNo,"_sbrk":_sbrk,"___cxa_begin_catch":___cxa_begin_catch,"_sinf":_sinf,"___resumeException":___resumeException,"__ZSt18uncaught_exceptionv":__ZSt18uncaught_exceptionv,"_b2WorldRayCastCallback":_b2WorldRayCastCallback,
"_emscripten_memcpy_big":_emscripten_memcpy_big,"_floorf":_floorf,"_sqrtf":_sqrtf,"_b2WorldBeginContactBody":_b2WorldBeginContactBody,"___errno_location":___errno_location,"__ZNSt9exceptionD2Ev":__ZNSt9exceptionD2Ev,"___cxa_throw":___cxa_throw,"_sysconf":_sysconf,"_abort":_abort,"___cxa_does_inherit":___cxa_does_inherit,"_b2WorldEndContactBody":_b2WorldEndContactBody,"_b2WorldQueryAABB":_b2WorldQueryAABB,"_b2WorldPostSolve":_b2WorldPostSolve,"_exit":_exit,"___cxa_pure_virtual":___cxa_pure_virtual,
"STACKTOP":STACKTOP,"STACK_MAX":STACK_MAX,"tempDoublePtr":tempDoublePtr,"ABORT":ABORT,"cttz_i8":cttz_i8,"ctlz_i8":ctlz_i8,"NaN":NaN,"Infinity":Infinity,"__ZTISt9exception":__ZTISt9exception},buffer);var _b2PrismaticJoint_IsMotorEnabled=Module["_b2PrismaticJoint_IsMotorEnabled"]=asm["_b2PrismaticJoint_IsMotorEnabled"];var _b2Body_GetWorldVector=Module["_b2Body_GetWorldVector"]=asm["_b2Body_GetWorldVector"];var _strlen=Module["_strlen"]=asm["_strlen"];
var _b2Body_GetLocalVector=Module["_b2Body_GetLocalVector"]=asm["_b2Body_GetLocalVector"];var _b2PrismaticJoint_GetMotorSpeed=Module["_b2PrismaticJoint_GetMotorSpeed"]=asm["_b2PrismaticJoint_GetMotorSpeed"];var _b2RopeJointDef_Create=Module["_b2RopeJointDef_Create"]=asm["_b2RopeJointDef_Create"];var _b2World_CreateParticleSystem=Module["_b2World_CreateParticleSystem"]=asm["_b2World_CreateParticleSystem"];var _b2ParticleSystem_SetRadius=Module["_b2ParticleSystem_SetRadius"]=asm["_b2ParticleSystem_SetRadius"];
var _b2FrictionJointDef_Create=Module["_b2FrictionJointDef_Create"]=asm["_b2FrictionJointDef_Create"];var _b2World_RayCast=Module["_b2World_RayCast"]=asm["_b2World_RayCast"];var _b2MotorJointDef_InitializeAndCreate=Module["_b2MotorJointDef_InitializeAndCreate"]=asm["_b2MotorJointDef_InitializeAndCreate"];var _b2GearJoint_GetRatio=Module["_b2GearJoint_GetRatio"]=asm["_b2GearJoint_GetRatio"];var _b2Body_GetLocalPoint=Module["_b2Body_GetLocalPoint"]=asm["_b2Body_GetLocalPoint"];
var _memcpy=Module["_memcpy"]=asm["_memcpy"];var _b2RevoluteJoint_EnableLimit=Module["_b2RevoluteJoint_EnableLimit"]=asm["_b2RevoluteJoint_EnableLimit"];var _b2Body_DestroyFixture=Module["_b2Body_DestroyFixture"]=asm["_b2Body_DestroyFixture"];var _b2World_Create=Module["_b2World_Create"]=asm["_b2World_Create"];var _b2PolygonShape_CreateFixture_3=Module["_b2PolygonShape_CreateFixture_3"]=asm["_b2PolygonShape_CreateFixture_3"];
var _b2PolygonShape_CreateFixture_6=Module["_b2PolygonShape_CreateFixture_6"]=asm["_b2PolygonShape_CreateFixture_6"];var _b2PolygonShape_CreateFixture_7=Module["_b2PolygonShape_CreateFixture_7"]=asm["_b2PolygonShape_CreateFixture_7"];var _b2PolygonShape_CreateFixture_4=Module["_b2PolygonShape_CreateFixture_4"]=asm["_b2PolygonShape_CreateFixture_4"];var _b2PolygonShape_CreateFixture_5=Module["_b2PolygonShape_CreateFixture_5"]=asm["_b2PolygonShape_CreateFixture_5"];
var _b2Body_SetAwake=Module["_b2Body_SetAwake"]=asm["_b2Body_SetAwake"];var _b2Body_GetWorldCenter=Module["_b2Body_GetWorldCenter"]=asm["_b2Body_GetWorldCenter"];var _b2ParticleGroup_DestroyParticles=Module["_b2ParticleGroup_DestroyParticles"]=asm["_b2ParticleGroup_DestroyParticles"];var _b2PrismaticJoint_EnableLimit=Module["_b2PrismaticJoint_EnableLimit"]=asm["_b2PrismaticJoint_EnableLimit"];var _b2Fixture_TestPoint=Module["_b2Fixture_TestPoint"]=asm["_b2Fixture_TestPoint"];
var _b2MotorJoint_SetLinearOffset=Module["_b2MotorJoint_SetLinearOffset"]=asm["_b2MotorJoint_SetLinearOffset"];var _free=Module["_free"]=asm["_free"];var _b2ParticleSystem_CreateParticle=Module["_b2ParticleSystem_CreateParticle"]=asm["_b2ParticleSystem_CreateParticle"];var _b2Body_SetLinearVelocity=Module["_b2Body_SetLinearVelocity"]=asm["_b2Body_SetLinearVelocity"];var _b2CircleShape_CreateParticleGroup=Module["_b2CircleShape_CreateParticleGroup"]=asm["_b2CircleShape_CreateParticleGroup"];
var _b2WeldJointDef_Create=Module["_b2WeldJointDef_Create"]=asm["_b2WeldJointDef_Create"];var _b2Body_GetAngularVelocity=Module["_b2Body_GetAngularVelocity"]=asm["_b2Body_GetAngularVelocity"];var _b2Body_ApplyForceToCenter=Module["_b2Body_ApplyForceToCenter"]=asm["_b2Body_ApplyForceToCenter"];var _b2DistanceJointDef_InitializeAndCreate=Module["_b2DistanceJointDef_InitializeAndCreate"]=asm["_b2DistanceJointDef_InitializeAndCreate"];var _b2Body_ApplyForce=Module["_b2Body_ApplyForce"]=asm["_b2Body_ApplyForce"];
var _b2RevoluteJoint_SetMotorSpeed=Module["_b2RevoluteJoint_SetMotorSpeed"]=asm["_b2RevoluteJoint_SetMotorSpeed"];var _b2Body_GetPosition=Module["_b2Body_GetPosition"]=asm["_b2Body_GetPosition"];var _b2World_CreateBody=Module["_b2World_CreateBody"]=asm["_b2World_CreateBody"];var _b2Body_GetLinearVelocity=Module["_b2Body_GetLinearVelocity"]=asm["_b2Body_GetLinearVelocity"];var _b2Body_SetMassData=Module["_b2Body_SetMassData"]=asm["_b2Body_SetMassData"];
var _b2MouseJointDef_Create=Module["_b2MouseJointDef_Create"]=asm["_b2MouseJointDef_Create"];var _b2ParticleSystem_GetColorBuffer=Module["_b2ParticleSystem_GetColorBuffer"]=asm["_b2ParticleSystem_GetColorBuffer"];var _b2DistanceJointDef_Create=Module["_b2DistanceJointDef_Create"]=asm["_b2DistanceJointDef_Create"];var _b2ParticleSystem_GetPositionBuffer=Module["_b2ParticleSystem_GetPositionBuffer"]=asm["_b2ParticleSystem_GetPositionBuffer"];
var _b2CircleShape_DestroyParticlesInShape=Module["_b2CircleShape_DestroyParticlesInShape"]=asm["_b2CircleShape_DestroyParticlesInShape"];var _b2World_QueryAABB=Module["_b2World_QueryAABB"]=asm["_b2World_QueryAABB"];var _b2PolygonShape_DestroyParticlesInShape_4=Module["_b2PolygonShape_DestroyParticlesInShape_4"]=asm["_b2PolygonShape_DestroyParticlesInShape_4"];var _b2RevoluteJointDef_InitializeAndCreate=Module["_b2RevoluteJointDef_InitializeAndCreate"]=asm["_b2RevoluteJointDef_InitializeAndCreate"];
var _b2GearJointDef_Create=Module["_b2GearJointDef_Create"]=asm["_b2GearJointDef_Create"];var _b2PrismaticJoint_IsLimitEnabled=Module["_b2PrismaticJoint_IsLimitEnabled"]=asm["_b2PrismaticJoint_IsLimitEnabled"];var _b2Contact_GetWorldManifold=Module["_b2Contact_GetWorldManifold"]=asm["_b2Contact_GetWorldManifold"];var _b2WheelJoint_SetSpringFrequencyHz=Module["_b2WheelJoint_SetSpringFrequencyHz"]=asm["_b2WheelJoint_SetSpringFrequencyHz"];var _b2Body_ApplyTorque=Module["_b2Body_ApplyTorque"]=asm["_b2Body_ApplyTorque"];
var _b2ParticleGroup_ApplyLinearImpulse=Module["_b2ParticleGroup_ApplyLinearImpulse"]=asm["_b2ParticleGroup_ApplyLinearImpulse"];var _b2PrismaticJointDef_InitializeAndCreate=Module["_b2PrismaticJointDef_InitializeAndCreate"]=asm["_b2PrismaticJointDef_InitializeAndCreate"];var _memset=Module["_memset"]=asm["_memset"];var _b2MotorJointDef_Create=Module["_b2MotorJointDef_Create"]=asm["_b2MotorJointDef_Create"];var _b2World_DestroyBody=Module["_b2World_DestroyBody"]=asm["_b2World_DestroyBody"];
var _b2RevoluteJointDef_Create=Module["_b2RevoluteJointDef_Create"]=asm["_b2RevoluteJointDef_Create"];var _b2ParticleGroup_GetParticleCount=Module["_b2ParticleGroup_GetParticleCount"]=asm["_b2ParticleGroup_GetParticleCount"];var _b2World_SetGravity=Module["_b2World_SetGravity"]=asm["_b2World_SetGravity"];var _b2PrismaticJoint_EnableMotor=Module["_b2PrismaticJoint_EnableMotor"]=asm["_b2PrismaticJoint_EnableMotor"];
var _b2PolygonShape_CreateParticleGroup_4=Module["_b2PolygonShape_CreateParticleGroup_4"]=asm["_b2PolygonShape_CreateParticleGroup_4"];var _b2PolygonShape_CreateFixture_8=Module["_b2PolygonShape_CreateFixture_8"]=asm["_b2PolygonShape_CreateFixture_8"];var _b2Body_SetAngularVelocity=Module["_b2Body_SetAngularVelocity"]=asm["_b2Body_SetAngularVelocity"];var _b2Body_GetWorldPoint=Module["_b2Body_GetWorldPoint"]=asm["_b2Body_GetWorldPoint"];
var _b2WheelJoint_SetMotorSpeed=Module["_b2WheelJoint_SetMotorSpeed"]=asm["_b2WheelJoint_SetMotorSpeed"];var _b2FrictionJointDef_InitializeAndCreate=Module["_b2FrictionJointDef_InitializeAndCreate"]=asm["_b2FrictionJointDef_InitializeAndCreate"];var _b2World_SetContactListener=Module["_b2World_SetContactListener"]=asm["_b2World_SetContactListener"];var _b2ParticleSystem_SetDamping=Module["_b2ParticleSystem_SetDamping"]=asm["_b2ParticleSystem_SetDamping"];
var _b2Body_SetType=Module["_b2Body_SetType"]=asm["_b2Body_SetType"];var _b2Body_SetTransform=Module["_b2Body_SetTransform"]=asm["_b2Body_SetTransform"];var _b2CircleShape_CreateFixture=Module["_b2CircleShape_CreateFixture"]=asm["_b2CircleShape_CreateFixture"];var _b2RevoluteJoint_GetJointAngle=Module["_b2RevoluteJoint_GetJointAngle"]=asm["_b2RevoluteJoint_GetJointAngle"];var _b2ParticleGroup_ApplyForce=Module["_b2ParticleGroup_ApplyForce"]=asm["_b2ParticleGroup_ApplyForce"];
var _malloc=Module["_malloc"]=asm["_malloc"];var _b2Contact_GetManifold=Module["_b2Contact_GetManifold"]=asm["_b2Contact_GetManifold"];var _b2RevoluteJoint_IsMotorEnabled=Module["_b2RevoluteJoint_IsMotorEnabled"]=asm["_b2RevoluteJoint_IsMotorEnabled"];var _b2ParticleSystem_GetVelocityBuffer=Module["_b2ParticleSystem_GetVelocityBuffer"]=asm["_b2ParticleSystem_GetVelocityBuffer"];var _b2RevoluteJoint_IsLimitEnabled=Module["_b2RevoluteJoint_IsLimitEnabled"]=asm["_b2RevoluteJoint_IsLimitEnabled"];
var _b2World_DestroyParticleSystem=Module["_b2World_DestroyParticleSystem"]=asm["_b2World_DestroyParticleSystem"];var _b2RevoluteJoint_EnableMotor=Module["_b2RevoluteJoint_EnableMotor"]=asm["_b2RevoluteJoint_EnableMotor"];var _b2Body_GetTransform=Module["_b2Body_GetTransform"]=asm["_b2Body_GetTransform"];var _b2WeldJointDef_InitializeAndCreate=Module["_b2WeldJointDef_InitializeAndCreate"]=asm["_b2WeldJointDef_InitializeAndCreate"];
var _b2EdgeShape_CreateFixture=Module["_b2EdgeShape_CreateFixture"]=asm["_b2EdgeShape_CreateFixture"];var _b2Body_GetType=Module["_b2Body_GetType"]=asm["_b2Body_GetType"];var _b2Manifold_GetPointCount=Module["_b2Manifold_GetPointCount"]=asm["_b2Manifold_GetPointCount"];var _b2ParticleSystem_SetDensity=Module["_b2ParticleSystem_SetDensity"]=asm["_b2ParticleSystem_SetDensity"];var _b2PrismaticJoint_GetMotorForce=Module["_b2PrismaticJoint_GetMotorForce"]=asm["_b2PrismaticJoint_GetMotorForce"];
var _b2Joint_GetBodyA=Module["_b2Joint_GetBodyA"]=asm["_b2Joint_GetBodyA"];var _b2PulleyJointDef_InitializeAndCreate=Module["_b2PulleyJointDef_InitializeAndCreate"]=asm["_b2PulleyJointDef_InitializeAndCreate"];var _b2Joint_GetBodyB=Module["_b2Joint_GetBodyB"]=asm["_b2Joint_GetBodyB"];var _b2ParticleSystem_GetParticleCount=Module["_b2ParticleSystem_GetParticleCount"]=asm["_b2ParticleSystem_GetParticleCount"];var _b2MouseJoint_SetTarget=Module["_b2MouseJoint_SetTarget"]=asm["_b2MouseJoint_SetTarget"];
var _b2Body_ApplyAngularImpulse=Module["_b2Body_ApplyAngularImpulse"]=asm["_b2Body_ApplyAngularImpulse"];var _b2ChainShape_CreateFixture=Module["_b2ChainShape_CreateFixture"]=asm["_b2ChainShape_CreateFixture"];var _b2World_DestroyJoint=Module["_b2World_DestroyJoint"]=asm["_b2World_DestroyJoint"];var _b2MotorJoint_SetAngularOffset=Module["_b2MotorJoint_SetAngularOffset"]=asm["_b2MotorJoint_SetAngularOffset"];var _b2World_Delete=Module["_b2World_Delete"]=asm["_b2World_Delete"];
var _b2PrismaticJoint_GetJointTranslation=Module["_b2PrismaticJoint_GetJointTranslation"]=asm["_b2PrismaticJoint_GetJointTranslation"];var _i64Add=Module["_i64Add"]=asm["_i64Add"];var _b2Body_GetMass=Module["_b2Body_GetMass"]=asm["_b2Body_GetMass"];var _b2Body_GetAngle=Module["_b2Body_GetAngle"]=asm["_b2Body_GetAngle"];var _b2ParticleGroup_GetBufferIndex=Module["_b2ParticleGroup_GetBufferIndex"]=asm["_b2ParticleGroup_GetBufferIndex"];
var _b2WheelJointDef_InitializeAndCreate=Module["_b2WheelJointDef_InitializeAndCreate"]=asm["_b2WheelJointDef_InitializeAndCreate"];var _b2World_Step=Module["_b2World_Step"]=asm["_b2World_Step"];var _b2PrismaticJointDef_Create=Module["_b2PrismaticJointDef_Create"]=asm["_b2PrismaticJointDef_Create"];var _b2WheelJointDef_Create=Module["_b2WheelJointDef_Create"]=asm["_b2WheelJointDef_Create"];var _b2PulleyJointDef_Create=Module["_b2PulleyJointDef_Create"]=asm["_b2PulleyJointDef_Create"];
var _b2Body_GetInertia=Module["_b2Body_GetInertia"]=asm["_b2Body_GetInertia"];var _memmove=Module["_memmove"]=asm["_memmove"];var _b2PrismaticJoint_SetMotorSpeed=Module["_b2PrismaticJoint_SetMotorSpeed"]=asm["_b2PrismaticJoint_SetMotorSpeed"];var __GLOBAL__I_a=Module["__GLOBAL__I_a"]=asm["__GLOBAL__I_a"];var runPostSets=Module["runPostSets"]=asm["runPostSets"];var dynCall_diiiiid=Module["dynCall_diiiiid"]=asm["dynCall_diiiiid"];var dynCall_ii=Module["dynCall_ii"]=asm["dynCall_ii"];
var dynCall_viiiii=Module["dynCall_viiiii"]=asm["dynCall_viiiii"];var dynCall_did=Module["dynCall_did"]=asm["dynCall_did"];var dynCall_vi=Module["dynCall_vi"]=asm["dynCall_vi"];var dynCall_diiiid=Module["dynCall_diiiid"]=asm["dynCall_diiiid"];var dynCall_vii=Module["dynCall_vii"]=asm["dynCall_vii"];var dynCall_iiii=Module["dynCall_iiii"]=asm["dynCall_iiii"];var dynCall_viii=Module["dynCall_viii"]=asm["dynCall_viii"];var dynCall_v=Module["dynCall_v"]=asm["dynCall_v"];
var dynCall_viid=Module["dynCall_viid"]=asm["dynCall_viid"];var dynCall_iiiii=Module["dynCall_iiiii"]=asm["dynCall_iiiii"];var dynCall_viiiiii=Module["dynCall_viiiiii"]=asm["dynCall_viiiiii"];var dynCall_iii=Module["dynCall_iii"]=asm["dynCall_iii"];var dynCall_iiiiii=Module["dynCall_iiiiii"]=asm["dynCall_iiiiii"];var dynCall_viiii=Module["dynCall_viiii"]=asm["dynCall_viiii"];Runtime.stackAlloc=asm["stackAlloc"];Runtime.stackSave=asm["stackSave"];Runtime.stackRestore=asm["stackRestore"];
Runtime.setTempRet0=asm["setTempRet0"];Runtime.getTempRet0=asm["getTempRet0"];
var i64Math=function(){var goog={math:{}};goog.math.Long=function(low,high){this.low_=low|0;this.high_=high|0};goog.math.Long.IntCache_={};goog.math.Long.fromInt=function(value){if(-128<=value&&value<128){var cachedObj=goog.math.Long.IntCache_[value];if(cachedObj)return cachedObj}var obj=new goog.math.Long(value|0,value<0?-1:0);if(-128<=value&&value<128)goog.math.Long.IntCache_[value]=obj;return obj};goog.math.Long.fromNumber=function(value){if(isNaN(value)||!isFinite(value))return goog.math.Long.ZERO;
else if(value<=-goog.math.Long.TWO_PWR_63_DBL_)return goog.math.Long.MIN_VALUE;else if(value+1>=goog.math.Long.TWO_PWR_63_DBL_)return goog.math.Long.MAX_VALUE;else if(value<0)return goog.math.Long.fromNumber(-value).negate();else return new goog.math.Long(value%goog.math.Long.TWO_PWR_32_DBL_|0,value/goog.math.Long.TWO_PWR_32_DBL_|0)};goog.math.Long.fromBits=function(lowBits,highBits){return new goog.math.Long(lowBits,highBits)};goog.math.Long.fromString=function(str,opt_radix){if(str.length==0)throw Error("number format error: empty string");
var radix=opt_radix||10;if(radix<2||36<radix)throw Error("radix out of range: "+radix);if(str.charAt(0)=="-")return goog.math.Long.fromString(str.substring(1),radix).negate();else if(str.indexOf("-")>=0)throw Error('number format error: interior "-" character: '+str);var radixToPower=goog.math.Long.fromNumber(Math.pow(radix,8));var result=goog.math.Long.ZERO;for(var i=0;i<str.length;i+=8){var size=Math.min(8,str.length-i);var value=parseInt(str.substring(i,i+size),radix);if(size<8){var power=goog.math.Long.fromNumber(Math.pow(radix,
size));result=result.multiply(power).add(goog.math.Long.fromNumber(value))}else{result=result.multiply(radixToPower);result=result.add(goog.math.Long.fromNumber(value))}}return result};goog.math.Long.TWO_PWR_16_DBL_=1<<16;goog.math.Long.TWO_PWR_24_DBL_=1<<24;goog.math.Long.TWO_PWR_32_DBL_=goog.math.Long.TWO_PWR_16_DBL_*goog.math.Long.TWO_PWR_16_DBL_;goog.math.Long.TWO_PWR_31_DBL_=goog.math.Long.TWO_PWR_32_DBL_/2;goog.math.Long.TWO_PWR_48_DBL_=goog.math.Long.TWO_PWR_32_DBL_*goog.math.Long.TWO_PWR_16_DBL_;
goog.math.Long.TWO_PWR_64_DBL_=goog.math.Long.TWO_PWR_32_DBL_*goog.math.Long.TWO_PWR_32_DBL_;goog.math.Long.TWO_PWR_63_DBL_=goog.math.Long.TWO_PWR_64_DBL_/2;goog.math.Long.ZERO=goog.math.Long.fromInt(0);goog.math.Long.ONE=goog.math.Long.fromInt(1);goog.math.Long.NEG_ONE=goog.math.Long.fromInt(-1);goog.math.Long.MAX_VALUE=goog.math.Long.fromBits(4294967295|0,2147483647|0);goog.math.Long.MIN_VALUE=goog.math.Long.fromBits(0,2147483648|0);goog.math.Long.TWO_PWR_24_=goog.math.Long.fromInt(1<<24);goog.math.Long.prototype.toInt=
function(){return this.low_};goog.math.Long.prototype.toNumber=function(){return this.high_*goog.math.Long.TWO_PWR_32_DBL_+this.getLowBitsUnsigned()};goog.math.Long.prototype.toString=function(opt_radix){var radix=opt_radix||10;if(radix<2||36<radix)throw Error("radix out of range: "+radix);if(this.isZero())return"0";if(this.isNegative())if(this.equals(goog.math.Long.MIN_VALUE)){var radixLong=goog.math.Long.fromNumber(radix);var div=this.div(radixLong);var rem=div.multiply(radixLong).subtract(this);
return div.toString(radix)+rem.toInt().toString(radix)}else return"-"+this.negate().toString(radix);var radixToPower=goog.math.Long.fromNumber(Math.pow(radix,6));var rem=this;var result="";while(true){var remDiv=rem.div(radixToPower);var intval=rem.subtract(remDiv.multiply(radixToPower)).toInt();var digits=intval.toString(radix);rem=remDiv;if(rem.isZero())return digits+result;else{while(digits.length<6)digits="0"+digits;result=""+digits+result}}};goog.math.Long.prototype.getHighBits=function(){return this.high_};
goog.math.Long.prototype.getLowBits=function(){return this.low_};goog.math.Long.prototype.getLowBitsUnsigned=function(){return this.low_>=0?this.low_:goog.math.Long.TWO_PWR_32_DBL_+this.low_};goog.math.Long.prototype.getNumBitsAbs=function(){if(this.isNegative())if(this.equals(goog.math.Long.MIN_VALUE))return 64;else return this.negate().getNumBitsAbs();else{var val=this.high_!=0?this.high_:this.low_;for(var bit=31;bit>0;bit--)if((val&1<<bit)!=0)break;return this.high_!=0?bit+33:bit+1}};goog.math.Long.prototype.isZero=
function(){return this.high_==0&&this.low_==0};goog.math.Long.prototype.isNegative=function(){return this.high_<0};goog.math.Long.prototype.isOdd=function(){return(this.low_&1)==1};goog.math.Long.prototype.equals=function(other){return this.high_==other.high_&&this.low_==other.low_};goog.math.Long.prototype.notEquals=function(other){return this.high_!=other.high_||this.low_!=other.low_};goog.math.Long.prototype.lessThan=function(other){return this.compare(other)<0};goog.math.Long.prototype.lessThanOrEqual=
function(other){return this.compare(other)<=0};goog.math.Long.prototype.greaterThan=function(other){return this.compare(other)>0};goog.math.Long.prototype.greaterThanOrEqual=function(other){return this.compare(other)>=0};goog.math.Long.prototype.compare=function(other){if(this.equals(other))return 0;var thisNeg=this.isNegative();var otherNeg=other.isNegative();if(thisNeg&&!otherNeg)return-1;if(!thisNeg&&otherNeg)return 1;if(this.subtract(other).isNegative())return-1;else return 1};goog.math.Long.prototype.negate=
function(){if(this.equals(goog.math.Long.MIN_VALUE))return goog.math.Long.MIN_VALUE;else return this.not().add(goog.math.Long.ONE)};goog.math.Long.prototype.add=function(other){var a48=this.high_>>>16;var a32=this.high_&65535;var a16=this.low_>>>16;var a00=this.low_&65535;var b48=other.high_>>>16;var b32=other.high_&65535;var b16=other.low_>>>16;var b00=other.low_&65535;var c48=0,c32=0,c16=0,c00=0;c00+=a00+b00;c16+=c00>>>16;c00&=65535;c16+=a16+b16;c32+=c16>>>16;c16&=65535;c32+=a32+b32;c48+=c32>>>
16;c32&=65535;c48+=a48+b48;c48&=65535;return goog.math.Long.fromBits(c16<<16|c00,c48<<16|c32)};goog.math.Long.prototype.subtract=function(other){return this.add(other.negate())};goog.math.Long.prototype.multiply=function(other){if(this.isZero())return goog.math.Long.ZERO;else if(other.isZero())return goog.math.Long.ZERO;if(this.equals(goog.math.Long.MIN_VALUE))return other.isOdd()?goog.math.Long.MIN_VALUE:goog.math.Long.ZERO;else if(other.equals(goog.math.Long.MIN_VALUE))return this.isOdd()?goog.math.Long.MIN_VALUE:
goog.math.Long.ZERO;if(this.isNegative())if(other.isNegative())return this.negate().multiply(other.negate());else return this.negate().multiply(other).negate();else if(other.isNegative())return this.multiply(other.negate()).negate();if(this.lessThan(goog.math.Long.TWO_PWR_24_)&&other.lessThan(goog.math.Long.TWO_PWR_24_))return goog.math.Long.fromNumber(this.toNumber()*other.toNumber());var a48=this.high_>>>16;var a32=this.high_&65535;var a16=this.low_>>>16;var a00=this.low_&65535;var b48=other.high_>>>
16;var b32=other.high_&65535;var b16=other.low_>>>16;var b00=other.low_&65535;var c48=0,c32=0,c16=0,c00=0;c00+=a00*b00;c16+=c00>>>16;c00&=65535;c16+=a16*b00;c32+=c16>>>16;c16&=65535;c16+=a00*b16;c32+=c16>>>16;c16&=65535;c32+=a32*b00;c48+=c32>>>16;c32&=65535;c32+=a16*b16;c48+=c32>>>16;c32&=65535;c32+=a00*b32;c48+=c32>>>16;c32&=65535;c48+=a48*b00+a32*b16+a16*b32+a00*b48;c48&=65535;return goog.math.Long.fromBits(c16<<16|c00,c48<<16|c32)};goog.math.Long.prototype.div=function(other){if(other.isZero())throw Error("division by zero");
else if(this.isZero())return goog.math.Long.ZERO;if(this.equals(goog.math.Long.MIN_VALUE))if(other.equals(goog.math.Long.ONE)||other.equals(goog.math.Long.NEG_ONE))return goog.math.Long.MIN_VALUE;else if(other.equals(goog.math.Long.MIN_VALUE))return goog.math.Long.ONE;else{var halfThis=this.shiftRight(1);var approx=halfThis.div(other).shiftLeft(1);if(approx.equals(goog.math.Long.ZERO))return other.isNegative()?goog.math.Long.ONE:goog.math.Long.NEG_ONE;else{var rem=this.subtract(other.multiply(approx));
var result=approx.add(rem.div(other));return result}}else if(other.equals(goog.math.Long.MIN_VALUE))return goog.math.Long.ZERO;if(this.isNegative())if(other.isNegative())return this.negate().div(other.negate());else return this.negate().div(other).negate();else if(other.isNegative())return this.div(other.negate()).negate();var res=goog.math.Long.ZERO;var rem=this;while(rem.greaterThanOrEqual(other)){var approx=Math.max(1,Math.floor(rem.toNumber()/other.toNumber()));var log2=Math.ceil(Math.log(approx)/
Math.LN2);var delta=log2<=48?1:Math.pow(2,log2-48);var approxRes=goog.math.Long.fromNumber(approx);var approxRem=approxRes.multiply(other);while(approxRem.isNegative()||approxRem.greaterThan(rem)){approx-=delta;approxRes=goog.math.Long.fromNumber(approx);approxRem=approxRes.multiply(other)}if(approxRes.isZero())approxRes=goog.math.Long.ONE;res=res.add(approxRes);rem=rem.subtract(approxRem)}return res};goog.math.Long.prototype.modulo=function(other){return this.subtract(this.div(other).multiply(other))};
goog.math.Long.prototype.not=function(){return goog.math.Long.fromBits(~this.low_,~this.high_)};goog.math.Long.prototype.and=function(other){return goog.math.Long.fromBits(this.low_&other.low_,this.high_&other.high_)};goog.math.Long.prototype.or=function(other){return goog.math.Long.fromBits(this.low_|other.low_,this.high_|other.high_)};goog.math.Long.prototype.xor=function(other){return goog.math.Long.fromBits(this.low_^other.low_,this.high_^other.high_)};goog.math.Long.prototype.shiftLeft=function(numBits){numBits&=
63;if(numBits==0)return this;else{var low=this.low_;if(numBits<32){var high=this.high_;return goog.math.Long.fromBits(low<<numBits,high<<numBits|low>>>32-numBits)}else return goog.math.Long.fromBits(0,low<<numBits-32)}};goog.math.Long.prototype.shiftRight=function(numBits){numBits&=63;if(numBits==0)return this;else{var high=this.high_;if(numBits<32){var low=this.low_;return goog.math.Long.fromBits(low>>>numBits|high<<32-numBits,high>>numBits)}else return goog.math.Long.fromBits(high>>numBits-32,high>=
0?0:-1)}};goog.math.Long.prototype.shiftRightUnsigned=function(numBits){numBits&=63;if(numBits==0)return this;else{var high=this.high_;if(numBits<32){var low=this.low_;return goog.math.Long.fromBits(low>>>numBits|high<<32-numBits,high>>>numBits)}else if(numBits==32)return goog.math.Long.fromBits(high,0);else return goog.math.Long.fromBits(high>>>numBits-32,0)}};var navigator={appName:"Modern Browser"};var dbits;var canary=0xdeadbeefcafe;var j_lm=(canary&16777215)==15715070;function BigInteger(a,b,
c){if(a!=null)if("number"==typeof a)this.fromNumber(a,b,c);else if(b==null&&"string"!=typeof a)this.fromString(a,256);else this.fromString(a,b)}function nbi(){return new BigInteger(null)}function am1(i,x,w,j,c,n){while(--n>=0){var v=x*this[i++]+w[j]+c;c=Math.floor(v/67108864);w[j++]=v&67108863}return c}function am2(i,x,w,j,c,n){var xl=x&32767,xh=x>>15;while(--n>=0){var l=this[i]&32767;var h=this[i++]>>15;var m=xh*l+h*xl;l=xl*l+((m&32767)<<15)+w[j]+(c&1073741823);c=(l>>>30)+(m>>>15)+xh*h+(c>>>30);
w[j++]=l&1073741823}return c}function am3(i,x,w,j,c,n){var xl=x&16383,xh=x>>14;while(--n>=0){var l=this[i]&16383;var h=this[i++]>>14;var m=xh*l+h*xl;l=xl*l+((m&16383)<<14)+w[j]+c;c=(l>>28)+(m>>14)+xh*h;w[j++]=l&268435455}return c}if(j_lm&&navigator.appName=="Microsoft Internet Explorer"){BigInteger.prototype.am=am2;dbits=30}else if(j_lm&&navigator.appName!="Netscape"){BigInteger.prototype.am=am1;dbits=26}else{BigInteger.prototype.am=am3;dbits=28}BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=
(1<<dbits)-1;BigInteger.prototype.DV=1<<dbits;var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array;var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv)BI_RC[rr++]=vv;rr="a".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;rr="A".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;function int2char(n){return BI_RM.charAt(n)}function intAt(s,i){var c=BI_RC[s.charCodeAt(i)];
return c==null?-1:c}function bnpCopyTo(r){for(var i=this.t-1;i>=0;--i)r[i]=this[i];r.t=this.t;r.s=this.s}function bnpFromInt(x){this.t=1;this.s=x<0?-1:0;if(x>0)this[0]=x;else if(x<-1)this[0]=x+DV;else this.t=0}function nbv(i){var r=nbi();r.fromInt(i);return r}function bnpFromString(s,b){var k;if(b==16)k=4;else if(b==8)k=3;else if(b==256)k=8;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else{this.fromRadix(s,b);return}this.t=0;this.s=0;var i=s.length,mi=false,sh=0;while(--i>=0){var x=k==8?s[i]&
255:intAt(s,i);if(x<0){if(s.charAt(i)=="-")mi=true;continue}mi=false;if(sh==0)this[this.t++]=x;else if(sh+k>this.DB){this[this.t-1]|=(x&(1<<this.DB-sh)-1)<<sh;this[this.t++]=x>>this.DB-sh}else this[this.t-1]|=x<<sh;sh+=k;if(sh>=this.DB)sh-=this.DB}if(k==8&&(s[0]&128)!=0){this.s=-1;if(sh>0)this[this.t-1]|=(1<<this.DB-sh)-1<<sh}this.clamp();if(mi)BigInteger.ZERO.subTo(this,this)}function bnpClamp(){var c=this.s&this.DM;while(this.t>0&&this[this.t-1]==c)--this.t}function bnToString(b){if(this.s<0)return"-"+
this.negate().toString(b);var k;if(b==16)k=4;else if(b==8)k=3;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else return this.toRadix(b);var km=(1<<k)-1,d,m=false,r="",i=this.t;var p=this.DB-i*this.DB%k;if(i-- >0){if(p<this.DB&&(d=this[i]>>p)>0){m=true;r=int2char(d)}while(i>=0){if(p<k){d=(this[i]&(1<<p)-1)<<k-p;d|=this[--i]>>(p+=this.DB-k)}else{d=this[i]>>(p-=k)&km;if(p<=0){p+=this.DB;--i}}if(d>0)m=true;if(m)r+=int2char(d)}}return m?r:"0"}function bnNegate(){var r=nbi();BigInteger.ZERO.subTo(this,
r);return r}function bnAbs(){return this.s<0?this.negate():this}function bnCompareTo(a){var r=this.s-a.s;if(r!=0)return r;var i=this.t;r=i-a.t;if(r!=0)return this.s<0?-r:r;while(--i>=0)if((r=this[i]-a[i])!=0)return r;return 0}function nbits(x){var r=1,t;if((t=x>>>16)!=0){x=t;r+=16}if((t=x>>8)!=0){x=t;r+=8}if((t=x>>4)!=0){x=t;r+=4}if((t=x>>2)!=0){x=t;r+=2}if((t=x>>1)!=0){x=t;r+=1}return r}function bnBitLength(){if(this.t<=0)return 0;return this.DB*(this.t-1)+nbits(this[this.t-1]^this.s&this.DM)}function bnpDLShiftTo(n,
r){var i;for(i=this.t-1;i>=0;--i)r[i+n]=this[i];for(i=n-1;i>=0;--i)r[i]=0;r.t=this.t+n;r.s=this.s}function bnpDRShiftTo(n,r){for(var i=n;i<this.t;++i)r[i-n]=this[i];r.t=Math.max(this.t-n,0);r.s=this.s}function bnpLShiftTo(n,r){var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<cbs)-1;var ds=Math.floor(n/this.DB),c=this.s<<bs&this.DM,i;for(i=this.t-1;i>=0;--i){r[i+ds+1]=this[i]>>cbs|c;c=(this[i]&bm)<<bs}for(i=ds-1;i>=0;--i)r[i]=0;r[ds]=c;r.t=this.t+ds+1;r.s=this.s;r.clamp()}function bnpRShiftTo(n,r){r.s=
this.s;var ds=Math.floor(n/this.DB);if(ds>=this.t){r.t=0;return}var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<bs)-1;r[0]=this[ds]>>bs;for(var i=ds+1;i<this.t;++i){r[i-ds-1]|=(this[i]&bm)<<cbs;r[i-ds]=this[i]>>bs}if(bs>0)r[this.t-ds-1]|=(this.s&bm)<<cbs;r.t=this.t-ds;r.clamp()}function bnpSubTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this[i]-a[i];r[i++]=c&this.DM;c>>=this.DB}if(a.t<this.t){c-=a.s;while(i<this.t){c+=this[i];r[i++]=c&this.DM;c>>=this.DB}c+=this.s}else{c+=this.s;while(i<
a.t){c-=a[i];r[i++]=c&this.DM;c>>=this.DB}c-=a.s}r.s=c<0?-1:0;if(c<-1)r[i++]=this.DV+c;else if(c>0)r[i++]=c;r.t=i;r.clamp()}function bnpMultiplyTo(a,r){var x=this.abs(),y=a.abs();var i=x.t;r.t=i+y.t;while(--i>=0)r[i]=0;for(i=0;i<y.t;++i)r[i+x.t]=x.am(0,y[i],r,i,0,x.t);r.s=0;r.clamp();if(this.s!=a.s)BigInteger.ZERO.subTo(r,r)}function bnpSquareTo(r){var x=this.abs();var i=r.t=2*x.t;while(--i>=0)r[i]=0;for(i=0;i<x.t-1;++i){var c=x.am(i,x[i],r,2*i,0,1);if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1))>=
x.DV){r[i+x.t]-=x.DV;r[i+x.t+1]=1}}if(r.t>0)r[r.t-1]+=x.am(i,x[i],r,2*i,0,1);r.s=0;r.clamp()}function bnpDivRemTo(m,q,r){var pm=m.abs();if(pm.t<=0)return;var pt=this.abs();if(pt.t<pm.t){if(q!=null)q.fromInt(0);if(r!=null)this.copyTo(r);return}if(r==null)r=nbi();var y=nbi(),ts=this.s,ms=m.s;var nsh=this.DB-nbits(pm[pm.t-1]);if(nsh>0){pm.lShiftTo(nsh,y);pt.lShiftTo(nsh,r)}else{pm.copyTo(y);pt.copyTo(r)}var ys=y.t;var y0=y[ys-1];if(y0==0)return;var yt=y0*(1<<this.F1)+(ys>1?y[ys-2]>>this.F2:0);var d1=
this.FV/yt,d2=(1<<this.F1)/yt,e=1<<this.F2;var i=r.t,j=i-ys,t=q==null?nbi():q;y.dlShiftTo(j,t);if(r.compareTo(t)>=0){r[r.t++]=1;r.subTo(t,r)}BigInteger.ONE.dlShiftTo(ys,t);t.subTo(y,y);while(y.t<ys)y[y.t++]=0;while(--j>=0){var qd=r[--i]==y0?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);if((r[i]+=y.am(0,qd,r,j,0,ys))<qd){y.dlShiftTo(j,t);r.subTo(t,r);while(r[i]<--qd)r.subTo(t,r)}}if(q!=null){r.drShiftTo(ys,q);if(ts!=ms)BigInteger.ZERO.subTo(q,q)}r.t=ys;r.clamp();if(nsh>0)r.rShiftTo(nsh,r);if(ts<0)BigInteger.ZERO.subTo(r,
r)}function bnMod(a){var r=nbi();this.abs().divRemTo(a,null,r);if(this.s<0&&r.compareTo(BigInteger.ZERO)>0)a.subTo(r,r);return r}function Classic(m){this.m=m}function cConvert(x){if(x.s<0||x.compareTo(this.m)>=0)return x.mod(this.m);else return x}function cRevert(x){return x}function cReduce(x){x.divRemTo(this.m,null,x)}function cMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}function cSqrTo(x,r){x.squareTo(r);this.reduce(r)}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=
cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;function bnpInvDigit(){if(this.t<1)return 0;var x=this[0];if((x&1)==0)return 0;var y=x&3;y=y*(2-(x&15)*y)&15;y=y*(2-(x&255)*y)&255;y=y*(2-((x&65535)*y&65535))&65535;y=y*(2-x*y%this.DV)%this.DV;return y>0?this.DV-y:-y}function Montgomery(m){this.m=m;this.mp=m.invDigit();this.mpl=this.mp&32767;this.mph=this.mp>>15;this.um=(1<<m.DB-15)-1;this.mt2=2*m.t}function montConvert(x){var r=nbi();x.abs().dlShiftTo(this.m.t,r);r.divRemTo(this.m,
null,r);if(x.s<0&&r.compareTo(BigInteger.ZERO)>0)this.m.subTo(r,r);return r}function montRevert(x){var r=nbi();x.copyTo(r);this.reduce(r);return r}function montReduce(x){while(x.t<=this.mt2)x[x.t++]=0;for(var i=0;i<this.m.t;++i){var j=x[i]&32767;var u0=j*this.mpl+((j*this.mph+(x[i]>>15)*this.mpl&this.um)<<15)&x.DM;j=i+this.m.t;x[j]+=this.m.am(0,u0,x,i,0,this.m.t);while(x[j]>=x.DV){x[j]-=x.DV;x[++j]++}}x.clamp();x.drShiftTo(this.m.t,x);if(x.compareTo(this.m)>=0)x.subTo(this.m,x)}function montSqrTo(x,
r){x.squareTo(r);this.reduce(r)}function montMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;function bnpIsEven(){return(this.t>0?this[0]&1:this.s)==0}function bnpExp(e,z){if(e>4294967295||e<1)return BigInteger.ONE;var r=nbi(),r2=nbi(),g=z.convert(this),i=nbits(e)-1;g.copyTo(r);while(--i>=0){z.sqrTo(r,r2);if((e&
1<<i)>0)z.mulTo(r2,g,r);else{var t=r;r=r2;r2=t}}return z.revert(r)}function bnModPowInt(e,m){var z;if(e<256||m.isEven())z=new Classic(m);else z=new Montgomery(m);return this.exp(e,z)}BigInteger.prototype.copyTo=bnpCopyTo;BigInteger.prototype.fromInt=bnpFromInt;BigInteger.prototype.fromString=bnpFromString;BigInteger.prototype.clamp=bnpClamp;BigInteger.prototype.dlShiftTo=bnpDLShiftTo;BigInteger.prototype.drShiftTo=bnpDRShiftTo;BigInteger.prototype.lShiftTo=bnpLShiftTo;BigInteger.prototype.rShiftTo=
bnpRShiftTo;BigInteger.prototype.subTo=bnpSubTo;BigInteger.prototype.multiplyTo=bnpMultiplyTo;BigInteger.prototype.squareTo=bnpSquareTo;BigInteger.prototype.divRemTo=bnpDivRemTo;BigInteger.prototype.invDigit=bnpInvDigit;BigInteger.prototype.isEven=bnpIsEven;BigInteger.prototype.exp=bnpExp;BigInteger.prototype.toString=bnToString;BigInteger.prototype.negate=bnNegate;BigInteger.prototype.abs=bnAbs;BigInteger.prototype.compareTo=bnCompareTo;BigInteger.prototype.bitLength=bnBitLength;BigInteger.prototype.mod=
bnMod;BigInteger.prototype.modPowInt=bnModPowInt;BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);function bnpFromRadix(s,b){this.fromInt(0);if(b==null)b=10;var cs=this.chunkSize(b);var d=Math.pow(b,cs),mi=false,j=0,w=0;for(var i=0;i<s.length;++i){var x=intAt(s,i);if(x<0){if(s.charAt(i)=="-"&&this.signum()==0)mi=true;continue}w=b*w+x;if(++j>=cs){this.dMultiply(d);this.dAddOffset(w,0);j=0;w=0}}if(j>0){this.dMultiply(Math.pow(b,j));this.dAddOffset(w,0)}if(mi)BigInteger.ZERO.subTo(this,this)}function bnpChunkSize(r){return Math.floor(Math.LN2*
this.DB/Math.log(r))}function bnSigNum(){if(this.s<0)return-1;else if(this.t<=0||this.t==1&&this[0]<=0)return 0;else return 1}function bnpDMultiply(n){this[this.t]=this.am(0,n-1,this,0,0,this.t);++this.t;this.clamp()}function bnpDAddOffset(n,w){if(n==0)return;while(this.t<=w)this[this.t++]=0;this[w]+=n;while(this[w]>=this.DV){this[w]-=this.DV;if(++w>=this.t)this[this.t++]=0;++this[w]}}function bnpToRadix(b){if(b==null)b=10;if(this.signum()==0||b<2||b>36)return"0";var cs=this.chunkSize(b);var a=Math.pow(b,
cs);var d=nbv(a),y=nbi(),z=nbi(),r="";this.divRemTo(d,y,z);while(y.signum()>0){r=(a+z.intValue()).toString(b).substr(1)+r;y.divRemTo(d,y,z)}return z.intValue().toString(b)+r}function bnIntValue(){if(this.s<0)if(this.t==1)return this[0]-this.DV;else{if(this.t==0)return-1}else if(this.t==1)return this[0];else if(this.t==0)return 0;return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}function bnpAddTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this[i]+a[i];r[i++]=c&this.DM;c>>=this.DB}if(a.t<
this.t){c+=a.s;while(i<this.t){c+=this[i];r[i++]=c&this.DM;c>>=this.DB}c+=this.s}else{c+=this.s;while(i<a.t){c+=a[i];r[i++]=c&this.DM;c>>=this.DB}c+=a.s}r.s=c<0?-1:0;if(c>0)r[i++]=c;else if(c<-1)r[i++]=this.DV+c;r.t=i;r.clamp()}BigInteger.prototype.fromRadix=bnpFromRadix;BigInteger.prototype.chunkSize=bnpChunkSize;BigInteger.prototype.signum=bnSigNum;BigInteger.prototype.dMultiply=bnpDMultiply;BigInteger.prototype.dAddOffset=bnpDAddOffset;BigInteger.prototype.toRadix=bnpToRadix;BigInteger.prototype.intValue=
bnIntValue;BigInteger.prototype.addTo=bnpAddTo;var Wrapper={abs:function(l,h){var x=new goog.math.Long(l,h);var ret;if(x.isNegative())ret=x.negate();else ret=x;HEAP32[tempDoublePtr>>2]=ret.low_;HEAP32[tempDoublePtr+4>>2]=ret.high_},ensureTemps:function(){if(Wrapper.ensuredTemps)return;Wrapper.ensuredTemps=true;Wrapper.two32=new BigInteger;Wrapper.two32.fromString("4294967296",10);Wrapper.two64=new BigInteger;Wrapper.two64.fromString("18446744073709551616",10);Wrapper.temp1=new BigInteger;Wrapper.temp2=
new BigInteger},lh2bignum:function(l,h){var a=new BigInteger;a.fromString(h.toString(),10);var b=new BigInteger;a.multiplyTo(Wrapper.two32,b);var c=new BigInteger;c.fromString(l.toString(),10);var d=new BigInteger;c.addTo(b,d);return d},stringify:function(l,h,unsigned){var ret=(new goog.math.Long(l,h)).toString();if(unsigned&&ret[0]=="-"){Wrapper.ensureTemps();var bignum=new BigInteger;bignum.fromString(ret,10);ret=new BigInteger;Wrapper.two64.addTo(bignum,ret);ret=ret.toString(10)}return ret},fromString:function(str,
base,min,max,unsigned){Wrapper.ensureTemps();var bignum=new BigInteger;bignum.fromString(str,base);var bigmin=new BigInteger;bigmin.fromString(min,10);var bigmax=new BigInteger;bigmax.fromString(max,10);if(unsigned&&bignum.compareTo(BigInteger.ZERO)<0){var temp=new BigInteger;bignum.addTo(Wrapper.two64,temp);bignum=temp}var error=false;if(bignum.compareTo(bigmin)<0){bignum=bigmin;error=true}else if(bignum.compareTo(bigmax)>0){bignum=bigmax;error=true}var ret=goog.math.Long.fromString(bignum.toString());
HEAP32[tempDoublePtr>>2]=ret.low_;HEAP32[tempDoublePtr+4>>2]=ret.high_;if(error)throw"range error";}};return Wrapper}();
if(memoryInitializer)if(ENVIRONMENT_IS_NODE||ENVIRONMENT_IS_SHELL){var data=Module["readBinary"](memoryInitializer);HEAPU8.set(data,STATIC_BASE)}else{addRunDependency("memory initializer");Browser.asyncLoad(memoryInitializer,function(data){HEAPU8.set(data,STATIC_BASE);removeRunDependency("memory initializer")},function(data){throw"could not load memory initializer "+memoryInitializer;})}
function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}ExitStatus.prototype=new Error;ExitStatus.prototype.constructor=ExitStatus;var initialStackTop;var preloadStartTime=null;var calledMain=false;dependenciesFulfilled=function runCaller(){if(!Module["calledRun"]&&shouldRunNow)run();if(!Module["calledRun"])dependenciesFulfilled=runCaller};
Module["callMain"]=Module.callMain=function callMain(args){assert(runDependencies==0,"cannot call main when async dependencies remain! (listen on __ATMAIN__)");assert(__ATPRERUN__.length==0,"cannot call main when preRun functions remain to be called");args=args||[];ensureInitRuntime();var argc=args.length+1;function pad(){for(var i=0;i<4-1;i++)argv.push(0)}var argv=[allocate(intArrayFromString("/bin/this.program"),"i8",ALLOC_NORMAL)];pad();for(var i=0;i<argc-1;i=i+1){argv.push(allocate(intArrayFromString(args[i]),
"i8",ALLOC_NORMAL));pad()}argv.push(0);argv=allocate(argv,"i32",ALLOC_NORMAL);initialStackTop=STACKTOP;try{var ret=Module["_main"](argc,argv,0);if(!Module["noExitRuntime"])exit(ret)}catch(e){if(e instanceof ExitStatus)return;else if(e=="SimulateInfiniteLoop"){Module["noExitRuntime"]=true;return}else{if(e&&typeof e==="object"&&e.stack)Module.printErr("exception thrown: "+[e,e.stack]);throw e;}}finally{calledMain=true}};
function run(args){args=args||Module["arguments"];if(preloadStartTime===null)preloadStartTime=Date.now();if(runDependencies>0){Module.printErr("run() called, but dependencies remain, so not running");return}preRun();if(runDependencies>0)return;if(Module["calledRun"])return;function doRun(){if(Module["calledRun"])return;Module["calledRun"]=true;ensureInitRuntime();preMain();if(ENVIRONMENT_IS_WEB&&preloadStartTime!==null)Module.printErr("pre-main prep time: "+(Date.now()-preloadStartTime)+" ms");if(Module["_main"]&&
shouldRunNow)Module["callMain"](args);postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);if(!ABORT)doRun()},1)}else doRun()}Module["run"]=Module.run=run;function exit(status){ABORT=true;EXITSTATUS=status;STACKTOP=initialStackTop;exitRuntime();throw new ExitStatus(status);}Module["exit"]=Module.exit=exit;
function abort(text){if(text){Module.print(text);Module.printErr(text)}ABORT=true;EXITSTATUS=1;var extra="\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";throw"abort() at "+stackTrace()+extra;}Module["abort"]=Module.abort=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0)Module["preInit"].pop()()}var shouldRunNow=true;if(Module["noInitialRun"])shouldRunNow=false;run();var Offsets={b2Body:{type:0,islandIndex:8,xf:12,xf0:28,sweep:44,linearVelocity:80,angularVelocity:88,force:92,torque:100,world:104,prev:108,next:112,fixtureList:116,fixtureCount:120,jointList:124,contactList:128,mass:132,invMass:136,I:140,invI:144,linearDamping:148,angularDamping:152,gravityScale:156,sleepTime:160,userData:164},b2Contact:{flags:4,prev:8,next:12,nodeA:16,nodeB:32,fixtureA:48,fixtureB:52,indexA:56,indexB:60,manifold:64,toiCount:128,toi:132,friction:136,restitution:140,tangentSpeed:144},
b2Fixture:{density:0,next:4,body:8,shape:12,friction:16,restitution:20,proxies:24,proxyCount:28,filter:32,isSensor:38,userData:40},b2ParticleGroup:{system:0,firstIndex:4,lastIndex:8,groupFlags:12,strength:16,prev:20,next:24,timestamp:28,mass:32,inertia:36,center:40,linearVelocity:48,angularVelocity:56,transform:60,userData:76},b2WorldManifold:{normal:0,points:8,separations:24},b2World:{bodyList:102960}};var FLT_EPSILON=1.1920929E-7;function b2Max(a,b){return new b2Vec2(Math.max(a.x,b.x),Math.max(a.y,b.y))}function b2Min(a,b){return new b2Vec2(Math.min(a.x,b.x),Math.min(a.y,b.y))}function b2Clamp(a,low,high){return b2Max(low,b2Min(a,high))}function b2Vec2(x,y){if(x===undefined)x=0;if(y===undefined)y=0;this.x=x;this.y=y}b2Vec2.Add=function(out,a,b){out.x=a.x+b.x;out.y=a.y+b.y};b2Vec2.CrossScalar=function(output,input,scalar){output.x=-scalar*input.y;output.y=scalar*input.x};
b2Vec2.Cross=function(a,b){return a.x*b.y-a.y*b.x};b2Vec2.MulScalar=function(out,input,scalar){out.x=input.x*scalar;out.y=input.y*scalar};b2Vec2.Mul=function(out,T,v){var Tp=T.p;var Tqc=T.q.c;var Tqs=T.q.s;var x=v.x;var y=v.y;out.x=Tqc*x-Tqs*y+Tp.x;out.y=Tqs*x+Tqc*y+Tp.y};b2Vec2.Normalize=function(out,input){var length=input.Length();if(length<FLT_EPSILON){out.x=0;out.y=0;return}var invLength=1/length;out.x=input.x*invLength;out.y=input.y*invLength};
b2Vec2.Sub=function(out,input,subtract){out.x=input.x-subtract.x;out.y=input.y-subtract.y};b2Vec2.prototype.Clone=function(){return new b2Vec2(this.x,this.y)};b2Vec2.prototype.Set=function(x,y){this.x=x;this.y=y};b2Vec2.prototype.Length=function(){var x=this.x;var y=this.y;return Math.sqrt(x*x+y*y)};b2Vec2.prototype.LengthSquared=function(){var x=this.x;var y=this.y;return x*x+y*y};function b2Rot(radians){if(radians===undefined)radians=0;this.s=Math.sin(radians);this.c=Math.cos(radians)}
b2Rot.prototype.Set=function(radians){this.s=Math.sin(radians);this.c=Math.cos(radians)};b2Rot.prototype.SetIdentity=function(){this.s=0;this.c=1};b2Rot.prototype.GetXAxis=function(){return new b2Vec2(this.c,this.s)};function b2Transform(position,rotation){if(position===undefined)position=new b2Vec2;if(rotation===undefined)rotation=new b2Rot;this.p=position;this.q=rotation}b2Transform.prototype.FromFloat64Array=function(arr){var p=this.p;var q=this.q;p.x=arr[0];p.y=arr[1];q.s=arr[2];q.c=arr[3]};
b2Transform.prototype.SetIdentity=function(){this.p.Set(0,0);this.q.SetIdentity()};function b2AABB(){this.lowerBound=new b2Vec2;this.upperBound=new b2Vec2}b2AABB.prototype.GetCenter=function(){var sum=new b2Vec2;b2Vec2.Add(sum,this.lowerBound,this.upperBound);b2Vec2.MulScalar(sum,sum,.5)};var b2Manifold_GetPointCount=Module.cwrap("b2Manifold_GetPointCount","number",["number"]);function b2Manifold(ptr){this.ptr=ptr}b2Manifold.prototype.GetPointCount=function(){return b2Manifold_GetPointCount(this.ptr)};var b2WorldManifold_points_offset=Offsets.b2WorldManifold.points;
function b2WorldManifold(ptr){this.buffer=new DataView(Module.HEAPU8.buffer,ptr);this.ptr=ptr}b2WorldManifold.prototype.GetPoint=function(i){var point=new b2Vec2;point.x=this.buffer.getFloat32(i*2+b2WorldManifold_points_offset,true);point.y=this.buffer.getFloat32(i*2+4+b2WorldManifold_points_offset,true);return point};var b2EdgeShape_CreateFixture=Module.cwrap("b2EdgeShape_CreateFixture","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);function b2EdgeShape(){this.hasVertex0=false;this.hasVertex3=false;this.vertex0=new b2Vec2;this.vertex1=new b2Vec2;this.vertex2=new b2Vec2;this.vertex3=new b2Vec2;this.type=b2Shape_Type_e_edge}
b2EdgeShape.prototype.Set=function(v1,v2){this.vertex1=v1;this.vertex2=v2;this.hasVertex0=false;this.hasVertex3=false};
b2EdgeShape.prototype._CreateFixture=function(body,fixtureDef){return b2EdgeShape_CreateFixture(body.ptr,fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,this.hasVertex0,this.hasVertex3,this.vertex0.x,this.vertex0.y,this.vertex1.x,this.vertex1.y,this.vertex2.x,this.vertex2.y,this.vertex3.x,this.vertex3.y)};var b2PolygonShape_CreateFixture_3=Module.cwrap("b2PolygonShape_CreateFixture_3","number",["number","number","number","number","number","number","number","number","number","number","number","number"]);var b2PolygonShape_CreateFixture_4=Module.cwrap("b2PolygonShape_CreateFixture_4","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2PolygonShape_CreateFixture_5=Module.cwrap("b2PolygonShape_CreateFixture_5","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);var b2PolygonShape_CreateFixture_6=Module.cwrap("b2PolygonShape_CreateFixture_6","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2PolygonShape_CreateFixture_7=Module.cwrap("b2PolygonShape_CreateFixture_7","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2PolygonShape_CreateFixture_8=Module.cwrap("b2PolygonShape_CreateFixture_8","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2PolygonShape_CreateParticleGroup_4=Module.cwrap("b2PolygonShape_CreateParticleGroup_4","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2PolygonShape_DestroyParticlesInShape_4=Module.cwrap("b2PolygonShape_DestroyParticlesInShape_4","number",["number","number","number","number","number","number","number","number","number","number","number","number","number"]);function b2PolygonShape(){this.position=new b2Vec2;this.vertices=[];this.type=b2Shape_Type_e_polygon}
b2PolygonShape.prototype.SetAsBoxXY=function(hx,hy){this.vertices[0]=new b2Vec2(-hx,-hy);this.vertices[1]=new b2Vec2(hx,-hy);this.vertices[2]=new b2Vec2(hx,hy);this.vertices[3]=new b2Vec2(-hx,hy)};
b2PolygonShape.prototype.SetAsBoxXYCenterAngle=function(hx,hy,center,angle){this.vertices[0]=new b2Vec2(-hx,-hy);this.vertices[1]=new b2Vec2(hx,-hy);this.vertices[2]=new b2Vec2(hx,hy);this.vertices[3]=new b2Vec2(-hx,hy);var xf=new b2Transform;xf.p=center;xf.q.Set(angle);for(var i=0;i<4;i++)b2Vec2.Mul(this.vertices[i],xf,this.vertices[i])};
b2PolygonShape.prototype._CreateFixture=function(body,fixtureDef){var vertices=this.vertices;switch(vertices.length){case 3:var v0=vertices[0];var v1=vertices[1];var v2=vertices[2];return b2PolygonShape_CreateFixture_3(body.ptr,fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,v0.x,v0.y,v1.x,v1.y,v2.x,v2.y);break;case 4:var v0=vertices[0];var v1=vertices[1];var v2=
vertices[2];var v3=vertices[3];return b2PolygonShape_CreateFixture_4(body.ptr,fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,v0.x,v0.y,v1.x,v1.y,v2.x,v2.y,v3.x,v3.y);break;case 5:var v0=vertices[0];var v1=vertices[1];var v2=vertices[2];var v3=vertices[3];var v4=vertices[4];return b2PolygonShape_CreateFixture_5(body.ptr,fixtureDef.density,fixtureDef.friction,
fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,v0.x,v0.y,v1.x,v1.y,v2.x,v2.y,v3.x,v3.y,v4.x,v4.y);break;case 6:var v0=vertices[0];var v1=vertices[1];var v2=vertices[2];var v3=vertices[3];var v4=vertices[4];var v5=vertices[5];return b2PolygonShape_CreateFixture_6(body.ptr,fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,
fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,v0.x,v0.y,v1.x,v1.y,v2.x,v2.y,v3.x,v3.y,v4.x,v4.y,v5.x,v5.y);break;case 7:var v0=vertices[0];var v1=vertices[1];var v2=vertices[2];var v3=vertices[3];var v4=vertices[4];var v5=vertices[5];var v6=vertices[6];return b2PolygonShape_CreateFixture_7(body.ptr,fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,v0.x,
v0.y,v1.x,v1.y,v2.x,v2.y,v3.x,v3.y,v4.x,v4.y,v5.x,v5.y,v6.x,v6.y);break;case 8:var v0=vertices[0];var v1=vertices[1];var v2=vertices[2];var v3=vertices[3];var v4=vertices[4];var v5=vertices[5];var v6=vertices[6];var v7=vertices[7];return b2PolygonShape_CreateFixture_8(body.ptr,fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,v0.x,v0.y,v1.x,v1.y,v2.x,v2.y,v3.x,
v3.y,v4.x,v4.y,v5.x,v5.y,v6.x,v6.y,v6.x,v7.y);break}};
b2PolygonShape.prototype._CreateParticleGroup=function(particleSystem,pgd){var v=this.vertices;switch(v.length){case 3:break;case 4:return b2PolygonShape_CreateParticleGroup_4(particleSystem.ptr,pgd.angle,pgd.angularVelocity,pgd.color.r,pgd.color.g,pgd.color.b,pgd.color.a,pgd.flags,pgd.group.ptr,pgd.groupFlags,pgd.lifetime,pgd.linearVelocity.x,pgd.linearVelocity.y,pgd.position.x,pgd.position.y,pgd.positionData,pgd.particleCount,pgd.strength,pgd.stride,pgd.userData,v[0].x,v[0].y,v[1].x,v[1].y,v[2].x,
v[2].y,v[3].x,v[3].y);break}};b2PolygonShape.prototype._DestroyParticlesInShape=function(ps,xf){var v=this.vertices;switch(v.length){case 3:break;case 4:return b2PolygonShape_DestroyParticlesInShape_4(ps.ptr,v[0].x,v[0].y,v[1].x,v[1].y,v[2].x,v[2].y,v[3].x,v[3].y,xf.p.x,xf.p.y,xf.q.s,xf.q.c);break}};
b2PolygonShape.prototype.Validate=function(){for(var i=0,max=this.vertices.length;i<max;++i){var i1=i;var i2=i<max-1?i1+1:0;var p=this.vertices[i1];var e=this.vertices[i2];var eSubP=new b2Vec2;b2Vec2.Sub(eSubP,e,p);for(var j=0;j<max;++j){if(j==i1||j==i2)continue;var v=new b2Vec2;b2Vec2.Sub(v,this.vertices[j],p);var c=b2Vec2.Cross(eSubP,v);if(c<0)return false}}return true};var b2Shape_Type_e_circle=0;var b2Shape_Type_e_edge=1;var b2Shape_Type_e_polygon=2;var b2Shape_Type_e_chain=3;var b2Shape_Type_e_typeCount=4;var b2_linearSlop=.005;var b2_polygonRadius=2*b2_linearSlop;var b2_maxPolygonVertices=8;function b2MassData(mass,center,I){this.mass=mass;this.center=center;this.I=I};var b2ChainShape_CreateFixture=Module.cwrap("b2ChainShape_CreateFixture","number",["number","number","number","number","number","number","number","number"]);function b2ChainShape(){this.radius=b2_polygonRadius;this.vertices=[];this.type=b2Shape_Type_e_chain}b2ChainShape.prototype.CreateLoop=function(){this.vertices.push(this.vertices[0])};
b2ChainShape.prototype._CreateFixture=function(body,fixtureDef){var vertices=this.vertices;var chainLength=vertices.length;var dataLength=chainLength*2;var data=new Float32Array(dataLength);for(var i=0,j=0;i<dataLength;i+=2,j++){data[i]=vertices[j].x;data[i+1]=vertices[j].y}var nDataBytes=data.length*data.BYTES_PER_ELEMENT;var dataPtr=Module._malloc(nDataBytes);var dataHeap=new Uint8Array(Module.HEAPU8.buffer,dataPtr,nDataBytes);dataHeap.set(new Uint8Array(data.buffer));var fixture=b2ChainShape_CreateFixture(body.ptr,
fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,dataHeap.byteOffset,data.length);Module._free(dataHeap.byteOffset);return fixture};var b2CircleShape_CreateFixture=Module.cwrap("b2CircleShape_CreateFixture","number",["number","number","number","number","number","number","number","number","number"]);var b2CircleShape_CreateParticleGroup=Module.cwrap("b2CircleShape_CreateParticleGroup","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2CircleShape_DestroyParticlesInShape=Module.cwrap("b2CircleShape_DestroyParticlesInShape","number",["number","number","number","number","number","number","number","number"]);function b2CircleShape(){this.position=new b2Vec2;this.radius=0;this.type=b2Shape_Type_e_circle}
b2CircleShape.prototype._CreateFixture=function(body,fixtureDef){return b2CircleShape_CreateFixture(body.ptr,fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,this.position.x,this.position.y,this.radius)};
b2CircleShape.prototype._CreateParticleGroup=function(particleSystem,pgd){return b2CircleShape_CreateParticleGroup(particleSystem.ptr,pgd.angle,pgd.angularVelocity,pgd.color.r,pgd.color.g,pgd.color.b,pgd.color.a,pgd.flags,pgd.group.ptr,pgd.groupFlags,pgd.lifetime,pgd.linearVelocity.x,pgd.linearVelocity.y,pgd.position.x,pgd.position.y,pgd.positionData,pgd.particleCount,pgd.strength,pgd.stride,pgd.userData,this.position.x,this.position.y,this.radius)};
b2CircleShape.prototype._DestroyParticlesInShape=function(ps,xf){return b2CircleShape_DestroyParticlesInShape(ps.ptr,this.position.x,this.position.y,this.radius,xf.p.x,xf.p.y,xf.q.s,xf.q.c)};var b2Body_ApplyAngularImpulse=Module.cwrap("b2Body_ApplyAngularImpulse","null",["number","number","number"]);var b2Body_ApplyForce=Module.cwrap("b2Body_ApplyForce","number",["number","number","number","number","number","number"]);var b2Body_ApplyForceToCenter=Module.cwrap("b2Body_ApplyForceToCenter","number",["number","number","number","number"]);var b2Body_ApplyTorque=Module.cwrap("b2Body_ApplyTorque","number",["number","number","number"]);
var b2Body_DestroyFixture=Module.cwrap("b2Body_DestroyFixture","null",["number","number"]);var b2Body_GetAngle=Module.cwrap("b2Body_GetAngle","number",["number"]);var b2Body_GetAngularVelocity=Module.cwrap("b2Body_GetAngularVelocity","number",["number"]);var b2Body_GetInertia=Module.cwrap("b2Body_GetInertia","number",["number"]);var b2Body_GetLinearVelocity=Module.cwrap("b2Body_GetLinearVelocity","null",["number","number"]);
var b2Body_GetLocalPoint=Module.cwrap("b2Body_GetLocalPoint","null",["number","number","number","number"]);var b2Body_GetLocalVector=Module.cwrap("b2Body_GetLocalVector","null",["number","number","number","number"]);var b2Body_GetMass=Module.cwrap("b2Body_GetMass","number",["number"]);var b2Body_GetPosition=Module.cwrap("b2Body_GetPosition","null",["number","number"]);var b2Body_GetTransform=Module.cwrap("b2Body_GetTransform","null",["number","number"]);
var b2Body_GetType=Module.cwrap("b2Body_GetType","number",["number"]);var b2Body_GetWorldCenter=Module.cwrap("b2Body_GetWorldCenter","null",["number","number"]);var b2Body_GetWorldPoint=Module.cwrap("b2Body_GetWorldPoint","null",["number","number","number","number"]);var b2Body_GetWorldVector=Module.cwrap("b2Body_GetWorldVector","null",["number","number","number","number"]);var b2Body_SetAngularVelocity=Module.cwrap("b2Body_SetAngularVelocity","null",["number","number"]);
var b2Body_SetAwake=Module.cwrap("b2Body_SetAwake","number",["number","number"]);var b2Body_SetLinearVelocity=Module.cwrap("b2Body_SetLinearVelocity","null",["number","number","number"]);var b2Body_SetMassData=Module.cwrap("b2Body_SetMassData","null",["number","number","number","number","number"]);var b2Body_SetTransform=Module.cwrap("b2Body_SetTransform","null",["number","number","number"]);var b2Body_SetType=Module.cwrap("b2Body_SetType","null",["number","number"]);var b2Body_xf_offset=Offsets.b2Body.xf;
var b2Body_userData_offset=Offsets.b2Body.userData;function b2Body(ptr){this.buffer=new DataView(Module.HEAPU8.buffer,ptr);this.ptr=ptr;this.fixtures=[]}b2Body.prototype.ApplyAngularImpulse=function(force,wake){b2Body_ApplyAngularImpulse(this.ptr,force,wake)};b2Body.prototype.ApplyForce=function(force,point,wake){b2Body_ApplyForce(this.ptr,force.x,force.y,point.x,point.y,wake)};b2Body.prototype.ApplyForceToCenter=function(force,wake){b2Body_ApplyForceToCenter(this.ptr,force.x,force.y,wake)};
b2Body.prototype.ApplyTorque=function(force,wake){b2Body_ApplyTorque(this.ptr,force,wake)};b2Body.prototype.CreateFixtureFromDef=function(fixtureDef){var fixture=new b2Fixture;fixture.FromFixtureDef(fixtureDef);fixture._SetPtr(fixtureDef.shape._CreateFixture(this,fixtureDef));fixture.body=this;b2World._Push(fixture,this.fixtures);world.fixturesLookup[fixture.ptr]=fixture;return fixture};
b2Body.prototype.CreateFixtureFromShape=function(shape,density){var fixtureDef=new b2FixtureDef;fixtureDef.shape=shape;fixtureDef.density=density;return this.CreateFixtureFromDef(fixtureDef)};b2Body.prototype.DestroyFixture=function(fixture){b2Body_DestroyFixture(this.ptr,fixture.ptr);b2World._RemoveItem(fixture,this.fixtures)};b2Body.prototype.GetAngle=function(){return b2Body_GetAngle(this.ptr)};b2Body.prototype.GetAngularVelocity=function(){return b2Body_GetAngularVelocity(this.ptr)};
b2Body.prototype.GetInertia=function(){return b2Body_GetInertia(this.ptr)};b2Body.prototype.GetMass=function(){return b2Body_GetMass(this.ptr)};b2Body.prototype.GetLinearVelocity=function(){b2Body_GetLinearVelocity(this.ptr,_vec2Buf.byteOffset);var result=new Float32Array(_vec2Buf.buffer,_vec2Buf.byteOffset,_vec2Buf.length);return new b2Vec2(result[0],result[1])};
b2Body.prototype.GetLocalPoint=function(vec){b2Body_GetLocalPoint(this.ptr,vec.x,vec.y,_vec2Buf.byteOffset);var result=new Float32Array(_vec2Buf.buffer,_vec2Buf.byteOffset,_vec2Buf.length);return new b2Vec2(result[0],result[1])};b2Body.prototype.GetLocalVector=function(vec){b2Body_GetLocalVector(this.ptr,vec.x,vec.y,_vec2Buf.byteOffset);var result=new Float32Array(_vec2Buf.buffer,_vec2Buf.byteOffset,_vec2Buf.length);return new b2Vec2(result[0],result[1])};
b2Body.prototype.GetPosition=function(){b2Body_GetPosition(this.ptr,_vec2Buf.byteOffset);var result=new Float32Array(_vec2Buf.buffer,_vec2Buf.byteOffset,_vec2Buf.length);return new b2Vec2(result[0],result[1])};
b2Body.prototype.GetTransform=function(){var transform=new b2Transform;transform.p.x=this.buffer.getFloat32(b2Body_xf_offset,true);transform.p.y=this.buffer.getFloat32(b2Body_xf_offset+4,true);transform.q.s=this.buffer.getFloat32(b2Body_xf_offset+8,true);transform.q.c=this.buffer.getFloat32(b2Body_xf_offset+12,true);return transform};b2Body.prototype.GetType=function(){return b2Body_GetType(this.ptr)};b2Body.prototype.GetUserData=function(){return this.buffer.getUint32(b2Body_userData_offset,true)};
b2Body.prototype.GetWorldCenter=function(){b2Body_GetWorldCenter(this.ptr,_vec2Buf.byteOffset);var result=new Float32Array(_vec2Buf.buffer,_vec2Buf.byteOffset,_vec2Buf.length);return new b2Vec2(result[0],result[1])};b2Body.prototype.GetWorldPoint=function(vec){b2Body_GetWorldPoint(this.ptr,vec.x,vec.y,_vec2Buf.byteOffset);var result=new Float32Array(_vec2Buf.buffer,_vec2Buf.byteOffset,_vec2Buf.length);return new b2Vec2(result[0],result[1])};
b2Body.prototype.GetWorldVector=function(vec){b2Body_GetWorldVector(this.ptr,vec.x,vec.y,_vec2Buf.byteOffset);var result=new Float32Array(_vec2Buf.buffer,_vec2Buf.byteOffset,_vec2Buf.length);return new b2Vec2(result[0],result[1])};b2Body.prototype.SetAngularVelocity=function(angle){b2Body_SetAngularVelocity(this.ptr,angle)};b2Body.prototype.SetAwake=function(flag){b2Body_SetAwake(this.ptr,flag)};b2Body.prototype.SetLinearVelocity=function(v){b2Body_SetLinearVelocity(this.ptr,v.x,v.y)};
b2Body.prototype.SetMassData=function(massData){b2Body_SetMassData(this.ptr,massData.mass,massData.center.x,massData.center.y,massData.I)};b2Body.prototype.SetTransform=function(v,angle){b2Body_SetTransform(this.ptr,v.x,v.y,angle)};b2Body.prototype.SetType=function(type){b2Body_SetType(this.ptr,type)};var b2_staticBody=0;var b2_kinematicBody=1;var b2_dynamicBody=2;
function b2BodyDef(){this.active=true;this.allowSleep=true;this.angle=0;this.angularVelocity=0;this.angularDamping=0;this.awake=true;this.bullet=false;this.fixedRotation=false;this.gravityScale=1;this.linearDamping=0;this.linearVelocity=new b2Vec2;this.position=new b2Vec2;this.type=b2_staticBody;this.userData=null};b2World.BeginContactBody=function(contactPtr){if(world.listener.BeginContactBody===undefined)return;var contact=new b2Contact(contactPtr);world.listener.BeginContactBody(contact)};b2World.EndContactBody=function(contactPtr){if(world.listener.EndContactBody===undefined)return;var contact=new b2Contact(contactPtr);world.listener.EndContactBody(contact)};
b2World.PreSolve=function(contactPtr,oldManifoldPtr){if(world.listener.PreSolve===undefined)return;world.listener.PreSolve(new b2Contact(contactPtr),new b2Manifold(oldManifoldPtr))};b2World.PostSolve=function(contactPtr,impulsePtr){if(world.listener.PostSolve===undefined)return;world.listener.PostSolve(new b2Contact(contactPtr),new b2ContactImpulse(impulsePtr))};b2World.QueryAABB=function(fixturePtr){return world.queryAABBCallback.ReportFixture(world.fixturesLookup[fixturePtr])};
b2World.RayCast=function(fixturePtr,pointX,pointY,normalX,normalY,fraction){return world.rayCastCallback.ReportFixture(world.fixturesLookup[fixturePtr],new b2Vec2(pointX,pointY),new b2Vec2(normalX,normalY),fraction)};var b2World_Create=Module.cwrap("b2World_Create","number",["number","number"]);
var b2World_CreateBody=Module.cwrap("b2World_CreateBody","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);var b2World_CreateParticleSystem=Module.cwrap("b2World_CreateParticleSystem","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2World_DestroyBody=Module.cwrap("b2World_DestroyBody","null",["number","number"]);var b2World_DestroyJoint=Module.cwrap("b2World_DestroyJoint","null",["number","number"]);var b2World_DestroyParticleSystem=Module.cwrap("b2World_DestroyParticleSystem","null",["number","number"]);var b2World_QueryAABB=Module.cwrap("b2World_QueryAABB","null",["number","number","number","number","number"]);var b2World_RayCast=Module.cwrap("b2World_RayCast","null",["number","number","number","number","number"]);
var b2World_SetContactListener=Module.cwrap("b2World_SetContactListener","null",["number"]);var b2World_SetGravity=Module.cwrap("b2World_SetGravity","null",["number","number","number"]);var b2World_Step=Module.cwrap("b2World_Step","null",["number","number","number"]);var _transBuf=null;var _vec2Buf=null;
function b2World(gravity){this.bodies=[];this.bodiesLookup={};this.fixturesLookup={};this.joints=[];this.listener=null;this.particleSystems=[];this.ptr=b2World_Create(gravity.x,gravity.y);this.queryAABBCallback=null;this.rayCastCallback=null;this.buffer=new DataView(Module.HEAPU8.buffer,this.ptr);var nDataBytes=4*Float32Array.BYTES_PER_ELEMENT;var dataPtr=Module._malloc(nDataBytes);_transBuf=new Uint8Array(Module.HEAPU8.buffer,dataPtr,nDataBytes);nDataBytes=2*Float32Array.BYTES_PER_ELEMENT;dataPtr=
Module._malloc(nDataBytes);_vec2Buf=new Uint8Array(Module.HEAPU8.buffer,dataPtr,nDataBytes)}b2World._Push=function(item,list){item.lindex=list.length;list.push(item)};b2World._RemoveItem=function(item,list){var length=list.length;var lindex=item.lindex;if(length>1){list[lindex]=list[length-1];list[lindex].lindex=lindex}list.pop()};
b2World.prototype.CreateBody=function(bodyDef){var body=new b2Body(b2World_CreateBody(this.ptr,bodyDef.active,bodyDef.allowSleep,bodyDef.angle,bodyDef.angularVelocity,bodyDef.angularDamping,bodyDef.awake,bodyDef.bullet,bodyDef.fixedRotation,bodyDef.gravityScale,bodyDef.linearDamping,bodyDef.linearVelocity.x,bodyDef.linearVelocity.y,bodyDef.position.x,bodyDef.position.y,bodyDef.type,bodyDef.userData));b2World._Push(body,this.bodies);this.bodiesLookup[body.ptr]=body;return body};
b2World.prototype.CreateJoint=function(jointDef){var joint=jointDef.Create(this);b2World._Push(joint,this.joints);return joint};
b2World.prototype.CreateParticleSystem=function(psd){var ps=new b2ParticleSystem(b2World_CreateParticleSystem(this.ptr,psd.colorMixingStrength,psd.dampingStrength,psd.destroyByAge,psd.ejectionStrength,psd.elasticStrength,psd.lifetimeGranularity,psd.powderStrength,psd.pressureStrength,psd.radius,psd.repulsiveStrength,psd.springStrength,psd.staticPressureIterations,psd.staticPressureRelaxation,psd.staticPressureStrength,psd.surfaceTensionNormalStrength,psd.surfaceTensionPressureStrength,psd.viscousStrength));
b2World._Push(ps,this.particleSystems);ps.dampingStrength=psd.dampingStrength;ps.radius=psd.radius;return ps};b2World.prototype.DestroyBody=function(body){b2World_DestroyBody(this.ptr,body.ptr);b2World._RemoveItem(body,this.bodies)};b2World.prototype.DestroyJoint=function(joint){b2World_DestroyJoint(this.ptr,joint.ptr);b2World._RemoveItem(joint,this.joints)};
b2World.prototype.DestroyParticleSystem=function(particleSystem){b2World_DestroyParticleSystem(this.ptr,particleSystem.ptr);b2World._RemoveItem(particleSystem,this.particleSystems)};b2World.prototype.QueryAABB=function(callback,aabb){this.queryAABBCallback=callback;b2World_QueryAABB(this.ptr,aabb.lowerBound.x,aabb.lowerBound.y,aabb.upperBound.x,aabb.upperBound.y)};
b2World.prototype.RayCast=function(callback,point1,point2){this.rayCastCallback=callback;b2World_RayCast(this.ptr,point1.x,point1.y,point2.x,point2.y)};b2World.prototype.SetContactListener=function(listener){this.listener=listener;b2World_SetContactListener(this.ptr)};b2World.prototype.SetGravity=function(gravity){b2World_SetGravity(this.ptr,gravity.x,gravity.y)};b2World.prototype.Step=function(steps,vIterations,pIterations){b2World_Step(this.ptr,steps,vIterations,pIterations)};var b2WheelJoint_SetMotorSpeed=Module.cwrap("b2WheelJoint_SetMotorSpeed","null",["number","number"]);var b2WheelJoint_SetSpringFrequencyHz=Module.cwrap("b2WheelJoint_SetSpringFrequencyHz","null",["number","number"]);function b2WheelJoint(def){this.next=null;this.ptr=null}b2WheelJoint.prototype.SetMotorSpeed=function(speed){b2WheelJoint_SetMotorSpeed(this.ptr,speed)};b2WheelJoint.prototype.SetSpringFrequencyHz=function(hz){b2WheelJoint_SetSpringFrequencyHz(this.ptr,hz)};
var b2WheelJointDef_Create=Module.cwrap("b2WheelJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);var b2WheelJointDef_InitializeAndCreate=Module.cwrap("b2WheelJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number","number","number","number","number","number"]);
function b2WheelJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.dampingRatio=.7;this.enableMotor=false;this.frequencyHz=2;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.localAxisA=new b2Vec2(1,0);this.maxMotorTorque=0;this.motorSpeed=0}
b2WheelJointDef.prototype.Create=function(world){var wheelJoint=new b2WheelJoint(this);wheelJoint.ptr=b2WheelJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.dampingRatio,this.enableMotor,this.frequencyHz,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y,this.localAxisA.x,this.localAxisA.y,this.maxMotorTorque,this.motorSpeed);return wheelJoint};
b2WheelJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB,anchor,axis){this.bodyA=bodyA;this.bodyB=bodyB;var wheelJoint=new b2WheelJoint(this);wheelJoint.ptr=b2WheelJointDef_InitializeAndCreate(world.ptr,this.bodyA.ptr,this.bodyB.ptr,anchor.x,anchor.y,axis.x,axis.y,this.collideConnected,this.dampingRatio,this.enableMotor,this.frequencyHz,this.maxMotorTorque,this.motorSpeed);b2World._Push(wheelJoint,world.joints);return wheelJoint};var b2WeldJointDef_Create=Module.cwrap("b2WeldJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number"]);var b2WeldJointDef_InitializeAndCreate=Module.cwrap("b2WeldJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number"]);
function b2WeldJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.dampingRatio=0;this.frequencyHz=0;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.referenceAngle=0}
b2WeldJointDef.prototype.Create=function(world){var weldJoint=new b2WeldJoint(this);weldJoint.ptr=b2WeldJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.dampingRatio,this.frequencyHz,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y,this.referenceAngle);return weldJoint};
b2WeldJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB,anchor){this.bodyA=bodyA;this.bodyB=bodyB;var weldJoint=new b2WeldJoint(this);weldJoint.ptr=b2WeldJointDef_InitializeAndCreate(world.ptr,this.bodyA.ptr,this.bodyB.ptr,anchor.x,anchor.y,this.collideConnected,this.dampingRatio,this.frequencyHz);b2World._Push(weldJoint,world.joints);return weldJoint};function b2WeldJoint(def){this.bodyA=def.bodyA;this.bodyB=def.bodyB;this.next=null;this.ptr=null};var b2GearJoint_GetRatio=Module.cwrap("b2GearJoint_GetRatio","number",["number"]);function b2GearJoint(def){this.ptr=null;this.next=null}b2GearJoint.prototype.GetRatio=function(){return b2GearJoint_GetRatio(this.ptr)};var b2GearJointDef_Create=Module.cwrap("b2GearJointDef_Create","number",["number","number","number","number","number","number","number"]);function b2GearJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.joint1=null;this.joint2=null;this.ratio=0}
b2GearJointDef.prototype.Create=function(world){var gearJoint=new b2GearJoint(this);gearJoint.ptr=b2GearJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.joint1.ptr,this.joint2.ptr,this.ratio);return gearJoint};var e_unknownJoint=0;var e_revoluteJoint=1;var e_prismaticJoint=2;var e_distanceJoint=3;var e_pulleyJoint=4;var e_mouseJoint=5;var e_gearJoint=6;var e_wheelJoint=7;var e_weldJoint=8;var e_frictionJoint=9;var e_ropeJoint=10;var e_motorJoint=11;var b2Joint_GetBodyA=Module.cwrap("b2Joint_GetBodyA","number",["number"]);var b2Joint_GetBodyB=Module.cwrap("b2Joint_GetBodyB","number",["number"]);function b2Joint(){}b2Joint.prototype.GetBodyA=function(){return world.bodiesLookup[b2Joint_GetBodyA(this.ptr)]};
b2Joint.prototype.GetBodyB=function(){return world.bodiesLookup[b2Joint_GetBodyB(this.ptr)]};var b2FrictionJointDef_Create=Module.cwrap("b2FrictionJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number"]);var b2FrictionJointDef_InitializeAndCreate=Module.cwrap("b2FrictionJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number"]);
function b2FrictionJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.maxForce=0;this.maxTorque=0;this.userData=null}
b2FrictionJointDef.prototype.Create=function(world){var frictionJoint=new b2FrictionJoint(this);frictionJoint.ptr=b2FrictionJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y,this.maxForce,this.maxTorque);return frictionJoint};
b2FrictionJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB,anchor){this.bodyA=bodyA;this.bodyB=bodyB;var frictionJoint=new b2FrictionJoint(this);frictionJoint.ptr=b2FrictionJointDef_InitializeAndCreate(world.ptr,this.bodyA.ptr,this.bodyB.ptr,anchor.x,anchor.y,this.collideConnected,this.maxForce,this.maxTorque);b2World._Push(frictionJoint,world.joints);return frictionJoint};function b2FrictionJoint(def){this.bodyA=def.bodyA;this.bodyB=def.bodyB;this.ptr=null;this.next=null};var b2RevoluteJoint_EnableLimit=Module.cwrap("b2RevoluteJoint_EnableLimit","number",["number","number"]);var b2RevoluteJoint_EnableMotor=Module.cwrap("b2RevoluteJoint_EnableMotor","number",["number","number"]);var b2RevoluteJoint_GetJointAngle=Module.cwrap("b2RevoluteJoint_GetJointAngle","number",["number"]);var b2RevoluteJoint_IsLimitEnabled=Module.cwrap("b2RevoluteJoint_IsLimitEnabled","number",["number"]);
var b2RevoluteJoint_IsMotorEnabled=Module.cwrap("b2RevoluteJoint_IsMotorEnabled","number",["number"]);var b2RevoluteJoint_SetMotorSpeed=Module.cwrap("b2RevoluteJoint_SetMotorSpeed","number",["number","number"]);
function b2RevoluteJoint(revoluteJointDef){this.collideConnected=revoluteJointDef.collideConnected;this.enableLimit=revoluteJointDef.enableLimit;this.enableMotor=revoluteJointDef.enableMotor;this.lowerAngle=revoluteJointDef.lowerAngle;this.maxMotorTorque=revoluteJointDef.maxMotorTorque;this.motorSpeed=revoluteJointDef.motorSpeed;this.next=null;this.ptr=null;this.upperAngle=revoluteJointDef.upperAngle;this.userData=revoluteJointDef.userData}b2RevoluteJoint.prototype=new b2Joint;
b2RevoluteJoint.prototype.EnableLimit=function(flag){b2RevoluteJoint_EnableLimit(this.ptr,flag)};b2RevoluteJoint.prototype.EnableMotor=function(flag){b2RevoluteJoint_EnableMotor(this.ptr,flag)};b2RevoluteJoint.prototype.GetJointAngle=function(flag){return b2RevoluteJoint_GetJointAngle(this.ptr)};b2RevoluteJoint.prototype.IsLimitEnabled=function(){return b2RevoluteJoint_IsLimitEnabled(this.ptr)};b2RevoluteJoint.prototype.IsMotorEnabled=function(){return b2RevoluteJoint_IsMotorEnabled(this.ptr)};
b2RevoluteJoint.prototype.SetMotorSpeed=function(speed){b2RevoluteJoint_SetMotorSpeed(this.ptr,speed);this.motorSpeed=speed};var b2RevoluteJointDef_Create=Module.cwrap("b2RevoluteJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2RevoluteJointDef_InitializeAndCreate=Module.cwrap("b2RevoluteJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number","number","number","number","number"]);function b2RevoluteJointDef(){this.collideConnected=false;this.enableLimit=false;this.enableMotor=false;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.lowerAngle=0;this.maxMotorTorque=0;this.motorSpeed=0;this.referenceAngle=0;this.upperAngle=0;this.userData=null}
b2RevoluteJointDef.prototype.Create=function(world){var revoluteJoint=new b2RevoluteJoint(this);revoluteJoint.ptr=b2RevoluteJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.enableLimit,this.enableMotor,this.lowerAngle,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y,this.maxMotorTorque,this.motorSpeed,this.referenceAngle,this.upperAngle);return revoluteJoint};
b2RevoluteJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB,anchor){this.bodyA=bodyA;this.bodyB=bodyB;var revoluteJoint=new b2RevoluteJoint(this);revoluteJoint.ptr=b2RevoluteJointDef_InitializeAndCreate(world.ptr,bodyA.ptr,bodyB.ptr,anchor.x,anchor.y,this.collideConnected,this.enableLimit,this.enableMotor,this.lowerAngle,this.maxMotorTorque,this.motorSpeed,this.upperAngle);b2World._Push(revoluteJoint,world.joints);return revoluteJoint};var b2MotorJoint_SetAngularOffset=Module.cwrap("b2MotorJoint_SetAngularOffset","null",["number","number"]);var b2MotorJoint_SetLinearOffset=Module.cwrap("b2MotorJoint_SetLinearOffset","null",["number","number","number"]);function b2MotorJoint(def){this.bodyA=def.bodyA;this.bodyB=def.bodyB;this.ptr=null;this.next=null}b2MotorJoint.prototype.SetAngularOffset=function(angle){b2MotorJoint_SetAngularOffset(this.ptr,angle)};
b2MotorJoint.prototype.SetLinearOffset=function(v){b2MotorJoint_SetLinearOffset(this.ptr,v.x,v.y)};var b2MotorJointDef_Create=Module.cwrap("b2MotorJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number"]);var b2MotorJointDef_InitializeAndCreate=Module.cwrap("b2MotorJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number"]);
function b2MotorJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.angularOffset=0;this.correctionFactor=.3;this.linearOffset=new b2Vec2;this.maxForce=0;this.maxTorque=0}b2MotorJointDef.prototype.Create=function(world){var motorJoint=new b2MotorJoint(this);motorJoint.ptr=b2MotorJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.angularOffset,this.correctionFactor,this.linearOffset.x,this.linearOffset.y,this.maxForce,this.maxTorque);return motorJoint};
b2MotorJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB){this.bodyA=bodyA;this.bodyB=bodyB;var motorJoint=new b2MotorJoint(this);motorJoint.ptr=b2MotorJointDef_InitializeAndCreate(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.correctionFactor,this.maxForce,this.maxTorque);b2World._Push(motorJoint,world.joints);return motorJoint};function b2PulleyJoint(def){this.ptr=null;this.next=null}var b2PulleyJointDef_Create=Module.cwrap("b2PulleyJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);var b2PulleyJointDef_InitializeAndCreate=Module.cwrap("b2PulleyJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
function b2PulleyJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=true;this.groundAnchorA=new b2Vec2;this.groundAnchorB=new b2Vec2;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.lengthA=0;this.lengthB=0;this.ratio=1}
b2PulleyJointDef.prototype.Create=function(world){var pulleyJoint=new b2PulleyJoint(this);pulleyJoint.ptr=b2PulleyJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.groundAnchorA.x,this.groundAnchorA.y,this.groundAnchorB.x,this.groundAnchorB.y,this.lengthA,this.lengthB,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y,this.ratio);return pulleyJoint};
b2PulleyJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB,groundAnchorA,groundAnchorB,anchorA,anchorB,ratio){this.bodyA=bodyA;this.bodyB=bodyB;var pulleyJoint=new b2PulleyJoint(this);pulleyJoint.ptr=b2PulleyJointDef_InitializeAndCreate(world.ptr,this.bodyA.ptr,this.bodyB.ptr,anchorA.x,anchorA.y,anchorB.x,anchorB.y,groundAnchorA.x,groundAnchorA.y,groundAnchorB.x,groundAnchorB.y,ratio,this.collideConnected);b2World._Push(pulleyJoint,world.joints);return pulleyJoint};function b2DistanceJoint(def){this.bodyA=def.bodyA;this.bodyB=def.bodyB;this.ptr=null;this.next=null}var b2DistanceJointDef_Create=Module.cwrap("b2DistanceJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number","number"]);var b2DistanceJointDef_InitializeAndCreate=Module.cwrap("b2DistanceJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number","number","number"]);
function b2DistanceJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.dampingRatio=0;this.length=1;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.frequencyHz=0}
b2DistanceJointDef.prototype.Create=function(world){var distanceJoint=new b2DistanceJoint(this);distanceJoint.ptr=b2DistanceJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.dampingRatio,this.frequencyHz,this.length,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y);return distanceJoint};
b2DistanceJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB,anchorA,anchorB){this.bodyA=bodyA;this.bodyB=bodyB;var distanceJoint=new b2DistanceJoint(this);distanceJoint.ptr=b2DistanceJointDef_InitializeAndCreate(world.ptr,this.bodyA.ptr,this.bodyB.ptr,anchorA.x,anchorA.y,anchorB.x,anchorB.y,this.collideConnected,this.dampingRatio,this.frequencyHz);b2World._Push(distanceJoint,world.joints);return distanceJoint};var b2PrismaticJoint_EnableLimit=Module.cwrap("b2PrismaticJoint_EnableLimit","number",["number","number"]);var b2PrismaticJoint_EnableMotor=Module.cwrap("b2PrismaticJoint_EnableMotor","number",["number","number"]);var b2PrismaticJoint_GetJointTranslation=Module.cwrap("b2PrismaticJoint_GetJointTranslation","number",["number"]);var b2PrismaticJoint_GetMotorSpeed=Module.cwrap("b2PrismaticJoint_GetMotorSpeed","number",["number"]);
var b2PrismaticJoint_GetMotorForce=Module.cwrap("b2PrismaticJoint_GetMotorForce","number",["number","number"]);var b2PrismaticJoint_IsLimitEnabled=Module.cwrap("b2PrismaticJoint_IsLimitEnabled","number",["number"]);var b2PrismaticJoint_IsMotorEnabled=Module.cwrap("b2PrismaticJoint_IsMotorEnabled","number",["number"]);var b2PrismaticJoint_SetMotorSpeed=Module.cwrap("b2PrismaticJoint_SetMotorSpeed","number",["number","number"]);function b2PrismaticJoint(def){this.ptr=null;this.next=null}
b2PrismaticJoint.prototype=new b2Joint;b2PrismaticJoint.prototype.EnableLimit=function(flag){return b2PrismaticJoint_EnableLimit(this.ptr,flag)};b2PrismaticJoint.prototype.EnableMotor=function(flag){return b2PrismaticJoint_EnableMotor(this.ptr,flag)};b2PrismaticJoint.prototype.GetJointTranslation=function(){return b2PrismaticJoint_GetJointTranslation(this.ptr)};b2PrismaticJoint.prototype.GetMotorSpeed=function(){return b2PrismaticJoint_GetMotorSpeed(this.ptr)};
b2PrismaticJoint.prototype.GetMotorForce=function(hz){return b2PrismaticJoint_GetMotorForce(this.ptr,hz)};b2PrismaticJoint.prototype.IsLimitEnabled=function(){return b2PrismaticJoint_IsLimitEnabled(this.ptr)};b2PrismaticJoint.prototype.IsMotorEnabled=function(){return b2PrismaticJoint_IsMotorEnabled(this.ptr)};b2PrismaticJoint.prototype.GetMotorEnabled=function(){return b2PrismaticJoint_IsMotorEnabled(this.ptr)};
b2PrismaticJoint.prototype.SetMotorSpeed=function(speed){return b2PrismaticJoint_SetMotorSpeed(this.ptr,speed)};var b2PrismaticJointDef_Create=Module.cwrap("b2PrismaticJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2PrismaticJointDef_InitializeAndCreate=Module.cwrap("b2PrismaticJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
function b2PrismaticJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.enableLimit=false;this.enableMotor=false;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.localAxisA=new b2Vec2(1,0);this.lowerTranslation=0;this.maxMotorForce=0;this.motorSpeed=0;this.referenceAngle=0;this.upperTranslation=0}
b2PrismaticJointDef.prototype.Create=function(world){var prismaticJoint=new b2PrismaticJoint(this);prismaticJoint.ptr=b2PrismaticJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.enableLimit,this.enableMotor,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y,this.localAxisA.x,this.localAxisA.y,this.lowerTranslation,this.maxMotorForce,this.motorSpeed,this.referenceAngle,this.upperTranslation);return prismaticJoint};
b2PrismaticJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB,anchor,axis){this.bodyA=bodyA;this.bodyB=bodyB;var prismaticJoint=new b2PrismaticJoint(this);prismaticJoint.ptr=b2PrismaticJointDef_InitializeAndCreate(world.ptr,this.bodyA.ptr,this.bodyB.ptr,anchor.x,anchor.y,axis.x,axis.y,this.collideConnected,this.enableLimit,this.enableMotor,this.lowerTranslation,this.maxMotorForce,this.motorSpeed,this.upperTranslation);b2World._Push(prismaticJoint,world.joints);return prismaticJoint};function b2RopeJoint(def){this.next=null;this.ptr=null}var b2RopeJointDef_Create=Module.cwrap("b2RopeJointDef_Create","number",["number","number","number","number","number","number","number","number","number"]);function b2RopeJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.maxLength=0}
b2RopeJointDef.prototype.Create=function(world){var ropeJoint=new b2RopeJoint(this);ropeJoint.ptr=b2RopeJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y,this.maxLength);return ropeJoint};var b2MouseJoint_SetTarget=Module.cwrap("b2MouseJoint_SetTarget","null",["number","number","number"]);function b2MouseJoint(def){this.ptr=null;this.next=null}b2MouseJoint.prototype.SetTarget=function(p){b2MouseJoint_SetTarget(this.ptr,p.x,p.y)};var b2MouseJointDef_Create=Module.cwrap("b2MouseJointDef_Create","number",["number","number","number","number","number","number","number","number","number"]);
function b2MouseJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.dampingRatio=.7;this.frequencyHz=5;this.maxForce=0;this.target=new b2Vec2}b2MouseJointDef.prototype.Create=function(world){var mouseJoint=new b2MouseJoint(this);mouseJoint.ptr=b2MouseJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.dampingRatio,this.frequencyHz,this.maxForce,this.target.x,this.target.y);return mouseJoint};var b2Contact_fixtureA_offset=Offsets.b2Contact.fixtureA;var b2Contact_fixtureB_offset=Offsets.b2Contact.fixtureB;var b2Contact_tangentSpeed_offset=Offsets.b2Contact.tangentSpeed;var b2Contact_GetManifold=Module.cwrap("b2Contact_GetManifold","number",["number"]);var b2Contact_GetWorldManifold=Module.cwrap("b2Contact_GetWorldManifold","number",["number"]);function b2Contact(ptr){this.buffer=new DataView(Module.HEAPU8.buffer,ptr);this.ptr=ptr}
b2Contact.prototype.GetFixtureA=function(){var fixAPtr=this.buffer.getUint32(b2Contact_fixtureA_offset,true);return world.fixturesLookup[fixAPtr]};b2Contact.prototype.GetFixtureB=function(){var fixBPtr=this.buffer.getUint32(b2Contact_fixtureB_offset,true);return world.fixturesLookup[fixBPtr]};b2Contact.prototype.GetManifold=function(){return new b2Manifold(b2Contact_GetManifold(this.ptr))};b2Contact.prototype.GetWorldManifold=function(){return new b2WorldManifold(b2Contact_GetWorldManifold(this.ptr))};
b2Contact.prototype.SetTangentSpeed=function(speed){this.buffer.setFloat32(b2Contact_tangentSpeed_offset,speed,true)};function b2Filter(){this.categoryBits=1;this.groupIndex=0;this.maskBits=65535}var b2Fixture_isSensor_offset=Offsets.b2Fixture.isSensor;var b2Fixture_userData_offset=Offsets.b2Fixture.userData;function b2Fixture(){this.body=null;this.buffer=null;this.ptr=null;this.shape=null}var b2Fixture_TestPoint=Module.cwrap("b2Fixture_TestPoint","number",["number","number","number"]);b2Fixture.prototype._SetPtr=function(ptr){this.ptr=ptr;this.buffer=new DataView(Module.HEAPU8.buffer,ptr)};
b2Fixture.prototype.FromFixtureDef=function(fixtureDef){this.density=fixtureDef.density;this.friction=fixtureDef.friction;this.isSensor=fixtureDef.isSensor;this.restitution=fixtureDef.restitution;this.shape=fixtureDef.shape;this.userData=fixtureDef.userData;this.vertices=[]};b2Fixture.prototype.GetUserData=function(){return this.buffer.getUint32(b2Fixture_userData_offset,true)};b2Fixture.prototype.SetSensor=function(flag){this.buffer.setUint32(b2Fixture_isSensor_offset,flag,true)};
b2Fixture.prototype.TestPoint=function(p){return b2Fixture_TestPoint(this.ptr,p.x,p.y)};function b2FixtureDef(){this.density=0;this.friction=.2;this.isSensor=false;this.restitution=0;this.shape=null;this.userData=null;this.filter=new b2Filter};function b2ContactImpulse(ptr){this.ptr=ptr;this.buffer=new DataView(Module.HEAPU8.buffer,ptr)}b2ContactImpulse.prototype.GetNormalImpulse=function(i){return this.buffer.getFloat32(i*4,true)};b2ContactImpulse.prototype.GetTangentImpulse=function(i){return this.buffer.getFloat32(i*4+8,true)};b2ContactImpulse.prototype.GetCount=function(i){console.log(this.buffer.getInt32(16,true))};function b2ParticleSystemDef(){this.colorMixingStrength=.5;this.dampingStrength=1;this.destroyByAge=true;this.ejectionStrength=.5;this.elasticStrength=.25;this.lifetimeGranularity=1/60;this.powderStrength=.5;this.pressureStrength=.05;this.radius=1;this.repulsiveStrength=1;this.springStrength=.25;this.staticPressureIterations=8;this.staticPressureRelaxation=.2;this.staticPressureStrength=.2;this.surfaceTensionNormalStrength=.2;this.surfaceTensionPressureStrength=.2;this.viscousStrength=.25}
var b2ParticleSystem_CreateParticle=Module.cwrap("b2ParticleSystem_CreateParticle","number",["number","number","number","number","number","number","number","number","number","number","number","number","number"]);var b2ParticleSystem_GetColorBuffer=Module.cwrap("b2ParticleSystem_GetColorBuffer","number",["number"]);var b2ParticleSystem_GetParticleCount=Module.cwrap("b2ParticleSystem_GetParticleCount","number",["number"]);
var b2ParticleSystem_GetPositionBuffer=Module.cwrap("b2ParticleSystem_GetPositionBuffer","number",["number"]);var b2ParticleSystem_GetVelocityBuffer=Module.cwrap("b2ParticleSystem_GetVelocityBuffer","number",["number"]);var b2ParticleSystem_SetDamping=Module.cwrap("b2ParticleSystem_SetDamping","null",["number","number"]);var b2ParticleSystem_SetDensity=Module.cwrap("b2ParticleSystem_SetDensity","null",["number","number"]);
var b2ParticleSystem_SetRadius=Module.cwrap("b2ParticleSystem_SetRadius","null",["number","number"]);function b2ParticleSystem(ptr){this.dampingStrength=1;this.density=1;this.ptr=ptr;this.particleGroups=[];this.radius=1}b2ParticleSystem.prototype.CreateParticle=function(pd){return b2ParticleSystem_CreateParticle(this.ptr,pd.color.r,pd.color.g,pd.color.b,pd.color.a,pd.flags,pd.group,pd.lifetime,pd.position.x,pd.position.y,pd.userData,pd.velocity.x,pd.velocity.y)};
b2ParticleSystem.prototype.CreateParticleGroup=function(pgd){var particleGroup=new b2ParticleGroup(pgd.shape._CreateParticleGroup(this,pgd));this.particleGroups.push(particleGroup);return particleGroup};b2ParticleSystem.prototype.DestroyParticlesInShape=function(shape,xf){return shape._DestroyParticlesInShape(this,xf)};
b2ParticleSystem.prototype.GetColorBuffer=function(){var count=b2ParticleSystem_GetParticleCount(this.ptr)*4;var offset=b2ParticleSystem_GetColorBuffer(this.ptr);return new Uint8Array(Module.HEAPU8.buffer,offset,count)};b2ParticleSystem.prototype.GetParticleCount=function(){return b2ParticleSystem_GetParticleCount(this.ptr)*2};
b2ParticleSystem.prototype.GetPositionBuffer=function(){var count=b2ParticleSystem_GetParticleCount(this.ptr)*2;var offset=b2ParticleSystem_GetPositionBuffer(this.ptr);return new Float32Array(Module.HEAPU8.buffer,offset,count)};b2ParticleSystem.prototype.GetVelocityBuffer=function(){var count=b2ParticleSystem_GetParticleCount(this.ptr)*2;var offset=b2ParticleSystem_GetVelocityBuffer(this.ptr);return new Float32Array(Module.HEAPU8.buffer,offset,count)};
b2ParticleSystem.prototype.SetDamping=function(damping){this.dampingStrength=damping;b2ParticleSystem_SetDamping(this.ptr,damping)};b2ParticleSystem.prototype.SetDensity=function(density){this.density=density;b2ParticleSystem_SetDensity(this.ptr,density)};b2ParticleSystem.prototype.SetRadius=function(radius){this.radius=radius;b2ParticleSystem_SetRadius(this.ptr,radius)};var b2_solidParticleGroup=1<<0;var b2_rigidParticleGroup=1<<1;var b2_particleGroupCanBeEmpty=1<<2;var b2_particleGroupWillBeDestroyed=1<<3;var b2_particleGroupNeedsUpdateDepth=1<<4;var b2_particleGroupInternalMask=b2_particleGroupWillBeDestroyed|b2_particleGroupNeedsUpdateDepth;var b2ParticleGroup_ApplyForce=Module.cwrap("b2ParticleGroup_ApplyForce","null",["number","number","number"]);
var b2ParticleGroup_ApplyLinearImpulse=Module.cwrap("b2ParticleGroup_ApplyLinearImpulse","null",["number","number","number"]);var b2ParticleGroup_DestroyParticles=Module.cwrap("b2ParticleGroup_DestroyParticles","null",["number","number"]);var b2ParticleGroup_GetBufferIndex=Module.cwrap("b2ParticleGroup_GetBufferIndex","number",["number"]);var b2ParticleGroup_GetParticleCount=Module.cwrap("b2ParticleGroup_GetParticleCount","number",["number"]);var b2ParticleGroup_groupFlags_offset=Offsets.b2ParticleGroup.groupFlags;
function b2ParticleGroup(ptr){this.buffer=new DataView(Module.HEAPU8.buffer,ptr);this.ptr=ptr}b2ParticleGroup.prototype.ApplyForce=function(force){b2ParticleGroup_ApplyForce(this.ptr,force.x,force.y)};b2ParticleGroup.prototype.ApplyLinearImpulse=function(impulse){b2ParticleGroup_ApplyLinearImpulse(this.ptr,impulse.x,impulse.y)};b2ParticleGroup.prototype.DestroyParticles=function(flag){b2ParticleGroup_DestroyParticles(this.ptr,flag)};b2ParticleGroup.prototype.GetBufferIndex=function(){return b2ParticleGroup_GetBufferIndex(this.ptr)};
b2ParticleGroup.prototype.GetGroupFlags=function(){return this.buffer.getUint32(b2ParticleGroup_groupFlags_offset,true)};b2ParticleGroup.prototype.GetParticleCount=function(){return b2ParticleGroup_GetParticleCount(this.ptr)};b2ParticleGroup.prototype.SetGroupFlags=function(flags){this.buffer.setUint32(b2ParticleGroup_groupFlags_offset,flags,true)};
function b2ParticleGroupDef(){this.angle=0;this.angularVelocity=0;this.color=new b2ParticleColor(0,0,0,0);this.flags=0;this.group=new b2ParticleGroup(null);this.groupFlags=0;this.lifetime=0;this.linearVelocity=new b2Vec2;this.position=new b2Vec2;this.positionData=null;this.particleCount=0;this.shape=null;this.strength=1;this.stride=0;this.userData=null};var b2_waterParticle=0;var b2_zombieParticle=1<<1;var b2_wallParticle=1<<2;var b2_springParticle=1<<3;var b2_elasticParticle=1<<4;var b2_viscousParticle=1<<5;var b2_powderParticle=1<<6;var b2_tensileParticle=1<<7;var b2_colorMixingParticle=1<<8;var b2_destructionListenerParticle=1<<9;var b2_barrierParticle=1<<10;var b2_staticPressureParticle=1<<11;var b2_reactiveParticle=1<<12;var b2_repulsiveParticle=1<<13;var b2_fixtureContactListenerParticle=1<<14;var b2_particleContactListenerParticle=1<<15;
var b2_fixtureContactFilterParticle=1<<16;var b2_particleContactFilterParticle=1<<17;function b2ParticleColor(r,g,b,a){if(r===undefined)r=0;if(g===undefined)g=0;if(b===undefined)b=0;if(a===undefined)a=0;this.r=r;this.g=g;this.b=b;this.a=a}b2ParticleColor.prototype.Set=function(r,g,b,a){this.r=r;this.g=g;this.b=b;this.a=a};function b2ParticleDef(){this.color=new b2Vec2;this.flags=0;this.group=0;this.lifetime=0;this.position=new b2Vec2;this.userData=0;this.velocity=new b2Vec2};
